keyword,description,content
skip to content,Skip to content,Content not available.
showcase,Showcase,Content not available.
docs,Docs,"IntroductionWelcome to the Next.js documentation!What is Next.js?Next.js is a React framework for building full-stack web applications. You use React Components to build user interfaces, and Next.js for additional features and optimizations.Under the hood, Next.js also abstracts and automatically configures tooling needed for React, like bundling, compiling, and more. This allows you to focus on building your application instead of spending time with configuration.Whether you're an individual developer or part of a larger team, Next.js can help you build interactive, dynamic, and fast React applications.Main FeaturesSome of the main Next.js features include:FeatureDescriptionRoutingA file-system based router built on top of Server Components that supports layouts, nested routing, loading states, error handling, and more.RenderingClient-side and Server-side Rendering with Client and Server Components. Further optimized with Static and Dynamic Rendering on the server with Next.js. Streaming on Edge and Node.js runtimes.Data FetchingSimplified data fetching with async/await in Server Components, and an extendedfetchAPI for request memoization, data caching and revalidation.StylingSupport for your preferred styling methods, including CSS Modules, Tailwind CSS, and CSS-in-JSOptimizationsImage, Fonts, and Script Optimizations to improve your application's Core Web Vitals and User Experience.TypeScriptImproved support for TypeScript, with better type checking and more efficient compilation, as well as custom TypeScript Plugin and type checker.How to Use These DocsOn the left side of the screen, you'll find the docs navbar. The pages of the docs are organized sequentially, from basic to advanced, so you can follow them step-by-step when building your application. However, you can read them in any order or skip to the pages that apply to your use case.On the right side of the screen, you'll see a table of contents that makes it easier to navigate between sections of a page. If you need to quickly find a page, you can use the search bar at the top, or the search shortcut (Ctrl+KorCmd+K).To get started, check out theInstallationguide.App Router vs Pages RouterNext.js has two different routers: the App Router and the Pages Router. The App Router is a newer router that allows you to use React's latest features, such as Server Components and Streaming. The Pages Router is the original Next.js router, which allowed you to build server-rendered React applications and continues to be supported for older Next.js applications.At the top of the sidebar, you'll notice a dropdown menu that allows you to switch between theApp Routerand thePages Routerfeatures. Since there are features that are unique to each directory, it's important to keep track of which tab is selected.The breadcrumbs at the top of the page will also indicate whether you're viewing App Router docs or Pages Router docs.Pre-Requisite KnowledgeAlthough our docs are designed to be beginner-friendly, we need to establish a baseline so that the docs can stay focused on Next.js functionality. We'll make sure to provide links to relevant documentation whenever we introduce a new concept.To get the most out of our docs, it's recommended that you have a basic understanding of HTML, CSS, and React. If you need to brush up on your React skills, check out ourReact Foundations Course, which will introduce you to the fundamentals. Then, learn more about Next.js bybuilding a dashboard application.AccessibilityFor optimal accessibility when using a screen reader while reading the docs, we recommend using Firefox and NVDA, or Safari and VoiceOver.Join our CommunityIf you have questions about anything related to Next.js, you're always welcome to ask our community onGitHub Discussions,Discord,X (Twitter), andReddit.Getting StartedLearn how to create full-stack web applications with the Next.js App Router.ExamplesLearn how to implement common UI patterns and use cases  using Next.jsBuilding Your ApplicationLearn how to use Next.js features to build your application.API ReferenceNext.js API Reference for the App Router.Getting StartedLearn how to create full-stack web applications with Next.js with the Pages Router.Building Your ApplicationLearn how to use Next.js features to build your application.API ReferenceNext.js API Reference for the Pages Router.ArchitectureHow Next.js WorksCommunityGet involved in the Next.js community.PreviousContribution GuideNextApp RouterWas this helpful?supported.Send"
blog,Blog,"January 3rd, 2025Composable Caching with Next.jsWe’re working on a simple and powerful caching model for Next.js. In a previous post, we talked about our journey with caching and how we’ve arrived at the'use cache'directive.Read More"
templates,Templates,Content not available.
enterprise,Enterprise,Content not available.
learn,Learn,Content not available.
getting started,Getting Started,"IntroductionApp RouterGetting StartedGetting StartedInstallationCreate a new Next.js application with the `create-next-app` CLI, and set up TypeScript, ESLint, and Module Path Aliases.Project StructureAn overview of the folder and file conventions in Next.js, and how to organize your project.Layouts and PagesCreate your first pages and layouts, and link between them.Images and FontsLearn how to optimize images and fonts.CSSLearn about the different ways to add CSS to your application, including CSS Modules, Global CSS, Tailwind CSS, and more.Fetching DataStart fetching data and streaming content in your application.Updating DataLearn how to update data in your Next.js application.Error HandlingLearn how to display expected errors and handle uncaught exceptions.PreviousApp RouterNextInstallationWas this helpful?supported.Send"
installation,Installation,"App RouterGetting StartedInstallationHow to set up a new Next.js projectSystem requirementsNode.js 18.18or later.macOS, Windows (including WSL), and Linux are supported.Automatic installationWe recommend starting a new Next.js app usingcreate-next-app, which sets up everything automatically for you. To create a project, run:Terminalnpxcreate-next-app@latestOn installation, you'll see the following prompts:TerminalWhat is your project named? my-appWould you like to use TypeScript? No / YesWould you like to use ESLint? No / YesWould you like to use Tailwind CSS? No / YesWould you like your code inside a `src/` directory? No / YesWould you like to use App Router? (recommended) No / YesWould you like to use Turbopack for `next dev`?  No / YesWould you like to customize the import alias (`@/*` by default)? No / YesWhat import alias would you like configured? @/*After the prompts,create-next-appwill create a folder with your project name and install the required dependencies.Manual installationTo manually create a new Next.js app, install the required packages:Terminalnpminstallnext@latestreact@latestreact-dom@latestOpen yourpackage.jsonfile and add the followingscripts:package.json{""scripts"":{""dev"":""next dev"",""build"":""next build"",""start"":""next start"",""lint"":""next lint""}}These scripts refer to the different stages of developing an application:dev: runsnext devto start Next.js in development mode.build: runsnext buildto build the application for production usage.start: runsnext startto start a Next.js production server.lint: runsnext lintto set up Next.js' built-in ESLint configuration.Create theappdirectoryNext.js uses file-system routing, which means the routes in your application are determined by how you structure your files.Create anappfolder, then add alayout.tsxandpage.tsxfile. These will be rendered when the user visits the root of your application (/).Create aroot layoutinsideapp/layout.tsxwith the required<html>and<body>tags:app/layout.tsxTypeScriptJavaScriptTypeScriptexportdefaultfunctionRootLayout({children,}:{children:React.ReactNode}) {return(<htmllang=""en""><body>{children}</body></html>)}Finally, create a home pageapp/page.tsxwith some initial content:app/page.tsxTypeScriptJavaScriptTypeScriptexportdefaultfunctionPage() {return<h1>Hello, Next.js!</h1>}Good to know:If you forget to createlayout.tsx, Next.js will automatically create this file when running the development server withnext dev.You can optionally use asrcdirectoryin the root of your project to separate your application's code from configuration files.Create thepublicfolder (optional)You can optionally create apublicfolderat the root of your project to store static assets such as images, fonts, etc. Files insidepubliccan then be referenced by your code starting from the base URL (/).Run the development serverRunnpm run devto start the development server.Visithttp://localhost:3000to view your application.Edit theapp/page.tsxfile and save it to see the updated result in your browser.Set up TypeScriptMinimum TypeScript version:v4.5.2Next.js comes with built-in TypeScript support. To add TypeScript to your project, rename a file to.ts/.tsx. Runnext dev, Next.js will automatically install the necessary dependencies and add atsconfig.jsonfile with the recommended config options.IDE PluginNext.js includes a custom TypeScript plugin and type checker, which VSCode and other code editors can use for advanced type-checking and auto-completion.You can enable the plugin in VS Code by:Opening the command palette (Ctrl/⌘+Shift+P)Searching for ""TypeScript: Select TypeScript Version""Selecting ""Use Workspace Version""Now, when editing files, the custom plugin will be enabled. When runningnext build, the custom type checker will be used.See theTypeScript configurationpage for more information on how to use TypeScript in your project.Set up ESLintNext.js comes with built-in ESLint, automatically installing the necessary packages and configuring the proper settings when you create a new project withcreate-next-app.To add ESLint to an existing project, addnext lintas a script topackage.json:package.json{""scripts"":{""lint"":""next lint""}}Then, runnpm run lintand you will be guided through the installation and configuration process.TerminalnpmrunlintYou'll see a prompt like this:? How would you like to configure ESLint?❯ Strict (recommended)BaseCancelStrict: Includes Next.js' base ESLint configuration along with a stricter Core Web Vitals rule-set. This is the recommended configuration for developers setting up ESLint for the first time.Base: Includes Next.js' base ESLint configuration.Cancel: Does not include any ESLint configuration. Only select this option if you plan on setting up your own custom ESLint configuration.If either of the two configuration options are selected, Next.js will automatically installeslintandeslint-config-nextas dependencies in your application and create an.eslintrc.jsonfile in the root of your project that includes your selected configuration.You can now runnext lintevery time you want to run ESLint to catch errors. Once ESLint has been set up, it will also automatically run during every build (next build). Errors will fail the build, while warnings will not.See theESLint Pluginpage for more information on how to configure ESLint in your project.Set up Absolute Imports and Module Path AliasesNext.js has in-built support for the""paths""and""baseUrl""options oftsconfig.jsonandjsconfig.jsonfiles. These options allow you to alias project directories to absolute paths, making it easier to import modules. For example:// Beforeimport{ Button }from'../../../components/button'// Afterimport{ Button }from'@/components/button'To configure absolute imports, add thebaseUrlconfiguration option to yourtsconfig.jsonorjsconfig.jsonfile. For example:tsconfig.json or jsconfig.json{""compilerOptions"":{""baseUrl"":""src/""}}In addition to configuring thebaseUrlpath, you can use the""paths""option to""alias""module paths.For example, the following configuration maps@/components/*tocomponents/*:tsconfig.json or jsconfig.json{""compilerOptions"":{""baseUrl"":""src/"",""paths"":{""@/styles/*"":[""styles/*""],""@/components/*"":[""components/*""]}}}Each of the""paths""are relative to thebaseUrllocation. For example:src/app/page.tsxTypeScriptJavaScriptTypeScriptimportButtonfrom'@/components/button'import'@/styles/styles.css'exportdefaultfunctionHomePage() {return(<div><h1>Hello World</h1><Button/></div>)}PreviousGetting StartedNextProject StructureWas this helpful?supported.Send"
project structure,Project Structure,"App RouterGetting StartedProject StructureProject structure and organizationThis page provides an overview of the folder and file conventions in Next.js, as well as tips for organizing your project.Folder and file conventionsTop-level foldersTop-level folders are used to organize your application's code and static assets.appApp RouterpagesPages RouterpublicStatic assets to be servedsrcOptional application source folderTop-level filesTop-level files are used to configure your application, manage dependencies, run middleware, integrate monitoring tools, and define environment variables.Next.jsnext.config.jsConfiguration file for Next.jspackage.jsonProject dependencies and scriptsinstrumentation.tsOpenTelemetry and Instrumentation filemiddleware.tsNext.js request middleware.envEnvironment variables.env.localLocal environment variables.env.productionProduction environment variables.env.developmentDevelopment environment variables.eslintrc.jsonConfiguration file for ESLint.gitignoreGit files and folders to ignorenext-env.d.tsTypeScript declaration file for Next.jstsconfig.jsonConfiguration file for TypeScriptjsconfig.jsonConfiguration file for JavaScriptRouting Fileslayout.js.jsx.tsxLayoutpage.js.jsx.tsxPageloading.js.jsx.tsxLoading UInot-found.js.jsx.tsxNot found UIerror.js.jsx.tsxError UIglobal-error.js.jsx.tsxGlobal error UIroute.js.tsAPI endpointtemplate.js.jsx.tsxRe-rendered layoutdefault.js.jsx.tsxParallel route fallback pageNested routesfolderRoute segmentfolder/folderNested route segmentDynamic routes[folder]Dynamic route segment[...folder]Catch-all route segment[[...folder]]Optional catch-all route segmentRoute Groups and private folders(folder)Group routes without affecting routing_folderOpt folder and all child segments out of routingParallel and Intercepted Routes@folderNamed slot(.)folderIntercept same level(..)folderIntercept one level above(..)(..)folderIntercept two levels above(...)folderIntercept from rootMetadata file conventionsApp iconsfavicon.icoFavicon fileicon.ico.jpg.jpeg.png.svgApp Icon fileicon.js.ts.tsxGenerated App Iconapple-icon.jpg.jpeg,.pngApple App Icon fileapple-icon.js.ts.tsxGenerated Apple App IconOpen Graph and Twitter imagesopengraph-image.jpg.jpeg.png.gifOpen Graph image fileopengraph-image.js.ts.tsxGenerated Open Graph imagetwitter-image.jpg.jpeg.png.gifTwitter image filetwitter-image.js.ts.tsxGenerated Twitter imageSEOsitemap.xmlSitemap filesitemap.js.tsGenerated Sitemaprobots.txtRobots filerobots.js.tsGenerated Robots fileComponent hierarchyThe React components defined in special files of a route segment are rendered in a specific hierarchy:layout.jstemplate.jserror.js(React error boundary)loading.js(React suspense boundary)not-found.js(React error boundary)page.jsor nestedlayout.jsIn a nested route, the components of a segment will be nestedinsidethe components of its parent segment.Organizing your projectApart fromfolder and file conventions, Next.js isunopinionatedabout how you organize and colocate your project files. But it does provide several features to help you organize your project.ColocationIn theappdirectory, nested folders define route structure. Each folder represents a route segment that is mapped to a corresponding segment in a URL path.However, even though route structure is defined through folders, a route isnot publicly accessibleuntil apage.jsorroute.jsfile is added to a route segment.And, even when a route is made publicly accessible, only thecontent returnedbypage.jsorroute.jsis sent to the client.This means thatproject filescan besafely colocatedinside route segments in theappdirectory without accidentally being routable.Good to know:While youcancolocate your project files inappyou don'thaveto. If you prefer, you cankeep them outside theappdirectory.Private foldersPrivate folders can be created by prefixing a folder with an underscore:_folderNameThis indicates the folder is a private implementation detail and should not be considered by the routing system, therebyopting the folder and all its subfoldersout of routing.Since files in theappdirectory can besafely colocated by default, private folders are not required for colocation. However, they can be useful for:Separating UI logic from routing logic.Consistently organizing internal files across a project and the Next.js ecosystem.Sorting and grouping files in code editors.Avoiding potential naming conflicts with future Next.js file conventions.Good to know:While not a framework convention, you might also consider marking files outside private folders as ""private"" using the same underscore pattern.You can create URL segments that start with an underscore by prefixing the folder name with%5F(the URL-encoded form of an underscore):%5FfolderName.If you don't use private folders, it would be helpful to know Next.jsspecial file conventionsto prevent unexpected naming conflicts.Route groupsRoute groups can be created by wrapping a folder in parenthesis:(folderName)This indicates the folder is for organizational purposes and shouldnot be includedin the route's URL path.Route groups are useful for:Organizing routes into groupse.g. by site section, intent, or team.Enabling nested layouts in the same route segment level:Creating multiple nested layouts in the same segment, including multiple root layoutsAdding a layout to a subset of routes in a common segmentsrcdirectoryNext.js supports storing application code (includingapp) inside an optionalsrcdirectory. This separates application code from project configuration files which mostly live in the root of a project.Common strategiesThe following section lists a very high-level overview of common strategies. The simplest takeaway is to choose a strategy that works for you and your team and be consistent across the project.Good to know: In our examples below, we're usingcomponentsandlibfolders as generalized placeholders, their naming has no special framework significance and your projects might use other folders likeui,utils,hooks,styles, etc.Store project files outside ofappThis strategy stores all application code in shared folders in theroot of your projectand keeps theappdirectory purely for routing purposes.Store project files in top-level folders inside ofappThis strategy stores all application code in shared folders in theroot of theappdirectory.Split project files by feature or routeThis strategy stores globally shared application code in the rootappdirectory andsplitsmore specific application code into the route segments that use them.PreviousInstallationNextLayouts and PagesWas this helpful?supported.Send"
layouts and pages,Layouts and Pages,"App RouterGetting StartedLayouts and PagesHow to create layouts and pagesNext.js usesfile-system based routing, meaning you can use folders and files to define routes. This page will guide you through how to create layouts and pages, and link between them.Creating a pageApageis UI that is rendered on a specific route. To create a page, add apagefileinside theappdirectory and default export a React component. For example, to create an index page (/):app/page.tsxTypeScriptJavaScriptTypeScriptexportdefaultfunctionPage() {return<h1>Hello Next.js!</h1>}Creating a layoutA layout is UI that issharedbetween multiple pages. On navigation, layouts preserve state, remain interactive, and do not rerender.You can define a layout by default exporting a React component from alayoutfile. The component should accept achildrenprop which can be a page or anotherlayout.For example, to create a layout that accepts your index page as child, add alayoutfile inside theappdirectory:app/layout.tsxTypeScriptJavaScriptTypeScriptexportdefaultfunctionDashboardLayout({children,}:{children:React.ReactNode}) {return(<htmllang=""en""><body>{/* Layout UI */}{/* Place children where you want to render a page or nested layout */}<main>{children}</main></body></html>)}The layout above is called aroot layoutbecause it's defined at the root of theappdirectory. The root layout isrequiredand must containhtmlandbodytags.Creating a nested routeA nested route is a route composed of multiple URL segments. For example, the/blog/[slug]route is composed of three segments:/(Root Segment)blog(Segment)[slug](Leaf Segment)In Next.js:Foldersare used to define the route segments that map to URL segments.Files(likepageandlayout) are used to create UI that is shown for a segment.To create nested routes, you can nest folders inside each other. For example, to add a route for/blog, create a folder calledblogin theappdirectory. Then, to make/blogpublicly accessible, add apagefile:app/blog/page.tsxTypeScriptJavaScriptTypeScriptimport{ getPosts }from'@/lib/posts'import{ Post }from'@/ui/post'exportdefaultasyncfunctionPage() {constposts=awaitgetPosts()return(<ul>{posts.map((post)=>(<Postkey={post.id}post={post} />))}</ul>)}You can continue nesting folders to create nested routes. For example, to create a route for a specific blog post, create a new[slug]folder insideblogand add apagefile:app/blog/[slug]/page.tsxTypeScriptJavaScriptTypeScriptfunctiongenerateStaticParams() {}exportdefaultfunctionPage() {return<h1>Hello, Blog Post Page!</h1>}Good to know: Wrapping a folder name in square brackets (e.g.[slug]) creates a specialdynamic route segmentused to generate multiple pages from data. This is useful for blog posts, product pages, etc.Nesting layoutsBy default, layouts in the folder hierarchy are also nested, which means they wrap child layouts via theirchildrenprop. You can nest layouts by addinglayoutinside specific route segments (folders).For example, to create a layout for the/blogroute, add a newlayoutfile inside theblogfolder.app/blog/layout.tsxTypeScriptJavaScriptTypeScriptexportdefaultfunctionBlogLayout({children,}:{children:React.ReactNode}) {return<section>{children}</section>}If you were to combine the two layouts above, the root layout (app/layout.js) would wrap the blog layout (app/blog/layout.js), which would wrap the blog (app/blog/page.js) and blog post page (app/blog/[slug]/page.js).Linking between pagesYou can use the<Link>componentto navigate between routes.<Link>is a built-in Next.js component that extends the HTML<a>tag to provide prefetching and client-side navigation.For example, to generate a list of blog posts, import<Link>fromnext/linkand pass ahrefprop to the component:app/ui/post.tsxTypeScriptJavaScriptTypeScriptimportLinkfrom'next/link'exportdefaultasyncfunctionPost({ post }) {constposts=awaitgetPosts()return(<ul>{posts.map((post)=>(<likey={post.slug}><Linkhref={`/blog/${post.slug}`}>{post.title}</Link></li>))}</ul>)}<Link>is the primary and recommended way to navigate between routes in your Next.js application. However, you can also use theuseRouterhookfor more advanced navigation.API ReferenceLearn more about the features mentioned in this page by reading the API Reference.layout.jsAPI reference for the layout.js file.page.jsAPI reference for the page.js file.LinkEnable fast client-side navigation with the built-in `next/link` component.PreviousProject StructureNextImages and FontsWas this helpful?supported.Send"
images and fonts,Images and Fonts,"App RouterGetting StartedImages and FontsHow to optimize images and fontsNext.js comes with automatic image and font optimization for better performance and user experience. This page will guide you through how to start using them.Handling static assetsYou can store static files, like images and fonts, under a folder calledpublicin the root directory. Files insidepubliccan then be referenced by your code starting from the base URL (/).Optimizing imagesThe Next.js<Image>component extends the HTML<img>element to provide:Size optimization:Automatically serving correctly sized images for each device, using modern image formats like WebP.Visual stability:Preventinglayout shiftautomatically when images are loading.Faster page loads:Only loading images when they enter the viewport using native browser lazy loading, with optional blur-up placeholders.Asset flexibility:Resizing images on-demand, even images stored on remote servers.To start using<Image>, import it fromnext/imageand render it within your component.app/page.tsxTypeScriptJavaScriptTypeScriptimportImagefrom'next/image'exportdefaultfunctionPage() {return<Imagesrc=""""alt=""""/>}Thesrcproperty can be alocalorremoteimage.Local imagesTo use a local image,importyour.jpg,.png, or.webpimage files from yourpublicfolder.app/page.tsxTypeScriptJavaScriptTypeScriptimportImagefrom'next/image'importprofilePicfrom'./me.png'exportdefaultfunctionPage() {return(<Imagesrc={profilePic}alt=""Picture of the author""// width={500} automatically provided// height={500} automatically provided// blurDataURL=""data:..."" automatically provided// placeholder=""blur"" // Optional blur-up while loading/>)}Next.js will automatically determine the intrinsicwidthandheightof your image based on the imported file. These values are used to determine the image ratio and preventCumulative Layout Shiftwhile your image is loading.Remote imagesTo use a remote image, you can provide a URL string for thesrcproperty.app/page.tsxTypeScriptJavaScriptTypeScriptimportImagefrom'next/image'exportdefaultfunctionPage() {return(<Imagesrc=""https://s3.amazonaws.com/my-bucket/profile.png""alt=""Picture of the author""width={500}height={500}/>)}Since Next.js does not have access to remote files during the build process, you'll need to provide thewidth,heightand optionalblurDataURLprops manually. Thewidthandheightattributes are used to infer the correct aspect ratio of image and avoid layout shift from the image loading in.Then, to safely allow images from remote servers, you need to define a list of supported URL patterns innext.config.js. Be as specific as possible to prevent malicious usage. For example, the following configuration will only allow images from a specific AWS S3 bucket:next.config.tsTypeScriptJavaScriptTypeScriptimport{ NextConfig }from'next'constconfig:NextConfig={images:{remotePatterns:[{protocol:'https',hostname:'s3.amazonaws.com',port:'',pathname:'/my-bucket/**',search:'',},],},}exportdefaultconfigOptimizing fontsThenext/fontmodule automatically optimizes your fonts and removes external network requests for improved privacy and performance.It includesbuilt-in automatic self-hostingforanyfont file. This means you can optimally load web fonts with no layout shift.To start usingnext/font, import it fromnext/font/localornext/font/google, call it as a function with the appropriate options, and set theclassNameof the element you want to apply the font to. For example:app/layout.tsxTypeScriptJavaScriptTypeScriptimport{ Geist }from'next/font/google'constgeist=Geist({subsets:['latin'],})exportdefaultfunctionLayout({ children }:{ children:React.ReactNode}) {return(<htmllang=""en""className={geist.className}><body>{children}</body></html>)}Google fontsYou can automatically self-host any Google Font. Fonts are included in the deployment and served from the same domain as your deployment, meaning no requests are sent to Google by the browser when the user visits your site.To start using a Google Font, import your chosen font fromnext/font/google:app/layout.tsxTypeScriptJavaScriptTypeScriptimport{ Geist }from'next/font/google'constgeist=Geist({subsets:['latin'],})exportdefaultfunctionRootLayout({children,}:{children:React.ReactNode}) {return(<htmllang=""en""className={geist.className}><body>{children}</body></html>)}We recommend usingvariable fontsfor the best performance and flexibility. But if you can't use a variable font, you willneed to specify a weight:app/layout.tsxTypeScriptJavaScriptTypeScriptimport{ Roboto }from'next/font/google'constroboto=Roboto({weight:'400',subsets:['latin'],})exportdefaultfunctionRootLayout({children,}:{children:React.ReactNode}) {return(<htmllang=""en""className={roboto.className}><body>{children}</body></html>)}Local fontsTo use a local font, import your font fromnext/font/localand specify thesrcof your local font file in thepublicfolder.app/layout.tsxTypeScriptJavaScriptTypeScriptimportlocalFontfrom'next/font/local'constmyFont=localFont({src:'./my-font.woff2',})exportdefaultfunctionRootLayout({children,}:{children:React.ReactNode}) {return(<htmllang=""en""className={myFont.className}><body>{children}</body></html>)}If you want to use multiple files for a single font family,srccan be an array:constroboto=localFont({src:[{path:'./Roboto-Regular.woff2',weight:'400',style:'normal',},{path:'./Roboto-Italic.woff2',weight:'400',style:'italic',},{path:'./Roboto-Bold.woff2',weight:'700',style:'normal',},{path:'./Roboto-BoldItalic.woff2',weight:'700',style:'italic',},],})API ReferenceLearn more about the features mentioned in this page by reading the API Reference.FontOptimizing loading web fonts with the built-in `next/font` loaders.ImageOptimize Images in your Next.js Application using the built-in `next/image` Component.PreviousLayouts and PagesNextCSSWas this helpful?supported.Send"
css,CSS,"App RouterGetting StartedCSSHow to use CSS in your applicationNext.js provides several ways to use CSS in your application, including:CSS ModulesGlobal CSSTailwind CSSSassCSS-in-JSExternal StylesheetsThis page will guide you through how to use each of these approaches.CSS ModulesCSS Modules locally scope CSS by generating unique class names. This allows you to use the same class in different files without worrying about collisions.To start using CSS Modules, create a new file with the extension.module.cssand import it into any component inside theappdirectory:app/blog/styles.module.css.blog{padding:24px;}app/blog/page.tsxTypeScriptJavaScriptTypeScriptimportstylesfrom'./styles.module.css'exportdefaultfunctionPage({ children }:{ children:React.ReactNode}) {return<mainclassName={styles.blog}>{children}</main>}Global CSSYou can use global CSS to apply styles across your application.To use global styles, create a new CSS file, for exampleapp/global.css:app/global.cssbody{padding:20px20px60px;max-width:680px;margin:0 auto;}Import the file in the root layout (app/layout.js) to apply the styles toevery routein your application:app/layout.tsxTypeScriptJavaScriptTypeScript// These styles apply to every route in the applicationimport'./global.css'exportdefaultfunctionRootLayout({children,}:{children:React.ReactNode}) {return(<htmllang=""en""><body>{children}</body></html>)}Good to know:Global styles can be imported into any layout, page, or component inside theappdirectory. However, since Next.js uses React's built-in support for stylesheets to integrate with Suspense. This built-in support currently does not remove stylesheets as you navigate between routes. Therefore, we recommend using global styles fortrulyglobal CSS, andCSS Modulesfor scoped CSS.Tailwind CSSTailwind CSSis a utility-first CSS framework that integrates seamlessly with Next.js.Installing TailwindTo start using Tailwind, install the necessary Tailwind CSS packages:Terminalnpminstall-Dtailwindcss@tailwindcss/postcsspostcssConfiguring TailwindCreate apostcss.config.mjsfile in the root of your project and add the@tailwindcss/postcssplugin to your PostCSS configuration:postcss.config.mjs/**@type{import('tailwindcss').Config}*/exportdefault{plugins:{'@tailwindcss/postcss':{},},}Using TailwindAdd theTailwind directivesto yourGlobal Stylesheet:app/globals.css@import'tailwindcss';Then, import the styles in theroot layout:app/layout.tsxTypeScriptJavaScriptTypeScriptimporttype{ Metadata }from'next'// These styles apply to every route in the applicationimport'./globals.css'exportconstmetadata:Metadata={title:'Create Next App',description:'Generated by create next app',}exportdefaultfunctionRootLayout({children,}:{children:React.ReactNode}) {return(<htmllang=""en""><body>{children}</body></html>)}Lastly, you can start writing Tailwind's utility classes in your application.app/page.tsxTypeScriptJavaScriptTypeScriptexportdefaultfunctionPage() {return<h1className=""text-3xl font-bold underline"">Hello, Next.js!</h1>}SassNext.js integrates withSassusing both the.scssand.sassextensions and syntax.You can also use component-level Sass viaCSS Modulesand the.module.scssor.module.sassextension.Installing SassTo start using Sass, install thesasspackage:Terminalnpminstall--save-devsassCustomizing Sass optionsIf you want to configure your Sass options, use thesassOptionsoption innext.config.js.next.config.tsTypeScriptJavaScriptTypeScriptimporttype{ NextConfig }from'next'constnextConfig:NextConfig={sassOptions:{additionalData:`$var: red;`,},}exportdefaultnextConfigCSS-in-JSWarning:CSS-in-JS libraries which require runtime JavaScript are not currently supported in React Server Components. Using CSS-in-JS with newer React features like Server Components and Streaming requires library authors to support the latest version of React.The following libraries are supported inClient Componentsin theappdirectory (alphabetical):ant-designchakra-ui@fluentui/react-componentskuma-ui@mui/material@mui/joypandacssstyled-jsxstyled-componentsstylextamaguitss-reactvanilla-extractThe following are currently working on support:emotionIf you want to style Server Components, we recommend usingCSS Modulesor other solutions that output CSS files, likeTailwind CSS.Configuring CSS-in-JSTo configure CSS-in-JS, you need to:Create astyle registryto collect all CSS rules in a render.Use theuseServerInsertedHTMLhook to inject rules before any content that might use them.Create a Client Component that wraps your app with the style registry during initial server-side rendering.styled-jsxTo configurestyled-jsxfor your application, create a new registry:app/registry.tsxTypeScriptJavaScriptTypeScript'use client'importReact,{ useState }from'react'import{ useServerInsertedHTML }from'next/navigation'import{ StyleRegistry,createStyleRegistry }from'styled-jsx'exportdefaultfunctionStyledJsxRegistry({children,}:{children:React.ReactNode}) {// Only create stylesheet once with lazy initial state// x-ref: https://reactjs.org/docs/hooks-reference.html#lazy-initial-stateconst[jsxStyleRegistry]=useState(()=>createStyleRegistry())useServerInsertedHTML(()=>{conststyles=jsxStyleRegistry.styles()jsxStyleRegistry.flush()return<>{styles}</>})return<StyleRegistryregistry={jsxStyleRegistry}>{children}</StyleRegistry>}Then, wrap yourroot layoutwith the registry:app/layout.tsxTypeScriptJavaScriptTypeScriptimportStyledJsxRegistryfrom'./registry'exportdefaultfunctionRootLayout({children,}:{children:React.ReactNode}) {return(<html><body><StyledJsxRegistry>{children}</StyledJsxRegistry></body></html>)}styled-componentsTo usestyled-components, enable it innext.config.js:next.config.tsTypeScriptJavaScriptTypeScriptimporttype{ NextConfig }from'next'constnextConfig:NextConfig={compiler:{styledComponents:true,},}exportdefaultnextConfigThen, use thestyled-componentsAPI to create a global registry component to collect all CSS style rules generated during a render, and a function to return those rules. Then use theuseServerInsertedHTMLhook to inject the styles collected in the registry into the<head>HTML tag in the root layout.lib/registry.tsxTypeScriptJavaScriptTypeScript'use client'importReact,{ useState }from'react'import{ useServerInsertedHTML }from'next/navigation'import{ ServerStyleSheet,StyleSheetManager }from'styled-components'exportdefaultfunctionStyledComponentsRegistry({children,}:{children:React.ReactNode}) {// Only create stylesheet once with lazy initial state// x-ref: https://reactjs.org/docs/hooks-reference.html#lazy-initial-stateconst[styledComponentsStyleSheet]=useState(()=>newServerStyleSheet())useServerInsertedHTML(()=>{conststyles=styledComponentsStyleSheet.getStyleElement()styledComponentsStyleSheet.instance.clearTag()return<>{styles}</>})if(typeofwindow!=='undefined')return<>{children}</>return(<StyleSheetManagersheet={styledComponentsStyleSheet.instance}>{children}</StyleSheetManager>)}Wrap thechildrenof the root layout with the style registry component:app/layout.tsxTypeScriptJavaScriptTypeScriptimportStyledComponentsRegistryfrom'./lib/registry'exportdefaultfunctionRootLayout({children,}:{children:React.ReactNode}) {return(<html><body><StyledComponentsRegistry>{children}</StyledComponentsRegistry></body></html>)}External stylesheetsStylesheets published by external packages can be imported anywhere in theappdirectory, including colocated components:app/layout.tsxTypeScriptJavaScriptTypeScriptimport'bootstrap/dist/css/bootstrap.css'exportdefaultfunctionRootLayout({children,}:{children:React.ReactNode}) {return(<htmllang=""en""><bodyclassName=""container"">{children}</body></html>)}External stylesheets must be directly imported from an npm package or downloaded and colocated with your codebase. You cannot use<link rel=""stylesheet"" />.API ReferenceLearn more about the features mentioned in this page by reading the API Reference.sassOptionsConfigure Sass options.Next.js CompilerNext.js Compiler, written in Rust, which transforms and minifies your Next.js application.PreviousImages and FontsNextFetching DataWas this helpful?supported.Send"
fetching data,Fetching Data,"App RouterGetting StartedFetching DataHow to fetch data and streamThis page will walk you through how you can fetch data inServer ComponentsandClient Components. As well as how tostreamcontent that depends on data.Fetching dataServer ComponentsYou can fetch data in Server Components using:ThefetchAPIAnORM or databaseWith thefetchAPITo fetch data with thefetchAPI, turn your component into an asynchronous function, and await thefetchcall. For example:app/blog/page.tsxTypeScriptJavaScriptTypeScriptexportdefaultasyncfunctionPage() {constdata=awaitfetch('https://api.vercel.app/blog')constposts=awaitdata.json()return(<ul>{posts.map((post)=>(<likey={post.id}>{post.title}</li>))}</ul>)}With an ORM or databaseYou can fetch data with an ORM or database by turning your component into an asynchronous function, and awaiting the call:app/blog/page.tsxTypeScriptJavaScriptTypeScriptimport{ db,posts }from'@/lib/db'exportdefaultasyncfunctionPage() {constallPosts=awaitdb.select().from(posts)return(<ul>{allPosts.map((post)=>(<likey={post.id}>{post.title}</li>))}</ul>)}Client ComponentsThere are two ways to fetch data in Client Components, using:React'susehookA community library likeSWRorReact QueryWith theusehookYou can use React'susehooktostreamdata from the server to client. Start by fetching data in your Server component, and pass the promise to your Client Component as prop:app/blog/page.tsxTypeScriptJavaScriptTypeScriptimportPostsfrom'@/app/ui/postsimport{ Suspense }from'react'exportdefaultfunctionPage() {// Don't await the data fetching functionconstposts=getPosts()return(<Suspensefallback={<div>Loading...</div>}><Postsposts={posts} /></Suspense>)}Then, in your Client Component, use theusehook to read the promise:app/ui/posts.tsxTypeScriptJavaScriptTypeScript'use client'import{ use }from'react'exportdefaultfunctionPosts({posts,}:{posts:Promise<{ id:string; title:string}[]>}) {constallPosts=use(posts)return(<ul>{allPosts.map((post)=>(<likey={post.id}>{post.title}</li>))}</ul>)}In the example above, you need to wrap the<Posts />component in a<Suspense>boundary. This means the fallback will be shown while the promise is being resolved. Learn more aboutstreaming.Community librariesYou can use a community library likeSWRorReact Queryto fetch data in Client Components. These libraries have their own semantics for caching, streaming, and other features. For example, with SWR:app/blog/page.tsxTypeScriptJavaScriptTypeScript'use client'importuseSWRfrom'swr'constfetcher=(url)=>fetch(url).then((r)=>r.json())exportdefaultfunctionBlogPage() {const{data,error,isLoading}=useSWR('https://api.vercel.app/blog',fetcher)if(isLoading)return<div>Loading...</div>if(error)return<div>Error: {error.message}</div>return(<ul>{data.map((post:{ id:string; title:string})=>(<likey={post.id}>{post.title}</li>))}</ul>)}StreamingWarning:The content below assumes thedynamicIOconfig optionis enabled in your application. The flag was introduced in Next.js 15 canary.When usingasync/awaitin Server Components, Next.js will opt intodynamic rendering. This means the data will be fetched and rendered on the server for every user request. If there are any slow data requests, the whole route will be blocked from rendering.To improve the initial load time and user experience, you can use streaming to break up the page's HTML into smaller chunks and progressively send those chunks from the server to the client.There are two ways you can implement streaming in your application:With theloading.jsfileWith React's<Suspense>componentWithloading.jsYou can create aloading.jsfile in the same folder as your page to stream theentire pagewhile the data is being fetched. For example, to streamapp/blog/page.js, add the file inside theapp/blogfolder.app/blog/loading.tsxTypeScriptJavaScriptTypeScriptexportdefaultfunctionLoading() {// Define the Loading UI herereturn<div>Loading...</div>}On navigation, the user will immediately see the layout and aloading statewhile the page is being rendered. The new content will then be automatically swapped in once rendering is complete.Behind-the-scenes,loading.jswill be nested insidelayout.js, and will automatically wrap thepage.jsfile and any children below in a<Suspense>boundary.This approach works well for route segments (layouts and pages), but for more granular streaming, you can use<Suspense>.With<Suspense><Suspense>allows you to be more granular about what parts of the page to stream. For example, you can immediately show any page content that falls outside of the<Suspense>boundary, and stream in the list of blog posts inside the boundary.app/blog/page.tsxTypeScriptJavaScriptTypeScriptimport{ Suspense }from'react'importBlogListfrom'@/components/BlogList'importBlogListSkeletonfrom'@/components/BlogListSkeleton'exportdefaultfunctionBlogPage() {return(<div>{/* This content will be sent to the client immediately */}<header><h1>Welcome to the Blog</h1><p>Read the latest posts below.</p></header><main>{/* Any content wrapped in a <Suspense> boundary will be streamed */}<Suspensefallback={<BlogListSkeleton/>}><BlogList/></Suspense></main></div>)}Creating meaningful loading statesAn instant loading state is fallback UI that is shown immediately to the user after navigation. For the best user experience, we recommend designing loading states that are meaningful and help users understand the app is responding. For example, you can use skeletons and spinners, or a small but meaningful part of future screens such as a cover photo, title, etc.In development, you can preview and inspect the loading state of your components using theReact Devtools.API ReferenceLearn more about the features mentioned in this page by reading the API Reference.fetchAPI reference for the extended fetch function.loading.jsAPI reference for the loading.js file.PreviousCSSNextUpdating DataWas this helpful?supported.Send"
updating data,Updating Data,"App RouterGetting StartedUpdating DataHow to update dataYou can update data in Next.js using React'sServer Functions. This page will go through how you cancreateandinvokeServer Functions.Creating Server FunctionsA Server Function can be defined by using theuse serverdirective. You can place the directive at the top of anasynchronousfunction to mark the function as a Server Function, or at the top of a separate file to mark all exports of that file. We recommend using a separate file in most instances.app/lib/actions.tsTypeScriptJavaScriptTypeScript'use server'exportasyncfunctioncreatePost(formData:FormData) {}exportasyncfunctiondeletePost(formData:FormData) {}Server ComponentsServer Functions can be inlined in Server Components by adding the""use server""directive to the top of the function body:app/page.tsxTypeScriptJavaScriptTypeScriptexportdefaultfunctionPage() {// Server ActionasyncfunctioncreatePost() {'use server'// Update data// ...return<></>}Client ComponentsIt's not possible to define Server Functions in Client Components. However, you can invoke them in Client Components by importing them from a file that has the""use server""directive at the top of it:app/actions.tsTypeScriptJavaScriptTypeScript'use server'exportasyncfunctioncreatePost() {}app/ui/button.tsxTypeScriptJavaScriptTypeScript'use client'import{ createPost }from'@/app/actions'exportfunctionButton() {return<buttonformAction={createPost}>Create</button>}Invoking Server FunctionsThere are two main ways you can invoke a Server Function:Formsin Server and Client ComponentsEvent Handlersin Client ComponentsFormsReact extends the HTML<form>element to allow Server Function to be invoked with the HTMLactionprop.When invoked in a form, the function automatically receives theFormDataobject. You can extract the data using the nativeFormDatamethods:app/ui/form.tsxTypeScriptJavaScriptTypeScriptimport{ createPost }from'@/app/actions'exportfunctionForm() {return(<formaction={createPost}><inputtype=""text""name=""title""/><inputtype=""text""name=""content""/><buttontype=""submit"">Create</button></form>)}app/actions.tsTypeScriptJavaScriptTypeScript'use server'exportasyncfunctioncreatePost(formData:FormData) {consttitle=formData.get('title')constcontent=formData.get('content')// Update data// Revalidate cache}Good to know:When passed to theactionprop, Server Functions are also known asServer Actions.Event HandlersYou can invoke a Server Function in a Client Component by using event handlers such asonClick.app/like-button.tsxTypeScriptJavaScriptTypeScript'use client'import{ incrementLike }from'./actions'import{ useState }from'react'exportdefaultfunctionLikeButton({ initialLikes }:{ initialLikes:number}) {const[likes,setLikes]=useState(initialLikes)return(<><p>Total Likes: {likes}</p><buttononClick={async()=>{constupdatedLikes=awaitincrementLike()setLikes(updatedLikes)}}>Like</button></>)}Showing a pending stateWhile executing a Server Function, you can show a loading indicator with React'suseActionStatehook. This hook returns apendingboolean:app/ui/button.tsxTypeScriptJavaScriptTypeScript'use client'import{ useActionState }from'react'import{ createPost }from'@/app/actions'import{ LoadingSpinner }from'@/app/ui/loading-spinner'exportfunctionButton() {const[state,action,pending]=useActionState(createPost,false)return(<buttononClick={async()=>action()}>{pending?<LoadingSpinner/>:'Create Post'}</button>)}Revalidating the cacheAfter performing an update, you can revalidate the Next.js cache and show the updated data by callingrevalidatePathorrevalidateTagwithin the Server Function:app/lib/actions.tsTypeScriptJavaScriptTypeScript'use server'import{ revalidatePath }from'next/cache'exportasyncfunctioncreatePost(formData:FormData) {// Update data// ...revalidatePath('/posts')}RedirectingYou may want to redirect the user to a different page after performing an update. You can do this by callingredirectwithin the Server Function:app/lib/actions.tsTypeScriptJavaScriptTypeScript'use server'import{ redirect }from'next/navigation'exportasyncfunctioncreatePost(formData:FormData) {// Update data// ...redirect('/posts')}API ReferenceLearn more about the features mentioned in this page by reading the API Reference.revalidatePathAPI Reference for the revalidatePath function.revalidateTagAPI Reference for the revalidateTag function.redirectAPI Reference for the redirect function.PreviousFetching DataNextError HandlingWas this helpful?supported.Send"
error handling,Error Handling,"App RouterGetting StartedError HandlingHow to handle errorsErrors can be divided into two categories:expected errorsanduncaught exceptions. This page will walk you through how you can handle these errors in your Next.js application.Handling expected errorsExpected errors are those that can occur during the normal operation of the application, such as those fromserver-side form validationor failed requests. These errors should be handled explicitly and returned to the client.Server ActionsYou can use theuseActionStatehook to manage the state ofServer Functionsand handle expected errors. Avoid usingtry/catchblocks for expected errors. Instead, you can model expected errors as return values, not as thrown exceptions.app/actions.tsTypeScriptJavaScriptTypeScript'use server'exportasyncfunctioncreatePost(prevState:any,formData:FormData) {consttitle=formData.get('title')constcontent=formData.get('content')constres=awaitfetch('https://api.vercel.app/posts',{method:'POST',body:{ title,content },})constjson=awaitres.json()if(!res.ok) {return{ message:'Failed to create post'}}}Then, you can pass your action to theuseActionStatehook and use the returnedstateto display an error message.app/ui/form.tsxTypeScriptJavaScriptTypeScript'use client'import{ useActionState }from'react'import{ createPost }from'@/app/actions'constinitialState={message:'',}exportfunctionForm() {const[state,formAction,pending]=useActionState(createPost,initialState)return(<formaction={formAction}><labelhtmlFor=""title"">Title</label><inputtype=""text""id=""title""name=""title""required/><labelhtmlFor=""content"">Content</label><textareaid=""content""name=""content""required/>{state?.message&&<paria-live=""polite"">{state.message}</p>}<buttondisabled={pending}>Create Post</button></form>)}Server ComponentsWhen fetching data inside of a Server Component, you can use the response to conditionally render an error message orredirect.app/page.tsxTypeScriptJavaScriptTypeScriptexportdefaultasyncfunctionPage() {constres=awaitfetch(`https://...`)constdata=awaitres.json()if(!res.ok) {return'There was an error.'}return'...'}Not foundYou can call thenotFoundfunction within a route segment and use thenot-found.jsfile to show a 404 UI.app/blog/[slug]/page.tsxTypeScriptJavaScriptTypeScriptimport{ getPostBySlug }from'@/lib/posts'exportdefaultasyncfunctionPage({ params }:{ params:{ slug:string} }) {constpost=getPostBySlug((awaitparams).slug)if(!post) {notFound()}return<div>{post.title}</div>}app/blog/[slug]/not-found.tsxTypeScriptJavaScriptTypeScriptexportdefaultfunctionNotFound() {return<div>404 - Page Not Found</div>}Handling uncaught exceptionsUncaught exceptions are unexpected errors that indicate bugs or issues that should not occur during the normal flow of your application. These should be handled by throwing errors, which will then be caught by error boundaries.Nested error boundariesNext.js uses error boundaries to handle uncaught exceptions. Error boundaries catch errors in their child components and display a fallback UI instead of the component tree that crashed.Create an error boundary by adding anerror.jsfile inside a route segment and exporting a React component:app/dashboard/error.tsxTypeScriptJavaScriptTypeScript'use client'// Error boundaries must be Client Componentsimport{ useEffect }from'react'exportdefaultfunctionError({error,reset,}:{error:Error&{ digest?:string}reset:()=>void}) {useEffect(()=>{// Log the error to an error reporting serviceconsole.error(error)},[error])return(<div><h2>Something went wrong!</h2><buttononClick={// Attempt to recover by trying to re-render the segment()=>reset()}>Try again</button></div>)}Errors will bubble up to the nearest parent error boundary. This allows for granular error handling by placingerror.tsxfiles at different levels in theroute hierarchy.Global errorsWhile less common, you can handle errors in the root layout using theglobal-error.jsfile, located in the root app directory, even when leveraginginternationalization. Global error UI must define its own<html>and<body>tags, since it is replacing the root layout or template when active.app/global-error.tsxTypeScriptJavaScriptTypeScript'use client'// Error boundaries must be Client ComponentsexportdefaultfunctionGlobalError({error,reset,}:{error:Error&{ digest?:string}reset:()=>void}) {return(// global-error must include html and body tags<html><body><h2>Something went wrong!</h2><buttononClick={()=>reset()}>Try again</button></body></html>)}API ReferenceLearn more about the features mentioned in this page by reading the API Reference.redirectAPI Reference for the redirect function.error.jsAPI reference for the error.js special file.notFoundAPI Reference for the notFound function.not-found.jsAPI reference for the not-found.js file.PreviousUpdating DataNextExamplesWas this helpful?supported.Send"
examples,Examples,"IntroductionApp RouterExamplesExamplesData FetchingUsing thefetchAPIUsing an ORM or database clientReading search params on the serverReading search params on the clientRevalidating DataUsing ISR to revalidate data after a certain timeUsing ISR to revalidate data on-demandFormsShowing a pending state while submitting a formServer-side form validationHandling expected errorsHandling unexpected exceptionsShowing optimistic UI updatesProgrammatic form submissionServer ActionsPassing additional valuesRevalidating dataRedirectingSetting cookiesDeleting cookiesMetadataCreating an RSS feedCreating an Open Graph imageCreating a sitemapCreating a robots.txt fileCreating a custom 404 pageCreating a custom 500 pageAuthCreating a sign-up formStateless, cookie-based session managementStateful, database-backed session managementManaging authorizationTestingVitestJestPlaywrightCypressDeploymentCreating a DockerfileCreating a static export (SPA)Configuring caching when self-hostingConfiguring Image Optimization when self-hostingPreviousError HandlingNextBuilding Your ApplicationWas this helpful?supported.Send"
building your application,Building Your Application,"IntroductionApp RouterBuilding Your ApplicationBuilding Your ApplicationNext.js provides the building blocks to create flexible, full-stack web applications. The guides inBuilding Your Applicationexplain how to use these features and how to customize your application's behavior.The sections and pages are organized sequentially, from basic to advanced, so you can follow them step-by-step when building your Next.js application. However, you can read them in any order or skip to the pages that apply to your use case.If you're new to Next.js, we recommend starting with theRouting,Rendering,Data FetchingandStylingsections, as they introduce the fundamental Next.js and web concepts to help you get started. Then, you can dive deeper into the other sections such asOptimizingandConfiguring. Finally, once you're ready, checkout theDeployingandUpgradingsections.RoutingLearn the fundamentals of routing for front-end applications.Data FetchingLearn how to fetch, cache, revalidate, and mutate data with Next.js.RenderingLearn the differences between Next.js rendering environments, strategies, and runtimes.CachingAn overview of caching mechanisms in Next.js.StylingLearn the different ways you can style your Next.js application.OptimizingOptimize your Next.js application for best performance and user experience.ConfiguringLearn how to configure your Next.js application.TestingLearn how to set up Next.js with four commonly used testing tools — Cypress, Playwright, Vitest, and Jest.AuthenticationLearn how to implement authentication in your Next.js application.DeployingLearn how to deploy your Next.js app to production, either managed or self-hosted.UpgradingLearn how to upgrade to the latest versions of Next.js.PreviousExamplesNextRoutingWas this helpful?supported.Send"
routing,Routing,"App RouterBuilding Your ApplicationRoutingRouting FundamentalsLayouts and TemplatesCreate your first shared layout in Next.js.Linking and NavigatingLearn how navigation works in Next.js, and how to use the Link Component and `useRouter` hook.Error HandlingLearn how to display expected errors and handle uncaught exceptions.Loading UI and StreamingBuilt on top of Suspense, Loading UI allows you to create a fallback for specific route segments, and automatically stream content as it becomes ready.RedirectingLearn the different ways to handle redirects in Next.js.Route GroupsRoute Groups can be used to partition your Next.js application into different sections.Dynamic RoutesDynamic Routes can be used to programmatically generate route segments from dynamic data.Parallel RoutesSimultaneously render one or more pages in the same view that can be navigated independently. A pattern for highly dynamic applications.Intercepting RoutesUse intercepting routes to load a new route within the current layout while masking the browser URL, useful for advanced routing patterns such as modals.Route HandlersCreate custom request handlers for a given route using the Web's Request and Response APIs.MiddlewareLearn how to use Middleware to run code before a request is completed.InternationalizationAdd support for multiple languages with internationalized routing and localized content.PreviousBuilding Your ApplicationNextLayouts and TemplatesWas this helpful?supported.Send"
layouts and templates,Layouts and Templates,"App RouterGetting StartedLayouts and PagesHow to create layouts and pagesNext.js usesfile-system based routing, meaning you can use folders and files to define routes. This page will guide you through how to create layouts and pages, and link between them.Creating a pageApageis UI that is rendered on a specific route. To create a page, add apagefileinside theappdirectory and default export a React component. For example, to create an index page (/):app/page.tsxTypeScriptJavaScriptTypeScriptexportdefaultfunctionPage() {return<h1>Hello Next.js!</h1>}Creating a layoutA layout is UI that issharedbetween multiple pages. On navigation, layouts preserve state, remain interactive, and do not rerender.You can define a layout by default exporting a React component from alayoutfile. The component should accept achildrenprop which can be a page or anotherlayout.For example, to create a layout that accepts your index page as child, add alayoutfile inside theappdirectory:app/layout.tsxTypeScriptJavaScriptTypeScriptexportdefaultfunctionDashboardLayout({children,}:{children:React.ReactNode}) {return(<htmllang=""en""><body>{/* Layout UI */}{/* Place children where you want to render a page or nested layout */}<main>{children}</main></body></html>)}The layout above is called aroot layoutbecause it's defined at the root of theappdirectory. The root layout isrequiredand must containhtmlandbodytags.Creating a nested routeA nested route is a route composed of multiple URL segments. For example, the/blog/[slug]route is composed of three segments:/(Root Segment)blog(Segment)[slug](Leaf Segment)In Next.js:Foldersare used to define the route segments that map to URL segments.Files(likepageandlayout) are used to create UI that is shown for a segment.To create nested routes, you can nest folders inside each other. For example, to add a route for/blog, create a folder calledblogin theappdirectory. Then, to make/blogpublicly accessible, add apagefile:app/blog/page.tsxTypeScriptJavaScriptTypeScriptimport{ getPosts }from'@/lib/posts'import{ Post }from'@/ui/post'exportdefaultasyncfunctionPage() {constposts=awaitgetPosts()return(<ul>{posts.map((post)=>(<Postkey={post.id}post={post} />))}</ul>)}You can continue nesting folders to create nested routes. For example, to create a route for a specific blog post, create a new[slug]folder insideblogand add apagefile:app/blog/[slug]/page.tsxTypeScriptJavaScriptTypeScriptfunctiongenerateStaticParams() {}exportdefaultfunctionPage() {return<h1>Hello, Blog Post Page!</h1>}Good to know: Wrapping a folder name in square brackets (e.g.[slug]) creates a specialdynamic route segmentused to generate multiple pages from data. This is useful for blog posts, product pages, etc.Nesting layoutsBy default, layouts in the folder hierarchy are also nested, which means they wrap child layouts via theirchildrenprop. You can nest layouts by addinglayoutinside specific route segments (folders).For example, to create a layout for the/blogroute, add a newlayoutfile inside theblogfolder.app/blog/layout.tsxTypeScriptJavaScriptTypeScriptexportdefaultfunctionBlogLayout({children,}:{children:React.ReactNode}) {return<section>{children}</section>}If you were to combine the two layouts above, the root layout (app/layout.js) would wrap the blog layout (app/blog/layout.js), which would wrap the blog (app/blog/page.js) and blog post page (app/blog/[slug]/page.js).Linking between pagesYou can use the<Link>componentto navigate between routes.<Link>is a built-in Next.js component that extends the HTML<a>tag to provide prefetching and client-side navigation.For example, to generate a list of blog posts, import<Link>fromnext/linkand pass ahrefprop to the component:app/ui/post.tsxTypeScriptJavaScriptTypeScriptimportLinkfrom'next/link'exportdefaultasyncfunctionPost({ post }) {constposts=awaitgetPosts()return(<ul>{posts.map((post)=>(<likey={post.slug}><Linkhref={`/blog/${post.slug}`}>{post.title}</Link></li>))}</ul>)}<Link>is the primary and recommended way to navigate between routes in your Next.js application. However, you can also use theuseRouterhookfor more advanced navigation.API ReferenceLearn more about the features mentioned in this page by reading the API Reference.layout.jsAPI reference for the layout.js file.page.jsAPI reference for the page.js file.LinkEnable fast client-side navigation with the built-in `next/link` component.PreviousProject StructureNextImages and FontsWas this helpful?supported.Send"
linking and navigating,Linking and Navigating,"Building Your ApplicationRoutingLinking and NavigatingLinking and NavigatingThere are four ways to navigate between routes in Next.js:Using the<Link>ComponentUsing theuseRouterhook(Client Components)Using theredirectfunction(Server Components)Using the nativeHistory APIThis page will go through how to use each of these options, and dive deeper into how navigation works.<Link>Component<Link>is a built-in component that extends the HTML<a>tag to provideprefetchingand client-side navigation between routes. It is the primary and recommended way to navigate between routes in Next.js.You can use it by importing it fromnext/link, and passing ahrefprop to the component:app/page.tsxTypeScriptJavaScriptTypeScriptimportLinkfrom'next/link'exportdefaultfunctionPage() {return<Linkhref=""/dashboard"">Dashboard</Link>}There are other optional props you can pass to<Link>. See theAPI referencefor more.useRouter()hookTheuseRouterhook allows you to programmatically change routes fromClient Components.app/page.tsxTypeScriptJavaScriptTypeScript'use client'import{ useRouter }from'next/navigation'exportdefaultfunctionPage() {constrouter=useRouter()return(<buttontype=""button""onClick={()=>router.push('/dashboard')}>Dashboard</button>)}For a full list ofuseRoutermethods, see theAPI reference.Recommendation:Use the<Link>component to navigate between routes unless you have a specific requirement for usinguseRouter.redirectfunctionForServer Components, use theredirectfunction instead.app/team/[id]/page.tsxTypeScriptJavaScriptTypeScriptimport{ redirect }from'next/navigation'asyncfunctionfetchTeam(id:string) {constres=awaitfetch('https://...')if(!res.ok)returnundefinedreturnres.json()}exportdefaultasyncfunctionProfile({params,}:{params:Promise<{ id:string}>}) {constid=(awaitparams).idif(!id) {redirect('/login')}constteam=awaitfetchTeam(id)if(!team) {redirect('/join')}// ...}Good to know:redirectreturns a 307 (Temporary Redirect) status code by default. When used in a Server Action, it returns a 303 (See Other), which is commonly used for redirecting to a success page as a result of a POST request.redirectinternally throws an error so it should be called outside oftry/catchblocks.redirectcan be called in Client Components during the rendering process but not in event handlers. You can use theuseRouterhookinstead.redirectalso accepts absolute URLs and can be used to redirect to external links.If you'd like to redirect before the render process, usenext.config.jsorMiddleware.See theredirectAPI referencefor more information.Using the native History APINext.js allows you to use the nativewindow.history.pushStateandwindow.history.replaceStatemethods to update the browser's history stack without reloading the page.pushStateandreplaceStatecalls integrate into the Next.js Router, allowing you to sync withusePathnameanduseSearchParams.window.history.pushStateUse it to add a new entry to the browser's history stack. The user can navigate back to the previous state. For example, to sort a list of products:'use client'import{ useSearchParams }from'next/navigation'exportdefaultfunctionSortProducts() {constsearchParams=useSearchParams()functionupdateSorting(sortOrder:string) {constparams=newURLSearchParams(searchParams.toString())params.set('sort',sortOrder)window.history.pushState(null,'',`?${params.toString()}`)}return(<><buttononClick={()=>updateSorting('asc')}>Sort Ascending</button><buttononClick={()=>updateSorting('desc')}>Sort Descending</button></>)}window.history.replaceStateUse it to replace the current entry on the browser's history stack. The user is not able to navigate back to the previous state. For example, to switch the application's locale:'use client'import{ usePathname }from'next/navigation'exportfunctionLocaleSwitcher() {constpathname=usePathname()functionswitchLocale(locale:string) {// e.g. '/en/about' or '/fr/contact'constnewPath=`/${locale}${pathname}`window.history.replaceState(null,'',newPath)}return(<><buttononClick={()=>switchLocale('en')}>English</button><buttononClick={()=>switchLocale('fr')}>French</button></>)}How Routing and Navigation WorksThe App Router uses a hybrid approach for routing and navigation. On the server, your application code is automaticallycode-splitby route segments. And on the client, Next.jsprefetchesandcachesthe route segments. This means, when a user navigates to a new route, the browser doesn't reload the page, and only the route segments that change re-render - improving the navigation experience and performance.1. Code SplittingCode splitting allows you to split your application code into smaller bundles to be downloaded and executed by the browser. This reduces the amount of data transferred and execution time for each request, leading to improved performance.Server Componentsallow your application code to be automatically code-split by route segments. This means only the code needed for the current route is loaded on navigation.2. PrefetchingPrefetching is a way to preload a route in the background before the user visits it.There are two ways routes are prefetched in Next.js:<Link>component: Routes are automatically prefetched as they become visible in the user's viewport. Prefetching happens when the page first loads or when it comes into view through scrolling.router.prefetch(): TheuseRouterhook can be used to prefetch routes programmatically.The<Link>'s default prefetching behavior (i.e. when theprefetchprop is left unspecified or set tonull) is different depending on your usage ofloading.js. Only the shared layout, down the rendered ""tree"" of components until the firstloading.jsfile, is prefetched and cached for30s. This reduces the cost of fetching an entire dynamic route, and it means you can show aninstant loading statefor better visual feedback to users.You can disable prefetching by setting theprefetchprop tofalse. Alternatively, you can prefetch the full page data beyond the loading boundaries by setting theprefetchprop totrue.See the<Link>API referencefor more information.Good to know:Prefetching is not enabled in development, only in production.3. CachingNext.js has anin-memory client-side cachecalled theRouter Cache. As users navigate around the app, the React Server Component Payload ofprefetchedroute segments and visited routes are stored in the cache.This means on navigation, the cache is reused as much as possible, instead of making a new request to the server - improving performance by reducing the number of requests and data transferred.Learn more about how theRouter Cacheworks and how to configure it.4. Partial RenderingPartial rendering means only the route segments that change on navigation re-render on the client, and any shared segments are preserved.For example, when navigating between two sibling routes,/dashboard/settingsand/dashboard/analytics, thesettingspage will be unmounted, theanalyticspage will be mounted with fresh state, and the shareddashboardlayout will be preserved. This behavior is also present between two routes on the same dynamic segment e.g. with/blog/[slug]/pageand navigating from/blog/firstto/blog/second.Without partial rendering, each navigation would cause the full page to re-render on the client. Rendering only the segment that changes reduces the amount of data transferred and execution time, leading to improved performance.5. Soft NavigationBrowsers perform a ""hard navigation"" when navigating between pages. The Next.js App Router enables ""soft navigation"" between pages, ensuring only the route segments that have changed are re-rendered (partial rendering). This enables client React state to be preserved during navigation.6. Back and Forward NavigationBy default, Next.js will maintain the scroll position for backwards and forwards navigation, and re-use route segments in theRouter Cache.7. Routing betweenpages/andapp/When incrementally migrating frompages/toapp/, the Next.js router will automatically handle hard navigation between the two. To detect transitions frompages/toapp/, there is a client router filter that leverages probabilistic checking of app routes, which can occasionally result in false positives. By default, such occurrences should be very rare, as we configure the false positive likelihood to be 0.01%. This likelihood can be customized via theexperimental.clientRouterFilterAllowedRateoption innext.config.js. It's important to note that lowering the false positive rate will increase the size of the generated filter in the client bundle.Alternatively, if you prefer to disable this handling completely and manage the routing betweenpages/andapp/manually, you can setexperimental.clientRouterFilterto false innext.config.js. When this feature is disabled, any dynamic routes in pages that overlap with app routes won't be navigated to properly by default.Next StepsCachingAn overview of caching mechanisms in Next.js.TypeScriptNext.js provides a TypeScript-first development experience for building your React application.PreviousLayouts and TemplatesNextError HandlingWas this helpful?supported.Send"
error handling,Error Handling,"Building Your ApplicationRoutingError HandlingError HandlingErrors can be divided into two categories:expected errorsanduncaught exceptions:Model expected errors as return values: Avoid usingtry/catchfor expected errors in Server Actions. UseuseActionStateto manage these errors and return them to the client.Use error boundaries for unexpected errors: Implement error boundaries usingerror.tsxandglobal-error.tsxfiles to handle unexpected errors and provide a fallback UI.Handling Expected ErrorsExpected errors are those that can occur during the normal operation of the application, such as those fromserver-side form validationor failed requests. These errors should be handled explicitly and returned to the client.Handling Expected Errors from Server ActionsUse theuseActionStatehook to manage the state of Server Actions, including handling errors. This approach avoidstry/catchblocks for expected errors, which should be modeled as return values rather than thrown exceptions.app/actions.tsTypeScriptJavaScriptTypeScript'use server'import{ redirect }from'next/navigation'exportasyncfunctioncreateUser(prevState:any,formData:FormData) {constres=awaitfetch('https://...')constjson=awaitres.json()if(!res.ok) {return{ message:'Please enter a valid email'}}redirect('/dashboard')}Then, you can pass your action to theuseActionStatehook and use the returnedstateto display an error message.app/ui/signup.tsxTypeScriptJavaScriptTypeScript'use client'import{ useActionState }from'react'import{ createUser }from'@/app/actions'constinitialState={message:'',}exportfunctionSignup() {const[state,formAction,pending]=useActionState(createUser,initialState)return(<formaction={formAction}><labelhtmlFor=""email"">Email</label><inputtype=""text""id=""email""name=""email""required/>{/* ... */}<paria-live=""polite"">{state?.message}</p><buttondisabled={pending}>Sign up</button></form>)}You could also use the returned state to display a toast message from the client component.Handling Expected Errors from Server ComponentsWhen fetching data inside of a Server Component, you can use the response to conditionally render an error message orredirect.app/page.tsxTypeScriptJavaScriptTypeScriptexportdefaultasyncfunctionPage() {constres=awaitfetch(`https://...`)constdata=awaitres.json()if(!res.ok) {return'There was an error.'}return'...'}Uncaught ExceptionsUncaught exceptions are unexpected errors that indicate bugs or issues that should not occur during the normal flow of your application. These should be handled by throwing errors, which will then be caught by error boundaries.Common:Handle uncaught errors below the root layout witherror.js.Optional:Handle granular uncaught errors with nestederror.jsfiles (e.g.app/dashboard/error.js)Uncommon:Handle uncaught errors in the root layout withglobal-error.js.Using Error BoundariesNext.js uses error boundaries to handle uncaught exceptions. Error boundaries catch errors in their child components and display a fallback UI instead of the component tree that crashed.Create an error boundary by adding anerror.tsxfile inside a route segment and exporting a React component:app/dashboard/error.tsxTypeScriptJavaScriptTypeScript'use client'// Error boundaries must be Client Componentsimport{ useEffect }from'react'exportdefaultfunctionError({error,reset,}:{error:Error&{ digest?:string}reset:()=>void}) {useEffect(()=>{// Log the error to an error reporting serviceconsole.error(error)},[error])return(<div><h2>Something went wrong!</h2><buttononClick={// Attempt to recover by trying to re-render the segment()=>reset()}>Try again</button></div>)}If you want errors to bubble up to the parent error boundary, you canthrowwhen rendering theerrorcomponent.Handling Errors in Nested RoutesErrors will bubble up to the nearest parent error boundary. This allows for granular error handling by placingerror.tsxfiles at different levels in theroute hierarchy.Handling Global ErrorsWhile less common, you can handle errors in the root layout usingapp/global-error.js, located in the root app directory, even when leveraginginternationalization. Global error UI must define its own<html>and<body>tags, since it is replacing the root layout or template when active.app/global-error.tsxTypeScriptJavaScriptTypeScript'use client'// Error boundaries must be Client ComponentsexportdefaultfunctionGlobalError({error,reset,}:{error:Error&{ digest?:string}reset:()=>void}) {return(// global-error must include html and body tags<html><body><h2>Something went wrong!</h2><buttononClick={()=>reset()}>Try again</button></body></html>)}Next Stepserror.jsAPI reference for the error.js special file.PreviousLinking and NavigatingNextLoading UI and StreamingWas this helpful?supported.Send"
loading ui and streaming,Loading UI and Streaming,"Building Your ApplicationRoutingLoading UI and StreamingLoading UI and StreamingThe special fileloading.jshelps you create meaningful Loading UI withReact Suspense. With this convention, you can show aninstant loading statefrom the server while the content of a route segment loads. The new content is automatically swapped in once rendering is complete.Instant Loading StatesAn instant loading state is fallback UI that is shown immediately upon navigation. You can pre-render loading indicators such as skeletons and spinners, or a small but meaningful part of future screens such as a cover photo, title, etc. This helps users understand the app is responding and provides a better user experience.Create a loading state by adding aloading.jsfile inside a folder.app/dashboard/loading.tsxTypeScriptJavaScriptTypeScriptexportdefaultfunctionLoading() {// You can add any UI inside Loading, including a Skeleton.return<LoadingSkeleton/>}In the same folder,loading.jswill be nested insidelayout.js. It will automatically wrap thepage.jsfile and any children below in a<Suspense>boundary.Good to know:Navigation is immediate, even withserver-centric routing.Navigation is interruptible, meaning changing routes does not need to wait for the content of the route to fully load before navigating to another route.Shared layouts remain interactive while new route segments load.Recommendation:Use theloading.jsconvention for route segments (layouts and pages) as Next.js optimizes this functionality.Streaming with SuspenseIn addition toloading.js, you can also manually create Suspense Boundaries for your own UI components. The App Router supports streaming withSuspense.Good to know:Some browsersbuffer a streaming response. You may not see the streamed response until the response exceeds 1024 bytes. This typically only affects “hello world” applications, but not real applications.What is Streaming?To learn how Streaming works in React and Next.js, it's helpful to understandServer-Side Rendering (SSR)and its limitations.With SSR, there's a series of steps that need to be completed before a user can see and interact with a page:First, all data for a given page is fetched on the server.The server then renders the HTML for the page.The HTML, CSS, and JavaScript for the page are sent to the client.A non-interactive user interface is shown using the generated HTML, and CSS.Finally, Reacthydratesthe user interface to make it interactive.These steps are sequential and blocking, meaning the server can only render the HTML for a page once all the data has been fetched. And, on the client, React can only hydrate the UI once the code for all components in the page has been downloaded.SSR with React and Next.js helps improve the perceived loading performance by showing a non-interactive page to the user as soon as possible.However, it can still be slow as all data fetching on server needs to be completed before the page can be shown to the user.Streamingallows you to break down the page's HTML into smaller chunks and progressively send those chunks from the server to the client.This enables parts of the page to be displayed sooner, without waiting for all the data to load before any UI can be rendered.Streaming works well with React's component model because each component can be considered a chunk. Components that have higher priority (e.g. product information) or that don't rely on data can be sent first (e.g. layout), and React can start hydration earlier. Components that have lower priority (e.g. reviews, related products) can be sent in the same server request after their data has been fetched.Streaming is particularly beneficial when you want to prevent long data requests from blocking the page from rendering as it can reduce theTime To First Byte (TTFB)andFirst Contentful Paint (FCP). It also helps improveTime to Interactive (TTI), especially on slower devices.Example<Suspense>works by wrapping a component that performs an asynchronous action (e.g. fetch data), showing fallback UI (e.g. skeleton, spinner) while it's happening, and then swapping in your component once the action completes.app/dashboard/page.tsxTypeScriptJavaScriptTypeScriptimport{ Suspense }from'react'import{ PostFeed,Weather }from'./Components'exportdefaultfunctionPosts() {return(<section><Suspensefallback={<p>Loading feed...</p>}><PostFeed/></Suspense><Suspensefallback={<p>Loading weather...</p>}><Weather/></Suspense></section>)}By using Suspense, you get the benefits of:Streaming Server Rendering- Progressively rendering HTML from the server to the client.Selective Hydration- React prioritizes what components to make interactive first based on user interaction.For more Suspense examples and use cases, please see theReact Documentation.SEONext.js will wait for data fetching insidegenerateMetadatato complete before streaming UI to the client. This guarantees the first part of a streamed response includes<head>tags.Since streaming is server-rendered, it does not impact SEO. You can use theRich Results Testtool from Google to see how your page appears to Google's web crawlers and view the serialized HTML (source).Status CodesWhen streaming, a200status code will be returned to signal that the request was successful.The server can still communicate errors or issues to the client within the streamed content itself, for example, when usingredirectornotFound. Since the response headers have already been sent to the client, the status code of the response cannot be updated. This does not affect SEO.PreviousError HandlingNextRedirectingWas this helpful?supported.Send"
redirecting,Redirecting,"Building Your ApplicationRoutingRedirectingRedirectingThere are a few ways you can handle redirects in Next.js. This page will go through each available option, use cases, and how to manage large numbers of redirects.APIPurposeWhereStatus CoderedirectRedirect user after a mutation or eventServer Components, Server Actions, Route Handlers307 (Temporary) or 303 (Server Action)permanentRedirectRedirect user after a mutation or eventServer Components, Server Actions, Route Handlers308 (Permanent)useRouterPerform a client-side navigationEvent Handlers in Client ComponentsN/Aredirectsinnext.config.jsRedirect an incoming request based on a pathnext.config.jsfile307 (Temporary) or 308 (Permanent)NextResponse.redirectRedirect an incoming request based on a conditionMiddlewareAnyredirectfunctionTheredirectfunction allows you to redirect the user to another URL. You can callredirectinServer Components,Route Handlers, andServer Actions.redirectis often used after a mutation or event. For example, creating a post:app/actions.tsTypeScriptJavaScriptTypeScript'use server'import{ redirect }from'next/navigation'import{ revalidatePath }from'next/cache'exportasyncfunctioncreatePost(id:string) {try{// Call database}catch(error) {// Handle errors}revalidatePath('/posts')// Update cached postsredirect(`/post/${id}`)// Navigate to the new post page}Good to know:redirectreturns a 307 (Temporary Redirect) status code by default. When used in a Server Action, it returns a 303 (See Other), which is commonly used for redirecting to a success page as a result of a POST request.redirectinternally throws an error so it should be called outside oftry/catchblocks.redirectcan be called in Client Components during the rendering process but not in event handlers. You can use theuseRouterhookinstead.redirectalso accepts absolute URLs and can be used to redirect to external links.If you'd like to redirect before the render process, usenext.config.jsorMiddleware.See theredirectAPI referencefor more information.permanentRedirectfunctionThepermanentRedirectfunction allows you topermanentlyredirect the user to another URL. You can callpermanentRedirectinServer Components,Route Handlers, andServer Actions.permanentRedirectis often used after a mutation or event that changes an entity's canonical URL, such as updating a user's profile URL after they change their username:app/actions.tsTypeScriptJavaScriptTypeScript'use server'import{ permanentRedirect }from'next/navigation'import{ revalidateTag }from'next/cache'exportasyncfunctionupdateUsername(username:string,formData:FormData) {try{// Call database}catch(error) {// Handle errors}revalidateTag('username')// Update all references to the usernamepermanentRedirect(`/profile/${username}`)// Navigate to the new user profile}Good to know:permanentRedirectreturns a 308 (permanent redirect) status code by default.permanentRedirectalso accepts absolute URLs and can be used to redirect to external links.If you'd like to redirect before the render process, usenext.config.jsorMiddleware.See thepermanentRedirectAPI referencefor more information.useRouter()hookIf you need to redirect inside an event handler in a Client Component, you can use thepushmethod from theuseRouterhook. For example:app/page.tsxTypeScriptJavaScriptTypeScript'use client'import{ useRouter }from'next/navigation'exportdefaultfunctionPage() {constrouter=useRouter()return(<buttontype=""button""onClick={()=>router.push('/dashboard')}>Dashboard</button>)}Good to know:If you don't need to programmatically navigate a user, you should use a<Link>component.See theuseRouterAPI referencefor more information.redirectsinnext.config.jsTheredirectsoption in thenext.config.jsfile allows you to redirect an incoming request path to a different destination path. This is useful when you change the URL structure of pages or have a list of redirects that are known ahead of time.redirectssupportspath,header, cookie, and query matching, giving you the flexibility to redirect users based on an incoming request.To useredirects, add the option to yournext.config.jsfile:next.config.tsTypeScriptJavaScriptTypeScriptimporttype{ NextConfig }from'next'constnextConfig:NextConfig={asyncredirects() {return[// Basic redirect{source:'/about',destination:'/',permanent:true,},// Wildcard path matching{source:'/blog/:slug',destination:'/news/:slug',permanent:true,},]},}exportdefaultnextConfigSee theredirectsAPI referencefor more information.Good to know:redirectscan return a 307 (Temporary Redirect) or 308 (Permanent Redirect) status code with thepermanentoption.redirectsmay have a limit on platforms. For example, on Vercel, there's a limit of 1,024 redirects. To manage a large number of redirects (1000+), consider creating a custom solution usingMiddleware. Seemanaging redirects at scalefor more.redirectsrunsbeforeMiddleware.NextResponse.redirectin MiddlewareMiddleware allows you to run code before a request is completed. Then, based on the incoming request, redirect to a different URL usingNextResponse.redirect. This is useful if you want to redirect users based on a condition (e.g. authentication, session management, etc) or havea large number of redirects.For example, to redirect the user to a/loginpage if they are not authenticated:middleware.tsTypeScriptJavaScriptTypeScriptimport{ NextResponse,NextRequest }from'next/server'import{ authenticate }from'auth-provider'exportfunctionmiddleware(request:NextRequest) {constisAuthenticated=authenticate(request)// If the user is authenticated, continue as normalif(isAuthenticated) {returnNextResponse.next()}// Redirect to login page if not authenticatedreturnNextResponse.redirect(newURL('/login',request.url))}exportconstconfig={matcher:'/dashboard/:path*',}Good to know:Middleware runsafterredirectsinnext.config.jsandbeforerendering.See theMiddlewaredocumentation for more information.Managing redirects at scale (advanced)To manage a large number of redirects (1000+), you may consider creating a custom solution using Middleware. This allows you to handle redirects programmatically without having to redeploy your application.To do this, you'll need to consider:Creating and storing a redirect map.Optimizing data lookup performance.Next.js Example: See ourMiddleware with Bloom filterexample for an implementation of the recommendations below.1. Creating and storing a redirect mapA redirect map is a list of redirects that you can store in a database (usually a key-value store) or JSON file.Consider the following data structure:{""/old"":{""destination"":""/new"",""permanent"":true},""/blog/post-old"":{""destination"":""/blog/post-new"",""permanent"":true}}InMiddleware, you can read from a database such as Vercel'sEdge ConfigorRedis, and redirect the user based on the incoming request:middleware.tsTypeScriptJavaScriptTypeScriptimport{ NextResponse,NextRequest }from'next/server'import{ get }from'@vercel/edge-config'typeRedirectEntry={destination:stringpermanent:boolean}exportasyncfunctionmiddleware(request:NextRequest) {constpathname=request.nextUrl.pathnameconstredirectData=awaitget(pathname)if(redirectData&&typeofredirectData==='string') {constredirectEntry:RedirectEntry=JSON.parse(redirectData)conststatusCode=redirectEntry.permanent?308:307returnNextResponse.redirect(redirectEntry.destination,statusCode)}// No redirect found, continue without redirectingreturnNextResponse.next()}2. Optimizing data lookup performanceReading a large dataset for every incoming request can be slow and expensive. There are two ways you can optimize data lookup performance:Use a database that is optimized for fast reads, such asVercel Edge ConfigorRedis.Use a data lookup strategy such as aBloom filterto efficiently check if a redirect existsbeforereading the larger redirects file or database.Considering the previous example, you can import a generated bloom filter file into Middleware, then, check if the incoming request pathname exists in the bloom filter.If it does, forward the request to aRoute Handlerwhich will check the actual file and redirect the user to the appropriate URL. This avoids importing a large redirects file into Middleware, which can slow down every incoming request.middleware.tsTypeScriptJavaScriptTypeScriptimport{ NextResponse,NextRequest }from'next/server'import{ ScalableBloomFilter }from'bloom-filters'importGeneratedBloomFilterfrom'./redirects/bloom-filter.json'typeRedirectEntry={destination:stringpermanent:boolean}// Initialize bloom filter from a generated JSON fileconstbloomFilter=ScalableBloomFilter.fromJSON(GeneratedBloomFilterasany)exportasyncfunctionmiddleware(request:NextRequest) {// Get the path for the incoming requestconstpathname=request.nextUrl.pathname// Check if the path is in the bloom filterif(bloomFilter.has(pathname)) {// Forward the pathname to the Route Handlerconstapi=newURL(`/api/redirects?pathname=${encodeURIComponent(request.nextUrl.pathname)}`,request.nextUrl.origin)try{// Fetch redirect data from the Route HandlerconstredirectData=awaitfetch(api)if(redirectData.ok) {constredirectEntry:RedirectEntry|undefined=awaitredirectData.json()if(redirectEntry) {// Determine the status codeconststatusCode=redirectEntry.permanent?308:307// Redirect to the destinationreturnNextResponse.redirect(redirectEntry.destination,statusCode)}}}catch(error) {console.error(error)}}// No redirect found, continue the request without redirectingreturnNextResponse.next()}Then, in the Route Handler:app/api/redirects/route.tsTypeScriptJavaScriptTypeScriptimport{ NextRequest,NextResponse }from'next/server'importredirectsfrom'@/app/redirects/redirects.json'typeRedirectEntry={destination:stringpermanent:boolean}exportfunctionGET(request:NextRequest) {constpathname=request.nextUrl.searchParams.get('pathname')if(!pathname) {returnnewResponse('Bad Request',{ status:400})}// Get the redirect entry from the redirects.json fileconstredirect=(redirectsasRecord<string,RedirectEntry>)[pathname]// Account for bloom filter false positivesif(!redirect) {returnnewResponse('No redirect',{ status:400})}// Return the redirect entryreturnNextResponse.json(redirect)}Good to know:To generate a bloom filter, you can use a library likebloom-filters.You should validate requests made to your Route Handler to prevent malicious requests.Next StepsredirectAPI Reference for the redirect function.permanentRedirectAPI Reference for the permanentRedirect function.MiddlewareLearn how to use Middleware to run code before a request is completed.redirectsAdd redirects to your Next.js app.PreviousLoading UI and StreamingNextRoute GroupsWas this helpful?supported.Send"
route groups,Route Groups,"Building Your ApplicationRoutingRoute GroupsRoute GroupsIn theappdirectory, nested folders are normally mapped to URL paths. However, you can mark a folder as aRoute Groupto prevent the folder from being included in the route's URL path.This allows you to organize your route segments and project files into logical groups without affecting the URL path structure.Route groups are useful for:Organizing routes into groupse.g. by site section, intent, or team.Enablingnested layoutsin the same route segment level:Creating multiple nested layouts in the same segment, including multiple root layoutsAdding a layout to a subset of routes in a common segmentAdding a loading skeleton to specific route in a common segmentConventionA route group can be created by wrapping a folder's name in parenthesis:(folderName)ExamplesOrganize routes without affecting the URL pathTo organize routes without affecting the URL, create a group to keep related routes together. The folders in parenthesis will be omitted from the URL (e.g.(marketing)or(shop).Even though routes inside(marketing)and(shop)share the same URL hierarchy, you can create a different layout for each group by adding alayout.jsfile inside their folders.Opting specific segments into a layoutTo opt specific routes into a layout, create a new route group (e.g.(shop)) and move the routes that share the same layout into the group (e.g.accountandcart). The routes outside of the group will not share the layout (e.g.checkout).Opting for loading skeletons on a specific routeTo apply aloading skeletonvia aloading.jsfile to a specific route, create a new route group (e.g.,/(overview)) and then move yourloading.tsxinside that route group.Now, theloading.tsxfile will only apply to your dashboard → overview page instead of all your dashboard pages without affecting the URL path structure.Creating multiple root layoutsTo create multipleroot layouts, remove the top-levellayout.jsfile, and add alayout.jsfile inside each route group. This is useful for partitioning an application into sections that have a completely different UI or experience. The<html>and<body>tags need to be added to each root layout.In the example above, both(marketing)and(shop)have their own root layout.Good to know:The naming of route groups has no special significance other than for organization. They do not affect the URL path.Routes that include a route groupshould notresolve to the same URL path as other routes. For example, since route groups don't affect URL structure,(marketing)/about/page.jsand(shop)/about/page.jswould both resolve to/aboutand cause an error.If you use multiple root layouts without a top-levellayout.jsfile, your homepage.jsfile should be defined in one of the route groups, For example:app/(marketing)/page.js.Navigatingacross multiple root layoutswill cause afull page load(as opposed to a client-side navigation). For example, navigating from/cartthat usesapp/(shop)/layout.jsto/blogthat usesapp/(marketing)/layout.jswill cause a full page load. Thisonlyapplies to multiple root layouts.PreviousRedirectingNextDynamic RoutesWas this helpful?supported.Send"
dynamic routes,Dynamic Routes,"Building Your ApplicationRoutingDynamic RoutesDynamic RoutesWhen you don't know the exact segment names ahead of time and want to create routes from dynamic data, you can use Dynamic Segments that are filled in at request time orprerenderedat build time.ConventionA Dynamic Segment can be created by wrapping a folder's name in square brackets:[folderName]. For example,[id]or[slug].Dynamic Segments are passed as theparamsprop tolayout,page,route, andgenerateMetadatafunctions.ExampleFor example, a blog could include the following routeapp/blog/[slug]/page.jswhere[slug]is the Dynamic Segment for blog posts.app/blog/[slug]/page.tsxTypeScriptJavaScriptTypeScriptexportdefaultasyncfunctionPage({params,}:{params:Promise<{ slug:string}>}) {constslug=(awaitparams).slugreturn<div>My Post: {slug}</div>}RouteExample URLparamsapp/blog/[slug]/page.js/blog/a{ slug: 'a' }app/blog/[slug]/page.js/blog/b{ slug: 'b' }app/blog/[slug]/page.js/blog/c{ slug: 'c' }See thegenerateStaticParams()page to learn how to generate the params for the segment.Good to knowSince theparamsprop is a promise. You must use async/await or React's use function to access the values.In version 14 and earlier,paramswas a synchronous prop. To help with backwards compatibility, you can still access it synchronously in Next.js 15, but this behavior will be deprecated in the future.Dynamic Segments are equivalent toDynamic Routesin thepagesdirectory.Generating Static ParamsThegenerateStaticParamsfunction can be used in combination withdynamic route segmentstostatically generateroutes at build time instead of on-demand at request time.app/blog/[slug]/page.tsxTypeScriptJavaScriptTypeScriptexportasyncfunctiongenerateStaticParams() {constposts=awaitfetch('https://.../posts').then((res)=>res.json())returnposts.map((post)=>({slug:post.slug,}))}The primary benefit of thegenerateStaticParamsfunction is its smart retrieval of data. If content is fetched within thegenerateStaticParamsfunction using afetchrequest, the requests areautomatically memoized. This means afetchrequest with the same arguments across multiplegenerateStaticParams, Layouts, and Pages will only be made once, which decreases build times.Use themigration guideif you are migrating from thepagesdirectory.SeegenerateStaticParamsserver function documentationfor more information and advanced use cases.Catch-all SegmentsDynamic Segments can be extended tocatch-allsubsequent segments by adding an ellipsis inside the brackets[...folderName].For example,app/shop/[...slug]/page.jswill match/shop/clothes, but also/shop/clothes/tops,/shop/clothes/tops/t-shirts, and so on.RouteExample URLparamsapp/shop/[...slug]/page.js/shop/a{ slug: ['a'] }app/shop/[...slug]/page.js/shop/a/b{ slug: ['a', 'b'] }app/shop/[...slug]/page.js/shop/a/b/c{ slug: ['a', 'b', 'c'] }Optional Catch-all SegmentsCatch-all Segments can be madeoptionalby including the parameter in double square brackets:[[...folderName]].For example,app/shop/[[...slug]]/page.jswillalsomatch/shop, in addition to/shop/clothes,/shop/clothes/tops,/shop/clothes/tops/t-shirts.The difference betweencatch-allandoptional catch-allsegments is that with optional, the route without the parameter is also matched (/shopin the example above).RouteExample URLparamsapp/shop/[[...slug]]/page.js/shop{ slug: undefined }app/shop/[[...slug]]/page.js/shop/a{ slug: ['a'] }app/shop/[[...slug]]/page.js/shop/a/b{ slug: ['a', 'b'] }app/shop/[[...slug]]/page.js/shop/a/b/c{ slug: ['a', 'b', 'c'] }TypeScriptWhen using TypeScript, you can add types forparamsdepending on your configured route segment.app/blog/[slug]/page.tsxTypeScriptJavaScriptTypeScriptexportdefaultasyncfunctionPage({params,}:{params:Promise<{ slug:string}>}) {return<h1>My Page</h1>}RouteparamsType Definitionapp/blog/[slug]/page.js{ slug: string }app/shop/[...slug]/page.js{ slug: string[] }app/shop/[[...slug]]/page.js{ slug?: string[] }app/[categoryId]/[itemId]/page.js{ categoryId: string, itemId: string }Good to know: This may be done automatically by theTypeScript pluginin the future.Next StepsFor more information on what to do next, we recommend the following sectionsLinking and NavigatingLearn how navigation works in Next.js, and how to use the Link Component and `useRouter` hook.generateStaticParamsAPI reference for the generateStaticParams function.PreviousRoute GroupsNextParallel RoutesWas this helpful?supported.Send"
parallel routes,Parallel Routes,"Building Your ApplicationRoutingParallel RoutesParallel RoutesParallel Routes allows you to simultaneously or conditionally render one or more pages within the same layout. They are useful for highly dynamic sections of an app, such as dashboards and feeds on social sites.For example, considering a dashboard, you can use parallel routes to simultaneously render theteamandanalyticspages:SlotsParallel routes are created using namedslots. Slots are defined with the@folderconvention. For example, the following file structure defines two slots:@analyticsand@team:Slots are passed as props to the shared parent layout. For the example above, the component inapp/layout.jsnow accepts the@analyticsand@teamslots props, and can render them in parallel alongside thechildrenprop:app/layout.tsxTypeScriptJavaScriptTypeScriptexportdefaultfunctionLayout({children,team,analytics,}:{children:React.ReactNodeanalytics:React.ReactNodeteam:React.ReactNode}) {return(<>{children}{team}{analytics}</>)}However, slots arenotroute segments and do not affect the URL structure. For example, for/@analytics/views, the URL will be/viewssince@analyticsis a slot. Slots are combined with the regularPagecomponent to form the final page associated with the route segment. Because of this, you cannot have separatestaticanddynamicslots at the same route segment level. If one slot is dynamic, all slots at that level must be dynamic.Good to know:Thechildrenprop is an implicit slot that does not need to be mapped to a folder. This meansapp/page.jsis equivalent toapp/@children/page.js.Active state and navigationBy default, Next.js keeps track of the activestate(or subpage) for each slot. However, the content rendered within a slot will depend on the type of navigation:Soft Navigation: During client-side navigation, Next.js will perform apartial render, changing the subpage within the slot, while maintaining the other slot's active subpages, even if they don't match the current URL.Hard Navigation: After a full-page load (browser refresh), Next.js cannot determine the active state for the slots that don't match the current URL. Instead, it will render adefault.jsfile for the unmatched slots, or404ifdefault.jsdoesn't exist.Good to know:The404for unmatched routes helps ensure that you don't accidentally render a parallel route on a page that it was not intended for.default.jsYou can define adefault.jsfile to render as a fallback for unmatched slots during the initial load or full-page reload.Consider the following folder structure. The@teamslot has a/settingspage, but@analyticsdoes not.When navigating to/settings, the@teamslot will render the/settingspage while maintaining the currently active page for the@analyticsslot.On refresh, Next.js will render adefault.jsfor@analytics. Ifdefault.jsdoesn't exist, a404is rendered instead.Additionally, sincechildrenis an implicit slot, you also need to create adefault.jsfile to render a fallback forchildrenwhen Next.js cannot recover the active state of the parent page.useSelectedLayoutSegment(s)BothuseSelectedLayoutSegmentanduseSelectedLayoutSegmentsaccept aparallelRoutesKeyparameter, which allows you to read the active route segment within a slot.app/layout.tsxTypeScriptJavaScriptTypeScript'use client'import{ useSelectedLayoutSegment }from'next/navigation'exportdefaultfunctionLayout({ auth }:{ auth:React.ReactNode}) {constloginSegment=useSelectedLayoutSegment('auth')// ...}When a user navigates toapp/@auth/login(or/loginin the URL bar),loginSegmentwill be equal to the string""login"".ExamplesConditional RoutesYou can use Parallel Routes to conditionally render routes based on certain conditions, such as user role. For example, to render a different dashboard page for the/adminor/userroles:app/dashboard/layout.tsxTypeScriptJavaScriptTypeScriptimport{ checkUserRole }from'@/lib/auth'exportdefaultfunctionLayout({user,admin,}:{user:React.ReactNodeadmin:React.ReactNode}) {constrole=checkUserRole()returnrole==='admin'?admin:user}Tab GroupsYou can add alayoutinside a slot to allow users to navigate the slot independently. This is useful for creating tabs.For example, the@analyticsslot has two subpages:/page-viewsand/visitors.Within@analytics, create alayoutfile to share the tabs between the two pages:app/@analytics/layout.tsxTypeScriptJavaScriptTypeScriptimportLinkfrom'next/link'exportdefaultfunctionLayout({ children }:{ children:React.ReactNode}) {return(<><nav><Linkhref=""/page-views"">Page Views</Link><Linkhref=""/visitors"">Visitors</Link></nav><div>{children}</div></>)}ModalsParallel Routes can be used together withIntercepting Routesto create modals that support deep linking. This allows you to solve common challenges when building modals, such as:Making the modal contentshareable through a URL.Preserving contextwhen the page is refreshed, instead of closing the modal.Closing the modal on backwards navigationrather than going to the previous route.Reopening the modal on forwards navigation.Consider the following UI pattern, where a user can open a login modal from a layout using client-side navigation, or access a separate/loginpage:To implement this pattern, start by creating a/loginroute that renders yourmainlogin page.app/login/page.tsxTypeScriptJavaScriptTypeScriptimport{ Login }from'@/app/ui/login'exportdefaultfunctionPage() {return<Login/>}Then, inside the@authslot, adddefault.jsfile that returnsnull. This ensures that the modal is not rendered when it's not active.app/@auth/default.tsxTypeScriptJavaScriptTypeScriptexportdefaultfunctionDefault() {returnnull}Inside your@authslot, intercept the/loginroute by updating the/(.)loginfolder. Import the<Modal>component and its children into the/(.)login/page.tsxfile:app/@auth/(.)login/page.tsxTypeScriptJavaScriptTypeScriptimport{ Modal }from'@/app/ui/modal'import{ Login }from'@/app/ui/login'exportdefaultfunctionPage() {return(<Modal><Login/></Modal>)}Good to know:The convention used to intercept the route, e.g.(.), depends on your file-system structure. SeeIntercepting Routes convention.By separating the<Modal>functionality from the modal content (<Login>), you can ensure any content inside the modal, e.g.forms, are Server Components. SeeInterleaving Client and Server Componentsfor more information.Opening the modalNow, you can leverage the Next.js router to open and close the modal. This ensures the URL is correctly updated when the modal is open, and when navigating backwards and forwards.To open the modal, pass the@authslot as a prop to the parent layout and render it alongside thechildrenprop.app/layout.tsxTypeScriptJavaScriptTypeScriptimportLinkfrom'next/link'exportdefaultfunctionLayout({auth,children,}:{auth:React.ReactNodechildren:React.ReactNode}) {return(<><nav><Linkhref=""/login"">Open modal</Link></nav><div>{auth}</div><div>{children}</div></>)}When the user clicks the<Link>, the modal will open instead of navigating to the/loginpage. However, on refresh or initial load, navigating to/loginwill take the user to the main login page.Closing the modalYou can close the modal by callingrouter.back()or by using theLinkcomponent.app/ui/modal.tsxTypeScriptJavaScriptTypeScript'use client'import{ useRouter }from'next/navigation'exportfunctionModal({ children }:{ children:React.ReactNode}) {constrouter=useRouter()return(<><buttononClick={()=>{router.back()}}>Close modal</button><div>{children}</div></>)}When using theLinkcomponent to navigate away from a page that shouldn't render the@authslot anymore, we need to make sure the parallel route matches to a component that returnsnull. For example, when navigating back to the root page, we create a@auth/page.tsxcomponent:app/ui/modal.tsxTypeScriptJavaScriptTypeScriptimportLinkfrom'next/link'exportfunctionModal({ children }:{ children:React.ReactNode}) {return(<><Linkhref=""/"">Close modal</Link><div>{children}</div></>)}app/@auth/page.tsxTypeScriptJavaScriptTypeScriptexportdefaultfunctionPage() {returnnull}Or if navigating to any other page (such as/foo,/foo/bar, etc), you can use a catch-all slot:app/@auth/[...catchAll]/page.tsxTypeScriptJavaScriptTypeScriptexportdefaultfunctionCatchAll() {returnnull}Good to know:We use a catch-all route in our@authslot to close the modal because of the behavior described inActive state and navigation. Since client-side navigations to a route that no longer match the slot will remain visible, we need to match the slot to a route that returnsnullto close the modal.Other examples could include opening a photo modal in a gallery while also having a dedicated/photo/[id]page, or opening a shopping cart in a side modal.View an exampleof modals with Intercepted and Parallel Routes.Loading and Error UIParallel Routes can be streamed independently, allowing you to define independent error and loading states for each route:See theLoading UIandError Handlingdocumentation for more information.Next Stepsdefault.jsAPI Reference for the default.js file.PreviousDynamic RoutesNextIntercepting RoutesWas this helpful?supported.Send"
intercepting routes,Intercepting Routes,"Building Your ApplicationRoutingIntercepting RoutesIntercepting RoutesIntercepting routes allows you to load a route from another part of your application within the current layout. This routing paradigm can be useful when you want to display the content of a route without the user switching to a different context.For example, when clicking on a photo in a feed, you can display the photo in a modal, overlaying the feed. In this case, Next.js intercepts the/photo/123route, masks the URL, and overlays it over/feed.However, when navigating to the photo by clicking a shareable URL or by refreshing the page, the entire photo page should render instead of the modal. No route interception should occur.ConventionIntercepting routes can be defined with the(..)convention, which is similar to relative path convention../but for segments.You can use:(.)to match segments on thesame level(..)to match segmentsone level above(..)(..)to match segmentstwo levels above(...)to match segments from therootappdirectoryFor example, you can intercept thephotosegment from within thefeedsegment by creating a(..)photodirectory.Note that the(..)convention is based onroute segments, not the file-system.ExamplesModalsIntercepting Routes can be used together withParallel Routesto create modals. This allows you to solve common challenges when building modals, such as:Making the modal contentshareable through a URL.Preserving contextwhen the page is refreshed, instead of closing the modal.Closing the modal on backwards navigationrather than going to the previous route.Reopening the modal on forwards navigation.Consider the following UI pattern, where a user can open a photo modal from a gallery using client-side navigation, or navigate to the photo page directly from a shareable URL:In the above example, the path to thephotosegment can use the(..)matcher since@modalis a slot andnota segment. This means that thephotoroute is only one segment level higher, despite being two file-system levels higher.See theParallel Routesdocumentation for a step-by-step example, or see ourimage gallery example.Good to know:Other examples could include opening a login modal in a top navbar while also having a dedicated/loginpage, or opening a shopping cart in a side modal.Next StepsLearn how to use modals with Intercepted and Parallel Routes.Parallel RoutesSimultaneously render one or more pages in the same view that can be navigated independently. A pattern for highly dynamic applications.PreviousParallel RoutesNextRoute HandlersWas this helpful?supported.Send"
route handlers,Route Handlers,"Building Your ApplicationRoutingRoute HandlersRoute HandlersRoute Handlers allow you to create custom request handlers for a given route using the WebRequestandResponseAPIs.Good to know: Route Handlers are only available inside theappdirectory. They are the equivalent ofAPI Routesinside thepagesdirectory meaning youdo notneed to use API Routes and Route Handlers together.ConventionRoute Handlers are defined in aroute.js|tsfileinside theappdirectory:app/api/route.tsTypeScriptJavaScriptTypeScriptexportasyncfunctionGET(request:Request) {}Route Handlers can be nested anywhere inside theappdirectory, similar topage.jsandlayout.js. But therecannotbe aroute.jsfile at the same route segment level aspage.js.Supported HTTP MethodsThe followingHTTP methodsare supported:GET,POST,PUT,PATCH,DELETE,HEAD, andOPTIONS. If an unsupported method is called, Next.js will return a405 Method Not Allowedresponse.ExtendedNextRequestandNextResponseAPIsIn addition to supporting the nativeRequestandResponseAPIs, Next.js extends them withNextRequestandNextResponseto provide convenient helpers for advanced use cases.BehaviorCachingRoute Handlers are not cached by default. You can, however, opt into caching forGETmethods. Other supported HTTP methods arenotcached. To cache aGETmethod, use aroute config optionsuch asexport const dynamic = 'force-static'in your Route Handler file.app/items/route.tsTypeScriptJavaScriptTypeScriptexportconstdynamic='force-static'exportasyncfunctionGET() {constres=awaitfetch('https://data.mongodb-api.com/...',{headers:{'Content-Type':'application/json','API-Key':process.env.DATA_API_KEY,},})constdata=awaitres.json()returnResponse.json({ data })}Good to know: Other supported HTTP methods arenotcached, even if they are placed alongside aGETmethod that is cached, in the same file.Special Route HandlersSpecial Route Handlers likesitemap.ts,opengraph-image.tsx, andicon.tsx, and othermetadata filesremain static by default unless they use Dynamic APIs or dynamic config options.Route ResolutionYou can consider aroutethe lowest level routing primitive.Theydo notparticipate in layouts or client-side navigations likepage.Therecannotbe aroute.jsfile at the same route aspage.js.PageRouteResultapp/page.jsapp/route.jsConflictapp/page.jsapp/api/route.jsValidapp/[user]/page.jsapp/api/route.jsValidEachroute.jsorpage.jsfile takes over all HTTP verbs for that route.app/page.tsTypeScriptJavaScriptTypeScriptexportdefaultfunctionPage() {return<h1>Hello,Next.js!</h1>}// ❌ Conflict// `app/route.ts`exportasyncfunctionPOST(request:Request) {}ExamplesThe following examples show how to combine Route Handlers with other Next.js APIs and features.Revalidating Cached DataYou canrevalidate cached datausing Incremental Static Regeneration (ISR):app/posts/route.tsTypeScriptJavaScriptTypeScriptexportconstrevalidate=60exportasyncfunctionGET() {constdata=awaitfetch('https://api.vercel.app/blog')constposts=awaitdata.json()returnResponse.json(posts)}CookiesYou can read or set cookies withcookiesfromnext/headers. This server function can be called directly in a Route Handler, or nested inside of another function.Alternatively, you can return a newResponseusing theSet-Cookieheader.app/api/route.tsTypeScriptJavaScriptTypeScriptimport{ cookies }from'next/headers'exportasyncfunctionGET(request:Request) {constcookieStore=awaitcookies()consttoken=cookieStore.get('token')returnnewResponse('Hello, Next.js!',{status:200,headers:{'Set-Cookie':`token=${token.value}`},})}You can also use the underlying Web APIs to read cookies from the request (NextRequest):app/api/route.tsTypeScriptJavaScriptTypeScriptimport{typeNextRequest }from'next/server'exportasyncfunctionGET(request:NextRequest) {consttoken=request.cookies.get('token')}HeadersYou can read headers withheadersfromnext/headers. This server function can be called directly in a Route Handler, or nested inside of another function.Thisheadersinstance is read-only. To set headers, you need to return a newResponsewith newheaders.app/api/route.tsTypeScriptJavaScriptTypeScriptimport{ headers }from'next/headers'exportasyncfunctionGET(request:Request) {constheadersList=awaitheaders()constreferer=headersList.get('referer')returnnewResponse('Hello, Next.js!',{status:200,headers:{ referer:referer },})}You can also use the underlying Web APIs to read headers from the request (NextRequest):app/api/route.tsTypeScriptJavaScriptTypeScriptimport{typeNextRequest }from'next/server'exportasyncfunctionGET(request:NextRequest) {constrequestHeaders=newHeaders(request.headers)}Redirectsapp/api/route.tsTypeScriptJavaScriptTypeScriptimport{ redirect }from'next/navigation'exportasyncfunctionGET(request:Request) {redirect('https://nextjs.org/')}Dynamic Route SegmentsRoute Handlers can useDynamic Segmentsto create request handlers from dynamic data.app/items/[slug]/route.tsTypeScriptJavaScriptTypeScriptexportasyncfunctionGET(request:Request,{ params }:{ params:Promise<{ slug:string}> }) {constslug=(awaitparams).slug// 'a', 'b', or 'c'}RouteExample URLparamsapp/items/[slug]/route.js/items/aPromise<{ slug: 'a' }>app/items/[slug]/route.js/items/bPromise<{ slug: 'b' }>app/items/[slug]/route.js/items/cPromise<{ slug: 'c' }>URL Query ParametersThe request object passed to the Route Handler is aNextRequestinstance, which hassome additional convenience methods, including for more easily handling query parameters.app/api/search/route.tsTypeScriptJavaScriptTypeScriptimport{typeNextRequest }from'next/server'exportfunctionGET(request:NextRequest) {constsearchParams=request.nextUrl.searchParamsconstquery=searchParams.get('query')// query is ""hello"" for /api/search?query=hello}StreamingStreaming is commonly used in combination with Large Language Models (LLMs), such as OpenAI, for AI-generated content. Learn more about theAI SDK.app/api/chat/route.tsTypeScriptJavaScriptTypeScriptimport{ openai }from'@ai-sdk/openai'import{ StreamingTextResponse,streamText }from'ai'exportasyncfunctionPOST(req:Request) {const{messages}=awaitreq.json()constresult=awaitstreamText({model:openai('gpt-4-turbo'),messages,})returnnewStreamingTextResponse(result.toAIStream())}These abstractions use the Web APIs to create a stream. You can also use the underlying Web APIs directly.app/api/route.tsTypeScriptJavaScriptTypeScript// https://developer.mozilla.org/docs/Web/API/ReadableStream#convert_async_iterator_to_streamfunctioniteratorToStream(iterator:any) {returnnewReadableStream({asyncpull(controller) {const{value,done}=awaititerator.next()if(done) {controller.close()}else{controller.enqueue(value)}},})}functionsleep(time:number) {returnnewPromise((resolve)=>{setTimeout(resolve,time)})}constencoder=newTextEncoder()asyncfunction*makeIterator() {yieldencoder.encode('<p>One</p>')awaitsleep(200)yieldencoder.encode('<p>Two</p>')awaitsleep(200)yieldencoder.encode('<p>Three</p>')}exportasyncfunctionGET() {constiterator=makeIterator()conststream=iteratorToStream(iterator)returnnewResponse(stream)}Request BodyYou can read theRequestbody using the standard Web API methods:app/items/route.tsTypeScriptJavaScriptTypeScriptexportasyncfunctionPOST(request:Request) {constres=awaitrequest.json()returnResponse.json({ res })}Request Body FormDataYou can read theFormDatausing therequest.formData()function:app/items/route.tsTypeScriptJavaScriptTypeScriptexportasyncfunctionPOST(request:Request) {constformData=awaitrequest.formData()constname=formData.get('name')constemail=formData.get('email')returnResponse.json({ name,email })}SinceformDatadata are all strings, you may want to usezod-form-datato validate the request and retrieve data in the format you prefer (e.g.number).CORSYou can set CORS headers for a specific Route Handler using the standard Web API methods:app/api/route.tsTypeScriptJavaScriptTypeScriptexportasyncfunctionGET(request:Request) {returnnewResponse('Hello, Next.js!',{status:200,headers:{'Access-Control-Allow-Origin':'*','Access-Control-Allow-Methods':'GET, POST, PUT, DELETE, OPTIONS','Access-Control-Allow-Headers':'Content-Type, Authorization',},})}Good to know:To add CORS headers to multiple Route Handlers, you can useMiddlewareor thenext.config.jsfile.Alternatively, see ourCORS examplepackage.WebhooksYou can use a Route Handler to receive webhooks from third-party services:app/api/route.tsTypeScriptJavaScriptTypeScriptexportasyncfunctionPOST(request:Request) {try{consttext=awaitrequest.text()// Process the webhook payload}catch(error) {returnnewResponse(`Webhook error:${error.message}`,{status:400,})}returnnewResponse('Success!',{status:200,})}Notably, unlike API Routes with the Pages Router, you do not need to usebodyParserto use any additional configuration.Non-UI ResponsesYou can use Route Handlers to return non-UI content. Note thatsitemap.xml,robots.txt,app icons, andopen graph imagesall have built-in support.app/rss.xml/route.tsTypeScriptJavaScriptTypeScriptexportasyncfunctionGET() {returnnewResponse(`<?xml version=""1.0"" encoding=""UTF-8"" ?><rss version=""2.0""><channel><title>Next.js Documentation</title><link>https://nextjs.org/docs</link><description>The React Framework for the Web</description></channel></rss>`,{headers:{'Content-Type':'text/xml',},})}Segment Config OptionsRoute Handlers use the sameroute segment configurationas pages and layouts.app/items/route.tsTypeScriptJavaScriptTypeScriptexportconstdynamic='auto'exportconstdynamicParams=trueexportconstrevalidate=falseexportconstfetchCache='auto'exportconstruntime='nodejs'exportconstpreferredRegion='auto'See theAPI referencefor more details.API ReferenceLearn more about the route.js file.route.jsAPI reference for the route.js special file.PreviousIntercepting RoutesNextMiddlewareWas this helpful?supported.Send"
middleware,Middleware,"Building Your ApplicationRoutingMiddlewareMiddlewareMiddleware allows you to run code before a request is completed. Then, based on the incoming request, you can modify the response by rewriting, redirecting, modifying the request or response headers, or responding directly.Middleware runs before cached content and routes are matched. SeeMatching Pathsfor more details.Use CasesIntegrating Middleware into your application can lead to significant improvements in performance, security, and user experience. Some common scenarios where Middleware is particularly effective include:Authentication and Authorization: Ensure user identity and check session cookies before granting access to specific pages or API routes.Server-Side Redirects: Redirect users at the server level based on certain conditions (e.g., locale, user role).Path Rewriting: Support A/B testing, feature rollouts, or legacy paths by dynamically rewriting paths to API routes or pages based on request properties.Bot Detection: Protect your resources by detecting and blocking bot traffic.Logging and Analytics: Capture and analyze request data for insights before processing by the page or API.Feature Flagging: Enable or disable features dynamically for seamless feature rollouts or testing.Recognizing situations where middleware may not be the optimal approach is just as crucial. Here are some scenarios to be mindful of:Complex Data Fetching and Manipulation: Middleware is not designed for direct data fetching or manipulation, this should be done within Route Handlers or server-side utilities instead.Heavy Computational Tasks: Middleware should be lightweight and respond quickly or it can cause delays in page load. Heavy computational tasks or long-running processes should be done within dedicated Route Handlers.Extensive Session Management: While Middleware can manage basic session tasks, extensive session management should be managed by dedicated authentication services or within Route Handlers.Direct Database Operations: Performing direct database operations within Middleware is not recommended. Database interactions should be done within Route Handlers or server-side utilities.ConventionUse the filemiddleware.ts(or.js) in the root of your project to define Middleware. For example, at the same level aspagesorapp, or insidesrcif applicable.Note: While only onemiddleware.tsfile is supported per project, you can still organize your middleware logic modularly. Break out middleware functionalities into separate.tsor.jsfiles and import them into your mainmiddleware.tsfile. This allows for cleaner management of route-specific middleware, aggregated in themiddleware.tsfor centralized control. By enforcing a single middleware file, it simplifies configuration, prevents potential conflicts, and optimizes performance by avoiding multiple middleware layers.Examplemiddleware.tsTypeScriptJavaScriptTypeScriptimport{ NextResponse }from'next/server'importtype{ NextRequest }from'next/server'// This function can be marked `async` if using `await` insideexportfunctionmiddleware(request:NextRequest) {returnNextResponse.redirect(newURL('/home',request.url))}// See ""Matching Paths"" below to learn moreexportconstconfig={matcher:'/about/:path*',}Matching PathsMiddleware will be invoked forevery route in your project. Given this, it's crucial to use matchers to precisely target or exclude specific routes. The following is the execution order:headersfromnext.config.jsredirectsfromnext.config.jsMiddleware (rewrites,redirects, etc.)beforeFiles(rewrites) fromnext.config.jsFilesystem routes (public/,_next/static/,pages/,app/, etc.)afterFiles(rewrites) fromnext.config.jsDynamic Routes (/blog/[slug])fallback(rewrites) fromnext.config.jsThere are two ways to define which paths Middleware will run on:Custom matcher configConditional statementsMatchermatcherallows you to filter Middleware to run on specific paths.middleware.jsexportconstconfig={matcher:'/about/:path*',}You can match a single path or multiple paths with an array syntax:middleware.jsexportconstconfig={matcher:['/about/:path*','/dashboard/:path*'],}Thematcherconfig allows full regex so matching like negative lookaheads or character matching is supported. An example of a negative lookahead to match all except specific paths can be seen here:middleware.jsexportconstconfig={matcher:[/** Match all request paths except for the ones starting with:* - api (API routes)* - _next/static (static files)* - _next/image (image optimization files)* - favicon.ico, sitemap.xml, robots.txt (metadata files)*/'/((?!api|_next/static|_next/image|favicon.ico|sitemap.xml|robots.txt).*)',],}You can also bypass Middleware for certain requests by using themissingorhasarrays, or a combination of both:middleware.jsexportconstconfig={matcher:[/** Match all request paths except for the ones starting with:* - api (API routes)* - _next/static (static files)* - _next/image (image optimization files)* - favicon.ico, sitemap.xml, robots.txt (metadata files)*/{source:'/((?!api|_next/static|_next/image|favicon.ico|sitemap.xml|robots.txt).*)',missing:[{ type:'header',key:'next-router-prefetch'},{ type:'header',key:'purpose',value:'prefetch'},],},{source:'/((?!api|_next/static|_next/image|favicon.ico|sitemap.xml|robots.txt).*)',has:[{ type:'header',key:'next-router-prefetch'},{ type:'header',key:'purpose',value:'prefetch'},],},{source:'/((?!api|_next/static|_next/image|favicon.ico|sitemap.xml|robots.txt).*)',has:[{ type:'header',key:'x-present'}],missing:[{ type:'header',key:'x-missing',value:'prefetch'}],},],}Good to know: Thematchervalues need to be constants so they can be statically analyzed at build-time. Dynamic values such as variables will be ignored.Configured matchers:MUST start with/Can include named parameters:/about/:pathmatches/about/aand/about/bbut not/about/a/cCan have modifiers on named parameters (starting with:):/about/:path*matches/about/a/b/cbecause*iszero or more.?iszero or oneand+one or moreCan use regular expression enclosed in parenthesis:/about/(.*)is the same as/about/:path*Read more details onpath-to-regexpdocumentation.Good to know: For backward compatibility, Next.js always considers/publicas/public/index. Therefore, a matcher of/public/:pathwill match.Conditional Statementsmiddleware.tsTypeScriptJavaScriptTypeScriptimport{ NextResponse }from'next/server'importtype{ NextRequest }from'next/server'exportfunctionmiddleware(request:NextRequest) {if(request.nextUrl.pathname.startsWith('/about')) {returnNextResponse.rewrite(newURL('/about-2',request.url))}if(request.nextUrl.pathname.startsWith('/dashboard')) {returnNextResponse.rewrite(newURL('/dashboard/user',request.url))}}NextResponseTheNextResponseAPI allows you to:redirectthe incoming request to a different URLrewritethe response by displaying a given URLSet request headers for API Routes,getServerSideProps, andrewritedestinationsSet response cookiesSet response headersTo produce a response from Middleware, you can:rewriteto a route (PageorRoute Handler) that produces a responsereturn aNextResponsedirectly. SeeProducing a ResponseUsing CookiesCookies are regular headers. On aRequest, they are stored in theCookieheader. On aResponsethey are in theSet-Cookieheader. Next.js provides a convenient way to access and manipulate these cookies through thecookiesextension onNextRequestandNextResponse.For incoming requests,cookiescomes with the following methods:get,getAll,set, anddeletecookies. You can check for the existence of a cookie withhasor remove all cookies withclear.For outgoing responses,cookieshave the following methodsget,getAll,set, anddelete.middleware.tsTypeScriptJavaScriptTypeScriptimport{ NextResponse }from'next/server'importtype{ NextRequest }from'next/server'exportfunctionmiddleware(request:NextRequest) {// Assume a ""Cookie:nextjs=fast"" header to be present on the incoming request// Getting cookies from the request using the `RequestCookies` APIletcookie=request.cookies.get('nextjs')console.log(cookie)// => { name: 'nextjs', value: 'fast', Path: '/' }constallCookies=request.cookies.getAll()console.log(allCookies)// => [{ name: 'nextjs', value: 'fast' }]request.cookies.has('nextjs')// => truerequest.cookies.delete('nextjs')request.cookies.has('nextjs')// => false// Setting cookies on the response using the `ResponseCookies` APIconstresponse=NextResponse.next()response.cookies.set('vercel','fast')response.cookies.set({name:'vercel',value:'fast',path:'/',})cookie=response.cookies.get('vercel')console.log(cookie)// => { name: 'vercel', value: 'fast', Path: '/' }// The outgoing response will have a `Set-Cookie:vercel=fast;path=/` header.returnresponse}Setting HeadersYou can set request and response headers using theNextResponseAPI (settingrequestheaders is available since Next.js v13.0.0).middleware.tsTypeScriptJavaScriptTypeScriptimport{ NextResponse }from'next/server'importtype{ NextRequest }from'next/server'exportfunctionmiddleware(request:NextRequest) {// Clone the request headers and set a new header `x-hello-from-middleware1`constrequestHeaders=newHeaders(request.headers)requestHeaders.set('x-hello-from-middleware1','hello')// You can also set request headers in NextResponse.nextconstresponse=NextResponse.next({request:{// New request headersheaders:requestHeaders,},})// Set a new response header `x-hello-from-middleware2`response.headers.set('x-hello-from-middleware2','hello')returnresponse}Good to know: Avoid setting large headers as it might cause431 Request Header Fields Too Largeerror depending on your backend web server configuration.CORSYou can set CORS headers in Middleware to allow cross-origin requests, includingsimpleandpreflightedrequests.middleware.tsTypeScriptJavaScriptTypeScriptimport{ NextRequest,NextResponse }from'next/server'constallowedOrigins=['https://acme.com','https://my-app.org']constcorsOptions={'Access-Control-Allow-Methods':'GET, POST, PUT, DELETE, OPTIONS','Access-Control-Allow-Headers':'Content-Type, Authorization',}exportfunctionmiddleware(request:NextRequest) {// Check the origin from the requestconstorigin=request.headers.get('origin')??''constisAllowedOrigin=allowedOrigins.includes(origin)// Handle preflighted requestsconstisPreflight=request.method==='OPTIONS'if(isPreflight) {constpreflightHeaders={...(isAllowedOrigin&&{'Access-Control-Allow-Origin':origin }),...corsOptions,}returnNextResponse.json({},{ headers:preflightHeaders })}// Handle simple requestsconstresponse=NextResponse.next()if(isAllowedOrigin) {response.headers.set('Access-Control-Allow-Origin',origin)}Object.entries(corsOptions).forEach(([key,value])=>{response.headers.set(key,value)})returnresponse}exportconstconfig={matcher:'/api/:path*',}Good to know:You can configure CORS headers for individual routes inRoute Handlers.Producing a ResponseYou can respond from Middleware directly by returning aResponseorNextResponseinstance. (This is available sinceNext.js v13.1.0)middleware.tsTypeScriptJavaScriptTypeScriptimporttype{ NextRequest }from'next/server'import{ isAuthenticated }from'@lib/auth'// Limit the middleware to paths starting with `/api/`exportconstconfig={matcher:'/api/:function*',}exportfunctionmiddleware(request:NextRequest) {// Call our authentication function to check the requestif(!isAuthenticated(request)) {// Respond with JSON indicating an error messagereturnResponse.json({ success:false,message:'authentication failed'},{ status:401})}}waitUntilandNextFetchEventTheNextFetchEventobject extends the nativeFetchEventobject, and includes thewaitUntil()method.ThewaitUntil()method takes a promise as an argument, and extends the lifetime of the Middleware until the promise settles. This is useful for performing work in the background.middleware.tsimport{ NextResponse }from'next/server'importtype{ NextFetchEvent,NextRequest }from'next/server'exportfunctionmiddleware(req:NextRequest,event:NextFetchEvent) {event.waitUntil(fetch('https://my-analytics-platform.com',{method:'POST',body:JSON.stringify({ pathname:req.nextUrl.pathname }),}))returnNextResponse.next()}Advanced Middleware FlagsInv13.1of Next.js two additional flags were introduced for middleware,skipMiddlewareUrlNormalizeandskipTrailingSlashRedirectto handle advanced use cases.skipTrailingSlashRedirectdisables Next.js redirects for adding or removing trailing slashes. This allows custom handling inside middleware to maintain the trailing slash for some paths but not others, which can make incremental migrations easier.next.config.jsmodule.exports={skipTrailingSlashRedirect:true,}middleware.jsconstlegacyPrefixes=['/docs','/blog']exportdefaultasyncfunctionmiddleware(req) {const{pathname}=req.nextUrlif(legacyPrefixes.some((prefix)=>pathname.startsWith(prefix))) {returnNextResponse.next()}// apply trailing slash handlingif(!pathname.endsWith('/')&&!pathname.match(/((?!\.well-known(?:\/.*)?)(?:[^/]+\/)*[^/]+\.\w+)/)) {returnNextResponse.redirect(newURL(`${req.nextUrl.pathname}/`,req.nextUrl))}}skipMiddlewareUrlNormalizeallows for disabling the URL normalization in Next.js to make handling direct visits and client-transitions the same. In some advanced cases, this option provides full control by using the original URL.next.config.jsmodule.exports={skipMiddlewareUrlNormalize:true,}middleware.jsexportdefaultasyncfunctionmiddleware(req) {const{pathname}=req.nextUrl// GET /_next/data/build-id/hello.jsonconsole.log(pathname)// with the flag this now /_next/data/build-id/hello.json// without the flag this would be normalized to /hello}Unit Testing (experimental)Starting in Next.js 15.1, thenext/experimental/testing/serverpackage contains utilities to help unit test middleware files. Unit testing middleware can help ensure that it's only run on desired paths and that custom routing logic works as intended before code reaches production.Theunstable_doesMiddlewareMatchfunction can be used to assert whether middleware will run for the provided URL, headers, and cookies.import{ unstable_doesMiddlewareMatch }from'next/experimental/testing/server'expect(unstable_doesMiddlewareMatch({config,nextConfig,url:'/test',})).toEqual(false)The entire middleware function can also be tested.import{ isRewrite,getRewrittenUrl }from'next/experimental/testing/server'constrequest=newNextRequest('https://nextjs.org/docs')constresponse=awaitmiddleware(request)expect(isRewrite(response)).toEqual(true)expect(getRewrittenUrl(response)).toEqual('https://other-domain.com/docs')// getRedirectUrl could also be used if the response were a redirectRuntimeMiddleware currently only supports APIs compatible with theEdge runtime. APIs exclusive to Node.js areunsupported.Version HistoryVersionChangesv13.1.0Advanced Middleware flags addedv13.0.0Middleware can modify request headers, response headers, and send responsesv12.2.0Middleware is stable, please see theupgrade guidev12.0.9Enforce absolute URLs in Edge Runtime (PR)v12.0.0Middleware (Beta) addedPreviousRoute HandlersNextInternationalizationWas this helpful?supported.Send"
internationalization,Internationalization,"Building Your ApplicationRoutingInternationalizationInternationalizationNext.js enables you to configure the routing and rendering of content to support multiple languages. Making your site adaptive to different locales includes translated content (localization) and internationalized routes.TerminologyLocale:An identifier for a set of language and formatting preferences. This usually includes the preferred language of the user and possibly their geographic region.en-US: English as spoken in the United Statesnl-NL: Dutch as spoken in the Netherlandsnl: Dutch, no specific regionRouting OverviewIt’s recommended to use the user’s language preferences in the browser to select which locale to use. Changing your preferred language will modify the incomingAccept-Languageheader to your application.For example, using the following libraries, you can look at an incomingRequestto determine which locale to select, based on theHeaders, locales you plan to support, and the default locale.middleware.jsimport{ match }from'@formatjs/intl-localematcher'importNegotiatorfrom'negotiator'letheaders={'accept-language':'en-US,en;q=0.5'}letlanguages=newNegotiator({ headers }).languages()letlocales=['en-US','nl-NL','nl']letdefaultLocale='en-US'match(languages,locales,defaultLocale)// -> 'en-US'Routing can be internationalized by either the sub-path (/fr/products) or domain (my-site.fr/products). With this information, you can now redirect the user based on the locale insideMiddleware.middleware.jsimport{ NextResponse }from""next/server"";letlocales=['en-US','nl-NL','nl']// Get the preferred locale, similar to the above or using a libraryfunctiongetLocale(request) {...}exportfunctionmiddleware(request) {// Check if there is any supported locale in the pathnameconst{pathname}=request.nextUrlconstpathnameHasLocale=locales.some((locale)=>pathname.startsWith(`/${locale}/`)||pathname===`/${locale}`)if(pathnameHasLocale)return// Redirect if there is no localeconstlocale=getLocale(request)request.nextUrl.pathname=`/${locale}${pathname}`// e.g. incoming request is /products// The new URL is now /en-US/productsreturnNextResponse.redirect(request.nextUrl)}exportconstconfig={matcher:[// Skip all internal paths (_next)'/((?!_next).*)',// Optional: only run on root (/) URL// '/'],}Finally, ensure all special files insideapp/are nested underapp/[lang]. This enables the Next.js router to dynamically handle different locales in the route, and forward thelangparameter to every layout and page. For example:app/[lang]/page.tsxTypeScriptJavaScriptTypeScript// You now have access to the current locale// e.g. /en-US/products -> `lang` is ""en-US""exportdefaultasyncfunctionPage({params,}:{params:Promise<{ lang:string}>}) {constlang=(awaitparams).lang;return...}The root layout can also be nested in the new folder (e.g.app/[lang]/layout.js).LocalizationChanging displayed content based on the user’s preferred locale, or localization, is not something specific to Next.js. The patterns described below would work the same with any web application.Let’s assume we want to support both English and Dutch content inside our application. We might maintain two different “dictionaries”, which are objects that give us a mapping from some key to a localized string. For example:dictionaries/en.json{""products"":{""cart"":""Add to Cart""}}dictionaries/nl.json{""products"":{""cart"":""Toevoegen aan Winkelwagen""}}We can then create agetDictionaryfunction to load the translations for the requested locale:app/[lang]/dictionaries.tsTypeScriptJavaScriptTypeScriptimport'server-only'constdictionaries={en:()=>import('./dictionaries/en.json').then((module)=>module.default),nl:()=>import('./dictionaries/nl.json').then((module)=>module.default),}exportconstgetDictionary=async(locale:'en'|'nl')=>dictionaries[locale]()Given the currently selected language, we can fetch the dictionary inside of a layout or page.app/[lang]/page.tsxTypeScriptJavaScriptTypeScriptimport{ getDictionary }from'./dictionaries'exportdefaultasyncfunctionPage({params,}:{params:Promise<{ lang:'en'|'nl'}>}) {constlang=(awaitparams).langconstdict=awaitgetDictionary(lang)// enreturn<button>{dict.products.cart}</button>// Add to Cart}Because all layouts and pages in theapp/directory default toServer Components, we do not need to worry about the size of the translation files affecting our client-side JavaScript bundle size. This code willonly run on the server, and only the resulting HTML will be sent to the browser.Static GenerationTo generate static routes for a given set of locales, we can usegenerateStaticParamswith any page or layout. This can be global, for example, in the root layout:app/[lang]/layout.tsxTypeScriptJavaScriptTypeScriptexportasyncfunctiongenerateStaticParams() {return[{ lang:'en-US'},{ lang:'de'}]}exportdefaultasyncfunctionRootLayout({children,params,}:Readonly<{children:React.ReactNodeparams:Promise<{ lang:'en-US'|'de'}>}>) {return(<htmllang={(awaitparams).lang}><body>{children}</body></html>)}ResourcesMinimal i18n routing and translationsnext-intlnext-internationalnext-i18n-routerparaglide-nextlinguiPreviousMiddlewareNextData FetchingWas this helpful?supported.Send"
data fetching,Data Fetching,App RouterBuilding Your ApplicationData FetchingData FetchingData Fetching and CachingLearn best practices for fetching data on the server or client in Next.js.Server Actions and MutationsLearn how to handle form submissions and data mutations with Next.js.Incremental Static Regeneration (ISR)Learn how to create or update static pages at runtime with Incremental Static Regeneration.PreviousInternationalizationNextData Fetching and CachingWas this helpful?supported.Send
data fetching and caching,Data Fetching and Caching,"Building Your ApplicationData FetchingData Fetching and CachingData Fetching and CachingExamplesNext.js CommerceOn-Demand ISRNext.js FormsThis guide will walk you through the basics of data fetching and caching in Next.js, providing practical examples and best practices.Here's a minimal example of data fetching in Next.js:app/page.tsxTypeScriptJavaScriptTypeScriptexportdefaultasyncfunctionPage() {constdata=awaitfetch('https://api.vercel.app/blog')constposts=awaitdata.json()return(<ul>{posts.map((post)=>(<likey={post.id}>{post.title}</li>))}</ul>)}This example demonstrates a basic server-side data fetch using thefetchAPI in an asynchronous React Server Component.ReferencefetchReactcacheNext.jsunstable_cacheExamplesFetching data on the server with thefetchAPIThis component will fetch and display a list of blog posts. The response fromfetchis not cached by default.app/page.tsxTypeScriptJavaScriptTypeScriptexportdefaultasyncfunctionPage() {constdata=awaitfetch('https://api.vercel.app/blog')constposts=awaitdata.json()return(<ul>{posts.map((post)=>(<likey={post.id}>{post.title}</li>))}</ul>)}If you are not using anyDynamic APIsanywhere else in this route, it will be prerendered duringnext buildto a static page. The data can then be updated usingIncremental Static Regeneration.To prevent the page from prerendering, you can add the following to your file:exportconstdynamic='force-dynamic'However, you will commonly use functions likecookies,headers, or reading the incomingsearchParamsfrom the page props, which will automatically make the page render dynamically. In this case, you donotneed to explicitly useforce-dynamic.Fetching data on the server with an ORM or databaseThis component will fetch and display a list of blog posts. The response from the database is not cached by default but could be withadditional configuration.app/page.tsxTypeScriptJavaScriptTypeScriptimport{ db,posts }from'@/lib/db'exportdefaultasyncfunctionPage() {constallPosts=awaitdb.select().from(posts)return(<ul>{allPosts.map((post)=>(<likey={post.id}>{post.title}</li>))}</ul>)}If you are not using anyDynamic APIsanywhere else in this route, it will be prerendered duringnext buildto a static page. The data can then be updated usingIncremental Static Regeneration.To prevent the page from prerendering, you can add the following to your file:exportconstdynamic='force-dynamic'However, you will commonly use functions likecookies,headers, or reading the incomingsearchParamsfrom the page props, which will automatically make the page render dynamically. In this case, you donotneed to explicitly useforce-dynamic.Fetching data on the clientWe recommend first attempting to fetch data on the server-side.However, there are still cases where client-side data fetching makes sense. In these scenarios, you can manually callfetchin auseEffect(not recommended), or lean on popular React libraries in the community (such asSWRorReact Query) for client fetching.app/page.tsxTypeScriptJavaScriptTypeScript'use client'import{ useState,useEffect }from'react'exportfunctionPosts() {const[posts,setPosts]=useState(null)useEffect(()=>{asyncfunctionfetchPosts() {constres=awaitfetch('https://api.vercel.app/blog')constdata=awaitres.json()setPosts(data)}fetchPosts()},[])if(!posts)return<div>Loading...</div>return(<ul>{posts.map((post)=>(<likey={post.id}>{post.title}</li>))}</ul>)}Caching data with an ORM or DatabaseYou can use theunstable_cacheAPI to cache the response when runningnext build.app/page.tsxTypeScriptJavaScriptTypeScriptimport{ unstable_cache }from'next/cache'import{ db,posts }from'@/lib/db'constgetPosts=unstable_cache(async()=>{returnawaitdb.select().from(posts)},['posts'],{ revalidate:3600,tags:['posts'] })exportdefaultasyncfunctionPage() {constallPosts=awaitgetPosts()return(<ul>{allPosts.map((post)=>(<likey={post.id}>{post.title}</li>))}</ul>)}This example caches the result of the database query for 1 hour (3600 seconds). It also adds the cache tagpostswhich can then be invalidated withIncremental Static Regeneration.Reusing data across multiple functionsNext.js uses APIs likegenerateMetadataandgenerateStaticParamswhere you will need to use the same data fetched in thepage.If you are usingfetch, requests can bememoizedby addingcache: 'force-cache'. This means you can safely call the same URL with the same options, and only one request will be made.Good to know:In previous versions of Next.js, usingfetchwould have a defaultcachevalue offorce-cache. This changed in version 15, to a default ofcache: no-store.app/blog/[id]/page.tsxTypeScriptJavaScriptTypeScriptimport{ notFound }from'next/navigation'interfacePost{id:stringtitle:stringcontent:string}asyncfunctiongetPost(id:string) {constres=awaitfetch(`https://api.vercel.app/blog/${id}`,{cache:'force-cache',})constpost:Post=awaitres.json()if(!post)notFound()returnpost}exportasyncfunctiongenerateStaticParams() {constposts=awaitfetch('https://api.vercel.app/blog',{cache:'force-cache',}).then((res)=>res.json())returnposts.map((post:Post)=>({id:String(post.id),}))}exportasyncfunctiongenerateMetadata({params,}:{params:Promise<{ id:string}>}) {const{id}=awaitparamsconstpost=awaitgetPost(id)return{title:post.title,}}exportdefaultasyncfunctionPage({params,}:{params:Promise<{ id:string}>}) {const{id}=awaitparamsconstpost=awaitgetPost(id)return(<article><h1>{post.title}</h1><p>{post.content}</p></article>)}If you arenotusingfetch, and instead using an ORM or database directly, you can wrap your data fetch with the Reactcachefunction. This will de-duplicate and only make one query.import{ cache }from'react'import{ db,posts,eq }from'@/lib/db'// Example with Drizzle ORMimport{ notFound }from'next/navigation'exportconstgetPost=cache(async(id)=>{constpost=awaitdb.query.posts.findFirst({where:eq(posts.id,parseInt(id)),})if(!post)notFound()returnpost})Revalidating cached dataLearn more about revalidating cached data withIncremental Static Regeneration.PatternsParallel and sequential data fetchingWhen fetching data inside components, you need to be aware of two data fetching patterns: Parallel and Sequential.Sequential: requests in a component tree are dependent on each other. This can lead to longer loading times.Parallel: requests in a route are eagerly initiated and will load data at the same time. This reduces the total time it takes to load data.Sequential data fetchingIf you have nested components, and each component fetches its own data, then data fetching will happen sequentially if those data requests are notmemoized.There may be cases where you want this pattern because one fetch depends on the result of the other. For example, thePlaylistscomponent will only start fetching data once theArtistcomponent has finished fetching data becausePlaylistsdepends on theartistIDprop:app/artist/[username]/page.tsxTypeScriptJavaScriptTypeScriptexportdefaultasyncfunctionPage({params,}:{params:Promise<{ username:string}>}) {const{username}=awaitparams// Getartistinformationconstartist=awaitgetArtist(username)return(<><h1>{artist.name}</h1>{/* Show fallback UI while the Playlists component is loading */}<Suspensefallback={<div>Loading...</div>}>{/* Pass theartistID to the Playlists component */}<PlaylistsartistID={artist.id} /></Suspense></>)}asyncfunctionPlaylists({artistID }:{artistID:string}) {// Use theartistID to fetch playlistsconstplaylists=awaitgetArtistPlaylists(artistID)return(<ul>{playlists.map((playlist)=>(<likey={playlist.id}>{playlist.name}</li>))}</ul>)}You can useloading.js(for route segments) orReact<Suspense>(for nested components) to show an instant loading state while React streams in the result.This will prevent the whole route from being blocked by data requests, and the user will be able to interact with the parts of the page that are ready.Parallel Data FetchingBy default, layout and page segments are rendered in parallel. This means requests will be initiated in parallel.However, due to the nature ofasync/await, an awaited request inside the same segment or component will block any requests below it.To fetch data in parallel, you can eagerly initiate requests by defining them outside the components that use the data. This saves time by initiating both requests in parallel, however, the user won't see the rendered result until both promises are resolved.In the example below, thegetArtistandgetAlbumsfunctions are defined outside thePagecomponent and initiated inside the component usingPromise.all:app/artist/[username]/page.tsxTypeScriptJavaScriptTypeScriptimportAlbumsfrom'./albums'asyncfunctiongetArtist(username:string) {constres=awaitfetch(`https://api.example.com/artist/${username}`)returnres.json()}asyncfunctiongetAlbums(username:string) {constres=awaitfetch(`https://api.example.com/artist/${username}/albums`)returnres.json()}exportdefaultasyncfunctionPage({params,}:{params:Promise<{ username:string}>}) {const{username}=awaitparamsconstartistData=getArtist(username)constalbumsData=getAlbums(username)// Initiate both requests in parallelconst[artist,albums]=awaitPromise.all([artistData,albumsData])return(<><h1>{artist.name}</h1><Albumslist={albums} /></>)}In addition, you can add aSuspense Boundaryto break up the rendering work and show part of the result as soon as possible.Preloading DataAnother way to prevent waterfalls is to use thepreloadpattern by creating an utility function that you eagerly call above blocking requests. For example,checkIsAvailable()blocks<Item/>from rendering, so you can callpreload()before it to eagerly initiate<Item/>data dependencies. By the time<Item/>is rendered, its data has already been fetched.Note thatpreloadfunction doesn't blockcheckIsAvailable()from running.components/Item.tsxTypeScriptJavaScriptTypeScriptimport{ getItem }from'@/utils/get-item'exportconstpreload=(id:string)=>{// void evaluates the given expression and returns undefined// https://developer.mozilla.org/docs/Web/JavaScript/Reference/Operators/voidvoidgetItem(id)}exportdefaultasyncfunctionItem({ id }:{ id:string}) {constresult=awaitgetItem(id)// ...}app/item/[id]/page.tsxTypeScriptJavaScriptTypeScriptimportItem,{ preload,checkIsAvailable }from'@/components/Item'exportdefaultasyncfunctionPage({params,}:{params:Promise<{ id:string}>}) {const{id}=awaitparams// starting loadingitemdatapreload(id)// perform another asynchronous taskconstisAvailable=awaitcheckIsAvailable()returnisAvailable?<Itemid={id} />:null}Good to know:The ""preload"" function can also have any name as it's a pattern, not an API.Using Reactcacheandserver-onlywith the Preload PatternYou can combine thecachefunction, thepreloadpattern, and theserver-onlypackage to create a data fetching utility that can be used throughout your app.utils/get-item.tsTypeScriptJavaScriptTypeScriptimport{ cache }from'react'import'server-only'exportconstpreload=(id:string)=>{voidgetItem(id)}exportconstgetItem=cache(async(id:string)=>{// ...})With this approach, you can eagerly fetch data, cache responses, and guarantee that this data fetchingonly happens on the server.Theutils/get-itemexports can be used by Layouts, Pages, or other components to give them control over when an item's data is fetched.Good to know:We recommend using theserver-onlypackageto make sure server data fetching functions are never used on the client.Preventing sensitive data from being exposed to the clientWe recommend using React's taint APIs,taintObjectReferenceandtaintUniqueValue, to prevent whole object instances or sensitive values from being passed to the client.To enable tainting in your application, set the Next.js Configexperimental.taintoption totrue:next.config.jsmodule.exports={experimental:{taint:true,},}Then pass the object or value you want to taint to theexperimental_taintObjectReferenceorexperimental_taintUniqueValuefunctions:app/utils.tsTypeScriptJavaScriptTypeScriptimport{ queryDataFromDB }from'./api'import{experimental_taintObjectReference,experimental_taintUniqueValue,}from'react'exportasyncfunctiongetUserData() {constdata=awaitqueryDataFromDB()experimental_taintObjectReference('Do not pass the whole user object to the client',data)experimental_taintUniqueValue(""Do not pass the user's address to the client"",data,data.address)returndata}app/page.tsxTypeScriptJavaScriptTypeScriptimport{ getUserData }from'./data'exportasyncfunctionPage() {constuserData=getUserData()return(<ClientComponentuser={userData}// this will cause an error because of taintObjectReferenceaddress={userData.address}// this will cause an error because of taintUniqueValue/>)}PreviousData FetchingNextServer Actions and MutationsWas this helpful?supported.Send"
server actions and mutations,Server Actions and Mutations,"Building Your ApplicationData FetchingServer Actions and MutationsServer Actions and MutationsServer Actionsareasynchronous functionsthat are executed on the server. They can be called in Server and Client Components to handle form submissions and data mutations in Next.js applications.🎥 Watch:Learn more about mutations with Server Actions →YouTube (10 minutes).ConventionA Server Action can be defined with the React""use server""directive. You can place the directive at the top of anasyncfunction to mark the function as a Server Action, or at the top of a separate file to mark all exports of that file as Server Actions.Server ComponentsServer Components can use the inline function level or module level""use server""directive. To inline a Server Action, add""use server""to the top of the function body:app/page.tsxTypeScriptJavaScriptTypeScriptexportdefaultfunctionPage() {// Server Actionasyncfunctioncreate() {'use server'// Mutate data}return'...'}Client ComponentsTo call a Server Action in a Client Component, create a new file and add the""use server""directive at the top of it. All exported functions within the file will be marked as Server Actions that can be reused in both Client and Server Components:app/actions.tsTypeScriptJavaScriptTypeScript'use server'exportasyncfunctioncreate() {}app/button.tsxTypeScriptJavaScriptTypeScript'use client'import{ create }from'./actions'exportfunctionButton() {return<buttononClick={()=>create()}>Create</button>}Passing actions as propsYou can also pass a Server Action to a Client Component as a prop:<ClientComponentupdateItemAction={updateItem} />app/client-component.tsxTypeScriptJavaScriptTypeScript'use client'exportdefaultfunctionClientComponent({updateItemAction,}:{updateItemAction:(formData:FormData)=>void}) {return<formaction={updateItemAction}>{/* ... */}</form>}Usually, the Next.js TypeScript plugin would flagupdateItemActioninclient-component.tsxsince it is a function which generally can't be serialized across client-server boundaries.
However, props namedactionor ending withActionare assumed to receive Server Actions.
This is only a heuristic since the TypeScript plugin doesn't actually know if it receives a Server Action or an ordinary function.
Runtime type-checking will still ensure you don't accidentally pass a function to a Client Component.BehaviorServer actions can be invoked using theactionattribute in a<form>element:Server Components support progressive enhancement by default, meaning the form will be submitted even if JavaScript hasn't loaded yet or is disabled.In Client Components, forms invoking Server Actions will queue submissions if JavaScript isn't loaded yet, prioritizing client hydration.After hydration, the browser does not refresh on form submission.Server Actions are not limited to<form>and can be invoked from event handlers,useEffect, third-party libraries, and other form elements like<button>.Server Actions integrate with the Next.jscaching and revalidationarchitecture. When an action is invoked, Next.js can return both the updated UI and new data in a single server roundtrip.Behind the scenes, actions use thePOSTmethod, and only this HTTP method can invoke them.The arguments and return value of Server Actions must be serializable by React. See the React docs for a list ofserializable arguments and values.Server Actions are functions. This means they can be reused anywhere in your application.Server Actions inherit theruntimefrom the page or layout they are used on.Server Actions inherit theRoute Segment Configfrom the page or layout they are used on, including fields likemaxDuration.ExamplesFormsReact extends the HTML<form>element to allow Server Actions to be invoked with theactionprop.When invoked in a form, the action automatically receives theFormDataobject. You don't need to use ReactuseStateto manage fields, instead, you can extract the data using the nativeFormDatamethods:app/invoices/page.tsxTypeScriptJavaScriptTypeScriptexportdefaultfunctionPage() {asyncfunctioncreateInvoice(formData:FormData) {'use server'constrawFormData={customerId:formData.get('customerId'),amount:formData.get('amount'),status:formData.get('status'),}// mutate data// revalidate cache}return<formaction={createInvoice}>...</form>}Good to know:Example:Form with Loading & Error StatesWhen working with forms that have many fields, you may want to consider using theentries()method with JavaScript'sObject.fromEntries(). For example:const rawFormData = Object.fromEntries(formData). One thing to note is that theformDatawill include additional$ACTION_properties.SeeReact<form>documentationto learn more.Passing additional argumentsYou can pass additional arguments to a Server Action using the JavaScriptbindmethod.app/client-component.tsxTypeScriptJavaScriptTypeScript'use client'import{ updateUser }from'./actions'exportfunctionUserProfile({ userId }:{ userId:string}) {constupdateUserWithId=updateUser.bind(null,userId)return(<formaction={updateUserWithId}><inputtype=""text""name=""name""/><buttontype=""submit"">Update User Name</button></form>)}The Server Action will receive theuserIdargument, in addition to the form data:app/actions.tsTypeScriptJavaScriptTypeScript'use server'exportasyncfunctionupdateUser(userId:string,formData:FormData) {}Good to know:An alternative is to pass arguments as hidden input fields in the form (e.g.<input type=""hidden"" name=""userId"" value={userId} />). However, the value will be part of the rendered HTML and will not be encoded..bindworks in both Server and Client Components. It also supports progressive enhancement.Nested form elementsYou can also invoke a Server Action in elements nested inside<form>such as<button>,<input type=""submit"">, and<input type=""image"">. These elements accept theformActionprop orevent handlers.This is useful in cases where you want to call multiple server actions within a form. For example, you can create a specific<button>element for saving a post draft in addition to publishing it. See theReact<form>docsfor more information.Programmatic form submissionYou can trigger a form submission programmatically using therequestSubmit()method. For example, when the user submits a form using the⌘+Enterkeyboard shortcut, you can listen for theonKeyDownevent:app/entry.tsxTypeScriptJavaScriptTypeScript'use client'exportfunctionEntry() {consthandleKeyDown=(e:React.KeyboardEvent<HTMLTextAreaElement>)=>{if((e.ctrlKey||e.metaKey)&&(e.key==='Enter'||e.key==='NumpadEnter')) {e.preventDefault()e.currentTarget.form?.requestSubmit()}}return(<div><textareaname=""entry""rows={20}requiredonKeyDown={handleKeyDown} /></div>)}This will trigger the submission of the nearest<form>ancestor, which will invoke the Server Action.Server-side form validationYou can use the HTML attributes likerequiredandtype=""email""for basic client-side form validation.For more advanced server-side validation, you can use a library likezodto validate the form fields before mutating the data:app/actions.tsTypeScriptJavaScriptTypeScript'use server'import{ z }from'zod'constschema=z.object({email:z.string({invalid_type_error:'Invalid Email',}),})exportdefaultasyncfunctioncreateUser(formData:FormData) {constvalidatedFields=schema.safeParse({email:formData.get('email'),})// Return early if the form data is invalidif(!validatedFields.success) {return{errors:validatedFields.error.flatten().fieldErrors,}}// Mutate data}Once the fields have been validated on the server, you can return a serializable object in your action and use the ReactuseActionStatehook to show a message to the user.By passing the action touseActionState, the action's function signature changes to receive a newprevStateorinitialStateparameter as its first argument.useActionStateis a React hook and therefore must be used in a Client Component.app/actions.tsTypeScriptJavaScriptTypeScript'use server'import{ redirect }from'next/navigation'exportasyncfunctioncreateUser(prevState:any,formData:FormData) {constres=awaitfetch('https://...')constjson=awaitres.json()if(!res.ok) {return{ message:'Please enter a valid email'}}redirect('/dashboard')}Then, you can pass your action to theuseActionStatehook and use the returnedstateto display an error message.app/ui/signup.tsxTypeScriptJavaScriptTypeScript'use client'import{ useActionState }from'react'import{ createUser }from'@/app/actions'constinitialState={message:'',}exportfunctionSignup() {const[state,formAction,pending]=useActionState(createUser,initialState)return(<formaction={formAction}><labelhtmlFor=""email"">Email</label><inputtype=""text""id=""email""name=""email""required/>{/* ... */}<paria-live=""polite"">{state?.message}</p><buttondisabled={pending}>Sign up</button></form>)}Pending statesTheuseActionStatehook exposes apendingboolean that can be used to show a loading indicator while the action is being executed.Alternatively, you can use theuseFormStatushook to show a loading indicator while the action is being executed. When using this hook, you'll need to create a separate component to render the loading indicator. For example, to disable the button when the action is pending:app/ui/button.tsxTypeScriptJavaScriptTypeScript'use client'import{ useFormStatus }from'react-dom'exportfunctionSubmitButton() {const{pending}=useFormStatus()return(<buttondisabled={pending}type=""submit"">Sign Up</button>)}You can then nest theSubmitButtoncomponent inside the form:app/ui/signup.tsxTypeScriptJavaScriptTypeScriptimport{ SubmitButton }from'./button'import{ createUser }from'@/app/actions'exportfunctionSignup() {return(<formaction={createUser}>{/* Other form elements */}<SubmitButton/></form>)}Good to know:In React 19,useFormStatusincludes additional keys on the returned object, like data, method, and action. If you are not using React 19, only thependingkey is available.Optimistic updatesYou can use the ReactuseOptimistichook to optimistically update the UI before the Server Action finishes executing, rather than waiting for the response:app/page.tsxTypeScriptJavaScriptTypeScript'use client'import{ useOptimistic }from'react'import{ send }from'./actions'typeMessage={message:string}exportfunctionThread({ messages }:{ messages:Message[] }) {const[optimisticMessages,addOptimisticMessage]=useOptimistic<Message[],string>(messages,(state,newMessage)=>[...state,{ message:newMessage }])constformAction=async(formData:FormData)=>{constmessage=formData.get('message')asstringaddOptimisticMessage(message)awaitsend(message)}return(<div>{optimisticMessages.map((m,i)=>(<divkey={i}>{m.message}</div>))}<formaction={formAction}><inputtype=""text""name=""message""/><buttontype=""submit"">Send</button></form></div>)}Event handlersWhile it's common to use Server Actions within<form>elements, they can also be invoked with event handlers such asonClick. For example, to increment a like count:app/like-button.tsxTypeScriptJavaScriptTypeScript'use client'import{ incrementLike }from'./actions'import{ useState }from'react'exportdefaultfunctionLikeButton({ initialLikes }:{ initialLikes:number}) {const[likes,setLikes]=useState(initialLikes)return(<><p>Total Likes: {likes}</p><buttononClick={async()=>{constupdatedLikes=awaitincrementLike()setLikes(updatedLikes)}}>Like</button></>)}You can also add event handlers to form elements, for example, to save a form fieldonChange:app/ui/edit-post.tsx'use client'import{ publishPost,saveDraft }from'./actions'exportdefaultfunctionEditPost() {return(<formaction={publishPost}><textareaname=""content""onChange={async(e)=>{awaitsaveDraft(e.target.value)}}/><buttontype=""submit"">Publish</button></form>)}For cases like this, where multiple events might be fired in quick succession, we recommenddebouncingto prevent unnecessary Server Action invocations.useEffectYou can use the ReactuseEffecthook to invoke a Server Action when the component mounts or a dependency changes. This is useful for mutations that depend on global events or need to be triggered automatically. For example,onKeyDownfor app shortcuts, an intersection observer hook for infinite scrolling, or when the component mounts to update a view count:app/view-count.tsxTypeScriptJavaScriptTypeScript'use client'import{ incrementViews }from'./actions'import{ useState,useEffect }from'react'exportdefaultfunctionViewCount({ initialViews }:{ initialViews:number}) {const[views,setViews]=useState(initialViews)useEffect(()=>{constupdateViews=async()=>{constupdatedViews=awaitincrementViews()setViews(updatedViews)}updateViews()},[])return<p>Total Views: {views}</p>}Remember to consider thebehavior and caveatsofuseEffect.Error HandlingWhen an error is thrown, it'll be caught by the nearesterror.jsor<Suspense>boundary on the client. SeeError Handlingfor more information.Good to know:Aside from throwing the error, you can also return an object to be handled byuseActionState. SeeServer-side validation and error handling.Revalidating dataYou can revalidate theNext.js Cacheinside your Server Actions with therevalidatePathAPI:app/actions.tsTypeScriptJavaScriptTypeScript'use server'import{ revalidatePath }from'next/cache'exportasyncfunctioncreatePost() {try{// ...}catch(error) {// ...}revalidatePath('/posts')}Or invalidate a specific data fetch with a cache tag usingrevalidateTag:app/actions.tsTypeScriptJavaScriptTypeScript'use server'import{ revalidateTag }from'next/cache'exportasyncfunctioncreatePost() {try{// ...}catch(error) {// ...}revalidateTag('posts')}RedirectingIf you would like to redirect the user to a different route after the completion of a Server Action, you can useredirectAPI.redirectneeds to be called outside of thetry/catchblock:app/actions.tsTypeScriptJavaScriptTypeScript'use server'import{ redirect }from'next/navigation'import{ revalidateTag }from'next/cache'exportasyncfunctioncreatePost(id:string) {try{// ...}catch(error) {// ...}revalidateTag('posts')// Update cached postsredirect(`/post/${id}`)// Navigate to the new post page}CookiesYou canget,set, anddeletecookies inside a Server Action using thecookiesAPI:app/actions.tsTypeScriptJavaScriptTypeScript'use server'import{ cookies }from'next/headers'exportasyncfunctionexampleAction() {constcookieStore=awaitcookies()// Get cookiecookieStore.get('name')?.value// Set cookiecookieStore.set('name','Delba')// Delete cookiecookieStore.delete('name')}Seeadditional examplesfor deleting cookies from Server Actions.SecurityBy default, when a Server Action is created and exported, it creates a public HTTP endpoint
and should be treated with the same security assumptions and authorization checks. This means, even if a Server Action or utility function is not imported elsewhere in your code, it’s still publicly accessible.To improve security, Next.js has the following built-in features:Secure action IDs:Next.js creates encrypted, non-deterministic IDs to allow the client to reference and call the Server Action. These IDs are periodically recalculated between builds for enhanced security.Dead code elimination:Unused Server Actions (referenced by their IDs) are removed from client bundle to avoid public access by third-party.Good to know:The IDs are created during compilation and are cached for a maximum of 14 days. They will be regenerated when a new build is initiated or when the build cache is invalidated.
This security improvement reduces the risk in cases where an authentication layer is missing. However, you should still treat Server Actions like public HTTP endpoints.// app/actions.js'use server'// This action **is** used in our application, so Next.js// will create a secure ID to allow the client to reference// and call the Server Action.exportasyncfunctionupdateUserAction(formData) {}// This action **is not** used in our application, so Next.js// will automatically remove this code during `next build`// and will not create a public endpoint.exportasyncfunctiondeleteUserAction(formData) {}Authentication and authorizationYou should ensure that the user is authorized to perform the action. For example:app/actions.ts'use server'import{ auth }from'./lib'exportfunctionaddItem() {const{user}=auth()if(!user) {thrownewError('You must be signed in to perform this action')}// ...}Closures and encryptionDefining a Server Action inside a component creates aclosurewhere the action has access to the outer function's scope. For example, thepublishaction has access to thepublishVersionvariable:app/page.tsxTypeScriptJavaScriptTypeScriptexportdefaultasyncfunctionPage() {constpublishVersion=awaitgetLatestVersion();asyncfunctionpublish() {""use server"";if(publishVersion!==awaitgetLatestVersion()) {thrownewError('The version has changed since pressing publish');}...}return(<form><buttonformAction={publish}>Publish</button></form>);}Closures are useful when you need to capture asnapshotof data (e.g.publishVersion) at the time of rendering so that it can be used later when the action is invoked.However, for this to happen, the captured variables are sent to the client and back to the server when the action is invoked. To prevent sensitive data from being exposed to the client, Next.js automatically encrypts the closed-over variables. A new private key is generated for each action every time a Next.js application is built. This means actions can only be invoked for a specific build.Good to know:We don't recommend relying on encryption alone to prevent sensitive values from being exposed on the client. Instead, you should use theReact taint APIsto proactively prevent specific data from being sent to the client.Overwriting encryption keys (advanced)When self-hosting your Next.js application across multiple servers, each server instance may end up with a different encryption key, leading to potential inconsistencies.To mitigate this, you can overwrite the encryption key using theprocess.env.NEXT_SERVER_ACTIONS_ENCRYPTION_KEYenvironment variable. Specifying this variable ensures that your encryption keys are persistent across builds, and all server instances use the same key. This variablemustbe AES-GCM encrypted.This is an advanced use case where consistent encryption behavior across multiple deployments is critical for your application. You should consider standard security practices such key rotation and signing.Good to know:Next.js applications deployed to Vercel automatically handle this.Allowed origins (advanced)Since Server Actions can be invoked in a<form>element, this opens them up toCSRF attacks.Behind the scenes, Server Actions use thePOSTmethod, and only this HTTP method is allowed to invoke them. This prevents most CSRF vulnerabilities in modern browsers, particularly withSameSite cookiesbeing the default.As an additional protection, Server Actions in Next.js also compare theOrigin headerto theHost header(orX-Forwarded-Host). If these don't match, the request will be aborted. In other words, Server Actions can only be invoked on the same host as the page that hosts it.For large applications that use reverse proxies or multi-layered backend architectures (where the server API differs from the production domain), it's recommended to use the configuration optionserverActions.allowedOriginsoption to specify a list of safe origins. The option accepts an array of strings.next.config.js/**@type{import('next').NextConfig}*/module.exports={experimental:{serverActions:{allowedOrigins:['my-proxy.com','*.my-proxy.com'],},},}Learn more aboutSecurity and Server Actions.Additional resourcesFor more information, check out the following React docs:Server Actions""use server""<form>useFormStatususeActionStateuseOptimisticNext StepsLearn how to configure Server Actions in Next.jsserverActionsConfigure Server Actions behavior in your Next.js application.PreviousData Fetching and CachingNextIncremental Static Regeneration (ISR)Was this helpful?supported.Send"
incremental static regeneration (isr),Incremental Static Regeneration (ISR),"Building Your ApplicationData FetchingIncremental Static Regeneration (ISR)Incremental Static Regeneration (ISR)ExamplesNext.js CommerceOn-Demand ISRNext.js FormsIncremental Static Regeneration (ISR) enables you to:Update static content without rebuilding the entire siteReduce server load by serving prerendered, static pages for most requestsEnsure propercache-controlheaders are automatically added to pagesHandle large amounts of content pages without longnext buildtimesHere's a minimal example:app/blog/[id]/page.tsxTypeScriptJavaScriptTypeScriptinterfacePost{id:stringtitle:stringcontent:string}// Next.js will invalidate the cache when a// request comes in, at most once every 60 seconds.exportconstrevalidate=60// We'll prerender only the params from `generateStaticParams` at build time.// If a request comes in for a path that hasn't been generated,// Next.js will server-render the page on-demand.exportconstdynamicParams=true// or false, to 404 on unknown pathsexportasyncfunctiongenerateStaticParams() {constposts:Post[]=awaitfetch('https://api.vercel.app/blog').then((res)=>res.json())returnposts.map((post)=>({id:String(post.id),}))}exportdefaultasyncfunctionPage({params,}:{params:Promise<{ id:string}>}) {constid=(awaitparams).idconstpost:Post=awaitfetch(`https://api.vercel.app/blog/${id}`).then((res)=>res.json())return(<main><h1>{post.title}</h1><p>{post.content}</p></main>)}Here's how this example works:Duringnext build, all known blog posts are generated (there are 25 in this example)All requests made to these pages (e.g./blog/1) are cached and instantaneousAfter 60 seconds has passed, the next request will still show the cached (stale) pageThe cache is invalidated and a new version of the page begins generating in the backgroundOnce generated successfully, Next.js will display and cache the updated pageIf/blog/26is requested, Next.js will generate and cache this page on-demandReferenceRoute segment configrevalidatedynamicParamsFunctionsrevalidatePathrevalidateTagExamplesTime-based revalidationThis fetches and displays a list of blog posts on/blog. After an hour, the cache for this page is invalidated on the next visit to the page. Then, in the background, a new version of the page is generated with the latest blog posts.app/blog/page.tsxTypeScriptJavaScriptTypeScriptinterfacePost{id:stringtitle:stringcontent:string}exportconstrevalidate=3600// invalidate every hourexportdefaultasyncfunctionPage() {constdata=awaitfetch('https://api.vercel.app/blog')constposts:Post[]=awaitdata.json()return(<main><h1>Blog Posts</h1><ul>{posts.map((post)=>(<likey={post.id}>{post.title}</li>))}</ul></main>)}We recommend setting a high revalidation time. For instance, 1 hour instead of 1 second. If you need more precision, consider using on-demand revalidation. If you need real-time data, consider switching todynamic rendering.On-demand revalidation withrevalidatePathFor a more precise method of revalidation, invalidate pages on-demand with therevalidatePathfunction.For example, this Server Action would get called after adding a new post. Regardless of how you retrieve your data in your Server Component, either usingfetchor connecting to a database, this will clear the cache for the entire route and allow the Server Component to fetch fresh data.app/actions.tsTypeScriptJavaScriptTypeScript'use server'import{ revalidatePath }from'next/cache'exportasyncfunctioncreatePost() {// Invalidate the /posts route in the cacherevalidatePath('/posts')}View a demoandexplore the source code.On-demand revalidation withrevalidateTagFor most use cases, prefer revalidating entire paths. If you need more granular control, you can use therevalidateTagfunction. For example, you can tag individualfetchcalls:app/blog/page.tsxTypeScriptJavaScriptTypeScriptexportdefaultasyncfunctionPage() {constdata=awaitfetch('https://api.vercel.app/blog',{next:{ tags:['posts'] },})constposts=awaitdata.json()// ...}If you are using an ORM or connecting to a database, you can useunstable_cache:app/blog/page.tsxTypeScriptJavaScriptTypeScriptimport{ unstable_cache }from'next/cache'import{ db,posts }from'@/lib/db'constgetCachedPosts=unstable_cache(async()=>{returnawaitdb.select().from(posts)},['posts'],{ revalidate:3600,tags:['posts'] })exportdefaultasyncfunctionPage() {constposts=getCachedPosts()// ...}You can then userevalidateTagin aServer ActionsorRoute Handler:app/actions.tsTypeScriptJavaScriptTypeScript'use server'import{ revalidateTag }from'next/cache'exportasyncfunctioncreatePost() {// Invalidate all data tagged with 'posts' in the cacherevalidateTag('posts')}Handling uncaught exceptionsIf an error is thrown while attempting to revalidate data, the last successfully generated data will continue to be served from the cache. On the next subsequent request, Next.js will retry revalidating the data.Learn more about error handling.Customizing the cache locationCaching and revalidating pages (with Incremental Static Regeneration) use the same shared cache. Whendeploying to Vercel, the ISR cache is automatically persisted to durable storage.When self-hosting, the ISR cache is stored to the filesystem (on disk) on your Next.js server. This works automatically when self-hosting using both the Pages and App Router.You can configure the Next.js cache location if you want to persist cached pages and data to durable storage, or share the cache across multiple containers or instances of your Next.js application.Learn more.TroubleshootingDebugging cached data in local developmentIf you are using thefetchAPI, you can add additional logging to understand which requests are cached or uncached.Learn more about theloggingoption.next.config.jsmodule.exports={logging:{fetches:{fullUrl:true,},},}Verifying correct production behaviorTo verify your pages are cached and revalidated correctly in production, you can test locally by runningnext buildand thennext startto run the production Next.js server.This will allow you to test ISR behavior as it would work in a production environment. For further debugging, add the following environment variable to your.envfile:.envNEXT_PRIVATE_DEBUG_CACHE=1This will make the Next.js server console log ISR cache hits and misses. You can inspect the output to see which pages are generated duringnext build, as well as how pages are updated as paths are accessed on-demand.CaveatsISR is only supported when using the Node.js runtime (default).ISR is not supported when creating aStatic Export.If you have multiplefetchrequests in a statically rendered route, and each has a differentrevalidatefrequency, the lowest time will be used for ISR. However, those revalidate frequencies will still be respected by theData Cache.If any of thefetchrequests used on a route have arevalidatetime of0, or an explicitno-store, the route will bedynamically rendered.Middleware won't be executed for on-demand ISR requests, meaning any path rewrites or logic in Middleware will not be applied. Ensure you are revalidating the exact path. For example,/post/1instead of a rewritten/post-1.Version historyVersionChangesv14.1.0CustomcacheHandleris stable.v13.0.0App Router is introduced.v12.2.0Pages Router: On-Demand ISR is stablev12.0.0Pages Router:Bot-aware ISR fallbackadded.v9.5.0Pages Router:Stable ISR introduced.PreviousServer Actions and MutationsNextRenderingWas this helpful?supported.Send"
rendering,Rendering,"App RouterBuilding Your ApplicationRenderingRenderingRendering converts the code you write into user interfaces. React and Next.js allow you to create hybrid web applications where parts of your code can be rendered on the server or the client. This section will help you understand the differences between these rendering environments, strategies, and runtimes.FundamentalsTo start, it's helpful to be familiar with three foundational web concepts:TheEnvironmentsyour application code can be executed in: the server and the client.TheRequest-Response Lifecyclethat's initiated when a user visits or interacts with your application.TheNetwork Boundarythat separates server and client code.Rendering EnvironmentsThere are two environments where web applications can be rendered: the client and the server.Theclientrefers to the browser on a user's device that sends a request to a server for your application code. It then turns the response from the server into a user interface.Theserverrefers to the computer in a data center that stores your application code, receives requests from a client, and sends back an appropriate response.Historically, developers had to use different languages (e.g. JavaScript, PHP) and frameworks when writing code for the server and the client. With React, developers can use thesame language(JavaScript), and thesame framework(e.g. Next.js or your framework of choice). This flexibility allows you to seamlessly write code for both environments without context switching.However, each environment has its own set of capabilities and constraints. Therefore, the code you write for the server and the client is not always the same. There are certain operations (e.g. data fetching or managing user state) that are better suited for one environment over the other.Understanding these differences is key to effectively using React and Next.js. We'll cover the differences and use cases in more detail on theServerandClientComponents pages, for now, let's continue building on our foundation.Request-Response LifecycleBroadly speaking, all websites follow the sameRequest-Response Lifecycle:User Action:The user interacts with a web application. This could be clicking a link, submitting a form, or typing a URL directly into the browser's address bar.HTTP Request:The client sends anHTTPrequest to the server that contains necessary information about what resources are being requested, what method is being used (e.g.GET,POST), and additional data if necessary.Server:The server processes the request and responds with the appropriate resources. This process may take a couple of steps like routing, fetching data, etc.HTTP Response:After processing the request, the server sends an HTTP response back to the client. This response contains a status code (which tells the client whether the request was successful or not) and requested resources (e.g. HTML, CSS, JavaScript, static assets, etc).Client:The client parses the resources to render the user interface.User Action:Once the user interface is rendered, the user can interact with it, and the whole process starts again.A major part of building a hybrid web application is deciding how to split the work in the lifecycle, and where to place the Network Boundary.Network BoundaryIn web development, theNetwork Boundaryis a conceptual line that separates the different environments. For example, the client and the server, or the server and the data store.In React, you choose where to place the client-server network boundary wherever it makes the most sense.Behind the scenes, the work is split into two parts: theclient module graphand theserver module graph. The server module graph contains all the components that are rendered on the server, and the client module graph contains all components that are rendered on the client.It may be helpful to think about module graphs as a visual representation of how files in your application depend on each other.You can use the React""use client""convention to define the boundary. There's also a""use server""convention, which tells React to do some computational work on the server.Building Hybrid ApplicationsWhen working in these environments, it's helpful to think of the flow of the code in your application asunidirectional. In other words, during a response, your application code flows in one direction: from the server to the client.If you need to access the server from the client, you send anewrequest to the server rather than re-use the same request. This makes it easier to understand where to render your components and where to place the Network Boundary.In practice, this model encourages developers to think about what they want to execute on the server first, before sending the result to the client and making the application interactive.This concept will become clearer when we look at how you caninterleave client and server componentsin the same component tree.Server ComponentsLearn how you can use React Server Components to render parts of your application on the server.Client ComponentsLearn how to use Client Components to render parts of your application on the client.Composition PatternsRecommended patterns for using Server and Client Components.Partial PrerenderingLearn how to combine the benefits of static and dynamic rendering with Partial Prerendering.RuntimesLearn about the switchable runtimes (Edge and Node.js) in Next.js.PreviousIncremental Static Regeneration (ISR)NextServer ComponentsWas this helpful?supported.Send"
server components,Server Components,"Building Your ApplicationRenderingServer ComponentsServer ComponentsReact Server Components allow you to write UI that can be rendered and optionally cached on the server. In Next.js, the rendering work is further split by route segments to enable streaming and partial rendering, and there are three different server rendering strategies:Static RenderingDynamic RenderingStreamingThis page will go through how Server Components work, when you might use them, and the different server rendering strategies.Benefits of Server RenderingThere are a couple of benefits to doing the rendering work on the server, including:Data Fetching: Server Components allow you to move data fetching to the server, closer to your data source. This can improve performance by reducing time it takes to fetch data needed for rendering, and the number of requests the client needs to make.Security: Server Components allow you to keep sensitive data and logic on the server, such as tokens and API keys, without the risk of exposing them to the client.Caching: By rendering on the server, the result can be cached and reused on subsequent requests and across users. This can improve performance and reduce cost by reducing the amount of rendering and data fetching done on each request.Performance: Server Components give you additional tools to optimize performance from the baseline. For example, if you start with an app composed of entirely Client Components, moving non-interactive pieces of your UI to Server Components can reduce the amount of client-side JavaScript needed. This is beneficial for users with slower internet or less powerful devices, as the browser has less client-side JavaScript to download, parse, and execute.Initial Page Load andFirst Contentful Paint (FCP): On the server, we can generate HTML to allow users to view the page immediately, without waiting for the client to download, parse and execute the JavaScript needed to render the page.Search Engine Optimization and Social Network Shareability: The rendered HTML can be used by search engine bots to index your pages and social network bots to generate social card previews for your pages.Streaming: Server Components allow you to split the rendering work into chunks and stream them to the client as they become ready. This allows the user to see parts of the page earlier without having to wait for the entire page to be rendered on the server.Using Server Components in Next.jsBy default, Next.js uses Server Components. This allows you to automatically implement server rendering with no additional configuration, and you can opt into using Client Components when needed, seeClient Components.How are Server Components rendered?On the server, Next.js uses React's APIs to orchestrate rendering. The rendering work is split into chunks: by individual route segments andSuspense Boundaries.Each chunk is rendered in two steps:React renders Server Components into a special data format called theReact Server Component Payload (RSC Payload).Next.js uses the RSC Payload and Client Component JavaScript instructions to renderHTMLon the server.Then, on the client:The HTML is used to immediately show a fast non-interactive preview of the route - this is for the initial page load only.The React Server Components Payload is used to reconcile the Client and Server Component trees, and update the DOM.The JavaScript instructions are used tohydrateClient Components and make the application interactive.What is the React Server Component Payload (RSC)?The RSC Payload is a compact binary representation of the rendered React Server Components tree. It's used by React on the client to update the browser's DOM. The RSC Payload contains:The rendered result of Server ComponentsPlaceholders for where Client Components should be rendered and references to their JavaScript filesAny props passed from a Server Component to a Client ComponentServer Rendering StrategiesThere are three subsets of server rendering: Static, Dynamic, and Streaming.Static Rendering (Default)With Static Rendering, routes are rendered atbuild time, or in the background afterdata revalidation. The result is cached and can be pushed to aContent Delivery Network (CDN). This optimization allows you to share the result of the rendering work between users and server requests.Static rendering is useful when a route has data that is not personalized to the user and can be known at build time, such as a static blog post or a product page.Dynamic RenderingWith Dynamic Rendering, routes are rendered for each user atrequest time.Dynamic rendering is useful when a route has data that is personalized to the user or has information that can only be known at request time, such as cookies or the URL's search params.Dynamic Routes with Cached DataIn most websites, routes are not fully static or fully dynamic - it's a spectrum. For example, you can have an e-commerce page that uses cached product data that's revalidated at an interval, but also has uncached, personalized customer data.In Next.js, you can have dynamically rendered routes that have both cached and uncached data. This is because the RSC Payload and data are cached separately. This allows you to opt into dynamic rendering without worrying about the performance impact of fetching all the data at request time.Learn more about thefull-route cacheandData Cache.Switching to Dynamic RenderingDuring rendering, if aDynamic APIor afetchoption of{ cache: 'no-store' }is discovered, Next.js will switch to dynamically rendering the whole route. This table summarizes how Dynamic APIs and data caching affect whether a route is statically or dynamically rendered:Dynamic APIsDataRouteNoCachedStatically RenderedYesCachedDynamically RenderedNoNot CachedDynamically RenderedYesNot CachedDynamically RenderedIn the table above, for a route to be fully static, all data must be cached. However, you can have a dynamically rendered route that uses both cached and uncached data fetches.As a developer, you do not need to choose between static and dynamic rendering as Next.js will automatically choose the best rendering strategy for each route based on the features and APIs used. Instead, you choose when tocacheorrevalidate specific data, and you may choose tostreamparts of your UI.Dynamic APIsDynamic APIs rely on information that can only be known at request time (and not ahead of time during prerendering). Using any of these APIs signals the developer's intention and will opt the whole route into dynamic rendering at the request time. These APIs include:cookiesheadersconnectiondraftModesearchParamspropunstable_noStoreStreamingStreaming enables you to progressively render UI from the server. Work is split into chunks and streamed to the client as it becomes ready. This allows the user to see parts of the page immediately, before the entire content has finished rendering.Streaming is built into the Next.js App Router by default. This helps improve both the initial page loading performance, as well as UI that depends on slower data fetches that would block rendering the whole route. For example, reviews on a product page.You can start streaming route segments usingloading.jsand UI components withReact Suspense. See theLoading UI and Streamingsection for more information.Next StepsLearn how Next.js caches data and the result of static rendering.CachingAn overview of caching mechanisms in Next.js.PreviousRenderingNextClient ComponentsWas this helpful?supported.Send"
client components,Client Components,"Building Your ApplicationRenderingClient ComponentsClient ComponentsClient Components allow you to write interactive UI that isprerendered on the serverand can use client JavaScript to run in the browser.This page will go through how Client Components work, how they're rendered, and when you might use them.Benefits of Client RenderingThere are a couple of benefits to doing the rendering work on the client, including:Interactivity: Client Components can use state, effects, and event listeners, meaning they can provide immediate feedback to the user and update the UI.Browser APIs: Client Components have access to browser APIs, likegeolocationorlocalStorage.Using Client Components in Next.jsTo use Client Components, you can add the React""use client""directiveat the top of a file, above your imports.""use client""is used to declare aboundarybetween a Server and Client Component modules. This means that by defining a""use client""in a file, all other modules imported into it, including child components, are considered part of the client bundle.app/counter.tsxTypeScriptJavaScriptTypeScript'use client'import{ useState }from'react'exportdefaultfunctionCounter() {const[count,setCount]=useState(0)return(<div><p>You clicked {count} times</p><buttononClick={()=>setCount(count+1)}>Click me</button></div>)}The diagram below shows that usingonClickanduseStatein a nested component (toggle.js) will cause an error if the""use client""directive is not defined. This is because, by default, all components in the App Router are Server Components where these APIs are not available. By defining the""use client""directive intoggle.js, you can tell React to enter the client boundary where these APIs are available.Defining multipleuse cliententry points:You can define multiple ""use client"" entry points in your React Component tree. This allows you to split your application into multiple client bundles.However,""use client""doesn't need to be defined in every component that needs to be rendered on the client. Once you define the boundary, all child components and modules imported into it are considered part of the client bundle.How are Client Components Rendered?In Next.js, Client Components are rendered differently depending on whether the request is part of a full page load (an initial visit to your application or a page reload triggered by a browser refresh) or a subsequent navigation.Full page loadTo optimize the initial page load, Next.js will use React's APIs to render a static HTML preview on the server for both Client and Server Components. This means, when the user first visits your application, they will see the content of the page immediately, without having to wait for the client to download, parse, and execute the Client Component JavaScript bundle.On the server:React renders Server Components into a special data format called theReact Server Component Payload (RSC Payload), which includes references to Client Components.Next.js uses the RSC Payload and Client Component JavaScript instructions to renderHTMLfor the route on the server.Then, on the client:The HTML is used to immediately show a fast non-interactive initial preview of the route.The React Server Components Payload is used to reconcile the Client and Server Component trees, and update the DOM.The JavaScript instructions are used tohydrateClient Components and make their UI interactive.What is hydration?Hydration is the process of attaching event listeners to the DOM, to make the static HTML interactive. Behind the scenes, hydration is done with thehydrateRootReact API.Subsequent NavigationsOn subsequent navigations, Client Components are rendered entirely on the client, without the server-rendered HTML.This means the Client Component JavaScript bundle is downloaded and parsed. Once the bundle is ready, React will use theRSC Payloadto reconcile the Client and Server Component trees, and update the DOM.Going back to the Server EnvironmentSometimes, after you've declared the""use client""boundary, you may want to go back to the server environment. For example, you may want to reduce the client bundle size, fetch data on the server, or use an API that is only available on the server.You can keep code on the server even though it's theoretically nested inside Client Components by interleaving Client and Server Components andServer Actions. See theComposition Patternspage for more information.PreviousServer ComponentsNextComposition PatternsWas this helpful?supported.Send"
composition patterns,Composition Patterns,"Building Your ApplicationRenderingComposition PatternsServer and Client Composition PatternsWhen building React applications, you will need to consider what parts of your application should be rendered on the server or the client. This page covers some recommended composition patterns when using Server and Client Components.When to use Server and Client Components?Here's a quick summary of the different use cases for Server and Client Components:What do you need to do?Server ComponentClient ComponentFetch dataAccess backend resources (directly)Keep sensitive information on the server (access tokens, API keys, etc)Keep large dependencies on the server / Reduce client-side JavaScriptAdd interactivity and event listeners (onClick(),onChange(), etc)Use State and Lifecycle Effects (useState(),useReducer(),useEffect(), etc)Use browser-only APIsUse custom hooks that depend on state, effects, or browser-only APIsUseReact Class componentsServer Component PatternsBefore opting into client-side rendering, you may wish to do some work on the server like fetching data, or accessing your database or backend services.Here are some common patterns when working with Server Components:Sharing data between componentsWhen fetching data on the server, there may be cases where you need to share data across different components. For example, you may have a layout and a page that depend on the same data.Instead of usingReact Context(which is not available on the server) or passing data as props, you can usefetchor React'scachefunction to fetch the same data in the components that need it, without worrying about making duplicate requests for the same data. This is because React extendsfetchto automatically memoize data requests, and thecachefunction can be used whenfetchis not available.View an exampleof this pattern.Keeping Server-only Code out of the Client EnvironmentSince JavaScript modules can be shared between both Server and Client Components modules, it's possible for code that was only ever intended to be run on the server to sneak its way into the client.For example, take the following data-fetching function:lib/data.tsTypeScriptJavaScriptTypeScriptexportasyncfunctiongetData() {constres=awaitfetch('https://external-service.com/data',{headers:{authorization:process.env.API_KEY,},})returnres.json()}At first glance, it appears thatgetDataworks on both the server and the client. However, this function contains anAPI_KEY, written with the intention that it would only ever be executed on the server.Since the environment variableAPI_KEYis not prefixed withNEXT_PUBLIC, it's a private variable that can only be accessed on the server. To prevent your environment variables from being leaked to the client, Next.js replaces private environment variables with an empty string.As a result, even thoughgetData()can be imported and executed on the client, it won't work as expected. And while making the variable public would make the function work on the client, you may not want to expose sensitive information to the client.To prevent this sort of unintended client usage of server code, we can use theserver-onlypackage to give other developers a build-time error if they ever accidentally import one of these modules into a Client Component.To useserver-only, first install the package:Terminalnpminstallserver-onlyThen import the package into any module that contains server-only code:lib/data.jsimport'server-only'exportasyncfunctiongetData() {constres=awaitfetch('https://external-service.com/data',{headers:{authorization:process.env.API_KEY,},})returnres.json()}Now, any Client Component that importsgetData()will receive a build-time error explaining that this module can only be used on the server.The corresponding packageclient-onlycan be used to mark modules that contain client-only code – for example, code that accesses thewindowobject.Using Third-party Packages and ProvidersSince Server Components are a new React feature, third-party packages and providers in the ecosystem are just beginning to add the""use client""directive to components that use client-only features likeuseState,useEffect, andcreateContext.Today, many components fromnpmpackages that use client-only features do not yet have the directive. These third-party components will work as expected within Client Components since they have the""use client""directive, but they won't work within Server Components.For example, let's say you've installed the hypotheticalacme-carouselpackage which has a<Carousel />component. This component usesuseState, but it doesn't yet have the""use client""directive.If you use<Carousel />within a Client Component, it will work as expected:app/gallery.tsxTypeScriptJavaScriptTypeScript'use client'import{ useState }from'react'import{ Carousel }from'acme-carousel'exportdefaultfunctionGallery() {const[isOpen,setIsOpen]=useState(false)return(<div><buttononClick={()=>setIsOpen(true)}>View pictures</button>{/* Works, since Carousel is used within a Client Component */}{isOpen&&<Carousel/>}</div>)}However, if you try to use it directly within a Server Component, you'll see an error:app/page.tsxTypeScriptJavaScriptTypeScriptimport{ Carousel }from'acme-carousel'exportdefaultfunctionPage() {return(<div><p>View pictures</p>{/* Error: `useState` can not be used within Server Components */}<Carousel/></div>)}This is because Next.js doesn't know<Carousel />is using client-only features.To fix this, you can wrap third-party components that rely on client-only features in your own Client Components:app/carousel.tsxTypeScriptJavaScriptTypeScript'use client'import{ Carousel }from'acme-carousel'exportdefaultCarouselNow, you can use<Carousel />directly within a Server Component:app/page.tsxTypeScriptJavaScriptTypeScriptimportCarouselfrom'./carousel'exportdefaultfunctionPage() {return(<div><p>View pictures</p>{/*  Works, since Carousel is a Client Component */}<Carousel/></div>)}We don't expect you to need to wrap most third-party components since it's likely you'll be using them within Client Components. However, one exception is providers, since they rely on React state and context, and are typically needed at the root of an application.Learn more about third-party context providers below.Using Context ProvidersContext providers are typically rendered near the root of an application to share global concerns, like the current theme. SinceReact contextis not supported in Server Components, trying to create a context at the root of your application will cause an error:app/layout.tsxTypeScriptJavaScriptTypeScriptimport{ createContext }from'react'//  createContext is not supported in Server ComponentsexportconstThemeContext=createContext({})exportdefaultfunctionRootLayout({children,}:{children:React.ReactNode}) {return(<html><body><ThemeContext.Providervalue=""dark"">{children}</ThemeContext.Provider></body></html>)}To fix this, create your context and render its provider inside of a Client Component:app/theme-provider.tsxTypeScriptJavaScriptTypeScript'use client'import{ createContext }from'react'exportconstThemeContext=createContext({})exportdefaultfunctionThemeProvider({children,}:{children:React.ReactNode}) {return<ThemeContext.Providervalue=""dark"">{children}</ThemeContext.Provider>}Your Server Component will now be able to directly render your provider since it's been marked as a Client Component:app/layout.tsxTypeScriptJavaScriptTypeScriptimportThemeProviderfrom'./theme-provider'exportdefaultfunctionRootLayout({children,}:{children:React.ReactNode}) {return(<html><body><ThemeProvider>{children}</ThemeProvider></body></html>)}With the provider rendered at the root, all other Client Components throughout your app will be able to consume this context.Good to know: You should render providers as deep as possible in the tree – notice howThemeProvideronly wraps{children}instead of the entire<html>document. This makes it easier for Next.js to optimize the static parts of your Server Components.Advice for Library AuthorsIn a similar fashion, library authors creating packages to be consumed by other developers can use the""use client""directive to mark client entry points of their package. This allows users of the package to import package components directly into their Server Components without having to create a wrapping boundary.You can optimize your package by using'use client' deeper in the tree, allowing the imported modules to be part of the Server Component module graph.It's worth noting some bundlers might strip out""use client""directives. You can find an example of how to configure esbuild to include the""use client""directive in theReact Wrap BalancerandVercel Analyticsrepositories.Client ComponentsMoving Client Components Down the TreeTo reduce the Client JavaScript bundle size, we recommend moving Client Components down your component tree.For example, you may have a Layout that has static elements (e.g. logo, links, etc) and an interactive search bar that uses state.Instead of making the whole layout a Client Component, move the interactive logic to a Client Component (e.g.<SearchBar />) and keep your layout as a Server Component. This means you don't have to send all the component JavaScript of the layout to the client.app/layout.tsxTypeScriptJavaScriptTypeScript// SearchBar is a Client ComponentimportSearchBarfrom'./searchbar'// Logo is a Server ComponentimportLogofrom'./logo'// Layout is a Server Component by defaultexportdefaultfunctionLayout({ children }:{ children:React.ReactNode}) {return(<><nav><Logo/><SearchBar/></nav><main>{children}</main></>)}Passing props from Server to Client Components (Serialization)If you fetch data in a Server Component, you may want to pass data down as props to Client Components. Props passed from the Server to Client Components need to beserializableby React.If your Client Components depend on data that isnotserializable, you canfetch data on the client with a third party libraryor on the server with aRoute Handler.Interleaving Server and Client ComponentsWhen interleaving Client and Server Components, it may be helpful to visualize your UI as a tree of components. Starting with theroot layout, which is a Server Component, you can then render certain subtrees of components on the client by adding the""use client""directive.Within those client subtrees, you can still nest Server Components or call Server Actions, however there are some things to keep in mind:During a request-response lifecycle, your code moves from the server to the client. If you need to access data or resources on the server while on the client, you'll be making anewrequest to the server - not switching back and forth.When a new request is made to the server, all Server Components are rendered first, including those nested inside Client Components. The rendered result (RSC Payload) will contain references to the locations of Client Components. Then, on the client, React uses the RSC Payload to reconcile Server and Client Components into a single tree.Since Client Components are rendered after Server Components, you cannot import a Server Component into a Client Component module (since it would require a new request back to the server). Instead, you can pass a Server Component aspropsto a Client Component. See theunsupported patternandsupported patternsections below.Unsupported Pattern: Importing Server Components into Client ComponentsThe following pattern is not supported. You cannot import a Server Component into a Client Component:app/client-component.tsxTypeScriptJavaScriptTypeScript'use client'// You cannot import a Server Component into a Client Component.importServerComponentfrom'./Server-Component'exportdefaultfunctionClientComponent({children,}:{children:React.ReactNode}) {const[count,setCount]=useState(0)return(<><buttononClick={()=>setCount(count+1)}>{count}</button><ServerComponent/></>)}Supported Pattern: Passing Server Components to Client Components as PropsThe following pattern is supported. You can pass Server Components as a prop to a Client Component.A common pattern is to use the Reactchildrenprop to create a""slot""in your Client Component.In the example below,<ClientComponent>accepts achildrenprop:app/client-component.tsxTypeScriptJavaScriptTypeScript'use client'import{ useState }from'react'exportdefaultfunctionClientComponent({children,}:{children:React.ReactNode}) {const[count,setCount]=useState(0)return(<><buttononClick={()=>setCount(count+1)}>{count}</button>{children}</>)}<ClientComponent>doesn't know thatchildrenwill eventually be filled in by the result of a Server Component. The only responsibility<ClientComponent>has is to decidewherechildrenwill eventually be placed.In a parent Server Component, you can import both the<ClientComponent>and<ServerComponent>and pass<ServerComponent>as a child of<ClientComponent>:app/page.tsxTypeScriptJavaScriptTypeScript// This pattern works:// You can pass a Server Component as a child or prop of a// Client Component.importClientComponentfrom'./client-component'importServerComponentfrom'./server-component'// Pages in Next.js are Server Components by defaultexportdefaultfunctionPage() {return(<ClientComponent><ServerComponent/></ClientComponent>)}With this approach,<ClientComponent>and<ServerComponent>are decoupled and can be rendered independently. In this case, the child<ServerComponent>can be rendered on the server, well before<ClientComponent>is rendered on the client.Good to know:The pattern of ""lifting content up"" has been used to avoid re-rendering a nested child component when a parent component re-renders.You're not limited to thechildrenprop. You can use any prop to pass JSX.PreviousClient ComponentsNextPartial PrerenderingWas this helpful?supported.Send"
partial prerendering,Partial Prerendering,"Building Your ApplicationRenderingPartial PrerenderingPartial PrerenderingNote:Partial Prerendering is anexperimentalfeature only available on canary and is subject to change. It is not ready for production use.Partial Prerendering (PPR) enables you to combine static and dynamic components together in the same route.During the build, Next.js prerenders as much of the route as possible. Ifdynamiccode is detected, like reading from the incoming request, you can wrap the relevant component with aReact Suspenseboundary. The Suspense boundary fallback will then be included in the prerendered HTML.🎥 Watch:Why PPR and how it works →YouTube (10 minutes).BackgroundPPR enables your Next.js server to immediately send prerendered content.To prevent client to server waterfalls, dynamic components begin streaming from the server in parallel while serving the initial prerender. This ensures dynamic components can begin rendering before client JavaScript has been loaded in the browser.To prevent creating many HTTP requests for each dynamic component, PPR is able to combine the static prerender and dynamic components together into a single HTTP request. This ensures there are not multiple network roundtrips needed for each dynamic component.Using Partial PrerenderingIncremental Adoption (Version 15 Canary Versions)In Next.js 15 canary versions, PPR is available as an experimental feature. It's not available in the stable versions yet. To install:npminstallnext@canaryYou can incrementally adopt Partial Prerendering inlayoutsandpagesby setting thepproption innext.config.jstoincremental, and exporting theexperimental_pprroute config optionat the top of the file:next.config.tsTypeScriptJavaScriptTypeScriptimporttype{ NextConfig }from'next'constnextConfig:NextConfig={experimental:{ppr:'incremental',},}exportdefaultnextConfigapp/page.tsxTypeScriptJavaScriptTypeScriptimport{ Suspense }from'react'import{ StaticComponent,DynamicComponent,Fallback }from'@/app/ui'exportconstexperimental_ppr=trueexportdefaultfunctionPage() {return(<><StaticComponent/><Suspensefallback={<Fallback/>}><DynamicComponent/></Suspense></>)}Good to know:Routes that don't haveexperimental_pprwill default tofalseand will not be prerendered using PPR. You need to explicitly opt-in to PPR for each route.experimental_pprwill apply to all children of the route segment, including nested layouts and pages. You don't have to add it to every file, only the top segment of a route.To disable PPR for children segments, you can setexperimental_pprtofalsein the child segment.Dynamic ComponentsWhen creating the prerender for your route duringnext build, Next.js requires that Dynamic APIs are wrapped with React Suspense. Thefallbackis then included in the prerender.For example, using functions likecookiesorheaders:app/user.tsxTypeScriptJavaScriptTypeScriptimport{ cookies }from'next/headers'exportasyncfunctionUser() {constsession=(awaitcookies()).get('session')?.valuereturn'...'}This component requires looking at the incoming request to read cookies. To use this with PPR, you should wrap the component with Suspense:app/page.tsxTypeScriptJavaScriptTypeScriptimport{ Suspense }from'react'import{ User,AvatarSkeleton }from'./user'exportconstexperimental_ppr=trueexportdefaultfunctionPage() {return(<section><h1>This will be prerendered</h1><Suspensefallback={<AvatarSkeleton/>}><User/></Suspense></section>)}Components only opt into dynamic rendering when the value is accessed.For example, if you are readingsearchParamsfrom apage, you can forward this value to another component as a prop:app/page.tsxTypeScriptJavaScriptTypeScriptimport{ Table }from'./table'exportdefaultfunctionPage({searchParams,}:{searchParams:Promise<{ sort:string}>}) {return(<section><h1>This will be prerendered</h1><TablesearchParams={searchParams} /></section>)}Inside of the table component, accessing the value fromsearchParamswill make the component run dynamically:app/table.tsxTypeScriptJavaScriptTypeScriptexportasyncfunctionTable({searchParams,}:{searchParams:Promise<{ sort:string}>}) {constsort=(awaitsearchParams).sort==='true'return'...'}PreviousComposition PatternsNextRuntimesWas this helpful?supported.Send"
runtimes,Runtimes,"Building Your ApplicationRenderingRuntimesRuntimesNext.js has two server runtimes you can use in your application:TheNode.js Runtime(default), which has access to all Node.js APIs and compatible packages from the ecosystem.TheEdge Runtimewhich contains a more limitedset of APIs.Use CasesThe Node.js Runtime is used for rendering your application.The Edge Runtime is used for Middleware (routing rules like redirects, rewrites, and setting headers).CaveatsThe Edge Runtime does not support all Node.js APIs. Some packages may not work as expected. Learn more about the unsupported APIs in theEdge Runtime.The Edge Runtime does not support Incremental Static Regeneration (ISR).Both runtimes can supportstreamingdepending on your deployment infrastructure.Next StepsView the Edge Runtime API reference.Edge RuntimeAPI Reference for the Edge Runtime.PreviousPartial PrerenderingNextCachingWas this helpful?supported.Send"
caching,Caching,"App RouterBuilding Your ApplicationCachingCaching in Next.jsNext.js improves your application's performance and reduces costs by caching rendering work and data requests. This page provides an in-depth look at Next.js caching mechanisms, the APIs you can use to configure them, and how they interact with each other.Good to know: This page helps you understand how Next.js works under the hood but isnotessential knowledge to be productive with Next.js. Most of Next.js' caching heuristics are determined by your API usage and have defaults for the best performance with zero or minimal configuration. If you instead want to jump to examples,start here.OverviewHere's a high-level overview of the different caching mechanisms and their purpose:MechanismWhatWherePurposeDurationRequest MemoizationReturn values of functionsServerRe-use data in a React Component treePer-request lifecycleData CacheDataServerStore data across user requests and deploymentsPersistent (can be revalidated)Full Route CacheHTML and RSC payloadServerReduce rendering cost and improve performancePersistent (can be revalidated)Router CacheRSC PayloadClientReduce server requests on navigationUser session or time-basedBy default, Next.js will cache as much as possible to improve performance and reduce cost. This means routes arestatically renderedand data requests arecachedunless you opt out. The diagram below shows the default caching behavior: when a route is statically rendered at build time and when a static route is first visited.Caching behavior changes depending on whether the route is statically or dynamically rendered, data is cached or uncached, and whether a request is part of an initial visit or a subsequent navigation. Depending on your use case, you can configure the caching behavior for individual routes and data requests.Request MemoizationNext.js extends thefetchAPIto automaticallymemoizerequests that have the same URL and options. This means you can call a fetch function for the same data in multiple places in a React component tree while only executing it once.For example, if you need to use the same data across a route (e.g. in a Layout, Page, and multiple components), you do not have to fetch data at the top of the tree, and forward props between components. Instead, you can fetch data in the components that need it without worrying about the performance implications of making multiple requests across the network for the same data.app/example.tsxTypeScriptJavaScriptTypeScriptasyncfunctiongetItem() {// The `fetch` function is automatically memoized and the result// is cachedconstres=awaitfetch('https://.../item/1')returnres.json()}// This function is called twice, but only executed the first timeconstitem=awaitgetItem()// cache MISS// The second call could be anywhere in your routeconstitem=awaitgetItem()// cache HITHow Request Memoization WorksWhile rendering a route, the first time a particular request is called, its result will not be in memory and it'll be a cacheMISS.Therefore, the function will be executed, and the data will be fetched from the external source, and the result will be stored in memory.Subsequent function calls of the request in the same render pass will be a cacheHIT, and the data will be returned from memory without executing the function.Once the route has been rendered and the rendering pass is complete, memory is ""reset"" and all request memoization entries are cleared.Good to know:Request memoization is a React feature, not a Next.js feature. It's included here to show how it interacts with the other caching mechanisms.Memoization only applies to theGETmethod infetchrequests.Memoization only applies to the React Component tree, this means:It applies tofetchrequests ingenerateMetadata,generateStaticParams, Layouts, Pages, and other Server Components.It doesn't apply tofetchrequests in Route Handlers as they are not a part of the React component tree.For cases wherefetchis not suitable (e.g. some database clients, CMS clients, or GraphQL clients), you can use theReactcachefunctionto memoize functions.DurationThe cache lasts the lifetime of a server request until the React component tree has finished rendering.RevalidatingSince the memoization is not shared across server requests and only applies during rendering, there is no need to revalidate it.Opting outMemoization only applies to theGETmethod infetchrequests, other methods, such asPOSTandDELETE, are not memoized. This default behavior is a React optimization and we do not recommend opting out of it.To manage individual requests, you can use thesignalproperty fromAbortController. However, this will not opt requests out of memoization, rather, abort in-flight requests.app/example.jsconst{signal}=newAbortController()fetch(url,{ signal })Data CacheNext.js has a built-in Data Cache thatpersiststhe result of data fetches across incomingserver requestsanddeployments. This is possible because Next.js extends the nativefetchAPI to allow each request on the server to set its own persistent caching semantics.Good to know: In the browser, thecacheoption offetchindicates how a request will interact with the browser's HTTP cache, in Next.js, thecacheoption indicates how a server-side request will interact with the server's Data Cache.You can use thecacheandnext.revalidateoptions offetchto configure the caching behavior.How the Data Cache WorksThe first time afetchrequest with the'force-cache'option is called during rendering, Next.js checks the Data Cache for a cached response.If a cached response is found, it's returned immediately andmemoized.If a cached response is not found, the request is made to the data source, the result is stored in the Data Cache, and memoized.For uncached data (e.g. nocacheoption defined or using{ cache: 'no-store' }), the result is always fetched from the data source, and memoized.Whether the data is cached or uncached, the requests are always memoized to avoid making duplicate requests for the same data during a React render pass.Differences between the Data Cache and Request MemoizationWhile both caching mechanisms help improve performance by re-using cached data, the Data Cache is persistent across incoming requests and deployments, whereas memoization only lasts the lifetime of a request.DurationThe Data Cache is persistent across incoming requests and deployments unless you revalidate or opt-out.RevalidatingCached data can be revalidated in two ways, with:Time-based Revalidation: Revalidate data after a certain amount of time has passed and a new request is made. This is useful for data that changes infrequently and freshness is not as critical.On-demand Revalidation:Revalidate data based on an event (e.g. form submission). On-demand revalidation can use a tag-based or path-based approach to revalidate groups of data at once. This is useful when you want to ensure the latest data is shown as soon as possible (e.g. when content from your headless CMS is updated).Time-based RevalidationTo revalidate data at a timed interval, you can use thenext.revalidateoption offetchto set the cache lifetime of a resource (in seconds).// Revalidate at most every hourfetch('https://...',{ next:{ revalidate:3600} })Alternatively, you can useRoute Segment Config optionsto configure allfetchrequests in a segment or for cases where you're not able to usefetch.How Time-based Revalidation WorksThe first time a fetch request withrevalidateis called, the data will be fetched from the external data source and stored in the Data Cache.Any requests that are called within the specified timeframe (e.g. 60-seconds) will return the cached data.After the timeframe, the next request will still return the cached (now stale) data.Next.js will trigger a revalidation of the data in the background.Once the data is fetched successfully, Next.js will update the Data Cache with the fresh data.If the background revalidation fails, the previous data will be kept unaltered.This is similar tostale-while-revalidatebehavior.On-demand RevalidationData can be revalidated on-demand by path (revalidatePath) or by cache tag (revalidateTag).How On-Demand Revalidation WorksThe first time afetchrequest is called, the data will be fetched from the external data source and stored in the Data Cache.When an on-demand revalidation is triggered, the appropriate cache entries will be purged from the cache.This is different from time-based revalidation, which keeps the stale data in the cache until the fresh data is fetched.The next time a request is made, it will be a cacheMISSagain, and the data will be fetched from the external data source and stored in the Data Cache.Opting outIf you donotwant to cache the response fromfetch, you can do the following:letdata=awaitfetch('https://api.vercel.app/blog',{ cache:'no-store'})Full Route CacheRelated terms:You may see the termsAutomatic Static Optimization,Static Site Generation, orStatic Renderingbeing used interchangeably to refer to the process of rendering and caching routes of your application at build time.Next.js automatically renders and caches routes at build time. This is an optimization that allows you to serve the cached route instead of rendering on the server for every request, resulting in faster page loads.To understand how the Full Route Cache works, it's helpful to look at how React handles rendering, and how Next.js caches the result:1. React Rendering on the ServerOn the server, Next.js uses React's APIs to orchestrate rendering. The rendering work is split into chunks: by individual routes segments and Suspense boundaries.Each chunk is rendered in two steps:React renders Server Components into a special data format, optimized for streaming, called theReact Server Component Payload.Next.js uses the React Server Component Payload and Client Component JavaScript instructions to renderHTMLon the server.This means we don't have to wait for everything to render before caching the work or sending a response. Instead, we can stream a response as work is completed.What is the React Server Component Payload?The React Server Component Payload is a compact binary representation of the rendered React Server Components tree. It's used by React on the client to update the browser's DOM. The React Server Component Payload contains:The rendered result of Server ComponentsPlaceholders for where Client Components should be rendered and references to their JavaScript filesAny props passed from a Server Component to a Client ComponentTo learn more, see theServer Componentsdocumentation.2. Next.js Caching on the Server (Full Route Cache)The default behavior of Next.js is to cache the rendered result (React Server Component Payload and HTML) of a route on the server. This applies to statically rendered routes at build time, or during revalidation.3. React Hydration and Reconciliation on the ClientAt request time, on the client:The HTML is used to immediately show a fast non-interactive initial preview of the Client and Server Components.The React Server Components Payload is used to reconcile the Client and rendered Server Component trees, and update the DOM.The JavaScript instructions are used tohydrateClient Components and make the application interactive.4. Next.js Caching on the Client (Router Cache)The React Server Component Payload is stored in the client-sideRouter Cache- a separate in-memory cache, split by individual route segment. This Router Cache is used to improve the navigation experience by storing previously visited routes and prefetching future routes.5. Subsequent NavigationsOn subsequent navigations or during prefetching, Next.js will check if the React Server Components Payload is stored in the Router Cache. If so, it will skip sending a new request to the server.If the route segments are not in the cache, Next.js will fetch the React Server Components Payload from the server, and populate the Router Cache on the client.Static and Dynamic RenderingWhether a route is cached or not at build time depends on whether it's statically or dynamically rendered. Static routes are cached by default, whereas dynamic routes are rendered at request time, and not cached.This diagram shows the difference between statically and dynamically rendered routes, with cached and uncached data:Learn more aboutstatic and dynamic rendering.DurationBy default, the Full Route Cache is persistent. This means that the render output is cached across user requests.InvalidationThere are two ways you can invalidate the Full Route Cache:Revalidating Data: Revalidating theData Cache, will in turn invalidate the Router Cache by re-rendering components on the server and caching the new render output.Redeploying: Unlike the Data Cache, which persists across deployments, the Full Route Cache is cleared on new deployments.Opting outYou can opt out of the Full Route Cache, or in other words, dynamically render components for every incoming request, by:Using aDynamic API: This will opt the route out from the Full Route Cache and dynamically render it at request time. The Data Cache can still be used.Using thedynamic = 'force-dynamic'orrevalidate = 0route segment config options: This will skip the Full Route Cache and the Data Cache. Meaning components will be rendered and data fetched on every incoming request to the server. The Router Cache will still apply as it's a client-side cache.Opting out of theData Cache: If a route has afetchrequest that is not cached, this will opt the route out of the Full Route Cache. The data for the specificfetchrequest will be fetched for every incoming request. Otherfetchrequests that do not opt out of caching will still be cached in the Data Cache. This allows for a hybrid of cached and uncached data.Client-side Router CacheNext.js has an in-memory client-side router cache that stores the RSC payload of route segments, split by layouts, loading states, and pages.When a user navigates between routes, Next.js caches the visited route segments andprefetchesthe routes the user is likely to navigate to. This results in instant back/forward navigation, no full-page reload between navigations, and preservation of React state and browser state.With the Router Cache:Layoutsare cached and reused on navigation (partial rendering).Loading statesare cached and reused on navigation forinstant navigation.Pagesare not cached by default, but are reused during browser backward and forward navigation. You can enable caching for page segments by using the experimentalstaleTimesconfig option.Good to know:This cache specifically applies to Next.js and Server Components, and is different to the browser'sbfcache, though it has a similar result.DurationThe cache is stored in the browser's temporary memory. Two factors determine how long the router cache lasts:Session: The cache persists across navigation. However, it's cleared on page refresh.Automatic Invalidation Period: The cache of layouts and loading states is automatically invalidated after a specific time. The duration depends on how the resource wasprefetched, and if the resource wasstatically generated:Default Prefetching(prefetch={null}or unspecified): not cached for dynamic pages, 5 minutes for static pages.Full Prefetching(prefetch={true}orrouter.prefetch): 5 minutes for both static & dynamic pages.While a page refresh will clearallcached segments, the automatic invalidation period only affects the individual segment from the time it was prefetched.Good to know: The experimentalstaleTimesconfig option can be used to adjust the automatic invalidation times mentioned above.InvalidationThere are two ways you can invalidate the Router Cache:In aServer Action:Revalidating data on-demand by path with (revalidatePath) or by cache tag with (revalidateTag)Usingcookies.setorcookies.deleteinvalidates the Router Cache to prevent routes that use cookies from becoming stale (e.g. authentication).Callingrouter.refreshwill invalidate the Router Cache and make a new request to the server for the current route.Opting outAs of Next.js 15, page segments are opted out by default.Good to know:You can also opt out ofprefetchingby setting theprefetchprop of the<Link>component tofalse.Cache InteractionsWhen configuring the different caching mechanisms, it's important to understand how they interact with each other:Data Cache and Full Route CacheRevalidating or opting out of the Data Cachewillinvalidate the Full Route Cache, as the render output depends on data.Invalidating or opting out of the Full Route Cachedoes notaffect the Data Cache. You can dynamically render a route that has both cached and uncached data. This is useful when most of your page uses cached data, but you have a few components that rely on data that needs to be fetched at request time. You can dynamically render without worrying about the performance impact of re-fetching all the data.Data Cache and Client-side Router cacheTo immediately invalidate the Data Cache and Router cache, you can userevalidatePathorrevalidateTagin aServer Action.Revalidating the Data Cache in aRoute Handlerwill notimmediately invalidate the Router Cache as the Route Handler isn't tied to a specific route. This means Router Cache will continue to serve the previous payload until a hard refresh, or the automatic invalidation period has elapsed.APIsThe following table provides an overview of how different Next.js APIs affect caching:APIRouter CacheFull Route CacheData CacheReact Cache<Link prefetch>Cacherouter.prefetchCacherouter.refreshRevalidatefetchCacheCachefetchoptions.cacheCache or Opt outfetchoptions.next.revalidateRevalidateRevalidatefetchoptions.next.tagsCacheCacherevalidateTagRevalidate (Server Action)RevalidateRevalidaterevalidatePathRevalidate (Server Action)RevalidateRevalidateconst revalidateRevalidate or Opt outRevalidate or Opt outconst dynamicCache or Opt outCache or Opt outcookiesRevalidate (Server Action)Opt outheaders,searchParamsOpt outgenerateStaticParamsCacheReact.cacheCacheunstable_cacheCache<Link>By default, the<Link>component automatically prefetches routes from the Full Route Cache and adds the React Server Component Payload to the Router Cache.To disable prefetching, you can set theprefetchprop tofalse. But this will not skip the cache permanently, the route segment will still be cached client-side when the user visits the route.Learn more about the<Link>component.router.prefetchTheprefetchoption of theuseRouterhook can be used to manually prefetch a route. This adds the React Server Component Payload to the Router Cache.See theuseRouterhookAPI reference.router.refreshTherefreshoption of theuseRouterhook can be used to manually refresh a route. This completely clears the Router Cache, and makes a new request to the server for the current route.refreshdoes not affect the Data or Full Route Cache.The rendered result will be reconciled on the client while preserving React state and browser state.See theuseRouterhookAPI reference.fetchData returned fromfetchisnotautomatically cached in the Data Cache.The default caching behavior offetch(e.g., when thecacheoption is not specified) is equal to setting thecacheoption tono-store:letdata=awaitfetch('https://api.vercel.app/blog',{ cache:'no-store'})See thefetchAPI Referencefor more options.fetch options.cacheYou can opt individualfetchinto caching by setting thecacheoption toforce-cache:// Opt into cachingfetch(`https://...`,{ cache:'force-cache'})See thefetchAPI Referencefor more options.fetch options.next.revalidateYou can use thenext.revalidateoption offetchto set the revalidation period (in seconds) of an individualfetchrequest. This will revalidate the Data Cache, which in turn will revalidate the Full Route Cache. Fresh data will be fetched, and components will be re-rendered on the server.// Revalidate at most after 1 hourfetch(`https://...`,{ next:{ revalidate:3600} })See thefetchAPI referencefor more options.fetch options.next.tagsandrevalidateTagNext.js has a cache tagging system for fine-grained data caching and revalidation.When usingfetchorunstable_cache, you have the option to tag cache entries with one or more tags.Then, you can callrevalidateTagto purge the cache entries associated with that tag.For example, you can set a tag when fetching data:// Cache data with a tagfetch(`https://...`,{ next:{ tags:['a','b','c'] } })Then, callrevalidateTagwith a tag to purge the cache entry:// Revalidate entries with a specific tagrevalidateTag('a')There are two places you can userevalidateTag, depending on what you're trying to achieve:Route Handlers- to revalidate data in response of a third party event (e.g. webhook). This will not invalidate the Router Cache immediately as the Router Handler isn't tied to a specific route.Server Actions- to revalidate data after a user action (e.g. form submission). This will invalidate the Router Cache for the associated route.revalidatePathrevalidatePathallows you manually revalidate dataandre-render the route segments below a specific path in a single operation. Calling therevalidatePathmethod revalidates the Data Cache, which in turn invalidates the Full Route Cache.revalidatePath('/')There are two places you can userevalidatePath, depending on what you're trying to achieve:Route Handlers- to revalidate data in response to a third party event (e.g. webhook).Server Actions- to revalidate data after a user interaction (e.g. form submission, clicking a button).See therevalidatePathAPI referencefor more information.revalidatePathvs.router.refresh:Callingrouter.refreshwill clear the Router cache, and re-render route segments on the server without invalidating the Data Cache or the Full Route Cache.The difference is thatrevalidatePathpurges the Data Cache and Full Route Cache, whereasrouter.refresh()does not change the Data Cache and Full Route Cache, as it is a client-side API.Dynamic APIsDynamic APIs likecookiesandheaders, and thesearchParamsprop in Pages depend on runtime incoming request information. Using them will opt a route out of the Full Route Cache, in other words, the route will be dynamically rendered.cookiesUsingcookies.setorcookies.deletein a Server Action invalidates the Router Cache to prevent routes that use cookies from becoming stale (e.g. to reflect authentication changes).See thecookiesAPI reference.Segment Config OptionsThe Route Segment Config options can be used to override the route segment defaults or when you're not able to use thefetchAPI (e.g. database client or 3rd party libraries).The following Route Segment Config options will opt out of the Full Route Cache:const dynamic = 'force-dynamic'This config option will opt all fetches out of the Data Cache (i.e.no-store):const fetchCache = 'default-no-store'See thefetchCacheto see more advanced options.See theRoute Segment Configdocumentation for more options.generateStaticParamsFordynamic segments(e.g.app/blog/[slug]/page.js), paths provided bygenerateStaticParamsare cached in the Full Route Cache at build time. At request time, Next.js will also cache paths that weren't known at build time the first time they're visited.To statically render all paths at build time, supply the full list of paths togenerateStaticParams:app/blog/[slug]/page.jsexportasyncfunctiongenerateStaticParams() {constposts=awaitfetch('https://.../posts').then((res)=>res.json())returnposts.map((post)=>({slug:post.slug,}))}To statically render a subset of paths at build time, and the rest the first time they're visited at runtime, return a partial list of paths:app/blog/[slug]/page.jsexportasyncfunctiongenerateStaticParams() {constposts=awaitfetch('https://.../posts').then((res)=>res.json())// Render the first 10 posts at build timereturnposts.slice(0,10).map((post)=>({slug:post.slug,}))}To statically render all paths the first time they're visited, return an empty array (no paths will be rendered at build time) or utilizeexport const dynamic = 'force-static':app/blog/[slug]/page.jsexportasyncfunctiongenerateStaticParams() {return[]}Good to know:You must return an array fromgenerateStaticParams, even if it's empty. Otherwise, the route will be dynamically rendered.app/changelog/[slug]/page.jsexportconstdynamic='force-static'To disable caching at request time, add theexport const dynamicParams = falseoption in a route segment. When this config option is used, only paths provided bygenerateStaticParamswill be served, and other routes will 404 or match (in the case ofcatch-all routes).ReactcachefunctionThe Reactcachefunction allows you to memoize the return value of a function, allowing you to call the same function multiple times while only executing it once.Sincefetchrequests are automatically memoized, you do not need to wrap it in Reactcache. However, you can usecacheto manually memoize data requests for use cases when thefetchAPI is not suitable. For example, some database clients, CMS clients, or GraphQL clients.utils/get-item.tsTypeScriptJavaScriptTypeScriptimport{ cache }from'react'importdbfrom'@/lib/db'exportconstgetItem=cache(async(id:string)=>{constitem=awaitdb.item.findUnique({ id })returnitem})PreviousRuntimesNextStylingWas this helpful?supported.Send"
styling,Styling,"App RouterBuilding Your ApplicationStylingStylingNext.js supports different ways of styling your application, including:CSS Modules: Create locally scoped CSS classes to avoid naming conflicts and improve maintainability.Global CSS: Simple to use and familiar for those experienced with traditional CSS, but can lead to larger CSS bundles and difficulty managing styles as the application grows.Tailwind CSS: A utility-first CSS framework that allows for rapid custom designs by composing utility classes.Sass: A popular CSS preprocessor that extends CSS with features like variables, nested rules, and mixins.CSS-in-JS: Embed CSS directly in your JavaScript components, enabling dynamic and scoped styling.Learn more about each approach by exploring their respective documentation:CSSStyle your Next.js Application with CSS Modules, Global Styles, and external stylesheets.Tailwind CSSStyle your Next.js Application using Tailwind CSS.SassStyle your Next.js application using Sass.CSS-in-JSUse CSS-in-JS libraries with Next.jsPreviousCachingNextCSSWas this helpful?supported.Send"
css,CSS,"App RouterBuilding Your ApplicationStylingStylingNext.js supports different ways of styling your application, including:CSS Modules: Create locally scoped CSS classes to avoid naming conflicts and improve maintainability.Global CSS: Simple to use and familiar for those experienced with traditional CSS, but can lead to larger CSS bundles and difficulty managing styles as the application grows.Tailwind CSS: A utility-first CSS framework that allows for rapid custom designs by composing utility classes.Sass: A popular CSS preprocessor that extends CSS with features like variables, nested rules, and mixins.CSS-in-JS: Embed CSS directly in your JavaScript components, enabling dynamic and scoped styling.Learn more about each approach by exploring their respective documentation:CSSStyle your Next.js Application with CSS Modules, Global Styles, and external stylesheets.Tailwind CSSStyle your Next.js Application using Tailwind CSS.SassStyle your Next.js application using Sass.CSS-in-JSUse CSS-in-JS libraries with Next.jsPreviousCachingNextCSSWas this helpful?supported.Send"
tailwind css,Tailwind CSS,"Building Your ApplicationStylingTailwind CSSTailwind CSSTailwind CSSis a utility-first CSS framework that works exceptionally well with Next.js.Installing TailwindInstall the Tailwind CSS packages and run theinitcommand to generate both thetailwind.config.jsandpostcss.config.jsfiles:Terminalnpminstall-Dtailwindcsspostcssautoprefixernpxtailwindcssinit-pConfiguring TailwindInside your Tailwind configuration file, add paths to the files that will use Tailwind class names:tailwind.config.tsTypeScriptJavaScriptTypeScriptimporttype{ Config }from'tailwindcss'exportdefault{content:['./app/**/*.{js,ts,jsx,tsx,mdx}',// Note the addition of the `app` directory.'./pages/**/*.{js,ts,jsx,tsx,mdx}','./components/**/*.{js,ts,jsx,tsx,mdx}',// Or if using `src` directory:'./src/**/*.{js,ts,jsx,tsx,mdx}',],theme:{extend:{},},plugins:[],}satisfiesConfigYou do not need to modifypostcss.config.js.Importing StylesAdd theTailwind CSS directivesthat Tailwind will use to inject its generated styles to aGlobal Stylesheetin your application, for example:app/globals.css@tailwindbase;@tailwindcomponents;@tailwindutilities;Inside theroot layout(app/layout.tsx), import theglobals.cssstylesheet to apply the styles to every route in your application.app/layout.tsxTypeScriptJavaScriptTypeScriptimporttype{ Metadata }from'next'// These styles apply to every route in the applicationimport'./globals.css'exportconstmetadata:Metadata={title:'Create Next App',description:'Generated by create next app',}exportdefaultfunctionRootLayout({children,}:{children:React.ReactNode}) {return(<htmllang=""en""><body>{children}</body></html>)}Using ClassesAfter installing Tailwind CSS and adding the global styles, you can use Tailwind's utility classes in your application.app/page.tsxTypeScriptJavaScriptTypeScriptexportdefaultfunctionPage() {return<h1className=""text-3xl font-bold underline"">Hello, Next.js!</h1>}Usage with TurbopackAs of Next.js 13.1, Tailwind CSS and PostCSS are supported withTurbopack.PreviousCSSNextSassWas this helpful?supported.Send"
sass,Sass,"Building Your ApplicationStylingSassSassNext.js has built-in support for integrating with Sass after the package is installed using both the.scssand.sassextensions. You can use component-level Sass via CSS Modules and the.module.scssor.module.sassextension.First, installsass:Terminalnpminstall--save-devsassGood to know:Sass supportstwo different syntaxes, each with their own extension.
The.scssextension requires you use theSCSS syntax,
while the.sassextension requires you use theIndented Syntax (""Sass"").If you're not sure which to choose, start with the.scssextension which is a superset of CSS, and doesn't require you learn the
Indented Syntax (""Sass"").Customizing Sass OptionsIf you want to configure your Sass options, usesassOptionsinnext.config.next.config.tsTypeScriptJavaScriptTypeScriptimporttype{ NextConfig }from'next'constnextConfig:NextConfig={sassOptions:{additionalData:`$var: red;`,},}exportdefaultnextConfigImplementationYou can use theimplementationproperty to specify the Sass implementation to use. By default, Next.js uses thesasspackage.next.config.tsTypeScriptJavaScriptTypeScriptimporttype{ NextConfig }from'next'constnextConfig:NextConfig={sassOptions:{implementation:'sass-embedded',},}exportdefaultnextConfigSass VariablesNext.js supports Sass variables exported from CSS Module files.For example, using the exportedprimaryColorSass variable:app/variables.module.scss$primary-color:#64ff00;:export {primaryColor:$primary-color;}app/page.js// maps to root `/` URLimportvariablesfrom'./variables.module.scss'exportdefaultfunctionPage() {return<h1style={{ color:variables.primaryColor }}>Hello, Next.js!</h1>}PreviousTailwind CSSNextCSS-in-JSWas this helpful?supported.Send"
css-in-js,CSS-in-JS,"Building Your ApplicationStylingCSS-in-JSCSS-in-JSWarning:Using CSS-in-JS with newer React features like Server Components and Streaming requires library authors to support the latest version of React, includingconcurrent rendering.The following libraries are supported in Client Components in theappdirectory (alphabetical):ant-designchakra-ui@fluentui/react-componentskuma-ui@mui/material@mui/joypandacssstyled-jsxstyled-componentsstylextamaguitss-reactvanilla-extractThe following are currently working on support:emotionGood to know: We're testing out different CSS-in-JS libraries and we'll be adding more examples for libraries that support React 18 features and/or theappdirectory.If you want to style Server Components, we recommend usingCSS Modulesor other solutions that output CSS files, like PostCSS orTailwind CSS.Configuring CSS-in-JS inappConfiguring CSS-in-JS is a three-step opt-in process that involves:Astyle registryto collect all CSS rules in a render.The newuseServerInsertedHTMLhook to inject rules before any content that might use them.A Client Component that wraps your app with the style registry during initial server-side rendering.styled-jsxUsingstyled-jsxin Client Components requires usingv5.1.0. First, create a new registry:app/registry.tsxTypeScriptJavaScriptTypeScript'use client'importReact,{ useState }from'react'import{ useServerInsertedHTML }from'next/navigation'import{ StyleRegistry,createStyleRegistry }from'styled-jsx'exportdefaultfunctionStyledJsxRegistry({children,}:{children:React.ReactNode}) {// Only create stylesheet once with lazy initial state// x-ref: https://reactjs.org/docs/hooks-reference.html#lazy-initial-stateconst[jsxStyleRegistry]=useState(()=>createStyleRegistry())useServerInsertedHTML(()=>{conststyles=jsxStyleRegistry.styles()jsxStyleRegistry.flush()return<>{styles}</>})return<StyleRegistryregistry={jsxStyleRegistry}>{children}</StyleRegistry>}Then, wrap yourroot layoutwith the registry:app/layout.tsxTypeScriptJavaScriptTypeScriptimportStyledJsxRegistryfrom'./registry'exportdefaultfunctionRootLayout({children,}:{children:React.ReactNode}) {return(<html><body><StyledJsxRegistry>{children}</StyledJsxRegistry></body></html>)}View an example here.Styled ComponentsBelow is an example of how to configurestyled-components@6or newer:First, enable styled-components innext.config.js.next.config.jsmodule.exports={compiler:{styledComponents:true,},}Then, use thestyled-componentsAPI to create a global registry component to collect all CSS style rules generated during a render, and a function to return those rules. Then use theuseServerInsertedHTMLhook to inject the styles collected in the registry into the<head>HTML tag in the root layout.lib/registry.tsxTypeScriptJavaScriptTypeScript'use client'importReact,{ useState }from'react'import{ useServerInsertedHTML }from'next/navigation'import{ ServerStyleSheet,StyleSheetManager }from'styled-components'exportdefaultfunctionStyledComponentsRegistry({children,}:{children:React.ReactNode}) {// Only create stylesheet once with lazy initial state// x-ref: https://reactjs.org/docs/hooks-reference.html#lazy-initial-stateconst[styledComponentsStyleSheet]=useState(()=>newServerStyleSheet())useServerInsertedHTML(()=>{conststyles=styledComponentsStyleSheet.getStyleElement()styledComponentsStyleSheet.instance.clearTag()return<>{styles}</>})if(typeofwindow!=='undefined')return<>{children}</>return(<StyleSheetManagersheet={styledComponentsStyleSheet.instance}>{children}</StyleSheetManager>)}Wrap thechildrenof the root layout with the style registry component:app/layout.tsxTypeScriptJavaScriptTypeScriptimportStyledComponentsRegistryfrom'./lib/registry'exportdefaultfunctionRootLayout({children,}:{children:React.ReactNode}) {return(<html><body><StyledComponentsRegistry>{children}</StyledComponentsRegistry></body></html>)}View an example here.Good to know:During server rendering, styles will be extracted to a global registry and flushed to the<head>of your HTML. This ensures the style rules are placed before any content that might use them. In the future, we may use an upcoming React feature to determine where to inject the styles.During streaming, styles from each chunk will be collected and appended to existing styles. After client-side hydration is complete,styled-componentswill take over as usual and inject any further dynamic styles.We specifically use a Client Component at the top level of the tree for the style registry because it's more efficient to extract CSS rules this way. It avoids re-generating styles on subsequent server renders, and prevents them from being sent in the Server Component payload.For advanced use cases where you need to configure individual properties of styled-components compilation, you can read ourNext.js styled-components API referenceto learn more.PreviousSassNextOptimizingWas this helpful?supported.Send"
optimizing,Optimizing,"App RouterBuilding Your ApplicationOptimizingOptimizationsNext.js comes with a variety of built-in optimizations designed to improve your application's speed andCore Web Vitals. This guide will cover the optimizations you can leverage to enhance your user experience.Built-in ComponentsBuilt-in components abstract away the complexity of implementing common UI optimizations. These components are:Images: Built on the native<img>element. The Image Component optimizes images for performance by lazy loading and automatically resizing images based on device size.Link: Built on the native<a>tags. The Link Component prefetches pages in the background, for faster and smoother page transitions.Scripts: Built on the native<script>tags. The Script Component gives you control over loading and execution of third-party scripts.MetadataMetadata helps search engines understand your content better (which can result in better SEO), and allows you to customize how your content is presented on social media, helping you create a more engaging and consistent user experience across various platforms.The Metadata API in Next.js allows you to modify the<head>element of a page. You can configure metadata in two ways:Config-based Metadata: Export astaticmetadataobjector a dynamicgenerateMetadatafunctionin alayout.jsorpage.jsfile.File-based Metadata: Add static or dynamically generated special files to route segments.Additionally, you can create dynamic Open Graph Images using JSX and CSS withimageResponseconstructor.Static AssetsNext.js/publicfolder can be used to serve static assets like images, fonts, and other files. Files inside/publiccan also be cached by CDN providers so that they are delivered efficiently.Analytics and MonitoringFor large applications, Next.js integrates with popular analytics and monitoring tools to help you understand how your application is performing. Learn more in theOpenTelemetryandInstrumentationguides.ImagesOptimize your images with the built-in `next/image` component.VideosRecommendations and best practices for optimizing videos in your Next.js application.FontsOptimize your application's web fonts with the built-in `next/font` loaders.MetadataUse the Metadata API to define metadata in any layout or page.ScriptsOptimize 3rd party scripts with the built-in Script component.Package BundlingLearn how to optimize your application's server and client bundles.Lazy LoadingLazy load imported libraries and React Components to improve your application's loading performance.AnalyticsMeasure and track page performance using Next.js Speed InsightsInstrumentationLearn how to use instrumentation to run code at server startup in your Next.js appOpenTelemetryLearn how to instrument your Next.js app with OpenTelemetry.Static AssetsNext.js allows you to serve static files, like images, in the public directory. You can learn how it works here.Third Party LibrariesOptimize the performance of third-party libraries in your application with the `@next/third-parties` package.Memory UsageOptimize memory used by your application in development and production.PreviousCSS-in-JSNextImagesWas this helpful?supported.Send"
images,Images,"Building Your ApplicationOptimizingImagesImage OptimizationExamplesImage ComponentAccording toWeb Almanac, images account for a huge portion of the typical website’spage weightand can have a sizable impact on your website'sLCP performance.The Next.js Image component extends the HTML<img>element with features for automatic image optimization:Size Optimization:Automatically serve correctly sized images for each device, using modern image formats like WebP.Visual Stability:Preventlayout shiftautomatically when images are loading.Faster Page Loads:Images are only loaded when they enter the viewport using native browser lazy loading, with optional blur-up placeholders.Asset Flexibility:On-demand image resizing, even for images stored on remote servers🎥 Watch:Learn more about how to usenext/image→YouTube (9 minutes).UsageimportImagefrom'next/image'You can then define thesrcfor your image (either local or remote).Local ImagesTo use a local image,importyour.jpg,.png, or.webpimage files.Next.js willautomatically determinethe intrinsicwidthandheightof your image based on the imported file. These values are used to determine the image ratio and preventCumulative Layout Shiftwhile your image is loading.app/page.jsimportImagefrom'next/image'importprofilePicfrom'./me.png'exportdefaultfunctionPage() {return(<Imagesrc={profilePic}alt=""Picture of the author""// width={500} automatically provided// height={500} automatically provided// blurDataURL=""data:..."" automatically provided// placeholder=""blur"" // Optional blur-up while loading/>)}Warning:Dynamicawait import()orrequire()arenotsupported. Theimportmust be static so it can be analyzed at build time.You can optionally configurelocalPatternsin yournext.config.jsfile in order to allow specific images and block all others.next.config.jsmodule.exports={images:{localPatterns:[{pathname:'/assets/images/**',search:'',},],},}Remote ImagesTo use a remote image, thesrcproperty should be a URL string.Since Next.js does not have access to remote files during the build process, you'll need to provide thewidth,heightand optionalblurDataURLprops manually.Thewidthandheightattributes are used to infer the correct aspect ratio of image and avoid layout shift from the image loading in. Thewidthandheightdonotdetermine the rendered size of the image file. Learn more aboutImage Sizing.app/page.jsimportImagefrom'next/image'exportdefaultfunctionPage() {return(<Imagesrc=""https://s3.amazonaws.com/my-bucket/profile.png""alt=""Picture of the author""width={500}height={500}/>)}To safely allow optimizing images, define a list of supported URL patterns innext.config.js. Be as specific as possible to prevent malicious usage. For example, the following configuration will only allow images from a specific AWS S3 bucket:next.config.jsmodule.exports={images:{remotePatterns:[{protocol:'https',hostname:'s3.amazonaws.com',port:'',pathname:'/my-bucket/**',search:'',},],},}Learn more aboutremotePatternsconfiguration. If you want to use relative URLs for the imagesrc, use aloader.DomainsSometimes you may want to optimize a remote image, but still use the built-in Next.js Image Optimization API. To do this, leave theloaderat its default setting and enter an absolute URL for the Imagesrcprop.To protect your application from malicious users, you must define a list of remote hostnames you intend to use with thenext/imagecomponent.Learn more aboutremotePatternsconfiguration.LoadersNote that in theexample earlier, a partial URL (""/me.png"") is provided for a local image. This is possible because of the loader architecture.A loader is a function that generates the URLs for your image. It modifies the providedsrc, and generates multiple URLs to request the image at different sizes. These multiple URLs are used in the automaticsrcsetgeneration, so that visitors to your site will be served an image that is the right size for their viewport.The default loader for Next.js applications uses the built-in Image Optimization API, which optimizes images from anywhere on the web, and then serves them directly from the Next.js web server. If you would like to serve your images directly from a CDN or image server, you can write your own loader function with a few lines of JavaScript.You can define a loader per-image with theloaderprop, or at the application level with theloaderFileconfiguration.PriorityYou should add thepriorityproperty to the image that will be theLargest Contentful Paint (LCP) elementfor each page. Doing so allows Next.js topreloadthe image, leading to a meaningful boost in LCP.The LCP element is typically the largest image or text block visible within the viewport of the page. When you runnext dev, you'll see a console warning if the LCP element is an<Image>without thepriorityproperty.Once you've identified the LCP image, you can add the property like this:app/page.jsimportImagefrom'next/image'importprofilePicfrom'../public/me.png'exportdefaultfunctionPage() {return<Imagesrc={profilePic}alt=""Picture of the author""priority/>}See more about priority in thenext/imagecomponent documentation.Image SizingOne of the ways that images most commonly hurt performance is throughlayout shift, where the image pushes other elements around on the page as it loads in. This performance problem is so annoying to users that it has its own Core Web Vital, calledCumulative Layout Shift. The way to avoid image-based layout shifts is toalways size your images. This allows the browser to reserve precisely enough space for the image before it loads.Becausenext/imageis designed to guarantee good performance results, it cannot be used in a way that will contribute to layout shift, andmustbe sized in one of three ways:Automatically, using astatic importManually, by including awidthandheightproperty used to determine the image's aspect ratio.Implicitly, by usingfillwhich causes the image to expand to fill its parent element.What if I don't know the size of my images?If you are accessing images from a source without knowledge of the images' sizes, there are several things you can do:UsefillThefillprop allows your image to be sized by its parent element. Consider using CSS to give the image's parent element space on the page alongsizesprop to match any media query break points. You can also useobject-fitwithfill,contain, orcover, andobject-positionto define how the image should occupy that space.Normalize your imagesIf you're serving images from a source that you control, consider modifying your image pipeline to normalize the images to a specific size.Modify your API callsIf your application is retrieving image URLs using an API call (such as to a CMS), you may be able to modify the API call to return the image dimensions along with the URL.If none of the suggested methods works for sizing your images, thenext/imagecomponent is designed to work well on a page alongside standard<img>elements.StylingStyling the Image component is similar to styling a normal<img>element, but there are a few guidelines to keep in mind:UseclassNameorstyle, notstyled-jsx.In most cases, we recommend using theclassNameprop. This can be an importedCSS Module, aglobal stylesheet, etc.You can also use thestyleprop to assign inline styles.You cannot usestyled-jsxbecause it's scoped to the current component (unless you mark the style asglobal).When usingfill, the parent element must haveposition: relativeThis is necessary for the proper rendering of the image element in that layout mode.When usingfill, the parent element must havedisplay: blockThis is the default for<div>elements but should be specified otherwise.ExamplesResponsiveimportImagefrom'next/image'importmountainsfrom'../public/mountains.jpg'exportdefaultfunctionResponsive() {return(<divstyle={{ display:'flex',flexDirection:'column'}}><Imagealt=""Mountains""// Importing an image will// automatically set the width and heightsrc={mountains}sizes=""100vw""// Make the image display full widthstyle={{width:'100%',height:'auto',}}/></div>)}Fill ContainerimportImagefrom'next/image'importmountainsfrom'../public/mountains.jpg'exportdefaultfunctionFill() {return(<divstyle={{display:'grid',gridGap:'8px',gridTemplateColumns:'repeat(auto-fit, minmax(400px, auto))',}}><divstyle={{ position:'relative',height:'400px'}}><Imagealt=""Mountains""src={mountains}fillsizes=""(min-width: 808px) 50vw, 100vw""style={{objectFit:'cover',// cover, contain, none}}/></div>{/* And more images in the grid... */}</div>)}Background ImageimportImagefrom'next/image'importmountainsfrom'../public/mountains.jpg'exportdefaultfunctionBackground() {return(<Imagealt=""Mountains""src={mountains}placeholder=""blur""quality={100}fillsizes=""100vw""style={{objectFit:'cover',}}/>)}For examples of the Image component used with the various styles, see theImage Component Demo.Other PropertiesView all properties available to thenext/imagecomponent.ConfigurationThenext/imagecomponent and Next.js Image Optimization API can be configured in thenext.config.jsfile. These configurations allow you toenable remote images,define custom image breakpoints,change caching behaviorand more.Read the full image configuration documentation for more information.API ReferenceLearn more about the next/image API.ImageOptimize Images in your Next.js Application using the built-in `next/image` Component.PreviousOptimizingNextVideosWas this helpful?supported.Send"
videos,Videos,"Building Your ApplicationOptimizingVideosVideo OptimizationThis page outlines how to use videos with Next.js applications, showing how to store and display video files without affecting performance.Using<video>and<iframe>Videos can be embedded on the page using the HTML<video>tag for direct video files and<iframe>for external platform-hosted videos.<video>The HTML<video>tag can embed self-hosted or directly served video content, allowing full control over the playback and appearance.app/ui/video.jsxexportfunctionVideo() {return(<videowidth=""320""height=""240""controlspreload=""none""><sourcesrc=""/path/to/video.mp4""type=""video/mp4""/><tracksrc=""/path/to/captions.vtt""kind=""subtitles""srcLang=""en""label=""English""/>Your browser does not support the video tag.</video>)}Common<video>tag attributesAttributeDescriptionExample ValuesrcSpecifies the source of the video file.<video src=""/path/to/video.mp4"" />widthSets the width of the video player.<video width=""320"" />heightSets the height of the video player.<video height=""240"" />controlsIf present, it displays the default set of playback controls.<video controls />autoPlayAutomatically starts playing the video when the page loads. Note: Autoplay policies vary across browsers.<video autoPlay />loopLoops the video playback.<video loop />mutedMutes the audio by default. Often used withautoPlay.<video muted />preloadSpecifies how the video is preloaded. Values:none,metadata,auto.<video preload=""none"" />playsInlineEnables inline playback on iOS devices, often necessary for autoplay to work on iOS Safari.<video playsInline />Good to know: When using theautoPlayattribute, it is important to also include themutedattribute to ensure the video plays automatically in most browsers and theplaysInlineattribute for compatibility with iOS devices.For a comprehensive list of video attributes, refer to theMDN documentation.Video best practicesFallback Content:When using the<video>tag, include fallback content inside the tag for browsers that do not support video playback.Subtitles or Captions:Include subtitles or captions for users who are deaf or hard of hearing. Utilize the<track>tag with your<video>elements to specify caption file sources.Accessible Controls:Standard HTML5 video controls are recommended for keyboard navigation and screen reader compatibility. For advanced needs, consider third-party players likereact-playerorvideo.js, which offer accessible controls and consistent browser experience.<iframe>The HTML<iframe>tag allows you to embed videos from external platforms like YouTube or Vimeo.app/page.jsxexportdefaultfunctionPage() {return(<iframesrc=""https://www.youtube.com/embed/19g66ezsKAg""allowFullScreen/>)}Common<iframe>tag attributesAttributeDescriptionExample ValuesrcThe URL of the page to embed.<iframe src=""https://example.com"" />widthSets the width of the iframe.<iframe width=""500"" />heightSets the height of the iframe.<iframe height=""300"" />allowFullScreenAllows the iframe content to be displayed in full-screen mode.<iframe allowFullScreen />sandboxEnables an extra set of restrictions on the content within the iframe.<iframe sandbox />loadingOptimize loading behavior (e.g., lazy loading).<iframe loading=""lazy"" />titleProvides a title for the iframe to support accessibility.<iframe title=""Description"" />For a comprehensive list of iframe attributes, refer to theMDN documentation.Choosing a video embedding methodThere are two ways you can embed videos in your Next.js application:Self-hosted or direct video files:Embed self-hosted videos using the<video>tag for scenarios requiring detailed control over the player's functionality and appearance. This integration method within Next.js allows for customization and control of your video content.Using video hosting services (YouTube, Vimeo, etc.):For video hosting services like YouTube or Vimeo, you'll embed their iframe-based players using the<iframe>tag. While this method limits some control over the player, it offers ease of use and features provided by these platforms.Choose the embedding method that aligns with your application's requirements and the user experience you aim to deliver.Embedding externally hosted videosTo embed videos from external platforms, you can use Next.js to fetch the video information and React Suspense to handle the fallback state while loading.1. Create a Server Component for video embeddingThe first step is to create aServer Componentthat generates the appropriate iframe for embedding the video. This component will fetch the source URL for the video and render the iframe.app/ui/video-component.jsxexportdefaultasyncfunctionVideoComponent() {constsrc=awaitgetVideoSrc()return<iframesrc={src}allowFullScreen/>}2. Stream the video component using React SuspenseAfter creating the Server Component to embed the video, the next step is tostreamthe component usingReact Suspense.app/page.jsximport{ Suspense }from'react'importVideoComponentfrom'../ui/VideoComponent.jsx'exportdefaultfunctionPage() {return(<section><Suspensefallback={<p>Loading video...</p>}><VideoComponent/></Suspense>{/* Other content of the page */}</section>)}Good to know: When embedding videos from external platforms, consider the following best practices:Ensure the video embeds are responsive. Use CSS to make the iframe or video player adapt to different screen sizes.Implementstrategies for loading videosbased on network conditions, especially for users with limited data plans.This approach results in a better user experience as it prevents the page from blocking, meaning the user can interact with the page while the video component streams in.For a more engaging and informative loading experience, consider using a loading skeleton as the fallback UI. So instead of showing a simple loading message, you can show a skeleton that resembles the video player like this:app/page.jsximport{ Suspense }from'react'importVideoComponentfrom'../ui/VideoComponent.jsx'importVideoSkeletonfrom'../ui/VideoSkeleton.jsx'exportdefaultfunctionPage() {return(<section><Suspensefallback={<VideoSkeleton/>}><VideoComponent/></Suspense>{/* Other content of the page */}</section>)}Self-hosted videosSelf-hosting videos may be preferable for several reasons:Complete control and independence: Self-hosting gives you direct management over your video content, from playback to appearance, ensuring full ownership and control, free from external platform constraints.Customization for specific needs: Ideal for unique requirements, like dynamic background videos, it allows for tailored customization to align with design and functional needs.Performance and scalability considerations: Choose storage solutions that are both high-performing and scalable, to support increasing traffic and content size effectively.Cost and integration: Balance the costs of storage and bandwidth with the need for easy integration into your Next.js framework and broader tech ecosystem.Using Vercel Blob for video hostingVercel Bloboffers an efficient way to host videos, providing a scalable cloud storage solution that works well with Next.js. Here's how you can host a video using Vercel Blob:1. Uploading a video to Vercel BlobIn your Vercel dashboard, navigate to the ""Storage"" tab and select yourVercel Blobstore. In the Blob table's upper-right corner, find and click the ""Upload"" button. Then, choose the video file you wish to upload. After the upload completes, the video file will appear in the Blob table.Alternatively, you can upload your video using a server action. For detailed instructions, refer to the Vercel documentation onserver-side uploads. Vercel also supportsclient-side uploads. This method may be preferable for certain use cases.2. Displaying the video in Next.jsOnce the video is uploaded and stored, you can display it in your Next.js application. Here's an example of how to do this using the<video>tag and React Suspense:app/page.jsximport{ Suspense }from'react'import{ list }from'@vercel/blob'exportdefaultfunctionPage() {return(<Suspensefallback={<p>Loading video...</p>}><VideoComponentfileName=""my-video.mp4""/></Suspense>)}asyncfunctionVideoComponent({ fileName }) {const{blobs}=awaitlist({prefix:fileName,limit:1,})const{url}=blobs[0]return(<videocontrolspreload=""none""aria-label=""Video player""><sourcesrc={url}type=""video/mp4""/>Your browser does not support the video tag.</video>)}In this approach, the page uses the video's@vercel/blobURL to display the video using theVideoComponent. React Suspense is used to show a fallback until the video URL is fetched and the video is ready to be displayed.Adding subtitles to your videoIf you have subtitles for your video, you can easily add them using the<track>element inside your<video>tag. You can fetch the subtitle file fromVercel Blobin a similar way as the video file. Here's how you can update the<VideoComponent>to include subtitles.app/page.jsxasyncfunctionVideoComponent({ fileName }) {const{blobs}=awaitlist({prefix:fileName,limit:2,})const{url}=blobs[0]const{ url:captionsUrl}=blobs[1]return(<videocontrolspreload=""none""aria-label=""Video player""><sourcesrc={url}type=""video/mp4""/><tracksrc={captionsUrl}kind=""subtitles""srcLang=""en""label=""English""/>Your browser does not support the video tag.</video>)}By following this approach, you can effectively self-host and integrate videos into your Next.js applications.ResourcesTo continue learning more about video optimization and best practices, please refer to the following resources:Understanding video formats and codecs: Choose the right format and codec, like MP4 for compatibility or WebM for web optimization, for your video needs. For more details, seeMozilla's guide on video codecs.Video compression: Use tools like FFmpeg to effectively compress videos, balancing quality with file size. Learn about compression techniques atFFmpeg's official website.Resolution and bitrate adjustment: Adjustresolution and bitratebased on the viewing platform, with lower settings for mobile devices.Content Delivery Networks (CDNs): Utilize a CDN to enhance video delivery speed and manage high traffic. When using some storage solutions, such as Vercel Blob, CDN functionality is automatically handled for you.Learn moreabout CDNs and their benefits.Explore these video streaming platforms for integrating video into your Next.js projects:Open sourcenext-videocomponentProvides a<Video>component for Next.js, compatible with various hosting services includingVercel Blob, S3, Backblaze, and Mux.Detailed documentationfor usingnext-video.devwith different hosting services.Cloudinary IntegrationOfficialdocumentation and integration guidefor using Cloudinary with Next.js.Includes a<CldVideoPlayer>component fordrop-in video support.Findexamplesof integrating Cloudinary with Next.js includingAdaptive Bitrate Streaming.OtherCloudinary librariesincluding a Node.js SDK are also available.Mux Video APIMux provides astarter templatefor creating a video course with Mux and Next.js.Learn about Mux's recommendations for embeddinghigh-performance video for your Next.js application.Explore anexample projectdemonstrating Mux with Next.js.FastlyLearn more about integrating Fastly's solutions forvideo on demandand streaming media into Next.js.ImageKit.io IntegrationCheck out theofficial quick start guidefor integrating ImageKit with Next.js.The integration provides an<IKVideo>component, offeringseamless video support.You can also explore otherImageKit libraries, such as the Node.js SDK, which is also available.PreviousImagesNextFontsWas this helpful?supported.Send"
fonts,Fonts,"Building Your ApplicationOptimizingFontsFont Optimizationnext/fontwill automatically optimize your fonts (including custom fonts) and remove external network requests for improved privacy and performance.🎥 Watch:Learn more about usingnext/font→YouTube (6 minutes).next/fontincludesbuilt-in automatic self-hostingforanyfont file. This means you can optimally load web fonts with zero layout shift, thanks to the underlying CSSsize-adjustproperty used.This new font system also allows you to conveniently use all Google Fonts with performance and privacy in mind. CSS and font files are downloaded at build time and self-hosted with the rest of your static assets.No requests are sent to Google by the browser.Google FontsAutomatically self-host any Google Font. Fonts are included in the deployment and served from the same domain as your deployment.No requests are sent to Google by the browser.Get started by importing the font you would like to use fromnext/font/googleas a function. We recommend usingvariable fontsfor the best performance and flexibility.app/layout.tsxTypeScriptJavaScriptTypeScriptimport{ Inter }from'next/font/google'// If loading a variable font, you don't need to specify the font weightconstinter=Inter({subsets:['latin'],display:'swap',})exportdefaultfunctionRootLayout({children,}:{children:React.ReactNode}) {return(<htmllang=""en""className={inter.className}><body>{children}</body></html>)}If you can't use a variable font, you willneed to specify a weight:app/layout.tsxTypeScriptJavaScriptTypeScriptimport{ Roboto }from'next/font/google'constroboto=Roboto({weight:'400',subsets:['latin'],display:'swap',})exportdefaultfunctionRootLayout({children,}:{children:React.ReactNode}) {return(<htmllang=""en""className={roboto.className}><body>{children}</body></html>)}You can specify multiple weights and/or styles by using an array:app/layout.jsconstroboto=Roboto({weight:['400','700'],style:['normal','italic'],subsets:['latin'],display:'swap',})Good to know: Use an underscore (_) for font names with multiple words. E.g.Roboto Monoshould be imported asRoboto_Mono.Specifying a subsetGoogle Fonts are automaticallysubset. This reduces the size of the font file and improves performance. You'll need to define which of these subsets you want to preload. Failing to specify any subsets whilepreloadistruewill result in a warning.This can be done by adding it to the function call:app/layout.tsxTypeScriptJavaScriptTypeScriptconstinter=Inter({ subsets:['latin'] })View theFont API Referencefor more information.Using Multiple FontsYou can import and use multiple fonts in your application. There are two approaches you can take.The first approach is to create a utility function that exports a font, imports it, and applies itsclassNamewhere needed. This ensures the font is preloaded only when it's rendered:app/fonts.tsTypeScriptJavaScriptTypeScriptimport{ Inter,Roboto_Mono }from'next/font/google'exportconstinter=Inter({subsets:['latin'],display:'swap',})exportconstroboto_mono=Roboto_Mono({subsets:['latin'],display:'swap',})app/layout.tsxTypeScriptJavaScriptTypeScriptimport{ inter }from'./fonts'exportdefaultfunctionLayout({ children }:{ children:React.ReactNode}) {return(<htmllang=""en""className={inter.className}><body><div>{children}</div></body></html>)}app/page.tsxTypeScriptJavaScriptTypeScriptimport{ roboto_mono }from'./fonts'exportdefaultfunctionPage() {return(<><h1className={roboto_mono.className}>My page</h1></>)}In the example above,Interwill be applied globally, andRoboto Monocan be imported and applied as needed.Alternatively, you can create aCSS variableand use it with your preferred CSS solution:app/layout.tsxTypeScriptJavaScriptTypeScriptimport{ Inter,Roboto_Mono }from'next/font/google'importstylesfrom'./global.css'constinter=Inter({subsets:['latin'],variable:'--font-inter',display:'swap',})constroboto_mono=Roboto_Mono({subsets:['latin'],variable:'--font-roboto-mono',display:'swap',})exportdefaultfunctionRootLayout({children,}:{children:React.ReactNode}) {return(<htmllang=""en""className={`${inter.variable}${roboto_mono.variable}`}><body><h1>My App</h1><div>{children}</div></body></html>)}app/global.csshtml{font-family:var(--font-inter);}h1{font-family:var(--font-roboto-mono);}In the example above,Interwill be applied globally, and any<h1>tags will be styled withRoboto Mono.Recommendation: Use multiple fonts conservatively since each new font is an additional resource the client has to download.Local FontsImportnext/font/localand specify thesrcof your local font file. We recommend usingvariable fontsfor the best performance and flexibility.app/layout.tsxTypeScriptJavaScriptTypeScriptimportlocalFontfrom'next/font/local'// Font files can be colocated inside of `app`constmyFont=localFont({src:'./my-font.woff2',display:'swap',})exportdefaultfunctionRootLayout({children,}:{children:React.ReactNode}) {return(<htmllang=""en""className={myFont.className}><body>{children}</body></html>)}If you want to use multiple files for a single font family,srccan be an array:constroboto=localFont({src:[{path:'./Roboto-Regular.woff2',weight:'400',style:'normal',},{path:'./Roboto-Italic.woff2',weight:'400',style:'italic',},{path:'./Roboto-Bold.woff2',weight:'700',style:'normal',},{path:'./Roboto-BoldItalic.woff2',weight:'700',style:'italic',},],})View theFont API Referencefor more information.With Tailwind CSSnext/fontcan be used withTailwind CSSthrough aCSS variable.In the example below, we use the fontInterfromnext/font/google(you can use any font from Google or Local Fonts). Load your font with thevariableoption to define your CSS variable name and assign it tointer. Then, useinter.variableto add the CSS variable to your HTML document.app/layout.tsxTypeScriptJavaScriptTypeScriptimport{ Inter,Roboto_Mono }from'next/font/google'constinter=Inter({subsets:['latin'],display:'swap',variable:'--font-inter',})constroboto_mono=Roboto_Mono({subsets:['latin'],display:'swap',variable:'--font-roboto-mono',})exportdefaultfunctionRootLayout({children,}:{children:React.ReactNode}) {return(<htmllang=""en""className={`${inter.variable}${roboto_mono.variable}`}><body>{children}</body></html>)}Finally, add the CSS variable to yourTailwind CSS config:tailwind.config.js/**@type{import('tailwindcss').Config}*/module.exports={content:['./pages/**/*.{js,ts,jsx,tsx}','./components/**/*.{js,ts,jsx,tsx}','./app/**/*.{js,ts,jsx,tsx}',],theme:{extend:{fontFamily:{sans:['var(--font-inter)'],mono:['var(--font-roboto-mono)'],},},},plugins:[],}You can now use thefont-sansandfont-monoutility classes to apply the font to your elements.PreloadingWhen a font function is called on a page of your site, it is not globally available and preloaded on all routes. Rather, the font is only preloaded on the related routes based on the type of file where it is used:If it's aunique page, it is preloaded on the unique route for that page.If it's alayout, it is preloaded on all the routes wrapped by the layout.If it's theroot layout, it is preloaded on all routes.Reusing fontsEvery time you call thelocalFontor Google font function, that font is hosted as one instance in your application. Therefore, if you load the same font function in multiple files, multiple instances of the same font are hosted. In this situation, it is recommended to do the following:Call the font loader function in one shared fileExport it as a constantImport the constant in each file where you would like to use this fontAPI ReferenceLearn more about the next/font API.FontOptimizing loading web fonts with the built-in `next/font` loaders.PreviousVideosNextMetadataWas this helpful?supported.Send"
metadata,Metadata,"Building Your ApplicationOptimizingMetadataMetadataNext.js has a Metadata API that can be used to define your application metadata (e.g.metaandlinktags inside your HTMLheadelement) for improved SEO and web shareability.There are two ways you can add metadata to your application:Config-based Metadata: Export astaticmetadataobjector a dynamicgenerateMetadatafunctionin alayout.jsorpage.jsfile.File-based Metadata: Add static or dynamically generated special files to route segments.With both these options, Next.js will automatically generate the relevant<head>elements for your pages. You can also create dynamic OG images using theImageResponseconstructor.Static MetadataTo define static metadata, export aMetadataobjectfrom alayout.jsor staticpage.jsfile.layout.tsx | page.tsxTypeScriptJavaScriptTypeScriptimporttype{ Metadata }from'next'exportconstmetadata:Metadata={title:'...',description:'...',}exportdefaultfunctionPage() {}For all the available options, see theAPI Reference.Dynamic MetadataYou can usegenerateMetadatafunction tofetchmetadata that requires dynamic values.app/products/[id]/page.tsxTypeScriptJavaScriptTypeScriptimporttype{ Metadata,ResolvingMetadata }from'next'typeProps={params:Promise<{ id:string}>searchParams:Promise<{ [key:string]:string|string[]|undefined}>}exportasyncfunctiongenerateMetadata({ params,searchParams }:Props,parent:ResolvingMetadata):Promise<Metadata> {// read route paramsconstid=(awaitparams).id// fetch dataconstproduct=awaitfetch(`https://.../${id}`).then((res)=>res.json())// optionally access and extend (rather than replace) parent metadataconstpreviousImages=(awaitparent).openGraph?.images||[]return{title:product.title,openGraph:{images:['/some-specific-page-image.jpg',...previousImages],},}}exportdefaultfunctionPage({ params,searchParams }:Props) {}For all the available params, see theAPI Reference.Good to know:Both static and dynamic metadata throughgenerateMetadataareonly supported in Server Components.fetchrequests are automaticallymemoizedfor the same data acrossgenerateMetadata,generateStaticParams, Layouts, Pages, and Server Components. Reactcachecan be usediffetchis unavailable.Next.js will wait for data fetching insidegenerateMetadatato complete before streaming UI to the client. This guarantees the first part of astreamed responseincludes<head>tags.File-based metadataThese special files are available for metadata:favicon.ico, apple-icon.jpg, and icon.jpgopengraph-image.jpg and twitter-image.jpgrobots.txtsitemap.xmlYou can use these for static metadata, or you can programmatically generate these files with code.For implementation and examples, see theMetadata FilesAPI Reference andDynamic Image Generation.BehaviorFile-based metadata has the higher priority and will override any config-based metadata.Default FieldsThere are two defaultmetatags that are always added even if a route doesn't define metadata:Themeta charset tagsets the character encoding for the website.Themeta viewport tagsets the viewport width and scale for the website to adjust for different devices.<metacharset=""utf-8""/><metaname=""viewport""content=""width=device-width, initial-scale=1""/>Good to know: You can overwrite the defaultviewportmeta tag.OrderingMetadata is evaluated in order, starting from the root segment down to the segment closest to the finalpage.jssegment. For example:app/layout.tsx(Root Layout)app/blog/layout.tsx(Nested Blog Layout)app/blog/[slug]/page.tsx(Blog Page)MergingFollowing theevaluation order, Metadata objects exported from multiple segments in the same route areshallowlymerged together to form the final metadata output of a route. Duplicate keys arereplacedbased on their ordering.This means metadata with nested fields such asopenGraphandrobotsthat are defined in an earlier segment areoverwrittenby the last segment to define them.Overwriting fieldsapp/layout.jsexportconstmetadata={title:'Acme',openGraph:{title:'Acme',description:'Acme is a...',},}app/blog/page.jsexportconstmetadata={title:'Blog',openGraph:{title:'Blog',},}// Output:// <title>Blog</title>// <meta property=""og:title"" content=""Blog"" />In the example above:titlefromapp/layout.jsisreplacedbytitleinapp/blog/page.js.AllopenGraphfields fromapp/layout.jsarereplacedinapp/blog/page.jsbecauseapp/blog/page.jssetsopenGraphmetadata. Note the absence ofopenGraph.description.If you'd like to share some nested fields between segments while overwriting others, you can pull them out into a separate variable:app/shared-metadata.jsexportconstopenGraphImage={ images:['http://...'] }app/page.jsimport{ openGraphImage }from'./shared-metadata'exportconstmetadata={openGraph:{...openGraphImage,title:'Home',},}app/about/page.jsimport{ openGraphImage }from'../shared-metadata'exportconstmetadata={openGraph:{...openGraphImage,title:'About',},}In the example above, the OG image is shared betweenapp/layout.jsandapp/about/page.jswhile the titles are different.Inheriting fieldsapp/layout.jsexportconstmetadata={title:'Acme',openGraph:{title:'Acme',description:'Acme is a...',},}app/about/page.jsexportconstmetadata={title:'About',}// Output:// <title>About</title>// <meta property=""og:title"" content=""Acme"" />// <meta property=""og:description"" content=""Acme is a..."" />Notestitlefromapp/layout.jsisreplacedbytitleinapp/about/page.js.AllopenGraphfields fromapp/layout.jsareinheritedinapp/about/page.jsbecauseapp/about/page.jsdoesn't setopenGraphmetadata.Dynamic Image GenerationTheImageResponseconstructor allows you to generate dynamic images using JSX and CSS. This is useful for creating social media images such as Open Graph images, Twitter cards, and more.To use it, you can importImageResponsefromnext/og:app/about/route.jsimport{ ImageResponse }from'next/og'exportasyncfunctionGET() {returnnewImageResponse((<divstyle={{fontSize:128,background:'white',width:'100%',height:'100%',display:'flex',textAlign:'center',alignItems:'center',justifyContent:'center',}}>Hello world!</div>),{width:1200,height:600,})}ImageResponseintegrates well with other Next.js APIs, includingRoute Handlersand file-based Metadata. For example, you can useImageResponsein aopengraph-image.tsxfile to generate Open Graph images at build time or dynamically at request time.ImageResponsesupports common CSS properties including flexbox and absolute positioning, custom fonts, text wrapping, centering, and nested images.See the full list of supported CSS properties.Good to know:Examples are available in theVercel OG Playground.ImageResponseuses@vercel/og,Satori, and Resvg to convert HTML and CSS into PNG.Only flexbox and a subset of CSS properties are supported. Advanced layouts (e.g.display: grid) will not work.Maximum bundle size of500KB. The bundle size includes your JSX, CSS, fonts, images, and any other assets. If you exceed the limit, consider reducing the size of any assets or fetching at runtime.Onlyttf,otf, andwofffont formats are supported. To maximize the font parsing speed,ttforotfare preferred overwoff.JSON-LDJSON-LDis a format for structured data that can be used by search engines to understand your content. For example, you can use it to describe a person, an event, an organization, a movie, a book, a recipe, and many other types of entities.Our current recommendation for JSON-LD is to render structured data as a<script>tag in yourlayout.jsorpage.jscomponents. For example:app/products/[id]/page.tsxTypeScriptJavaScriptTypeScriptexportdefaultasyncfunctionPage({ params }) {constproduct=awaitgetProduct((awaitparams).id)constjsonLd={'@context':'https://schema.org','@type':'Product',name:product.name,image:product.image,description:product.description,}return(<section>{/* Add JSON-LD to your page */}<scripttype=""application/ld+json""dangerouslySetInnerHTML={{ __html:JSON.stringify(jsonLd) }}/>{/* ... */}</section>)}You can validate and test your structured data with theRich Results Testfor Google or the genericSchema Markup Validator.You can type your JSON-LD with TypeScript using community packages likeschema-dts:import{ Product,WithContext }from'schema-dts'constjsonLd:WithContext<Product>={'@context':'https://schema.org','@type':'Product',name:'Next.js Sticker',image:'https://nextjs.org/imgs/sticker.png',description:'Dynamic at the speed of static.',}Next StepsView all the Metadata API options.generateMetadataLearn how to add Metadata to your Next.js application for improved search engine optimization (SEO) and web shareability.Metadata FilesAPI documentation for the metadata file conventions.generateViewportAPI Reference for the generateViewport function.PreviousFontsNextScriptsWas this helpful?supported.Send"
scripts,Scripts,"Building Your ApplicationOptimizingScriptsScript OptimizationLayout ScriptsTo load a third-party script for multiple routes, importnext/scriptand include the script directly in your layout component:app/dashboard/layout.tsxTypeScriptJavaScriptTypeScriptimportScriptfrom'next/script'exportdefaultfunctionDashboardLayout({children,}:{children:React.ReactNode}) {return(<><section>{children}</section><Scriptsrc=""https://example.com/script.js""/></>)}The third-party script is fetched when the folder route (e.g.dashboard/page.js) or any nested route (e.g.dashboard/settings/page.js) is accessed by the user. Next.js will ensure the script willonly load once, even if a user navigates between multiple routes in the same layout.Application ScriptsTo load a third-party script for all routes, importnext/scriptand include the script directly in your root layout:app/layout.tsxTypeScriptJavaScriptTypeScriptimportScriptfrom'next/script'exportdefaultfunctionRootLayout({children,}:{children:React.ReactNode}) {return(<htmllang=""en""><body>{children}</body><Scriptsrc=""https://example.com/script.js""/></html>)}This script will load and execute whenanyroute in your application is accessed. Next.js will ensure the script willonly load once, even if a user navigates between multiple pages.Recommendation: We recommend only including third-party scripts in specific pages or layouts in order to minimize any unnecessary impact to performance.StrategyAlthough the default behavior ofnext/scriptallows you to load third-party scripts in any page or layout, you can fine-tune its loading behavior by using thestrategyproperty:beforeInteractive: Load the script before any Next.js code and before any page hydration occurs.afterInteractive: (default) Load the script early but after some hydration on the page occurs.lazyOnload: Load the script later during browser idle time.worker: (experimental) Load the script in a web worker.Refer to thenext/scriptAPI reference documentation to learn more about each strategy and their use cases.Offloading Scripts To A Web Worker (experimental)Warning:Theworkerstrategy is not yet stable and does not yet work with the App Router. Use with caution.Scripts that use theworkerstrategy are offloaded and executed in a web worker withPartytown. This can improve the performance of your site by dedicating the main thread to the rest of your application code.This strategy is still experimental and can only be used if thenextScriptWorkersflag is enabled innext.config.js:next.config.jsmodule.exports={experimental:{nextScriptWorkers:true,},}Then, runnext(normallynpm run devoryarn dev) and Next.js will guide you through the installation of the required packages to finish the setup:TerminalnpmrundevYou'll see instructions like these: Please install Partytown by runningnpm install @builder.io/partytownOnce setup is complete, definingstrategy=""worker""will automatically instantiate Partytown in your application and offload the script to a web worker.pages/home.tsxTypeScriptJavaScriptTypeScriptimportScriptfrom'next/script'exportdefaultfunctionHome() {return(<><Scriptsrc=""https://example.com/script.js""strategy=""worker""/></>)}There are a number of trade-offs that need to be considered when loading a third-party script in a web worker. Please see Partytown'stradeoffsdocumentation for more information.Inline ScriptsInline scripts, or scripts not loaded from an external file, are also supported by the Script component. They can be written by placing the JavaScript within curly braces:<Scriptid=""show-banner"">{`document.getElementById('banner').classList.remove('hidden')`}</Script>Or by using thedangerouslySetInnerHTMLproperty:<Scriptid=""show-banner""dangerouslySetInnerHTML={{__html:`document.getElementById('banner').classList.remove('hidden')`,}}/>Warning: Anidproperty must be assigned for inline scripts in order for Next.js to track and optimize the script.Executing Additional CodeEvent handlers can be used with the Script component to execute additional code after a certain event occurs:onLoad: Execute code after the script has finished loading.onReady: Execute code after the script has finished loading and every time the component is mounted.onError: Execute code if the script fails to load.These handlers will only work whennext/scriptis imported and used inside of aClient Componentwhere""use client""is defined as the first line of code:app/page.tsxTypeScriptJavaScriptTypeScript'use client'importScriptfrom'next/script'exportdefaultfunctionPage() {return(<><Scriptsrc=""https://example.com/script.js""onLoad={()=>{console.log('Script has loaded')}}/></>)}Refer to thenext/scriptAPI reference to learn more about each event handler and view examples.Additional AttributesThere are many DOM attributes that can be assigned to a<script>element that are not used by the Script component, likenonceorcustom data attributes. Including any additional attributes will automatically forward it to the final, optimized<script>element that is included in the HTML.app/page.tsxTypeScriptJavaScriptTypeScriptimportScriptfrom'next/script'exportdefaultfunctionPage() {return(<><Scriptsrc=""https://example.com/script.js""id=""example-script""nonce=""XUENAJFW""data-test=""script""/></>)}API ReferenceLearn more about the next/script API.ScriptOptimize third-party scripts in your Next.js application using the built-in `next/script` Component.PreviousMetadataNextPackage BundlingWas this helpful?supported.Send"
package bundling,Package Bundling,"Building Your ApplicationOptimizingPackage BundlingOptimizing Package BundlingBundling external packages can significantly improve the performance of your application.By default, packages imported inside Server Components and Route Handlers are automatically bundled by Next.js. This page will guide you through how to analyze and further optimize package bundling.Analyzing JavaScript bundles@next/bundle-analyzeris a plugin for Next.js that helps you manage the size of your application bundles. It generates a visual report of the size of each package and their dependencies. You can use the information to remove large dependencies, split, orlazy-loadyour code.InstallationInstall the plugin by running the following command:npmi@next/bundle-analyzer# oryarnadd@next/bundle-analyzer# orpnpmadd@next/bundle-analyzerThen, add the bundle analyzer's settings to yournext.config.js.next.config.js/**@type{import('next').NextConfig}*/constnextConfig={}constwithBundleAnalyzer=require('@next/bundle-analyzer')({enabled:process.env.ANALYZE==='true',})module.exports=withBundleAnalyzer(nextConfig)Generating a reportRun the following command to analyze your bundles:ANALYZE=truenpmrunbuild# orANALYZE=trueyarnbuild# orANALYZE=truepnpmbuildThe report will open three new tabs in your browser, which you can inspect. Periodically evaluating your application's bundles can help you maintain application performance over time.Optimizing package importsSome packages, such as icon libraries, can export hundreds of modules, which can cause performance issues in development and production.You can optimize how these packages are imported by adding theoptimizePackageImportsoption to yournext.config.js. This option will only load the modules youactuallyuse, while still giving you the convenience of writing import statements with many named exports.next.config.js/**@type{import('next').NextConfig}*/constnextConfig={experimental:{optimizePackageImports:['icon-library'],},}module.exports=nextConfigNext.js also optimizes some libraries automatically, thus they do not need to be included in the optimizePackageImports list. See thefull list.Opting specific packages out of bundlingSince packages imported inside Server Components and Route Handlers are automatically bundled by Next.js, you can opt specific packages out of bundling using theserverExternalPackagesoption in yournext.config.js.next.config.js/**@type{import('next').NextConfig}*/constnextConfig={serverExternalPackages:['package-name'],}module.exports=nextConfigNext.js includes a list of popular packages that currently are working on compatibility and automatically opt-ed out. See thefull list.Next StepsLearn more about optimizing your application for production.Production ChecklistRecommendations to ensure the best performance and user experience before taking your Next.js application to production.PreviousScriptsNextLazy LoadingWas this helpful?supported.Send"
lazy loading,Lazy Loading,"Building Your ApplicationOptimizingLazy LoadingLazy LoadingLazy loadingin Next.js helps improve the initial loading performance of an application by decreasing the amount of JavaScript needed to render a route.It allows you to defer loading ofClient Componentsand imported libraries, and only include them in the client bundle when they're needed. For example, you might want to defer loading a modal until a user clicks to open it.There are two ways you can implement lazy loading in Next.js:UsingDynamic Importswithnext/dynamicUsingReact.lazy()withSuspenseBy default, Server Components are automaticallycode split, and you can usestreamingto progressively send pieces of UI from the server to the client. Lazy loading applies to Client Components.next/dynamicnext/dynamicis a composite ofReact.lazy()andSuspense. It behaves the same way in theappandpagesdirectories to allow for incremental migration.ExamplesImporting Client Componentsapp/page.js'use client'import{ useState }from'react'importdynamicfrom'next/dynamic'// Client Components:constComponentA=dynamic(()=>import('../components/A'))constComponentB=dynamic(()=>import('../components/B'))constComponentC=dynamic(()=>import('../components/C'),{ ssr:false})exportdefaultfunctionClientComponentExample() {const[showMore,setShowMore]=useState(false)return(<div>{/* Load immediately, but in a separate client bundle */}<ComponentA/>{/* Load on demand, only when/if the condition is met */}{showMore&&<ComponentB/>}<buttononClick={()=>setShowMore(!showMore)}>Toggle</button>{/* Load only on the client side */}<ComponentC/></div>)}Note:When a Server Component dynamically imports a Client Component, automaticcode splittingis currentlynotsupported.Skipping SSRWhen usingReact.lazy()and Suspense, Client Components will beprerendered(SSR) by default.Note:ssr: falseoption will only work for client components, move it into client components ensure the client code-splitting working properly.If you want to disable pre-rendering for a Client Component, you can use thessroption set tofalse:constComponentC=dynamic(()=>import('../components/C'),{ ssr:false})Importing Server ComponentsIf you dynamically import a Server Component, only the Client Components that are children of the Server Component will be lazy-loaded - not the Server Component itself.
It will also help preload the static assets such as CSS when you're using it in Server Components.app/page.jsimportdynamicfrom'next/dynamic'// Server Component:constServerComponent=dynamic(()=>import('../components/ServerComponent'))exportdefaultfunctionServerComponentExample() {return(<div><ServerComponent/></div>)}Note:ssr: falseoption is not supported in Server Components. You will see an error if you try to use it in Server Components.ssr: falseis not allowed withnext/dynamicin Server Components. Please move it into a client component.Loading External LibrariesExternal libraries can be loaded on demand using theimport()function. This example uses the external libraryfuse.jsfor fuzzy search. The module is only loaded on the client after the user types in the search input.app/page.js'use client'import{ useState }from'react'constnames=['Tim','Joe','Bel','Lee']exportdefaultfunctionPage() {const[results,setResults]=useState()return(<div><inputtype=""text""placeholder=""Search""onChange={async(e)=>{const{value}=e.currentTarget// Dynamically load fuse.jsconstFuse=(awaitimport('fuse.js')).defaultconstfuse=newFuse(names)setResults(fuse.search(value))}}/><pre>Results: {JSON.stringify(results,null,2)}</pre></div>)}Adding a custom loading componentapp/page.js'use client'importdynamicfrom'next/dynamic'constWithCustomLoading=dynamic(()=>import('../components/WithCustomLoading'),{loading:()=><p>Loading...</p>,})exportdefaultfunctionPage() {return(<div>{/* The loading component will be rendered while  <WithCustomLoading/> is loading */}<WithCustomLoading/></div>)}Importing Named ExportsTo dynamically import a named export, you can return it from the Promise returned byimport()function:components/hello.js'use client'exportfunctionHello() {return<p>Hello!</p>}app/page.jsimportdynamicfrom'next/dynamic'constClientComponent=dynamic(()=>import('../components/hello').then((mod)=>mod.Hello))PreviousPackage BundlingNextAnalyticsWas this helpful?supported.Send"
analytics,Analytics,"Building Your ApplicationOptimizingAnalyticsAnalyticsNext.js has built-in support for measuring and reporting performance metrics. You can either use theuseReportWebVitalshook to manage reporting yourself, or alternatively, Vercel provides amanaged serviceto automatically collect and visualize metrics for you.Build Your Ownapp/_components/web-vitals.js'use client'import{ useReportWebVitals }from'next/web-vitals'exportfunctionWebVitals() {useReportWebVitals((metric)=>{console.log(metric)})}app/layout.jsimport{ WebVitals }from'./_components/web-vitals'exportdefaultfunctionLayout({ children }) {return(<html><body><WebVitals/>{children}</body></html>)}Since theuseReportWebVitalshook requires the""use client""directive, the most performant approach is to create a separate component that the root layout imports. This confines the client boundary exclusively to theWebVitalscomponent.View theAPI Referencefor more information.Web VitalsWeb Vitalsare a set of useful metrics that aim to capture the user
experience of a web page. The following web vitals are all included:Time to First Byte(TTFB)First Contentful Paint(FCP)Largest Contentful Paint(LCP)First Input Delay(FID)Cumulative Layout Shift(CLS)Interaction to Next Paint(INP)You can handle all the results of these metrics using thenameproperty.app/_components/web-vitals.tsxTypeScriptJavaScriptTypeScript'use client'import{ useReportWebVitals }from'next/web-vitals'exportfunctionWebVitals() {useReportWebVitals((metric)=>{switch(metric.name) {case'FCP': {// handle FCP results}case'LCP': {// handle LCP results}// ...}})}Sending results to external systemsYou can send results to any endpoint to measure and track
real user performance on your site. For example:useReportWebVitals((metric)=>{constbody=JSON.stringify(metric)consturl='https://example.com/analytics'// Use `navigator.sendBeacon()` if available, falling back to `fetch()`.if(navigator.sendBeacon) {navigator.sendBeacon(url,body)}else{fetch(url,{ body,method:'POST',keepalive:true})}})Good to know: If you useGoogle Analytics, using theidvalue can allow you to construct metric distributions manually (to calculate percentiles,
etc.)useReportWebVitals((metric)=>{// Use `window.gtag` if you initialized Google Analytics as this example:// https://github.com/vercel/next.js/blob/canary/examples/with-google-analyticswindow.gtag('event',metric.name,{value:Math.round(metric.name==='CLS'?metric.value*1000:metric.value),// values must be integersevent_label:metric.id,// id unique to current page loadnon_interaction:true,// avoids affecting bounce rate.})})Read more aboutsending results to Google Analytics.PreviousLazy LoadingNextInstrumentationWas this helpful?supported.Send"
instrumentation,Instrumentation,"Building Your ApplicationOptimizingInstrumentationInstrumentationInstrumentation is the process of using code to integrate monitoring and logging tools into your application. This allows you to track the performance and behavior of your application, and to debug issues in production.ConventionTo set up instrumentation, createinstrumentation.ts|jsfile in theroot directoryof your project (or inside thesrcfolder if using one).Then, export aregisterfunction in the file. This function will be calledoncewhen a new Next.js server instance is initiated.For example, to use Next.js withOpenTelemetryand@vercel/otel:instrumentation.tsTypeScriptJavaScriptTypeScriptimport{ registerOTel }from'@vercel/otel'exportfunctionregister() {registerOTel('next-app')}See theNext.js with OpenTelemetry examplefor a complete implementation.Good to know:Theinstrumentationfile should be in the root of your project and not inside theapporpagesdirectory. If you're using thesrcfolder, then place the file insidesrcalongsidepagesandapp.If you use thepageExtensionsconfig optionto add a suffix, you will also need to update theinstrumentationfilename to match.ExamplesImporting files with side effectsSometimes, it may be useful to import a file in your code because of the side effects it will cause. For example, you might import a file that defines a set of global variables, but never explicitly use the imported file in your code. You would still have access to the global variables the package has declared.We recommend importing files using JavaScriptimportsyntax within yourregisterfunction. The following example demonstrates a basic usage ofimportin aregisterfunction:instrumentation.tsTypeScriptJavaScriptTypeScriptexportasyncfunctionregister() {awaitimport('package-with-side-effect')}Good to know:We recommend importing the file from within theregisterfunction, rather than at the top of the file. By doing this, you can colocate all of your side effects in one place in your code, and avoid any unintended consequences from importing globally at the top of the file.Importing runtime-specific codeNext.js callsregisterin all environments, so it's important to conditionally import any code that doesn't support specific runtimes (e.g.Edge or Node.js). You can use theNEXT_RUNTIMEenvironment variable to get the current environment:instrumentation.tsTypeScriptJavaScriptTypeScriptexportasyncfunctionregister() {if(process.env.NEXT_RUNTIME==='nodejs') {awaitimport('./instrumentation-node')}if(process.env.NEXT_RUNTIME==='edge') {awaitimport('./instrumentation-edge')}}Learn more about Instrumentationinstrumentation.jsAPI reference for the instrumentation.js file.PreviousAnalyticsNextOpenTelemetryWas this helpful?supported.Send"
opentelemetry,OpenTelemetry,"Building Your ApplicationOptimizingOpenTelemetryOpenTelemetryObservability is crucial for understanding and optimizing the behavior and performance of your Next.js app.As applications become more complex, it becomes increasingly difficult to identify and diagnose issues that may arise. By leveraging observability tools, such as logging and metrics, developers can gain insights into their application's behavior and identify areas for optimization. With observability, developers can proactively address issues before they become major problems and provide a better user experience. Therefore, it is highly recommended to use observability in your Next.js applications to improve performance, optimize resources, and enhance user experience.We recommend using OpenTelemetry for instrumenting your apps.
It's a platform-agnostic way to instrument apps that allows you to change your observability provider without changing your code.
ReadOfficial OpenTelemetry docsfor more information about OpenTelemetry and how it works.This documentation uses terms likeSpan,TraceorExporterthroughout this doc, all of which can be found inthe OpenTelemetry Observability Primer.Next.js supports OpenTelemetry instrumentation out of the box, which means that we already instrumented Next.js itself.
When you enable OpenTelemetry we will automatically wrap all your code likegetStaticPropsinspanswith helpful attributes.Getting StartedOpenTelemetry is extensible but setting it up properly can be quite verbose.
That's why we prepared a package@vercel/otelthat helps you get started quickly.Using@vercel/otelTo get started, install the following packages:Terminalnpminstall@vercel/otel@opentelemetry/sdk-logs@opentelemetry/api-logs@opentelemetry/instrumentationNext, create a custominstrumentation.ts(or.js) file in theroot directoryof the project (or insidesrcfolder if using one):your-project/instrumentation.tsTypeScriptJavaScriptTypeScriptimport{ registerOTel }from'@vercel/otel'exportfunctionregister() {registerOTel({ serviceName:'next-app'})}See the@vercel/oteldocumentationfor additional configuration options.Good to know:Theinstrumentationfile should be in the root of your project and not inside theapporpagesdirectory. If you're using thesrcfolder, then place the file insidesrcalongsidepagesandapp.If you use thepageExtensionsconfig optionto add a suffix, you will also need to update theinstrumentationfilename to match.We have created a basicwith-opentelemetryexample that you can use.Manual OpenTelemetry configurationThe@vercel/otelpackage provides many configuration options and should serve most of common use cases. But if it doesn't suit your needs, you can configure OpenTelemetry manually.Firstly you need to install OpenTelemetry packages:Terminalnpminstall@opentelemetry/sdk-node@opentelemetry/resources@opentelemetry/semantic-conventions@opentelemetry/sdk-trace-node@opentelemetry/exporter-trace-otlp-httpNow you can initializeNodeSDKin yourinstrumentation.ts.
Unlike@vercel/otel,NodeSDKis not compatible with edge runtime, so you need to make sure that you are importing them only whenprocess.env.NEXT_RUNTIME === 'nodejs'. We recommend creating a new fileinstrumentation.node.tswhich you conditionally import only when using node:instrumentation.tsTypeScriptJavaScriptTypeScriptexportasyncfunctionregister() {if(process.env.NEXT_RUNTIME==='nodejs') {awaitimport('./instrumentation.node.ts')}}instrumentation.node.tsTypeScriptJavaScriptTypeScriptimport{ OTLPTraceExporter }from'@opentelemetry/exporter-trace-otlp-http'import{ Resource }from'@opentelemetry/resources'import{ NodeSDK }from'@opentelemetry/sdk-node'import{ SimpleSpanProcessor }from'@opentelemetry/sdk-trace-node'import{ ATTR_SERVICE_NAME }from'@opentelemetry/semantic-conventions'constsdk=newNodeSDK({resource:newResource({[ATTR_SERVICE_NAME]:'next-app',}),spanProcessor:newSimpleSpanProcessor(newOTLPTraceExporter()),})sdk.start()Doing this is equivalent to using@vercel/otel, but it's possible to modify and extend some features that are not exposed by the@vercel/otel. If edge runtime support is necessary, you will have to use@vercel/otel.Testing your instrumentationYou need an OpenTelemetry collector with a compatible backend to test OpenTelemetry traces locally.
We recommend using ourOpenTelemetry dev environment.If everything works well you should be able to see the root server span labeled asGET /requested/pathname.
All other spans from that particular trace will be nested under it.Next.js traces more spans than are emitted by default.
To see more spans, you must setNEXT_OTEL_VERBOSE=1.DeploymentUsing OpenTelemetry CollectorWhen you are deploying with OpenTelemetry Collector, you can use@vercel/otel.
It will work both on Vercel and when self-hosted.Deploying on VercelWe made sure that OpenTelemetry works out of the box on Vercel.FollowVercel documentationto connect your project to an observability provider.Self-hostingDeploying to other platforms is also straightforward. You will need to spin up your own OpenTelemetry Collector to receive and process the telemetry data from your Next.js app.To do this, follow theOpenTelemetry Collector Getting Started guide, which will walk you through setting up the collector and configuring it to receive data from your Next.js app.Once you have your collector up and running, you can deploy your Next.js app to your chosen platform following their respective deployment guides.Custom ExportersOpenTelemetry Collector is not necessary. You can use a custom OpenTelemetry exporter with@vercel/otelormanual OpenTelemetry configuration.Custom SpansYou can add a custom span withOpenTelemetry APIs.Terminalnpminstall@opentelemetry/apiThe following example demonstrates a function that fetches GitHub stars and adds a customfetchGithubStarsspan to track the fetch request's result:import{ trace }from'@opentelemetry/api'exportasyncfunctionfetchGithubStars() {returnawaittrace.getTracer('nextjs-example').startActiveSpan('fetchGithubStars',async(span)=>{try{returnawaitgetValue()}finally{span.end()}})}Theregisterfunction will execute before your code runs in a new environment.
You can start creating new spans, and they should be correctly added to the exported trace.Default Spans in Next.jsNext.js automatically instruments several spans for you to provide useful insights into your application's performance.Attributes on spans followOpenTelemetry semantic conventions. We also add some custom attributes under thenextnamespace:next.span_name- duplicates span namenext.span_type- each span type has a unique identifiernext.route- The route pattern of the request (e.g.,/[param]/user).next.rsc(true/false) - Whether the request is an RSC request, such as prefetch.next.pageThis is an internal value used by an app router.You can think about it as a route to a special file (likepage.ts,layout.ts,loading.tsand others)It can be used as a unique identifier only when paired withnext.routebecause/layoutcan be used to identify both/(groupA)/layout.tsand/(groupB)/layout.ts[http.method] [next.route]next.span_type:BaseServer.handleRequestThis span represents the root span for each incoming request to your Next.js application. It tracks the HTTP method, route, target, and status code of the request.Attributes:Common HTTP attributeshttp.methodhttp.status_codeServer HTTP attributeshttp.routehttp.targetnext.span_namenext.span_typenext.routerender route (app) [next.route]next.span_type:AppRender.getBodyResult.This span represents the process of rendering a route in the app router.Attributes:next.span_namenext.span_typenext.routefetch [http.method] [http.url]next.span_type:AppRender.fetchThis span represents the fetch request executed in your code.Attributes:Common HTTP attributeshttp.methodClient HTTP attributeshttp.urlnet.peer.namenet.peer.port(only if specified)next.span_namenext.span_typeThis span can be turned off by settingNEXT_OTEL_FETCH_DISABLED=1in your environment. This is useful when you want to use a custom fetch instrumentation library.executing api route (app) [next.route]next.span_type:AppRouteRouteHandlers.runHandler.This span represents the execution of an API Route Handler in the app router.Attributes:next.span_namenext.span_typenext.routegetServerSideProps [next.route]next.span_type:Render.getServerSideProps.This span represents the execution ofgetServerSidePropsfor a specific route.Attributes:next.span_namenext.span_typenext.routegetStaticProps [next.route]next.span_type:Render.getStaticProps.This span represents the execution ofgetStaticPropsfor a specific route.Attributes:next.span_namenext.span_typenext.routerender route (pages) [next.route]next.span_type:Render.renderDocument.This span represents the process of rendering the document for a specific route.Attributes:next.span_namenext.span_typenext.routegenerateMetadata [next.page]next.span_type:ResolveMetadata.generateMetadata.This span represents the process of generating metadata for a specific page (a single route can have multiple of these spans).Attributes:next.span_namenext.span_typenext.pageresolve page componentsnext.span_type:NextNodeServer.findPageComponents.This span represents the process of resolving page components for a specific page.Attributes:next.span_namenext.span_typenext.routeresolve segment modulesnext.span_type:NextNodeServer.getLayoutOrPageModule.This span represents loading of code modules for a layout or a page.Attributes:next.span_namenext.span_typenext.segmentstart responsenext.span_type:NextNodeServer.startResponse.This zero-length span represents the time when the first byte has been sent in the response.PreviousInstrumentationNextStatic AssetsWas this helpful?supported.Send"
static assets,Static Assets,"Building Your ApplicationOptimizingStatic AssetsStatic Assets in `public`Next.js can serve static files, like images, under a folder calledpublicin the root directory. Files insidepubliccan then be referenced by your code starting from the base URL (/).For example, the filepublic/avatars/me.pngcan be viewed by visiting the/avatars/me.pngpath. The code to display that image might look like:avatar.jsimportImagefrom'next/image'exportfunctionAvatar({ id,alt }) {return<Imagesrc={`/avatars/${id}.png`}alt={alt}width=""64""height=""64""/>}exportfunctionAvatarOfMe() {return<Avatarid=""me""alt=""A portrait of me""/>}CachingNext.js cannot safely cache assets in thepublicfolder because they may change. The default caching headers applied are:Cache-Control:public,max-age=0Robots, Favicons, and othersFor static metadata files, such asrobots.txt,favicon.ico, etc, you should usespecial metadata filesinside theappfolder.Good to know:The directory must be namedpublic. The name cannot be changed and it's the only directory used to serve static assets.Only assets that are in thepublicdirectory atbuild timewill be served by Next.js. Files added at request time won't be available. We recommend using a third-party service likeVercel Blobfor persistent file storage.PreviousOpenTelemetryNextThird Party LibrariesWas this helpful?supported.Send"
third party libraries,Third Party Libraries,"Building Your ApplicationOptimizingThird Party LibrariesThird Party Libraries@next/third-partiesis a library that provides a collection of components and utilities that improve the performance and developer experience of loading popular third-party libraries in your Next.js application.All third-party integrations provided by@next/third-partieshave been optimized for performance and ease of use.Getting StartedTo get started, install the@next/third-partieslibrary:Terminalnpminstall@next/third-parties@latestnext@latest@next/third-partiesis currently anexperimentallibrary under active development. We recommend installing it with thelatestorcanaryflags while we work on adding more third-party integrations.Google Third-PartiesAll supported third-party libraries from Google can be imported from@next/third-parties/google.Google Tag ManagerTheGoogleTagManagercomponent can be used to instantiate aGoogle Tag Managercontainer to your page. By default, it fetches the original inline script after hydration occurs on the page.To load Google Tag Manager for all routes, include the component directly in your root layout and pass in your GTM container ID:app/layout.tsxTypeScriptJavaScriptTypeScriptimport{ GoogleTagManager }from'@next/third-parties/google'exportdefaultfunctionRootLayout({children,}:{children:React.ReactNode}) {return(<htmllang=""en""><GoogleTagManagergtmId=""GTM-XYZ""/><body>{children}</body></html>)}To load Google Tag Manager for a single route, include the component in your page file:app/page.jsimport{ GoogleTagManager }from'@next/third-parties/google'exportdefaultfunctionPage() {return<GoogleTagManagergtmId=""GTM-XYZ""/>}Sending EventsThesendGTMEventfunction can be used to track user interactions on your page by sending events
using thedataLayerobject. For this function to work, the<GoogleTagManager />component must be
included in either a parent layout, page, or component, or directly in the same file.app/page.js'use client'import{ sendGTMEvent }from'@next/third-parties/google'exportfunctionEventButton() {return(<div><buttononClick={()=>sendGTMEvent({ event:'buttonClicked',value:'xyz'})}>Send Event</button></div>)}Refer to the Tag Managerdeveloper
documentationto learn about the
different variables and events that can be passed into the function.Server-side TaggingIf you're using a server-side tag manager and servinggtm.jsscripts from your tagging server you can
usegtmScriptUrloption to specify the URL of the script.OptionsOptions to pass to the Google Tag Manager. For a full list of options, read theGoogle Tag Manager
docs.NameTypeDescriptiongtmIdRequiredYour GTM container ID. Usually starts withGTM-.gtmScriptUrlOptionalGTM script URL. Defaults tohttps://www.googletagmanager.com/gtm.js.dataLayerOptionalData layer object to instantiate the container with.dataLayerNameOptionalName of the data layer. Defaults todataLayer.authOptionalValue of authentication parameter (gtm_auth) for environment snippets.previewOptionalValue of preview parameter (gtm_preview) for environment snippets.Google AnalyticsTheGoogleAnalyticscomponent can be used to includeGoogle Analytics
4to your page via the Google tag
(gtag.js). By default, it fetches the original scripts after hydration occurs on the page.Recommendation: If Google Tag Manager is already included in your application, you can
configure Google Analytics directly using it, rather than including Google Analytics as a separate
component. Refer to thedocumentationto learn more about the differences between Tag Manager andgtag.js.To load Google Analytics for all routes, include the component directly in your root layout and pass
in your measurement ID:app/layout.tsxTypeScriptJavaScriptTypeScriptimport{ GoogleAnalytics }from'@next/third-parties/google'exportdefaultfunctionRootLayout({children,}:{children:React.ReactNode}) {return(<htmllang=""en""><body>{children}</body><GoogleAnalyticsgaId=""G-XYZ""/></html>)}To load Google Analytics for a single route, include the component in your page file:app/page.jsimport{ GoogleAnalytics }from'@next/third-parties/google'exportdefaultfunctionPage() {return<GoogleAnalyticsgaId=""G-XYZ""/>}Sending EventsThesendGAEventfunction can be used to measure user interactions on your page by sending events
using thedataLayerobject. For this function to work, the<GoogleAnalytics />component must be
included in either a parent layout, page, or component, or directly in the same file.app/page.js'use client'import{ sendGAEvent }from'@next/third-parties/google'exportfunctionEventButton() {return(<div><buttononClick={()=>sendGAEvent('event','buttonClicked',{ value:'xyz'})}>Send Event</button></div>)}Refer to the Google Analyticsdeveloper
documentationto learn
more about event parameters.Tracking PageviewsGoogle Analytics automatically tracks pageviews when the browser history state changes. This means
that client-side navigations between Next.js routes will send pageview data without any configuration.To ensure that client-side navigations are being measured correctly, verify that the“Enhanced
Measurement”property is
enabled in your Admin panel and the“Page changes based on browser history events”checkbox is
selected.Note: If you decide to manually send pageview events, make sure to disable the default
pageview measurement to avoid having duplicate data. Refer to the Google Analyticsdeveloper
documentationto learn more.OptionsOptions to pass to the<GoogleAnalytics>component.NameTypeDescriptiongaIdRequiredYourmeasurement ID. Usually starts withG-.dataLayerNameOptionalName of the data layer. Defaults todataLayer.nonceOptionalAnonce.Google Maps EmbedTheGoogleMapsEmbedcomponent can be used to add aGoogle Maps
Embedto your page. By
default, it uses theloadingattribute to lazy-load the embed below the fold.app/page.jsimport{ GoogleMapsEmbed }from'@next/third-parties/google'exportdefaultfunctionPage() {return(<GoogleMapsEmbedapiKey=""XYZ""height={200}width=""100%""mode=""place""q=""Brooklyn+Bridge,New+York,NY""/>)}OptionsOptions to pass to the Google Maps Embed. For a full list of options, read theGoogle Map Embed
docs.NameTypeDescriptionapiKeyRequiredYour api key.modeRequiredMap modeheightOptionalHeight of the embed. Defaults toauto.widthOptionalWidth of the embed. Defaults toauto.styleOptionalPass styles to the iframe.allowfullscreenOptionalProperty to allow certain map parts to go full screen.loadingOptionalDefaults to lazy. Consider changing if you know your embed will be above the fold.qOptionalDefines map marker location.This may be required depending on the map mode.centerOptionalDefines the center of the map view.zoomOptionalSets initial zoom level of the map.maptypeOptionalDefines type of map tiles to load.languageOptionalDefines the language to use for UI elements and for the display of labels on map tiles.regionOptionalDefines the appropriate borders and labels to display, based on geo-political sensitivities.YouTube EmbedTheYouTubeEmbedcomponent can be used to load and display a YouTube embed. This component loads
faster by usinglite-youtube-embedunder the
hood.app/page.jsimport{ YouTubeEmbed }from'@next/third-parties/google'exportdefaultfunctionPage() {return<YouTubeEmbedvideoid=""ogfYd705cRs""height={400}params=""controls=0""/>}OptionsNameTypeDescriptionvideoidRequiredYouTube video id.widthOptionalWidth of the video container. Defaults toautoheightOptionalHeight of the video container. Defaults toautoplaylabelOptionalA visually hidden label for the play button for accessibility.paramsOptionalThe video player params definedhere.Params are passed as a query param string.Eg:params=""controls=0&start=10&end=30""styleOptionalUsed to apply styles to the video container.PreviousStatic AssetsNextMemory UsageWas this helpful?supported.Send"
memory usage,Memory Usage,"Building Your ApplicationOptimizingMemory UsageMemory UsageAs applications grow and become more feature rich, they can demand more resources when developing locally or creating production builds.Let's explore some strategies and techniques to optimize memory and address common memory issues in Next.js.Reduce number of dependenciesApplications with a large amount of dependencies will use more memory.TheBundle Analyzercan help you investigate large dependencies in your application that may be able to be removed to improve performance and memory usage.Tryexperimental.webpackMemoryOptimizationsStarting inv15.0.0, you can addexperimental.webpackMemoryOptimizations: trueto yournext.config.jsfile to change behavior in Webpack that reduces max memory usage but may increase compilation times by a slight amount.Good to know: This feature is currently experimental to test on more projects first, but it is considered to be low-risk.Runnext buildwith--experimental-debug-memory-usageStarting in14.2.0, you can runnext build --experimental-debug-memory-usageto run the build in a mode where Next.js will print out information about memory usage continuously throughout the build, such as heap usage and garbage collection statistics. Heap snapshots will also be taken automatically when memory usage gets close to the configured limit.Good to know: This feature is not compatible with the Webpack build worker option which is auto-enabled unless you have custom webpack config.Record a heap profileTo look for memory issues, you can record a heap profile from Node.js and load it in Chrome DevTools to identify potential sources of memory leaks.In your terminal, pass the--heap-profflag to Node.js when starting your Next.js build:node--heap-profnode_modules/next/dist/bin/nextbuildAt the end of the build, a.heapprofilefile will be created by Node.js.In Chrome DevTools, you can open the Memory tab and click on the ""Load Profile"" button to visualize the file.Analyze a snapshot of the heapYou can use an inspector tool to analyze the memory usage of the application.When running thenext buildornext devcommand, addNODE_OPTIONS=--inspectto the beginning of the command. This will expose the inspector agent on the default port.
If you wish to break before any user code starts, you can pass--inspect-brkinstead. While the process is running, you can use a tool such as Chrome DevTools to connect to the debugging port to record and analyze a snapshot of the heap to see what memory is being retained.Starting in14.2.0, you can also runnext buildwith the--experimental-debug-memory-usageflag to make it easier to take heap snapshots.While running in this mode, you can send aSIGUSR2signal to the process at any point, and the process will take a heap snapshot.The heap snapshot will be saved to the project root of the Next.js application and can be loaded in any heap analyzer, such as Chrome DevTools, to see what memory is retained. This mode is not yet compatible with Webpack build workers.Seehow to record and analyze heap snapshotsfor more information.Webpack build workerThe Webpack build worker allows you to run Webpack compilations inside a separate Node.js worker which will decrease memory usage of your application during builds.This option is enabled by default if your application does not have a custom Webpack configuration starting inv14.1.0.If you are using an older version of Next.js or you have a custom Webpack configuration, you can enable this option by settingexperimental.webpackBuildWorker: trueinside yournext.config.js.Good to know: This feature may not be compatible with all custom Webpack plugins.Disable Webpack cacheTheWebpack cachesaves generated Webpack modules in memory and/or to disk to improve the speed of builds. This can
help with performance, but it will also increase the memory usage of your application to store the cached data.You can disable this behavior by adding acustom Webpack configurationto your application:next.config.mjs/**@type{import('next').NextConfig}*/constnextConfig={webpack:(config,{ buildId,dev,isServer,defaultLoaders,nextRuntime,webpack })=>{if(config.cache&&!dev) {config.cache=Object.freeze({type:'memory',})}// Important: return the modified configreturnconfig},}exportdefaultnextConfigDisable static analysisTypechecking and linting may require a lot of memory, especially in large projects.
However, most projects have a dedicated CI runner that already handles these tasks.
When the build produces out-of-memory issues during the ""Linting and checking validity of types"" step, you can disable these task during builds:next.config.mjs/**@type{import('next').NextConfig}*/constnextConfig={eslint:{// Warning: This allows production builds to successfully complete even if// your project has ESLint errors.ignoreDuringBuilds:true,},typescript:{// !! WARN !!// Dangerously allow production builds to successfully complete even if// your project has type errors.// !! WARN !!ignoreBuildErrors:true,},}exportdefaultnextConfigIgnoring TypeScript ErrorsESLint in Next.js configKeep in mind that this may produce faulty deploys due to type errors or linting issues.
We strongly recommend only promoting builds to production after static analysis has completed.
If you deploy to Vercel, you can check out theguide for staging deploymentsto learn how to promote builds to production after custom tasks have succeeded.Disable source mapsGenerating source maps consumes extra memory during the build process.You can disable source map generation by addingproductionBrowserSourceMaps: falseandexperimental.serverSourceMaps: falseto your Next.js configuration.Good to know: Some plugins may turn on source maps and may require custom configuration to disable.Edge memory issuesNext.jsv14.1.3fixed a memory issue when using the Edge runtime. Please update to this version (or later) to see if it addresses your issue.PreviousThird Party LibrariesNextConfiguringWas this helpful?supported.Send"
configuring,Configuring,"App RouterBuilding Your ApplicationConfiguringConfiguringNext.js allows you to customize your project to meet specific requirements. This includes integrations with TypeScript, ESlint, and more, as well as internal configuration options such as Absolute Imports and Environment Variables.Environment VariablesLearn to add and access environment variables in your Next.js application.MDXLearn how to configure MDX and use it in your Next.js apps.src DirectorySave pages under the `src` directory as an alternative to the root `pages` directory.Custom ServerStart a Next.js app programmatically using a custom server.Draft ModeNext.js has draft mode to toggle between static and dynamic pages. You can learn how it works with App Router here.Content Security PolicyLearn how to set a Content Security Policy (CSP) for your Next.js application.DebuggingLearn how to debug your Next.js application with VS Code, Chrome DevTools, or Firefox DevTools.Progressive Web Applications (PWA)Learn how to build a Progressive Web Application (PWA) with Next.js.PreviousMemory UsageNextEnvironment VariablesWas this helpful?supported.Send"
environment variables,Environment Variables,"Building Your ApplicationConfiguringEnvironment VariablesEnvironment VariablesExamplesEnvironment VariablesNext.js comes with built-in support for environment variables, which allows you to do the following:Use.envto load environment variablesBundle environment variables for the browser by prefixing withNEXT_PUBLIC_Warning:The defaultcreate-next-apptemplate ensures all.envfiles are added to your.gitignore. You almost never want to commit these files to your repository.Loading Environment VariablesNext.js has built-in support for loading environment variables from.env*files intoprocess.env..envDB_HOST=localhostDB_USER=myuserDB_PASS=mypasswordNote: Next.js also supports multiline variables inside of your.env*files:# .env# you can write with line breaksPRIVATE_KEY=""-----BEGIN RSA PRIVATE KEY-----...Kh9NV......-----END DSA PRIVATE KEY-----""# or with `\n` inside double quotesPRIVATE_KEY=""-----BEGIN RSA PRIVATE KEY-----\nKh9NV...\n-----END DSA PRIVATE KEY-----\n""Note: If you are using a/srcfolder, please note that Next.js will load the .env filesonlyfrom the parent folder andnotfrom the/srcfolder.
This loadsprocess.env.DB_HOST,process.env.DB_USER, andprocess.env.DB_PASSinto the Node.js environment automatically allowing you to use them inRoute Handlers.For example:app/api/route.jsexportasyncfunctionGET() {constdb=awaitmyDB.connect({host:process.env.DB_HOST,username:process.env.DB_USER,password:process.env.DB_PASS,})// ...}Loading Environment Variables with@next/envIf you need to load environment variables outside of the Next.js runtime, such as in a root config file for an ORM or test runner, you can use the@next/envpackage.This package is used internally by Next.js to load environment variables from.env*files.To use it, install the package and use theloadEnvConfigfunction to load the environment variables:npminstall@next/envenvConfig.tsTypeScriptJavaScriptTypeScriptimport{ loadEnvConfig }from'@next/env'constprojectDir=process.cwd()loadEnvConfig(projectDir)Then, you can import the configuration where needed. For example:orm.config.tsTypeScriptJavaScriptTypeScriptimport'./envConfig.ts'exportdefaultdefineConfig({dbCredentials:{connectionString:process.env.DATABASE_URL!,},})Referencing Other VariablesNext.js will automatically expand variables that use$to reference other variables e.g.$VARIABLEinside of your.env*files. This allows you to reference other secrets. For example:.envTWITTER_USER=nextjsTWITTER_URL=https://x.com/$TWITTER_USERIn the above example,process.env.TWITTER_URLwould be set tohttps://x.com/nextjs.Good to know: If you need to use variable with a$in the actual value, it needs to be escaped e.g.\$.Bundling Environment Variables for the BrowserNon-NEXT_PUBLIC_environment variables are only available in the Node.js environment, meaning they aren't accessible to the browser (the client runs in a differentenvironment).In order to make the value of an environment variable accessible in the browser, Next.js can ""inline"" a value, at build time, into the js bundle that is delivered to the client, replacing all references toprocess.env.[variable]with a hard-coded value. To tell it to do this, you just have to prefix the variable withNEXT_PUBLIC_. For example:TerminalNEXT_PUBLIC_ANALYTICS_ID=abcdefghijkThis will tell Next.js to replace all references toprocess.env.NEXT_PUBLIC_ANALYTICS_IDin the Node.js environment with the value from the environment in which you runnext build, allowing you to use it anywhere in your code. It will be inlined into any JavaScript sent to the browser.Note: After being built, your app will no longer respond to changes to these environment variables. For instance, if you use a Heroku pipeline to promote slugs built in one environment to another environment, or if you build and deploy a single Docker image to multiple environments, allNEXT_PUBLIC_variables will be frozen with the value evaluated at build time, so these values need to be set appropriately when the project is built. If you need access to runtime environment values, you'll have to setup your own API to provide them to the client (either on demand or during initialization).pages/index.jsimportsetupAnalyticsServicefrom'../lib/my-analytics-service'// 'NEXT_PUBLIC_ANALYTICS_ID' can be used here as it's prefixed by 'NEXT_PUBLIC_'.// It will be transformed at build time to `setupAnalyticsService('abcdefghijk')`.setupAnalyticsService(process.env.NEXT_PUBLIC_ANALYTICS_ID)functionHomePage() {return<h1>Hello World</h1>}exportdefaultHomePageNote that dynamic lookups willnotbe inlined, such as:// This will NOT be inlined, because it uses a variableconstvarName='NEXT_PUBLIC_ANALYTICS_ID'setupAnalyticsService(process.env[varName])// This will NOT be inlined, because it uses a variableconstenv=process.envsetupAnalyticsService(env.NEXT_PUBLIC_ANALYTICS_ID)Runtime Environment VariablesNext.js can support both build time and runtime environment variables.By default, environment variables are only available on the server. To expose an environment variable to the browser, it must be prefixed withNEXT_PUBLIC_. However, these public environment variables will be inlined into the JavaScript bundle duringnext build.You can safely read environment variables on the server during dynamic rendering:app/page.tsTypeScriptJavaScriptTypeScriptimport{ connection }from'next/server'exportdefaultasyncfunctionComponent() {awaitconnection()// cookies, headers, and other Dynamic APIs// will also opt into dynamic rendering, meaning// this env variable is evaluated at runtimeconstvalue=process.env.MY_VALUE// ...}This allows you to use a singular Docker image that can be promoted through multiple environments with different values.Good to know:You can run code on server startup using theregisterfunction.We do not recommend using theruntimeConfigoption, as this does not work with the standalone output mode. Instead, we recommendincrementally adoptingthe App Router if you need this feature.Environment Variables on VercelWhen deploying your Next.js application toVercel, Environment Variables can be configuredin the Project Settings.All types of Environment Variables should be configured there. Even Environment Variables used in Development – which can bedownloaded onto your local deviceafterwards.If you've configuredDevelopment Environment Variablesyou can pull them into a.env.localfor usage on your local machine using the following command:TerminalvercelenvpullGood to know: When deploying your Next.js application toVercel, your environment variables in.env*files will not be made available to Edge Runtime, unless their name are prefixed withNEXT_PUBLIC_. We strongly recommend managing your environment variables inProject Settingsinstead, from where all environment variables are available.Test Environment VariablesApart fromdevelopmentandproductionenvironments, there is a 3rd option available:test. In the same way you can set defaults for development or production environments, you can do the same with a.env.testfile for thetestingenvironment (though this one is not as common as the previous two). Next.js will not load environment variables from.env.developmentor.env.productionin thetestingenvironment.This one is useful when running tests with tools likejestorcypresswhere you need to set specific environment vars only for testing purposes. Test default values will be loaded ifNODE_ENVis set totest, though you usually don't need to do this manually as testing tools will address it for you.There is a small difference betweentestenvironment, and bothdevelopmentandproductionthat you need to bear in mind:.env.localwon't be loaded, as you expect tests to produce the same results for everyone. This way every test execution will use the same env defaults across different executions by ignoring your.env.local(which is intended to override the default set).Good to know: similar to Default Environment Variables,.env.testfile should be included in your repository, but.env.test.localshouldn't, as.env*.localare intended to be ignored through.gitignore.While running unit tests you can make sure to load your environment variables the same way Next.js does by leveraging theloadEnvConfigfunction from the@next/envpackage.// The below can be used in a Jest global setup file or similar for your testing set-upimport{ loadEnvConfig }from'@next/env'exportdefaultasync()=>{constprojectDir=process.cwd()loadEnvConfig(projectDir)}Environment Variable Load OrderEnvironment variables are looked up in the following places, in order, stopping once the variable is found.process.env.env.$(NODE_ENV).local.env.local(Not checked whenNODE_ENVistest.).env.$(NODE_ENV).envFor example, ifNODE_ENVisdevelopmentand you define a variable in both.env.development.localand.env, the value in.env.development.localwill be used.Good to know: The allowed values forNODE_ENVareproduction,developmentandtest.Good to knowIf you are using a/srcdirectory,.env.*files should remain in the root of your project.If the environment variableNODE_ENVis unassigned, Next.js automatically assignsdevelopmentwhen running thenext devcommand, orproductionfor all other commands.Version HistoryVersionChangesv9.4.0Support.envandNEXT_PUBLIC_introduced.PreviousConfiguringNextMDXWas this helpful?supported.Send"
mdx,MDX,"Building Your ApplicationConfiguringMDXMarkdown and MDXMarkdownis a lightweight markup language used to format text. It allows you to write using plain text syntax and convert it to structurally valid HTML. It's commonly used for writing content on websites and blogs.You write...I**love**using[Next.js](https://nextjs.org/)Output:<p>I <strong>love</strong> using <ahref=""https://nextjs.org/"">Next.js</a></p>MDXis a superset of markdown that lets you writeJSXdirectly in your markdown files. It is a powerful way to add dynamic interactivity and embed React components within your content.Next.js can support both local MDX content inside your application, as well as remote MDX files fetched dynamically on the server. The Next.js plugin handles transforming markdown and React components into HTML, including support for usage in Server Components (the default in App Router).Good to know: View thePortfolio Starter Kittemplate for a complete working example.Install dependenciesThe@next/mdxpackage, and related packages, are used to configure Next.js so it can process markdown and MDX.It sources data from local files, allowing you to create pages with a.mdor.mdxextension, directly in your/pagesor/appdirectory.Install these packages to render MDX with Next.js:Terminalnpminstall@next/mdx@mdx-js/loader@mdx-js/react@types/mdxConfigurenext.config.mjsUpdate thenext.config.mjsfile at your project's root to configure it to use MDX:next.config.mjsimportcreateMDXfrom'@next/mdx'/**@type{import('next').NextConfig}*/constnextConfig={// Configure `pageExtensions` to include markdown and MDX filespageExtensions:['js','jsx','md','mdx','ts','tsx'],// Optionally, add any other Next.js config below}constwithMDX=createMDX({// Add markdown plugins here, as desired})// Merge MDX config with Next.js configexportdefaultwithMDX(nextConfig)This allows.mdand.mdxfiles to act as pages, routes, or imports in your application.Add anmdx-components.tsxfileCreate anmdx-components.tsx(or.js) file in the root of your project to define global MDX Components. For example, at the same level aspagesorapp, or insidesrcif applicable.mdx-components.tsxTypeScriptJavaScriptTypeScriptimporttype{ MDXComponents }from'mdx/types'exportfunctionuseMDXComponents(components:MDXComponents):MDXComponents{return{...components,}}Good to know:mdx-components.tsxisrequiredto use@next/mdxwith App Router and will not work without it.Learn more about themdx-components.tsxfile convention.Learn how touse custom styles and components.Rendering MDXYou can render MDX using Next.js's file based routing or by importing MDX files into other pages.Using file based routingWhen using file based routing, you can use MDX pages like any other page.In App Router apps, that includes being able to usemetadata.Create a new MDX page within the/appdirectory:my-project├── app│   └── mdx-page│       └── page.(mdx/md)|── mdx-components.(tsx/js)└── package.jsonYou can use MDX in these files, and even import React components, directly inside your MDX page:import{ MyComponent }from'my-component'# Welcome to myMDXpage!This is some**bold**and _italics_ text.This is a listinmarkdown:-One-Two-ThreeCheckout my React component:<MyComponent/>Navigating to the/mdx-pageroute should display your rendered MDX page.Using importsCreate a new page within the/appdirectory and an MDX file wherever you'd like:my-project├── app│   └── mdx-page│       └── page.(tsx/js)├── markdown│   └── welcome.(mdx/md)|── mdx-components.(tsx/js)└── package.jsonYou can use MDX in these files, and even import React components, directly inside your MDX page:Import the MDX file inside the page to display the content:app/mdx-page/page.tsxTypeScriptJavaScriptTypeScriptimportWelcomefrom'@/markdown/welcome.mdx'exportdefaultfunctionPage() {return<Welcome/>}Navigating to the/mdx-pageroute should display your rendered MDX page.Using dynamic importsYou can import dynamic MDX components instead of using filesystem routing for MDX files.For example, you can have a dynamic route segment which loads MDX components from a separate directory:generateStaticParamscan be used to prerender the provided routes. By markingdynamicParamsasfalse, accessing a route not defined ingenerateStaticParamswill 404.app/blog/[slug]/page.tsxTypeScriptJavaScriptTypeScriptexportdefaultasyncfunctionPage({params,}:{params:Promise<{ slug:string}>}) {constslug=(awaitparams).slugconst{ default:Post}=awaitimport(`@/content/${slug}.mdx`)return<Post/>}exportfunctiongenerateStaticParams() {return[{ slug:'welcome'},{ slug:'about'}]}exportconstdynamicParams=falseGood to know: Ensure you specify the.mdxfile extension in your import. While it is not required to usemodule path aliases(e.g.,@/content), it does simplify your import path.Using custom styles and componentsMarkdown, when rendered, maps to native HTML elements. For example, writing the following markdown:## This is a headingThis is a list in markdown:- One- Two- ThreeGenerates the following HTML:<h2>This is a heading</h2><p>This is a list in markdown:</p><ul><li>One</li><li>Two</li><li>Three</li></ul>To style your markdown, you can provide custom components that map to the generated HTML elements. Styles and components can be implemented globally, locally, and with shared layouts.Global styles and componentsAdding styles and components inmdx-components.tsxwill affectallMDX files in your application.mdx-components.tsxTypeScriptJavaScriptTypeScriptimporttype{ MDXComponents }from'mdx/types'importImage,{ ImageProps }from'next/image'// This file allows you to provide custom React components// to be used in MDX files. You can import and use any// React component you want, including inline styles,// components from other libraries, and more.exportfunctionuseMDXComponents(components:MDXComponents):MDXComponents{return{// Allows customizing built-in components, e.g. to add styling.h1:({ children })=>(<h1style={{ color:'red',fontSize:'48px'}}>{children}</h1>),img:(props)=>(<Imagesizes=""100vw""style={{ width:'100%',height:'auto'}}{...(propsasImageProps)}/>),...components,}}Local styles and componentsYou can apply local styles and components to specific pages by passing them into imported MDX components. These will merge with and overrideglobal styles and components.app/mdx-page/page.tsxTypeScriptJavaScriptTypeScriptimportWelcomefrom'@/markdown/welcome.mdx'functionCustomH1({ children }) {return<h1style={{ color:'blue',fontSize:'100px'}}>{children}</h1>}constoverrideComponents={h1:CustomH1,}exportdefaultfunctionPage() {return<Welcomecomponents={overrideComponents} />}Shared layoutsTo share a layout across MDX pages, you can use thebuilt-in layouts supportwith the App Router.app/mdx-page/layout.tsxTypeScriptJavaScriptTypeScriptexportdefaultfunctionMdxLayout({ children }:{ children:React.ReactNode}) {// Create any shared layout or styles herereturn<divstyle={{ color:'blue'}}>{children}</div>}Using Tailwind typography pluginIf you are usingTailwindto style your application, using the@tailwindcss/typographypluginwill allow you to reuse your Tailwind configuration and styles in your markdown files.The plugin adds a set ofproseclasses that can be used to add typographic styles to content blocks that come from sources, like markdown.Install Tailwind typographyand use withshared layoutsto add theproseyou want.app/mdx-page/layout.tsxTypeScriptJavaScriptTypeScriptexportdefaultfunctionMdxLayout({ children }:{ children:React.ReactNode}) {// Create any shared layout or styles herereturn(<divclassName=""prose prose-headings:mt-8 prose-headings:font-semibold prose-headings:text-black prose-h1:text-5xl prose-h2:text-4xl prose-h3:text-3xl prose-h4:text-2xl prose-h5:text-xl prose-h6:text-lg dark:prose-headings:text-white"">{children}</div>)}FrontmatterFrontmatter is a YAML like key/value pairing that can be used to store data about a page.@next/mdxdoesnotsupport frontmatter by default, though there are many solutions for adding frontmatter to your MDX content, such as:remark-frontmatterremark-mdx-frontmattergray-matter@next/mdxdoesallow you to use exports like any other JavaScript component:Metadata can now be referenced outside of the MDX file:app/blog/page.tsxTypeScriptJavaScriptTypeScriptimportBlogPost,{ metadata }from'@/content/blog-post.mdx'exportdefaultfunctionPage() {console.log('metadata: ',metadata)//=> { author: 'John Doe' }return<BlogPost/>}A common use case for this is when you want to iterate over a collection of MDX and extract data. For example, creating a blog index page from all blog posts. You can use packages likeNode'sfsmoduleorglobbyto read a directory of posts and extract the metadata.Good to know:Usingfs,globby, etc. can only be used server-side.View thePortfolio Starter Kittemplate for a complete working example.remark and rehype PluginsYou can optionally provide remark and rehype plugins to transform the MDX content.For example, you can useremark-gfmto support GitHub Flavored Markdown.Since the remark and rehype ecosystem is ESM only, you'll need to usenext.config.mjsornext.config.tsas the configuration file.next.config.mjsimportremarkGfmfrom'remark-gfm'importcreateMDXfrom'@next/mdx'/**@type{import('next').NextConfig}*/constnextConfig={// Allow .mdx extensions for filespageExtensions:['js','jsx','md','mdx','ts','tsx'],// Optionally, add any other Next.js config below}constwithMDX=createMDX({// Add markdown plugins here, as desiredoptions:{remarkPlugins:[remarkGfm],rehypePlugins:[],},})// Combine MDX and Next.js configexportdefaultwithMDX(nextConfig)Using Plugins with TurbopackTo use plugins withTurbopack, upgrade to the latest@next/mdxand specify plugin names using a string:next.config.mjsimportcreateMDXfrom'@next/mdx'/**@type{import('next').NextConfig}*/constnextConfig={pageExtensions:['js','jsx','md','mdx','ts','tsx'],}constwithMDX=createMDX({options:{remarkPlugins:[],rehypePlugins:[['rehype-katex',{ strict:true,throwOnError:true}]],},})exportdefaultwithMDX(nextConfig)Good to know:remark and rehype plugins without serializable options cannot be used yet withTurbopack, due toinability to pass JavaScript functions to RustRemote MDXIf your MDX files or content livessomewhere else, you can fetch it dynamically on the server. This is useful for content stored in a CMS, database, or anywhere else. A popular community package for this use isnext-mdx-remote.Good to know: Please proceed with caution. MDX compiles to JavaScript and is executed on the server. You should only fetch MDX content from a trusted source, otherwise this can lead to remote code execution (RCE).The following example usesnext-mdx-remote:app/mdx-page-remote/page.tsxTypeScriptJavaScriptTypeScriptimport{ MDXRemote }from'next-mdx-remote/rsc'exportdefaultasyncfunctionRemoteMdxPage() {// MDX text - can be from a database, CMS, fetch, anywhere...constres=awaitfetch('https://...')constmarkdown=awaitres.text()return<MDXRemotesource={markdown} />}Navigating to the/mdx-page-remoteroute should display your rendered MDX.Deep Dive: How do you transform markdown into HTML?React does not natively understand markdown. The markdown plaintext needs to first be transformed into HTML. This can be accomplished withremarkandrehype.remarkis an ecosystem of tools around markdown.rehypeis the same, but for HTML. For example, the following code snippet transforms markdown into HTML:import{ unified }from'unified'importremarkParsefrom'remark-parse'importremarkRehypefrom'remark-rehype'importrehypeSanitizefrom'rehype-sanitize'importrehypeStringifyfrom'rehype-stringify'main()asyncfunctionmain() {constfile=awaitunified().use(remarkParse)// Convert into markdown AST.use(remarkRehype)// Transform to HTML AST.use(rehypeSanitize)// Sanitize HTML input.use(rehypeStringify)// Convert AST into serialized HTML.process('Hello, Next.js!')console.log(String(file))// <p>Hello, Next.js!</p>}Theremarkandrehypeecosystem contains plugins forsyntax highlighting,linking headings,generating a table of contents, and more.When using@next/mdxas shown above, youdo notneed to useremarkorrehypedirectly, as it is handled for you. We're describing it here for a deeper understanding of what the@next/mdxpackage is doing underneath.Using the Rust-based MDX compiler (experimental)Next.js supports a new MDX compiler written in Rust. This compiler is still experimental and is not recommended for production use. To use the new compiler, you need to configurenext.config.jswhen you pass it towithMDX:next.config.jsmodule.exports=withMDX({experimental:{mdxRs:true,},})mdxRsalso accepts an object to configure how to transform mdx files.next.config.jsmodule.exports=withMDX({experimental:{mdxRs:{jsxRuntime?:string// Custom jsx runtimejsxImportSource?:string// Custom jsx import source,mdxType?:'gfm'|'commonmark'// Configure what kind of mdx syntax will be used to parse & transform},},})Helpful LinksMDX@next/mdxremarkrehypeMarkdocPreviousEnvironment VariablesNextsrc DirectoryWas this helpful?supported.Send"
src directory,src Directory,"Building Your ApplicationConfiguringsrc Directorysrc DirectoryAs an alternative to having the special Next.jsapporpagesdirectories in the root of your project, Next.js also supports the common pattern of placing application code under thesrcdirectory.This separates application code from project configuration files which mostly live in the root of a project, which is preferred by some individuals and teams.To use thesrcdirectory, move theappRouter folder orpagesRouter folder tosrc/apporsrc/pagesrespectively.Good to know:The/publicdirectory should remain in the root of your project.Config files likepackage.json,next.config.jsandtsconfig.jsonshould remain in the root of your project..env.*files should remain in the root of your project.src/apporsrc/pageswill be ignored ifapporpagesare present in the root directory.If you're usingsrc, you'll probably also move other application folders such as/componentsor/lib.If you're using Middleware, ensure it is placed inside thesrcdirectory.If you're using Tailwind CSS, you'll need to add the/srcprefix to thetailwind.config.jsfile in thecontent section.If you are using TypeScript paths for imports such as@/*, you should update thepathsobject intsconfig.jsonto includesrc/.Next StepsProject StructureAn overview of the folder and file conventions in Next.js, and how to organize your project.PreviousMDXNextCustom ServerWas this helpful?supported.Send"
custom server,Custom Server,"Building Your ApplicationConfiguringCustom ServerCustom ServerNext.js includes its own server withnext startby default. If you have an existing backend, you can still use it with Next.js (this is not a custom server). A custom Next.js server allows you to programmatically start a server for custom patterns. The majority of the time, you will not need this approach. However, it's available if you need to eject.Good to know:Before deciding to use a custom server, keep in mind that it should only be used when the integrated router of Next.js can't meet your app requirements. A custom server will remove important performance optimizations, likeAutomatic Static Optimization.A custom servercannotbe deployed onVercel.When using standalone output mode, it does not trace custom server files. This mode outputs a separate minimalserver.jsfile, instead. These cannot be used together.Take a look at thefollowing exampleof a custom server:server.tsTypeScriptJavaScriptTypeScriptimport{ createServer }from'http'import{ parse }from'url'importnextfrom'next'constport=parseInt(process.env.PORT||'3000',10)constdev=process.env.NODE_ENV!=='production'constapp=next({ dev })consthandle=app.getRequestHandler()app.prepare().then(()=>{createServer((req,res)=>{constparsedUrl=parse(req.url!,true)handle(req,res,parsedUrl)}).listen(port)console.log(`> Server listening at http://localhost:${port}as${dev?'development':process.env.NODE_ENV}`)})server.jsdoes not run through the Next.js Compiler or bundling process. Make sure the syntax and source code this file requires are compatible with the current Node.js version you are using.View an example.To run the custom server, you'll need to update thescriptsinpackage.jsonlike so:package.json{""scripts"":{""dev"":""node server.js"",""build"":""next build"",""start"":""NODE_ENV=production node server.js""}}Alternatively, you can set upnodemon(example). The custom server uses the following import to connect the server with the Next.js application:importnextfrom'next'constapp=next({})The abovenextimport is a function that receives an object with the following options:OptionTypeDescriptionconfObjectThe same object you would use innext.config.js. Defaults to{}devBoolean(Optional) Whether or not to launch Next.js in dev mode. Defaults tofalsedirString(Optional) Location of the Next.js project. Defaults to'.'quietBoolean(Optional) Hide error messages containing server information. Defaults tofalsehostnameString(Optional) The hostname the server is running behindportNumber(Optional) The port the server is running behindhttpServernode:http#Server(Optional) The HTTP Server that Next.js is running behindturboBoolean(Optional) Enable TurbopackThe returnedappcan then be used to let Next.js handle requests as required.Previoussrc DirectoryNextDraft ModeWas this helpful?supported.Send"
draft mode,Draft Mode,"Building Your ApplicationConfiguringDraft ModeDraft ModeDraft Modeallows you to preview draft content from your headless CMS in your Next.js application. This is useful for static pages that are generated at build time as it allows you to switch todynamic renderingand see the draft changes without having to rebuild your entire site.This page walks through how to enable and use Draft Mode.Step 1: Create a Route HandlerCreate aRoute Handler. It can have any name, for example,app/api/draft/route.ts.app/api/draft/route.tsTypeScriptJavaScriptTypeScriptexportasyncfunctionGET(request:Request) {returnnewResponse('')}Then, import thedraftModefunction and call theenable()method.app/api/draft/route.tsTypeScriptJavaScriptTypeScriptimport{ draftMode }from'next/headers'exportasyncfunctionGET(request:Request) {constdraft=awaitdraftMode()draft.enable()returnnewResponse('Draft mode is enabled')}This will set acookieto enable draft mode. Subsequent requests containing this cookie will trigger draft mode and change the behavior of statically generated pages.You can test this manually by visiting/api/draftand looking at your browser’s developer tools. Notice theSet-Cookieresponse header with a cookie named__prerender_bypass.Step 2: Access the Route Handler from your Headless CMSThese steps assume that the headless CMS you’re using supports settingcustom draft URLs. If it doesn’t, you can still use this method to secure your draft URLs, but you’ll need to construct and access the draft URL manually. The specific steps will vary depending on which headless CMS you’re using.To securely access the Route Handler from your headless CMS:Create asecret token stringusing a token generator of your choice. This secret will only be known by your Next.js app and your headless CMS.If your headless CMS supports setting custom draft URLs, specify a draft URL (this assumes that your Route Handler is located atapp/api/draft/route.ts). For example:Terminalhttps://<your-site>/api/draft?secret=<token>&slug=<path><your-site>should be your deployment domain.<token>should be replaced with the secret token you generated.<path>should be the path for the page that you want to view. If you want to view/posts/one, then you should use&slug=/posts/one.Your headless CMS might allow you to include a variable in the draft URL so that<path>can be set dynamically based on the CMS’s data like so:&slug=/posts/{entry.fields.slug}In your Route Handler, check that the secret matches and that theslugparameter exists (if not, the request should fail), calldraftMode.enable()to set the cookie. Then, redirect the browser to the path specified byslug:app/api/draft/route.tsTypeScriptJavaScriptTypeScriptimport{ draftMode }from'next/headers'import{ redirect }from'next/navigation'exportasyncfunctionGET(request:Request) {// Parse query string parametersconst{searchParams}=newURL(request.url)constsecret=searchParams.get('secret')constslug=searchParams.get('slug')// Check the secret and next parameters// This secret should only be known to this Route Handler and the CMSif(secret!=='MY_SECRET_TOKEN'||!slug) {returnnewResponse('Invalid token',{ status:401})}// Fetch the headless CMS to check if the provided `slug` exists// getPostBySlug would implement the required fetching logic to the headless CMSconstpost=awaitgetPostBySlug(slug)// If the slug doesn't exist prevent draft mode from being enabledif(!post) {returnnewResponse('Invalid slug',{ status:401})}// Enable Draft Mode by setting the cookieconstdraft=awaitdraftMode()draft.enable()// Redirect to the path from the fetched post// We don't redirect to searchParams.slug as that might lead to open redirect vulnerabilitiesredirect(post.slug)}If it succeeds, then the browser will be redirected to the path you want to view with the draft mode cookie.Step 3: Preview the Draft ContentThe next step is to update your page to check the value ofdraftMode().isEnabled.If you request a page which has the cookie set, then data will be fetched atrequest time(instead of at build time).Furthermore, the value ofisEnabledwill betrue.app/page.tsxTypeScriptJavaScriptTypeScript// page that fetches dataimport{ draftMode }from'next/headers'asyncfunctiongetData() {const{isEnabled}=awaitdraftMode()consturl=isEnabled?'https://draft.example.com':'https://production.example.com'constres=awaitfetch(url)returnres.json()}exportdefaultasyncfunctionPage() {const{title,desc}=awaitgetData()return(<main><h1>{title}</h1><p>{desc}</p></main>)}If you access the draft Route Handler (withsecretandslug) from your headless CMS or manually using the URL, you should now be able to see the draft content. And, if you update your draft without publishing, you should be able to view the draft.Next StepsSee the API reference for more information on how to use Draft Mode.draftModeAPI Reference for the draftMode function.PreviousCustom ServerNextContent Security PolicyWas this helpful?supported.Send"
content security policy,Content Security Policy,"Building Your ApplicationConfiguringContent Security PolicyContent Security PolicyContent Security Policy (CSP)is important to guard your Next.js application against various security threats such as cross-site scripting (XSS), clickjacking, and other code injection attacks.By using CSP, developers can specify which origins are permissible for content sources, scripts, stylesheets, images, fonts, objects, media (audio, video), iframes, and more.ExamplesStrict CSPNoncesAnonceis a unique, random string of characters created for a one-time use. It is used in conjunction with CSP to selectively allow certain inline scripts or styles to execute, bypassing strict CSP directives.Why use a nonce?Even though CSPs are designed to block malicious scripts, there are legitimate scenarios where inline scripts are necessary. In such cases, nonces offer a way to allow these scripts to execute if they have the correct nonce.Adding a nonce with MiddlewareMiddlewareenables you to add headers and generate nonces before the page renders.Every time a page is viewed, a fresh nonce should be generated. This means that youmust use dynamic rendering to add nonces.For example:middleware.tsTypeScriptJavaScriptTypeScriptimport{ NextRequest,NextResponse }from'next/server'exportfunctionmiddleware(request:NextRequest) {constnonce=Buffer.from(crypto.randomUUID()).toString('base64')constcspHeader=`default-src 'self';script-src 'self' 'nonce-${nonce}' 'strict-dynamic';style-src 'self' 'nonce-${nonce}';img-src 'self' blob: data:;font-src 'self';object-src 'none';base-uri 'self';form-action 'self';frame-ancestors 'none';upgrade-insecure-requests;`// Replace newline characters and spacesconstcontentSecurityPolicyHeaderValue=cspHeader.replace(/\s{2,}/g,' ').trim()constrequestHeaders=newHeaders(request.headers)requestHeaders.set('x-nonce',nonce)requestHeaders.set('Content-Security-Policy',contentSecurityPolicyHeaderValue)constresponse=NextResponse.next({request:{headers:requestHeaders,},})response.headers.set('Content-Security-Policy',contentSecurityPolicyHeaderValue)returnresponse}By default, Middleware runs on all requests. You can filter Middleware to run on specific paths using amatcher.We recommend ignoring matching prefetches (fromnext/link) and static assets that don't need the CSP header.middleware.tsTypeScriptJavaScriptTypeScriptexportconstconfig={matcher:[/** Match all request paths except for the ones starting with:* - api (API routes)* - _next/static (static files)* - _next/image (image optimization files)* - favicon.ico (favicon file)*/{source:'/((?!api|_next/static|_next/image|favicon.ico).*)',missing:[{ type:'header',key:'next-router-prefetch'},{ type:'header',key:'purpose',value:'prefetch'},],},],}Reading the nonceYou can now read the nonce from aServer Componentusingheaders:app/page.tsxTypeScriptJavaScriptTypeScriptimport{ headers }from'next/headers'importScriptfrom'next/script'exportdefaultasyncfunctionPage() {constnonce=(awaitheaders()).get('x-nonce')return(<Scriptsrc=""https://www.googletagmanager.com/gtag/js""strategy=""afterInteractive""nonce={nonce}/>)}Without NoncesFor applications that do not require nonces, you can set the CSP header directly in yournext.config.jsfile:next.config.jsconstcspHeader=`default-src 'self';script-src 'self' 'unsafe-eval' 'unsafe-inline';style-src 'self' 'unsafe-inline';img-src 'self' blob: data:;font-src 'self';object-src 'none';base-uri 'self';form-action 'self';frame-ancestors 'none';upgrade-insecure-requests;`module.exports={asyncheaders() {return[{source:'/(.*)',headers:[{key:'Content-Security-Policy',value:cspHeader.replace(/\n/g,''),},],},]},}Version HistoryWe recommend usingv13.4.20+of Next.js to properly handle and apply nonces.Next StepsMiddlewareLearn how to use Middleware to run code before a request is completed.headersAPI reference for the headers function.PreviousDraft ModeNextDebuggingWas this helpful?supported.Send"
debugging,Debugging,"Building Your ApplicationConfiguringDebuggingDebuggingThis documentation explains how you can debug your Next.js frontend and backend code with full source maps support using theVS Code debugger,Chrome DevTools, orFirefox DevTools.Any debugger that can attach to Node.js can also be used to debug a Next.js application. You can find more details in the Node.jsDebugging Guide.Debugging with VS CodeCreate a file named.vscode/launch.jsonat the root of your project with the following content:launch.json{""version"":""0.2.0"",""configurations"":[{""name"":""Next.js: debug server-side"",""type"":""node-terminal"",""request"":""launch"",""command"":""npm run dev""},{""name"":""Next.js: debug client-side"",""type"":""chrome"",""request"":""launch"",""url"":""http://localhost:3000""},{""name"":""Next.js: debug client-side (Firefox)"",""type"":""firefox"",""request"":""launch"",""url"":""http://localhost:3000"",""reAttach"":true,""pathMappings"":[{""url"":""webpack://_N_E"",""path"":""${workspaceFolder}""}]},{""name"":""Next.js: debug full stack"",""type"":""node"",""request"":""launch"",""program"":""${workspaceFolder}/node_modules/.bin/next"",""runtimeArgs"":[""--inspect""],""skipFiles"":[""<node_internals>/**""],""serverReadyAction"":{""action"":""debugWithEdge"",""killOnServerStop"":true,""pattern"":""- Local:.+(https?://.+)"",""uriFormat"":""%s"",""webRoot"":""${workspaceFolder}""}}]}Note: To use Firefox debugging in VS Code, you'll need to install theFirefox Debugger extension.npm run devcan be replaced withyarn devif you're using Yarn orpnpm devif you're using pnpm.In the ""Next.js: debug full stack"" configuration,serverReadyAction.actionspecifies which browser to open when the server is ready.debugWithEdgemeans to launch the Edge browser. If you are using Chrome, change this value todebugWithChrome.If you'rechanging the port numberyour application starts on, replace the3000inhttp://localhost:3000with the port you're using instead.If you're running Next.js from a directory other than root (for example, if you're using Turborepo) then you need to addcwdto the server-side and full stack debugging tasks. For example,""cwd"": ""${workspaceFolder}/apps/web"".Now go to the Debug panel (Ctrl+Shift+Don Windows/Linux,⇧+⌘+Don macOS), select a launch configuration, then pressF5or selectDebug: Start Debuggingfrom the Command Palette to start your debugging session.Using the Debugger in Jetbrains WebStormClick the drop down menu listing the runtime configuration, and clickEdit Configurations.... Create aJavaScript Debugdebug configuration withhttp://localhost:3000as the URL. Customize to your liking (e.g. Browser for debugging, store as project file), and clickOK. Run this debug configuration, and the selected browser should automatically open. At this point, you should have 2 applications in debug mode: the NextJS node application, and the client/browser application.Debugging with Browser DevToolsClient-side codeStart your development server as usual by runningnext dev,npm run dev, oryarn dev. Once the server starts, openhttp://localhost:3000(or your alternate URL) in your preferred browser.For Chrome:Open Chrome's Developer Tools (Ctrl+Shift+Jon Windows/Linux,⌥+⌘+Ion macOS)Go to theSourcestabFor Firefox:Open Firefox's Developer Tools (Ctrl+Shift+Ion Windows/Linux,⌥+⌘+Ion macOS)Go to theDebuggertabIn either browser, any time your client-side code reaches adebuggerstatement, code execution will pause and that file will appear in the debug area. You can also search for files to set breakpoints manually:In Chrome: PressCtrl+Pon Windows/Linux or⌘+Pon macOSIn Firefox: PressCtrl+Pon Windows/Linux or⌘+Pon macOS, or use the file tree in the left panelNote that when searching, your source files will have paths starting withwebpack://_N_E/./.Server-side codeTo debug server-side Next.js code with browser DevTools, you need to pass the--inspectflag to the underlying Node.js process:TerminalNODE_OPTIONS='--inspect'nextdevGood to know: UseNODE_OPTIONS='--inspect=0.0.0.0'to allow remote debugging access outside localhost, such as when running the app in a Docker container.If you're usingnpm run devoryarn devthen you should update thedevscript on yourpackage.json:package.json{""scripts"":{""dev"":""NODE_OPTIONS='--inspect' next dev""}}Launching the Next.js dev server with the--inspectflag will look something like this:TerminalDebuggerlisteningonws://127.0.0.1:9229/0cf90313-350d-4466-a748-cd60f4e47c95Forhelp,see:https://nodejs.org/en/docs/inspectorready-startedserveron0.0.0.0:3000,url:http://localhost:3000For Chrome:Open a new tab and visitchrome://inspectClickConfigure...to ensure both debugging ports are listedAdd bothlocalhost:9229andlocalhost:9230if they're not already presentLook for your Next.js application in theRemote TargetsectionClickinspectto open a separate DevTools windowGo to theSourcestabFor Firefox:Open a new tab and visitabout:debuggingClickThis Firefoxin the left sidebarUnderRemote Targets, find your Next.js applicationClickInspectto open the debuggerGo to theDebuggertabDebugging server-side code works similarly to client-side debugging. When searching for files (Ctrl+P/⌘+P), your source files will have paths starting withwebpack://{application-name}/./(where{application-name}will be replaced with the name of your application according to yourpackage.jsonfile).Inspect Server Errors with Browser DevToolsWhen you encounter an error, inspecting the source code can help trace the root cause of errors.Next.js will display a Node.js icon underneath the Next.js version indicator on the error overlay. By clicking that icon, the DevTools URL is copied to your clipboard. You can open a new browser tab with that URL to inspect the Next.js server process.Debugging on WindowsWindows users may run into an issue when usingNODE_OPTIONS='--inspect'as that syntax is not supported on Windows platforms. To get around this, install thecross-envpackage as a development dependency (-Dwithnpmandyarn) and replace thedevscript with the following.package.json{""scripts"":{""dev"":""cross-env NODE_OPTIONS='--inspect' next dev""}}cross-envwill set theNODE_OPTIONSenvironment variable regardless of which platform you are on (including Mac, Linux, and Windows) and allow you to debug consistently across devices and operating systems.Good to know: Ensure Windows Defender is disabled on your machine. This external service will checkevery file read, which has been reported to greatly increase Fast Refresh time withnext dev. This is a known issue, not related to Next.js, but it does affect Next.js development.More informationTo learn more about how to use a JavaScript debugger, take a look at the following documentation:Node.js debugging in VS Code: BreakpointsChrome DevTools: Debug JavaScriptFirefox DevTools: DebuggerPreviousContent Security PolicyNextProgressive Web Applications (PWA)Was this helpful?supported.Send"
progressive web applications (pwa),Progressive Web Applications (PWA),"Building Your ApplicationConfiguringProgressive Web Applications (PWA)Progressive Web Applications (PWA)Progressive Web Applications (PWAs) offer the reach and accessibility of web applications combined with the features and user experience of native mobile apps. With Next.js, you can create PWAs that provide a seamless, app-like experience across all platforms without the need for multiple codebases or app store approvals.PWAs allow you to:Deploy updates instantly without waiting for app store approvalCreate cross-platform applications with a single codebaseProvide native-like features such as home screen installation and push notificationsCreating a PWA with Next.js1. Creating the Web App ManifestNext.js provides built-in support for creating aweb app manifestusing the App Router. You can create either a static or dynamic manifest file:For example, create aapp/manifest.tsorapp/manifest.jsonfile:app/manifest.tsTypeScriptJavaScriptTypeScriptimporttype{ MetadataRoute }from'next'exportdefaultfunctionmanifest():MetadataRoute.Manifest{return{name:'Next.js PWA',short_name:'NextPWA',description:'A Progressive Web App built with Next.js',start_url:'/',display:'standalone',background_color:'#ffffff',theme_color:'#000000',icons:[{src:'/icon-192x192.png',sizes:'192x192',type:'image/png',},{src:'/icon-512x512.png',sizes:'512x512',type:'image/png',},],}}This file should contain information about the name, icons, and how it should be displayed as an icon on the user's device. This will allow users to install your PWA on their home screen, providing a native app-like experience.You can use tools likefavicon generatorsto create the different icon sets and place the generated files in yourpublic/folder.2. Implementing Web Push NotificationsWeb Push Notifications are supported with all modern browsers, including:iOS 16.4+ for applications installed to the home screenSafari 16 for macOS 13 or laterChromium based browsersFirefoxThis makes PWAs a viable alternative to native apps. Notably, you can trigger install prompts without needing offline support.Web Push Notifications allow you to re-engage users even when they're not actively using your app. Here's how to implement them in a Next.js application:First, let's create the main page component inapp/page.tsx. We'll break it down into smaller parts for better understanding. First, we’ll add some of the imports and utilities we’ll need. It’s okay that the referenced Server Actions do not yet exist:'use client'import{ useState,useEffect }from'react'import{ subscribeUser,unsubscribeUser,sendNotification }from'./actions'functionurlBase64ToUint8Array(base64String:string) {constpadding='='.repeat((4-(base64String.length%4))%4)constbase64=(base64String+padding).replace(/-/g,'+').replace(/_/g,'/')constrawData=window.atob(base64)constoutputArray=newUint8Array(rawData.length)for(leti=0; i<rawData.length;++i) {outputArray[i]=rawData.charCodeAt(i)}returnoutputArray}Let’s now add a component to manage subscribing, unsubscribing, and sending push notifications.functionPushNotificationManager() {const[isSupported,setIsSupported]=useState(false)const[subscription,setSubscription]=useState<PushSubscription|null>(null)const[message,setMessage]=useState('')useEffect(()=>{if('serviceWorker'innavigator&&'PushManager'inwindow) {setIsSupported(true)registerServiceWorker()}},[])asyncfunctionregisterServiceWorker() {constregistration=awaitnavigator.serviceWorker.register('/sw.js',{scope:'/',updateViaCache:'none',})constsub=awaitregistration.pushManager.getSubscription()setSubscription(sub)}asyncfunctionsubscribeToPush() {constregistration=awaitnavigator.serviceWorker.readyconstsub=awaitregistration.pushManager.subscribe({userVisibleOnly:true,applicationServerKey:urlBase64ToUint8Array(process.env.NEXT_PUBLIC_VAPID_PUBLIC_KEY!),})setSubscription(sub)constserializedSub=JSON.parse(JSON.stringify(sub))awaitsubscribeUser(serializedSub)}asyncfunctionunsubscribeFromPush() {awaitsubscription?.unsubscribe()setSubscription(null)awaitunsubscribeUser()}asyncfunctionsendTestNotification() {if(subscription) {awaitsendNotification(message)setMessage('')}}if(!isSupported) {return<p>Push notifications are not supported in this browser.</p>}return(<div><h3>Push Notifications</h3>{subscription?(<><p>You are subscribed to push notifications.</p><buttononClick={unsubscribeFromPush}>Unsubscribe</button><inputtype=""text""placeholder=""Enter notification message""value={message}onChange={(e)=>setMessage(e.target.value)}/><buttononClick={sendTestNotification}>Send Test</button></>):(<><p>You are not subscribed to push notifications.</p><buttononClick={subscribeToPush}>Subscribe</button></>)}</div>)}Finally, let’s create a component to show a message for iOS devices to instruct them to install to their home screen, and only show this if the app is not already installed.functionInstallPrompt() {const[isIOS,setIsIOS]=useState(false)const[isStandalone,setIsStandalone]=useState(false)useEffect(()=>{setIsIOS(/iPad|iPhone|iPod/.test(navigator.userAgent)&&!(windowasany).MSStream)setIsStandalone(window.matchMedia('(display-mode: standalone)').matches)},[])if(isStandalone) {returnnull// Don't show install button if already installed}return(<div><h3>Install App</h3><button>Add to Home Screen</button>{isIOS&&(<p>To install this app on your iOS device, tap the share button<spanrole=""img""aria-label=""share icon"">{' '}⎋{' '}</span>and then ""Add to Home Screen""<spanrole=""img""aria-label=""plus icon"">{' '}➕{' '}</span>.</p>)}</div>)}exportdefaultfunctionPage() {return(<div><PushNotificationManager/><InstallPrompt/></div>)}Now, let’s create the Server Actions which this file calls.3. Implementing Server ActionsCreate a new file to contain your actions atapp/actions.ts. This file will handle creating subscriptions, deleting subscriptions, and sending notifications.app/actions.tsTypeScriptJavaScriptTypeScript'use server'importwebpushfrom'web-push'webpush.setVapidDetails('<mailto:your-email@example.com>',process.env.NEXT_PUBLIC_VAPID_PUBLIC_KEY!,process.env.VAPID_PRIVATE_KEY!)letsubscription:PushSubscription|null=nullexportasyncfunctionsubscribeUser(sub:PushSubscription) {subscription=sub// In a production environment, you would want to store the subscription in a database// For example: await db.subscriptions.create({ data: sub })return{ success:true}}exportasyncfunctionunsubscribeUser() {subscription=null// In a production environment, you would want to remove the subscription from the database// For example: await db.subscriptions.delete({ where: { ... } })return{ success:true}}exportasyncfunctionsendNotification(message:string) {if(!subscription) {thrownewError('No subscription available')}try{awaitwebpush.sendNotification(subscription,JSON.stringify({title:'Test Notification',body:message,icon:'/icon.png',}))return{ success:true}}catch(error) {console.error('Error sending push notification:',error)return{ success:false,error:'Failed to send notification'}}}Sending a notification will be handled by our service worker, created in step 5.In a production environment, you would want to store the subscription in a database for persistence across server restarts and to manage multiple users' subscriptions.4. Generating VAPID KeysTo use the Web Push API, you need to generateVAPIDkeys. The simplest way is to use the web-push CLI directly:First, install web-push globally:Terminalnpminstall-gweb-pushGenerate the VAPID keys by running:Terminalweb-pushgenerate-vapid-keysCopy the output and paste the keys into your.envfile:NEXT_PUBLIC_VAPID_PUBLIC_KEY=your_public_key_hereVAPID_PRIVATE_KEY=your_private_key_here5. Creating a Service WorkerCreate apublic/sw.jsfile for your service worker:public/sw.jsself.addEventListener('push',function(event) {if(event.data) {constdata=event.data.json()constoptions={body:data.body,icon:data.icon||'/icon.png',badge:'/badge.png',vibrate:[100,50,100],data:{dateOfArrival:Date.now(),primaryKey:'2',},}event.waitUntil(self.registration.showNotification(data.title,options))}})self.addEventListener('notificationclick',function(event) {console.log('Notification click received.')event.notification.close()event.waitUntil(clients.openWindow('<https://your-website.com>'))})This service worker supports custom images and notifications. It handles incoming push events and notification clicks.You can set custom icons for notifications using theiconandbadgeproperties.Thevibratepattern can be adjusted to create custom vibration alerts on supported devices.Additional data can be attached to the notification using thedataproperty.Remember to test your service worker thoroughly to ensure it behaves as expected across different devices and browsers. Also, make sure to update the'https://your-website.com'link in thenotificationclickevent listener to the appropriate URL for your application.6. Adding to Home ScreenTheInstallPromptcomponent defined in step 2 shows a message for iOS devices to instruct them to install to their home screen.To ensure your application can be installed to a mobile home screen, you must have:A valid web app manifest (created in step 1)The website served over HTTPSModern browsers will automatically show an installation prompt to users when these criteria are met. You can provide a custom installation button withbeforeinstallprompt, however, we do not recommend this as it is not cross browser and platform (does not work on Safari iOS).7. Testing LocallyTo ensure you can view notifications locally, ensure that:You arerunning locally with HTTPSUsenext dev --experimental-httpsfor testingYour browser (Chrome, Safari, Firefox) has notifications enabledWhen prompted locally, accept permissions to use notificationsEnsure notifications are not disabled globally for the entire browserIf you are still not seeing notifications, try using another browser to debug8. Securing your applicationSecurity is a crucial aspect of any web application, especially for PWAs. Next.js allows you to configure security headers using thenext.config.jsfile. For example:next.config.jsmodule.exports={asyncheaders() {return[{source:'/(.*)',headers:[{key:'X-Content-Type-Options',value:'nosniff',},{key:'X-Frame-Options',value:'DENY',},{key:'Referrer-Policy',value:'strict-origin-when-cross-origin',},],},{source:'/sw.js',headers:[{key:'Content-Type',value:'application/javascript; charset=utf-8',},{key:'Cache-Control',value:'no-cache, no-store, must-revalidate',},{key:'Content-Security-Policy',value:""default-src 'self'; script-src 'self'"",},],},]},}Let’s go over each of these options:Global Headers (applied to all routes):X-Content-Type-Options: nosniff: Prevents MIME type sniffing, reducing the risk of malicious file uploads.X-Frame-Options: DENY: Protects against clickjacking attacks by preventing your site from being embedded in iframes.Referrer-Policy: strict-origin-when-cross-origin: Controls how much referrer information is included with requests, balancing security and functionality.Service Worker Specific Headers:Content-Type: application/javascript; charset=utf-8: Ensures the service worker is interpreted correctly as JavaScript.Cache-Control: no-cache, no-store, must-revalidate: Prevents caching of the service worker, ensuring users always get the latest version.Content-Security-Policy: default-src 'self'; script-src 'self': Implements a strict Content Security Policy for the service worker, only allowing scripts from the same origin.Learn more about definingContent Security Policieswith Next.js.Next StepsExploring PWA Capabilities: PWAs can leverage various web APIs to provide advanced functionality. Consider exploring features like background sync, periodic background sync, or the File System Access API to enhance your application. For inspiration and up-to-date information on PWA capabilities, you can refer to resources likeWhat PWA Can Do Today.Static Exports:If your application requires not running a server, and instead using a static export of files, you can update the Next.js configuration to enable this change. Learn more in theNext.js Static Export documentation. However, you will need to move from Server Actions to calling an external API, as well as moving your defined headers to your proxy.Offline Support: To provide offline functionality, one option isSerwistwith Next.js. You can find an example of how to integrate Serwist with Next.js in theirdocumentation.Note:this plugin currently requires webpack configuration.Security Considerations: Ensure that your service worker is properly secured. This includes using HTTPS, validating the source of push messages, and implementing proper error handling.User Experience: Consider implementing progressive enhancement techniques to ensure your app works well even when certain PWA features are not supported by the user's browser.Next Stepsmanifest.jsonAPI Reference for manifest.json file.PreviousDebuggingNextTestingWas this helpful?supported.Send"
testing,Testing,"App RouterBuilding Your ApplicationTestingTestingIn React and Next.js, there are a few different types of tests you can write, each with its own purpose and use cases. This page provides an overview of types and commonly used tools you can use to test your application.Types of testsUnit Testinginvolves testing individual units (or blocks of code) in isolation. In React, a unit can be a single function, hook, or component.Component Testingis a more focused version of unit testing where the primary subject of the tests is React components. This may involve testing how components are rendered, their interaction with props, and their behavior in response to user events.Integration Testinginvolves testing how multiple units work together. This can be a combination of components, hooks, and functions.End-to-End (E2E) Testinginvolves testing user flows in an environment that simulates real user scenarios, like the browser. This means testing specific tasks (e.g. signup flow) in a production-like environment.Snapshot Testinginvolves capturing the rendered output of a component and saving it to a snapshot file. When tests run, the current rendered output of the component is compared against the saved snapshot. Changes in the snapshot are used to indicate unexpected changes in behavior.Async Server ComponentsSinceasyncServer Components are new to the React ecosystem, some tools do not fully support them. In the meantime, we recommend usingEnd-to-End TestingoverUnit Testingforasynccomponents.GuidesSee the guides below to learn how to set up Next.js with these commonly used testing tools:VitestLearn how to set up Vitest with Next.js for Unit Testing.JestLearn how to set up Jest with Next.js for Unit Testing and Snapshot Testing.PlaywrightLearn how to set up Playwright with Next.js for End-to-End (E2E) Testing.CypressLearn how to set up Cypress with Next.js for End-to-End (E2E) and Component Testing.PreviousProgressive Web Applications (PWA)NextVitestWas this helpful?supported.Send"
vitest,Vitest,"Building Your ApplicationTestingVitestSetting up Vitest with Next.jsVite and React Testing Library are frequently used together forUnit Testing. This guide will show you how to setup Vitest with Next.js and write your first tests.Good to know:SinceasyncServer Components are new to the React ecosystem, Vitest currently does not support them. While you can still rununit testsfor synchronous Server and Client Components, we recommend using anE2E testsforasynccomponents.QuickstartYou can usecreate-next-appwith the Next.jswith-vitestexample to quickly get started:Terminalnpxcreate-next-app@latest--examplewith-vitestwith-vitest-appManual SetupTo manually set up Vitest, installvitestand the following packages as dev dependencies:Terminal# Using TypeScriptnpminstall-Dvitest@vitejs/plugin-reactjsdom@testing-library/react@testing-library/domvite-tsconfig-paths# Using JavaScriptnpminstall-Dvitest@vitejs/plugin-reactjsdom@testing-library/react@testing-library/domCreate avitest.config.mts|jsfile in the root of your project, and add the following options:vitest.config.mtsTypeScriptJavaScriptTypeScriptimport{ defineConfig }from'vitest/config'importreactfrom'@vitejs/plugin-react'importtsconfigPathsfrom'vite-tsconfig-paths'exportdefaultdefineConfig({plugins:[tsconfigPaths(),react()],test:{environment:'jsdom',},})For more information on configuring Vitest, please refer to theVitest Configurationdocs.Then, add atestscript to yourpackage.json:package.json{""scripts"":{""dev"":""next dev"",""build"":""next build"",""start"":""next start"",""test"":""vitest""}}When you runnpm run test, Vitest willwatchfor changes in your project by default.Creating your first Vitest Unit TestCheck that everything is working by creating a test to check if the<Page />component successfully renders a heading:app/page.tsxTypeScriptJavaScriptTypeScriptimportLinkfrom'next/link'exportdefaultfunctionPage() {return(<div><h1>Home</h1><Linkhref=""/about"">About</Link></div>)}__tests__/page.test.tsxTypeScriptJavaScriptTypeScriptimport{ expect,test }from'vitest'import{ render,screen }from'@testing-library/react'importPagefrom'../app/page'test('Page',()=>{render(<Page/>)expect(screen.getByRole('heading',{ level:1,name:'Home'})).toBeDefined()})Good to know: The example above uses the common__tests__convention, but test files can also be colocated inside theapprouter.Running your testsThen, run the following command to run your tests:Terminalnpmruntest# oryarntest# orpnpmtest# orbuntestAdditional ResourcesYou may find these resources helpful:Next.js with Vitest exampleVitest DocsReact Testing Library DocsPreviousTestingNextJestWas this helpful?supported.Send"
jest,Jest,"Building Your ApplicationTestingJestSetting up Jest with Next.jsJest and React Testing Library are frequently used together forUnit TestingandSnapshot Testing. This guide will show you how to set up Jest with Next.js and write your first tests.Good to know:SinceasyncServer Components are new to the React ecosystem, Jest currently does not support them. While you can still rununit testsfor synchronous Server and Client Components, we recommend using anE2E testsforasynccomponents.QuickstartYou can usecreate-next-appwith the Next.jswith-jestexample to quickly get started:Terminalnpxcreate-next-app@latest--examplewith-jestwith-jest-appManual setupSince the release ofNext.js 12, Next.js now has built-in configuration for Jest.To set up Jest, installjestand the following packages as dev dependencies:Terminalnpminstall-Djestjest-environment-jsdom@testing-library/react@testing-library/dom@testing-library/jest-domts-node# oryarnadd-Djestjest-environment-jsdom@testing-library/react@testing-library/dom@testing-library/jest-domts-node# orpnpminstall-Djestjest-environment-jsdom@testing-library/react@testing-library/dom@testing-library/jest-domts-nodeGenerate a basic Jest configuration file by running the following command:Terminalnpminitjest@latest# oryarncreatejest@latest# orpnpmcreatejest@latestThis will take you through a series of prompts to setup Jest for your project, including automatically creating ajest.config.ts|jsfile.Update your config file to usenext/jest. This transformer has all the necessary configuration options for Jest to work with Next.js:jest.config.tsTypeScriptJavaScriptTypeScriptimporttype{ Config }from'jest'importnextJestfrom'next/jest.js'constcreateJestConfig=nextJest({// Provide the path to your Next.js app to load next.config.js and .env files in your test environmentdir:'./',})// Add any custom config to be passed to Jestconstconfig:Config={coverageProvider:'v8',testEnvironment:'jsdom',// Add more setup options before each test is run// setupFilesAfterEnv: ['<rootDir>/jest.setup.ts'],}// createJestConfig is exported this way to ensure that next/jest can load the Next.js config which is asyncexportdefaultcreateJestConfig(config)Under the hood,next/jestis automatically configuring Jest for you, including:Setting uptransformusing theNext.js Compiler.Auto mocking stylesheets (.css,.module.css, and their scss variants), image imports andnext/font.Loading.env(and all variants) intoprocess.env.Ignoringnode_modulesfrom test resolving and transforms.Ignoring.nextfrom test resolving.Loadingnext.config.jsfor flags that enable SWC transforms.Good to know: To test environment variables directly, load them manually in a separate setup script or in yourjest.config.tsfile. For more information, please seeTest Environment Variables.Optional: Handling Absolute Imports and Module Path AliasesIf your project is usingModule Path Aliases, you will need to configure Jest to resolve the imports by matching the paths option in thejsconfig.jsonfile with themoduleNameMapperoption in thejest.config.jsfile. For example:tsconfig.json or jsconfig.json{""compilerOptions"":{""module"":""esnext"",""moduleResolution"":""bundler"",""baseUrl"":""./"",""paths"":{""@/components/*"":[""components/*""]}}}jest.config.jsmoduleNameMapper:{// ...'^@/components/(.*)$':'<rootDir>/components/$1',}Optional: Extend Jest with custom matchers@testing-library/jest-domincludes a set of convenientcustom matcherssuch as.toBeInTheDocument()making it easier to write tests. You can import the custom matchers for every test by adding the following option to the Jest configuration file:jest.config.tsTypeScriptJavaScriptTypeScriptsetupFilesAfterEnv:['<rootDir>/jest.setup.ts']Then, insidejest.setup, add the following import:jest.setup.tsTypeScriptJavaScriptTypeScriptimport'@testing-library/jest-dom'Good to know:extend-expectwas removed inv6.0, so if you are using@testing-library/jest-dombefore version 6, you will need to import@testing-library/jest-dom/extend-expectinstead.If you need to add more setup options before each test, you can add them to thejest.setupfile above.Add a test script topackage.jsonFinally, add a Jesttestscript to yourpackage.jsonfile:package.json{""scripts"":{""dev"":""next dev"",""build"":""next build"",""start"":""next start"",""test"":""jest"",""test:watch"":""jest --watch""}}jest --watchwill re-run tests when a file is changed. For more Jest CLI options, please refer to theJest Docs.Creating your first testYour project is now ready to run tests. Create a folder called__tests__in your project's root directory.For example, we can add a test to check if the<Page />component successfully renders a heading:app/page.jsimportLinkfrom'next/link'exportdefaultfunctionPage() {return(<div><h1>Home</h1><Linkhref=""/about"">About</Link></div>)}__tests__/page.test.jsximport'@testing-library/jest-dom'import{ render,screen }from'@testing-library/react'importPagefrom'../app/page'describe('Page',()=>{it('renders a heading',()=>{render(<Page/>)constheading=screen.getByRole('heading',{ level:1})expect(heading).toBeInTheDocument()})})Optionally, add asnapshot testto keep track of any unexpected changes in your component:__tests__/snapshot.jsimport{ render }from'@testing-library/react'importPagefrom'../app/page'it('renders homepage unchanged',()=>{const{container}=render(<Page/>)expect(container).toMatchSnapshot()})Running your testsThen, run the following command to run your tests:Terminalnpmruntest# oryarntest# orpnpmtestAdditional ResourcesFor further reading, you may find these resources helpful:Next.js with Jest exampleJest DocsReact Testing Library DocsTesting Playground- use good testing practices to match elements.PreviousVitestNextPlaywrightWas this helpful?supported.Send"
playwright,Playwright,"Building Your ApplicationTestingPlaywrightSetting up Playwright with Next.jsPlaywright is a testing framework that lets you automate Chromium, Firefox, and WebKit with a single API. You can use it to writeEnd-to-End (E2E)testing. This guide will show you how to set up Playwright with Next.js and write your first tests.QuickstartThe fastest way to get started is to usecreate-next-appwith thewith-playwright example. This will create a Next.js project complete with Playwright configured.Terminalnpxcreate-next-app@latest--examplewith-playwrightwith-playwright-appManual setupTo install Playwright, run the following command:Terminalnpminitplaywright# oryarncreateplaywright# orpnpmcreateplaywrightThis will take you through a series of prompts to setup and configure Playwright for your project, including adding aplaywright.config.tsfile. Please refer to thePlaywright installation guidefor the step-by-step guide.Creating your first Playwright E2E testCreate two new Next.js pages:app/page.tsximportLinkfrom'next/link'exportdefaultfunctionPage() {return(<div><h1>Home</h1><Linkhref=""/about"">About</Link></div>)}app/about/page.tsximportLinkfrom'next/link'exportdefaultfunctionPage() {return(<div><h1>About</h1><Linkhref=""/"">Home</Link></div>)}Then, add a test to verify that your navigation is working correctly:tests/example.spec.tsimport{ test,expect }from'@playwright/test'test('should navigate to the about page',async({ page })=>{// Start from the index page (the baseURL is set via the webServer in the playwright.config.ts)awaitpage.goto('http://localhost:3000/')// Find an element with the text 'About' and click on itawaitpage.click('text=About')// The new URL should be ""/about"" (baseURL is used there)awaitexpect(page).toHaveURL('http://localhost:3000/about')// The new page should contain an h1 with ""About""awaitexpect(page.locator('h1')).toContainText('About')})Good to know: You can usepage.goto(""/"")instead ofpage.goto(""http://localhost:3000/""), if you add""baseURL"": ""http://localhost:3000""to theplaywright.config.tsconfiguration file.Running your Playwright testsPlaywright will simulate a user navigating your application using three browsers: Chromium, Firefox and Webkit, this requires your Next.js server to be running. We recommend running your tests against your production code to more closely resemble how your application will behave.Runnpm run buildandnpm run start, then runnpx playwright testin another terminal window to run the Playwright tests.Good to know: Alternatively, you can use thewebServerfeature to let Playwright start the development server and wait until it's fully available.Running Playwright on Continuous Integration (CI)Playwright will by default run your tests in theheadless mode. To install all the Playwright dependencies, runnpx playwright install-deps.You can learn more about Playwright and Continuous Integration from these resources:Next.js with Playwright examplePlaywright on your CI providerPlaywright DiscordPreviousJestNextCypressWas this helpful?supported.Send"
cypress,Cypress,"Building Your ApplicationTestingCypressSetting up Cypress with Next.jsCypressis a test runner used forEnd-to-End (E2E)andComponent Testing. This page will show you how to set up Cypress with Next.js and write your first tests.Warning:Cypress versions below 13.6.3 do not supportTypeScript version 5withmoduleResolution:""bundler"". However, this issue has been resolved in Cypress version 13.6.3 and later.cypress v13.6.3QuickstartYou can usecreate-next-appwith thewith-cypress exampleto quickly get started.Terminalnpxcreate-next-app@latest--examplewith-cypresswith-cypress-appManual setupTo manually set up Cypress, installcypressas a dev dependency:Terminalnpminstall-Dcypress# oryarnadd-Dcypress# orpnpminstall-DcypressAdd the Cypressopencommand to thepackage.jsonscripts field:package.json{""scripts"":{""dev"":""next dev"",""build"":""next build"",""start"":""next start"",""lint"":""next lint"",""cypress:open"":""cypress open""}}Run Cypress for the first time to open the Cypress testing suite:Terminalnpmruncypress:openYou can choose to configureE2E Testingand/orComponent Testing. Selecting any of these options will automatically create acypress.config.jsfile and acypressfolder in your project.Creating your first Cypress E2E testEnsure yourcypress.configfile has the following configuration:cypress.config.tsTypeScriptJavaScriptTypeScriptimport{ defineConfig }from'cypress'exportdefaultdefineConfig({e2e:{setupNodeEvents(on,config) {},},})Then, create two new Next.js files:app/page.jsimportLinkfrom'next/link'exportdefaultfunctionPage() {return(<div><h1>Home</h1><Linkhref=""/about"">About</Link></div>)}app/about/page.jsimportLinkfrom'next/link'exportdefaultfunctionPage() {return(<div><h1>About</h1><Linkhref=""/"">Home</Link></div>)}Add a test to check your navigation is working correctly:cypress/e2e/app.cy.jsdescribe('Navigation',()=>{it('should navigate to the about page',()=>{// Start from the index pagecy.visit('http://localhost:3000/')// Find a link with an href attribute containing ""about"" and click itcy.get('a[href*=""about""]').click()// The new url should include ""/about""cy.url().should('include','/about')// The new page should contain an h1 with ""About""cy.get('h1').contains('About')})})Running E2E TestsCypress will simulate a user navigating your application, this requires your Next.js server to be running. We recommend running your tests against your production code to more closely resemble how your application will behave.Runnpm run build && npm run startto build your Next.js application, then runnpm run cypress:openin another terminal window to start Cypress and run your E2E Testing suite.Good to know:You can usecy.visit(""/"")instead ofcy.visit(""http://localhost:3000/"")by addingbaseUrl: 'http://localhost:3000'to thecypress.config.jsconfiguration file.Alternatively, you can install thestart-server-and-testpackage to run the Next.js production server in conjunction with Cypress. After installation, add""test"": ""start-server-and-test start http://localhost:3000 cypress""to yourpackage.jsonscripts field. Remember to rebuild your application after new changes.Creating your first Cypress component testComponent tests build and mount a specific component without having to bundle your whole application or start a server.SelectComponent Testingin the Cypress app, then selectNext.jsas your front-end framework. Acypress/componentfolder will be created in your project, and acypress.config.jsfile will be updated to enable Component Testing.Ensure yourcypress.configfile has the following configuration:cypress.config.tsTypeScriptJavaScriptTypeScriptimport{ defineConfig }from'cypress'exportdefaultdefineConfig({component:{devServer:{framework:'next',bundler:'webpack',},},})Assuming the same components from the previous section, add a test to validate a component is rendering the expected output:cypress/component/about.cy.tsximportPagefrom'../../app/page'describe('<Page />',()=>{it('should render and display expected content',()=>{// Mount the Reactcomponentfor the Home pagecy.mount(<Page/>)// The new page should contain an h1 with ""Home""cy.get('h1').contains('Home')// Validate that a link with the expected URL is present// Following the link is better suited to an E2E testcy.get('a[href=""/about""]').should('be.visible')})})Good to know:Cypress currently doesn't support Component Testing forasyncServer Components. We recommend using E2E testing.Since component tests do not require a Next.js server, features like<Image />that rely on a server being available may not function out-of-the-box.Running Component TestsRunnpm run cypress:openin your terminal to start Cypress and run your Component Testing suite.Continuous Integration (CI)In addition to interactive testing, you can also run Cypress headlessly using thecypress runcommand, which is better suited for CI environments:package.json{""scripts"":{//...""e2e"":""start-server-and-test dev http://localhost:3000 \""cypress open --e2e\"""",""e2e:headless"":""start-server-and-test dev http://localhost:3000 \""cypress run --e2e\"""",""component"":""cypress open --component"",""component:headless"":""cypress run --component""}}You can learn more about Cypress and Continuous Integration from these resources:Next.js with Cypress exampleCypress Continuous Integration DocsCypress GitHub Actions GuideOfficial Cypress GitHub ActionCypress DiscordPreviousPlaywrightNextAuthenticationWas this helpful?supported.Send"
authentication,Authentication,"App RouterBuilding Your ApplicationAuthenticationAuthenticationUnderstanding authentication is crucial for protecting your application's data. This page will guide you through what React and Next.js features to use to implement auth.Before starting, it helps to break down the process into three concepts:Authentication: Verifies if the user is who they say they are. It requires the user to prove their identity with something they have, such as a username and password.Session Management: Tracks the user's auth state across requests.Authorization: Decides what routes and data the user can access.This diagram shows the authentication flow using React and Next.js features:The examples on this page walk through basic username and password auth for educational purposes. While you can implement a custom auth solution, for increased security and simplicity, we recommend using an authentication library. These offer built-in solutions for authentication, session management, and authorization, as well as additional features such as social logins, multi-factor authentication, and role-based access control. You can find a list in theAuth Librariessection.AuthenticationSign-up and login functionalityYou can use the<form>element with React'sServer ActionsanduseActionStateto capture user credentials, validate form fields, and call your Authentication Provider's API or database.Since Server Actions always execute on the server, they provide a secure environment for handling authentication logic.Here are the steps to implement signup/login functionality:1. Capture user credentialsTo capture user credentials, create a form that invokes a Server Action on submission. For example, a signup form that accepts the user's name, email, and password:app/ui/signup-form.tsxTypeScriptJavaScriptTypeScriptimport{ signup }from'@/app/actions/auth'exportfunctionSignupForm() {return(<formaction={signup}><div><labelhtmlFor=""name"">Name</label><inputid=""name""name=""name""placeholder=""Name""/></div><div><labelhtmlFor=""email"">Email</label><inputid=""email""name=""email""type=""email""placeholder=""Email""/></div><div><labelhtmlFor=""password"">Password</label><inputid=""password""name=""password""type=""password""/></div><buttontype=""submit"">Sign Up</button></form>)}app/actions/auth.tsTypeScriptJavaScriptTypeScriptexportasyncfunctionsignup(formData:FormData) {}2. Validate form fields on the serverUse the Server Action to validate the form fields on the server. If your authentication provider doesn't provide form validation, you can use a schema validation library likeZodorYup.Using Zod as an example, you can define a form schema with appropriate error messages:app/lib/definitions.tsTypeScriptJavaScriptTypeScriptimport{ z }from'zod'exportconstSignupFormSchema=z.object({name:z.string().min(2,{ message:'Name must be at least 2 characters long.'}).trim(),email:z.string().email({ message:'Please enter a valid email.'}).trim(),password:z.string().min(8,{ message:'Be at least 8 characters long'}).regex(/[a-zA-Z]/,{ message:'Contain at least one letter.'}).regex(/[0-9]/,{ message:'Contain at least one number.'}).regex(/[^a-zA-Z0-9]/,{message:'Contain at least one special character.',}).trim(),})exporttypeFormState=|{errors?:{name?:string[]email?:string[]password?:string[]}message?:string}|undefinedTo prevent unnecessary calls to your authentication provider's API or database, you canreturnearly in the Server Action if any form fields do not match the defined schema.app/actions/auth.tsTypeScriptJavaScriptTypeScriptimport{ SignupFormSchema,FormState }from'@/app/lib/definitions'exportasyncfunctionsignup(state:FormState,formData:FormData) {// Validate form fieldsconstvalidatedFields=SignupFormSchema.safeParse({name:formData.get('name'),email:formData.get('email'),password:formData.get('password'),})// If any form fields are invalid, return earlyif(!validatedFields.success) {return{errors:validatedFields.error.flatten().fieldErrors,}}// Call the provider or db to create a user...}Back in your<SignupForm />, you can use React'suseActionStatehook to display validation errors while the form is submitting:app/ui/signup-form.tsxTypeScriptJavaScriptTypeScript'use client'import{ signup }from'@/app/actions/auth'import{ useActionState }from'react'exportdefaultfunctionSignupForm() {const[state,action,pending]=useActionState(signup,undefined)return(<formaction={action}><div><labelhtmlFor=""name"">Name</label><inputid=""name""name=""name""placeholder=""Name""/></div>{state?.errors?.name&&<p>{state.errors.name}</p>}<div><labelhtmlFor=""email"">Email</label><inputid=""email""name=""email""placeholder=""Email""/></div>{state?.errors?.email&&<p>{state.errors.email}</p>}<div><labelhtmlFor=""password"">Password</label><inputid=""password""name=""password""type=""password""/></div>{state?.errors?.password&&(<div><p>Password must:</p><ul>{state.errors.password.map((error)=>(<likey={error}>- {error}</li>))}</ul></div>)}<buttondisabled={pending}type=""submit"">Sign Up</button></form>)}Good to know:In React 19,useFormStatusincludes additional keys on the returned object, like data, method, and action. If you are not using React 19, only thependingkey is available.Before mutating data, you should always ensure a user is also authorized to perform the action. SeeAuthentication and Authorization.3. Create a user or check user credentialsAfter validating form fields, you can create a new user account or check if the user exists by calling your authentication provider's API or database.Continuing from the previous example:app/actions/auth.tsxTypeScriptJavaScriptTypeScriptexportasyncfunctionsignup(state:FormState,formData:FormData) {// 1. Validate form fields// ...// 2. Prepare data for insertion into databaseconst{name,email,password}=validatedFields.data// e.g. Hash the user's password before storing itconsthashedPassword=awaitbcrypt.hash(password,10)// 3. Insert the user into the database or call an Auth Library's APIconstdata=awaitdb.insert(users).values({name,email,password:hashedPassword,}).returning({ id:users.id })constuser=data[0]if(!user) {return{message:'An error occurred while creating your account.',}}// TODO:// 4. Create user session// 5. Redirect user}After successfully creating the user account or verifying the user credentials, you can create a session to manage the user's auth state. Depending on your session management strategy, the session can be stored in a cookie or database, or both. Continue to theSession Managementsection to learn more.Tips:The example above is verbose since it breaks down the authentication steps for the purpose of education. This highlights that implementing your own secure solution can quickly become complex. Consider using anAuth Libraryto simplify the process.To improve the user experience, you may want to check for duplicate emails or usernames earlier in the registration flow. For example, as the user types in a username or the input field loses focus. This can help prevent unnecessary form submissions and provide immediate feedback to the user. You can debounce requests with libraries such asuse-debounceto manage the frequency of these checks.Session ManagementSession management ensures that the user's authenticated state is preserved across requests. It involves creating, storing, refreshing, and deleting sessions or tokens.There are two types of sessions:Stateless: Session data (or a token) is stored in the browser's cookies. The cookie is sent with each request, allowing the session to be verified on the server. This method is simpler, but can be less secure if not implemented correctly.Database: Session data is stored in a database, with the user's browser only receiving the encrypted session ID. This method is more secure, but can be complex and use more server resources.Good to know:While you can use either method, or both, we recommend using a session management library such asiron-sessionorJose.Stateless SessionsTo create and manage stateless sessions, there are a few steps you need to follow:Generate a secret key, which will be used to sign your session, and store it as anenvironment variable.Write logic to encrypt/decrypt session data using a session management library.Manage cookies using the Next.jscookiesAPI.In addition to the above, consider adding functionality toupdate (or refresh)the session when the user returns to the application, anddeletethe session when the user logs out.Good to know:Check if yourauth libraryincludes session management.1. Generating a secret keyThere are a few ways you can generate secret key to sign your session. For example, you may choose to use theopensslcommand in your terminal:terminalopensslrand-base6432This command generates a 32-character random string that you can use as your secret key and store in yourenvironment variables file:.envSESSION_SECRET=your_secret_keyYou can then reference this key in your session management logic:app/lib/session.jsconstsecretKey=process.env.SESSION_SECRET2. Encrypting and decrypting sessionsNext, you can use your preferredsession management libraryto encrypt and decrypt sessions. Continuing from the previous example, we'll useJose(compatible with theEdge Runtime) and React'sserver-onlypackage to ensure that your session management logic is only executed on the server.app/lib/session.tsTypeScriptJavaScriptTypeScriptimport'server-only'import{ SignJWT,jwtVerify }from'jose'import{ SessionPayload }from'@/app/lib/definitions'constsecretKey=process.env.SESSION_SECRETconstencodedKey=newTextEncoder().encode(secretKey)exportasyncfunctionencrypt(payload:SessionPayload) {returnnewSignJWT(payload).setProtectedHeader({ alg:'HS256'}).setIssuedAt().setExpirationTime('7d').sign(encodedKey)}exportasyncfunctiondecrypt(session:string|undefined='') {try{const{payload}=awaitjwtVerify(session,encodedKey,{algorithms:['HS256'],})returnpayload}catch(error) {console.log('Failed to verify session')}}Tips:The payload should contain theminimum, unique user data that'll be used in subsequent requests, such as the user's ID, role, etc. It should not contain personally identifiable information like phone number, email address, credit card information, etc, or sensitive data like passwords.3. Setting cookies (recommended options)To store the session in a cookie, use the Next.jscookiesAPI. The cookie should be set on the server, and include the recommended options:HttpOnly: Prevents client-side JavaScript from accessing the cookie.Secure: Use https to send the cookie.SameSite: Specify whether the cookie can be sent with cross-site requests.Max-Age or Expires: Delete the cookie after a certain period.Path: Define the URL path for the cookie.Please refer toMDNfor more information on each of these options.app/lib/session.tsTypeScriptJavaScriptTypeScriptimport'server-only'import{ cookies }from'next/headers'exportasyncfunctioncreateSession(userId:string) {constexpiresAt=newDate(Date.now()+7*24*60*60*1000)constsession=awaitencrypt({ userId,expiresAt })constcookieStore=awaitcookies()cookieStore.set('session',session,{httpOnly:true,secure:true,expires:expiresAt,sameSite:'lax',path:'/',})}Back in your Server Action, you can invoke thecreateSession()function, and use theredirect()API to redirect the user to the appropriate page:app/actions/auth.tsTypeScriptJavaScriptTypeScriptimport{ createSession }from'@/app/lib/session'exportasyncfunctionsignup(state:FormState,formData:FormData) {// Previous steps:// 1. Validate form fields// 2. Prepare data for insertion into database// 3. Insert the user into the database or call an Library API// Current steps:// 4. Create user sessionawaitcreateSession(user.id)// 5. Redirect userredirect('/profile')}Tips:Cookies should be set on the serverto prevent client-side tampering.🎥 Watch: Learn more about stateless sessions and authentication with Next.js →YouTube (11 minutes).Updating (or refreshing) sessionsYou can also extend the session's expiration time. This is useful for keeping the user logged in after they access the application again. For example:app/lib/session.tsTypeScriptJavaScriptTypeScriptimport'server-only'import{ cookies }from'next/headers'import{ decrypt }from'@/app/lib/session'exportasyncfunctionupdateSession() {constsession=(awaitcookies()).get('session')?.valueconstpayload=awaitdecrypt(session)if(!session||!payload) {returnnull}constexpires=newDate(Date.now()+7*24*60*60*1000)constcookieStore=awaitcookies()cookieStore.set('session',session,{httpOnly:true,secure:true,expires:expires,sameSite:'lax',path:'/',})}Tip:Check if your auth library supports refresh tokens, which can be used to extend the user's session.Deleting the sessionTo delete the session, you can delete the cookie:app/lib/session.tsTypeScriptJavaScriptTypeScriptimport'server-only'import{ cookies }from'next/headers'exportasyncfunctiondeleteSession() {constcookieStore=awaitcookies()cookieStore.delete('session')}Then you can reuse thedeleteSession()function in your application, for example, on logout:app/actions/auth.tsTypeScriptJavaScriptTypeScriptimport{ cookies }from'next/headers'import{ deleteSession }from'@/app/lib/session'exportasyncfunctionlogout() {deleteSession()redirect('/login')}Database SessionsTo create and manage database sessions, you'll need to follow these steps:Create a table in your database to store session and data (or check if your Auth Library handles this).Implement functionality to insert, update, and delete sessionsEncrypt the session ID before storing it in the user's browser, and ensure the database and cookie stay in sync (this is optional, but recommended for optimistic auth checks inMiddleware).For example:app/lib/session.tsTypeScriptJavaScriptTypeScriptimportcookiesfrom'next/headers'import{ db }from'@/app/lib/db'import{ encrypt }from'@/app/lib/session'exportasyncfunctioncreateSession(id:number) {constexpiresAt=newDate(Date.now()+7*24*60*60*1000)// 1. Create a session in the databaseconstdata=awaitdb.insert(sessions).values({userId:id,expiresAt,})// Return the session ID.returning({ id:sessions.id })constsessionId=data[0].id// 2. Encrypt the session IDconstsession=awaitencrypt({ sessionId,expiresAt })// 3. Store the session in cookies for optimistic auth checksconstcookieStore=awaitcookies()cookieStore.set('session',session,{httpOnly:true,secure:true,expires:expiresAt,sameSite:'lax',path:'/',})}Tips:For faster data retrieval, consider using a database likeVercel Redis. However, you can also keep the session data in your primary database, and combine data requests to reduce the number of queries.You may opt to use database sessions for more advanced use cases, such as keeping track of the last time a user logged in, or number of active devices, or give users the ability to log out of all devices.After implementing session management, you'll need to add authorization logic to control what users can access and do within your application. Continue to theAuthorizationsection to learn more.AuthorizationOnce a user is authenticated and a session is created, you can implement authorization to control what the user can access and do within your application.There are two main types of authorization checks:Optimistic: Checks if the user is authorized to access a route or perform an action using the session data stored in the cookie. These checks are useful for quick operations, such as showing/hiding UI elements or redirecting users based on permissions or roles.Secure: Checks if the user is authorized to access a route or perform an action using the session data stored in the database. These checks are more secure and are used for operations that require access to sensitive data or actions.For both cases, we recommend:Creating aData Access Layerto centralize your authorization logicUsingData Transfer Objects (DTO)to only return the necessary dataOptionally useMiddlewareto perform optimistic checks.Optimistic checks with Middleware (Optional)There are some cases where you may want to useMiddlewareand redirect users based on permissions:To perform optimistic checks. Since Middleware runs on every route, it's a good way to centralize redirect logic and pre-filter unauthorized users.To protect static routes that share data between users (e.g. content behind a paywall).However, since Middleware runs on every route, includingprefetchedroutes, it's important to only read the session from the cookie (optimistic checks), and avoid database checks to prevent performance issues.For example:middleware.tsTypeScriptJavaScriptTypeScriptimport{ NextRequest,NextResponse }from'next/server'import{ decrypt }from'@/app/lib/session'import{ cookies }from'next/headers'// 1. Specify protected and public routesconstprotectedRoutes=['/dashboard']constpublicRoutes=['/login','/signup','/']exportdefaultasyncfunctionmiddleware(req:NextRequest) {// 2. Check if the current route is protected or publicconstpath=req.nextUrl.pathnameconstisProtectedRoute=protectedRoutes.includes(path)constisPublicRoute=publicRoutes.includes(path)// 3. Decrypt the session from the cookieconstcookie=(awaitcookies()).get('session')?.valueconstsession=awaitdecrypt(cookie)// 4. Redirect to /login if the user is not authenticatedif(isProtectedRoute&&!session?.userId) {returnNextResponse.redirect(newURL('/login',req.nextUrl))}// 5. Redirect to /dashboard if the user is authenticatedif(isPublicRoute&&session?.userId&&!req.nextUrl.pathname.startsWith('/dashboard')) {returnNextResponse.redirect(newURL('/dashboard',req.nextUrl))}returnNextResponse.next()}// Routes Middleware should not run onexportconstconfig={matcher:['/((?!api|_next/static|_next/image|.*\\.png$).*)'],}While Middleware can be useful for initial checks, it should not be your only line of defense in protecting your data. The majority of security checks should be performed as close as possible to your data source, seeData Access Layerfor more information.Tips:In Middleware, you can also read cookies usingreq.cookies.get('session').value.Middleware uses theEdge Runtime, check if your Auth library and session management library are compatible.You can use thematcherproperty in the Middleware to specify which routes Middleware should run on. Although, for auth, it's recommended Middleware runs on all routes.Creating a Data Access Layer (DAL)We recommend creating a DAL to centralize your data requests and authorization logic.The DAL should include a function that verifies the user's session as they interact with your application. At the very least, the function should check if the session is valid, then redirect or return the user information needed to make further requests.For example, create a separate file for your DAL that includes averifySession()function. Then use React'scacheAPI to memoize the return value of the function during a React render pass:app/lib/dal.tsTypeScriptJavaScriptTypeScriptimport'server-only'import{ cookies }from'next/headers'import{ decrypt }from'@/app/lib/session'exportconstverifySession=cache(async()=>{constcookie=(awaitcookies()).get('session')?.valueconstsession=awaitdecrypt(cookie)if(!session?.userId) {redirect('/login')}return{ isAuth:true,userId:session.userId }})You can then invoke theverifySession()function in your data requests, Server Actions, Route Handlers:app/lib/dal.tsTypeScriptJavaScriptTypeScriptexportconstgetUser=cache(async()=>{constsession=awaitverifySession()if(!session)returnnulltry{constdata=awaitdb.query.users.findMany({where:eq(users.id,session.userId),// Explicitly return the columns you need rather than the whole user objectcolumns:{id:true,name:true,email:true,},})constuser=data[0]returnuser}catch(error) {console.log('Failed to fetch user')returnnull}})Tip:A DAL can be used to protect data fetched at request time. However, for static routes that share data between users, data will be fetched at build time and not at request time. UseMiddlewareto protect static routes.For secure checks, you can check if the session is valid by comparing the session ID with your database. Use React'scachefunction to avoid unnecessary duplicate requests to the database during a render pass.You may wish to consolidate related data requests in a JavaScript class that runsverifySession()before any methods.Using Data Transfer Objects (DTO)When retrieving data, it's recommended you return only the necessary data that will be used in your application, and not entire objects. For example, if you're fetching user data, you might only return the user's ID and name, rather than the entire user object which could contain passwords, phone numbers, etc.However, if you have no control over the returned data structure, or are working in a team where you want to avoid whole objects being passed to the client, you can use strategies such as specifying what fields are safe to be exposed to the client.app/lib/dto.tsTypeScriptJavaScriptTypeScriptimport'server-only'import{ getUser }from'@/app/lib/dal'functioncanSeeUsername(viewer:User) {returntrue}functioncanSeePhoneNumber(viewer:User,team:string) {returnviewer.isAdmin||team===viewer.team}exportasyncfunctiongetProfileDTO(slug:string) {constdata=awaitdb.query.users.findMany({where:eq(users.slug,slug),// Return specific columns here})constuser=data[0]constcurrentUser=awaitgetUser(user.id)// Or return only what's specific to the query herereturn{username:canSeeUsername(currentUser)?user.username:null,phonenumber:canSeePhoneNumber(currentUser,user.team)?user.phonenumber:null,}}By centralizing your data requests and authorization logic in a DAL and using DTOs, you can ensure that all data requests are secure and consistent, making it easier to maintain, audit, and debug as your application scales.Good to know:There are a couple of different ways you can define a DTO, from usingtoJSON(), to individual functions like the example above, or JS classes. Since these are JavaScript patterns and not a React or Next.js feature, we recommend doing some research to find the best pattern for your application.Learn more about security best practices in ourSecurity in Next.js article.Server ComponentsAuth check inServer Componentsare useful for role-based access. For example, to conditionally render components based on the user's role:app/dashboard/page.tsxTypeScriptJavaScriptTypeScriptimport{ verifySession }from'@/app/lib/dal'exportdefaultfunctionDashboard() {constsession=awaitverifySession()constuserRole=session?.user?.role// Assuming 'role' is part of the session objectif(userRole==='admin') {return<AdminDashboard/>}elseif(userRole==='user') {return<UserDashboard/>}else{redirect('/login')}}In the example, we use theverifySession()function from our DAL to check for 'admin', 'user', and unauthorized roles. This pattern ensures that each user interacts only with components appropriate to their role.Layouts and auth checksDue toPartial Rendering, be cautious when doing checks inLayoutsas these don't re-render on navigation, meaning the user session won't be checked on every route change.Instead, you should do the checks close to your data source or the component that'll be conditionally rendered.For example, consider a shared layout that fetches the user data and displays the user image in a nav. Instead of doing the auth check in the layout, you should fetch the user data (getUser()) in the layout and do the auth check in your DAL.This guarantees that wherevergetUser()is called within your application, the auth check is performed, and prevents developers forgetting to check the user is authorized to access the data.app/layout.tsxTypeScriptJavaScriptTypeScriptexportdefaultasyncfunctionLayout({children,}:{children:React.ReactNode;}) {constuser=awaitgetUser();return(// ...)}app/lib/dal.tsTypeScriptJavaScriptTypeScriptexportconstgetUser=cache(async()=>{constsession=awaitverifySession()if(!session)returnnull// Get user ID from session and fetch data})Good to know:A common pattern in SPAs is toreturn nullin a layout or a top-level component if a user is not authorized. This pattern isnot recommendedsince Next.js applications have multiple entry points, which will not prevent nested route segments and Server Actions from being accessed.Server ActionsTreatServer Actionswith the same security considerations as public-facing API endpoints, and verify if the user is allowed to perform a mutation.In the example below, we check the user's role before allowing the action to proceed:app/lib/actions.tsTypeScriptJavaScriptTypeScript'use server'import{ verifySession }from'@/app/lib/dal'exportasyncfunctionserverAction(formData:FormData) {constsession=awaitverifySession()constuserRole=session?.user?.role// Return early if user is not authorized to perform the actionif(userRole!=='admin') {returnnull}// Proceed with the action for authorized users}Route HandlersTreatRoute Handlerswith the same security considerations as public-facing API endpoints, and verify if the user is allowed to access the Route Handler.For example:app/api/route.tsTypeScriptJavaScriptTypeScriptimport{ verifySession }from'@/app/lib/dal'exportasyncfunctionGET() {// User authentication and role verificationconstsession=awaitverifySession()// Check if the user is authenticatedif(!session) {// User is not authenticatedreturnnewResponse(null,{ status:401})}// Check if the user has the 'admin' roleif(session.user.role!=='admin') {// User is authenticated but does not have the right permissionsreturnnewResponse(null,{ status:403})}// Continue for authorized users}The example above demonstrates a Route Handler with a two-tier security check. It first checks for an active session, and then verifies if the logged-in user is an 'admin'.Context ProvidersUsing context providers for auth works due tointerleaving. However, Reactcontextis not supported in Server Components, making them only applicable to Client Components.This works, but any child Server Components will be rendered on the server first, and will not have access to the context provider’s session data:app/layout.tsTypeScriptJavaScriptTypeScriptimport{ ContextProvider }from'auth-lib'exportdefaultfunctionRootLayout({ children }) {return(<htmllang=""en""><body><ContextProvider>{children}</ContextProvider></body></html>)}""use client"";import{ useSession }from""auth-lib"";exportdefaultfunctionProfile() {const{userId}=useSession();const{data}=useSWR(`/api/user/${userId}`,fetcher)return(// ...);}If session data is needed in Client Components (e.g. for client-side data fetching), use React’staintUniqueValueAPI to prevent sensitive session data from being exposed to the client.ResourcesNow that you've learned about authentication in Next.js, here are Next.js-compatible libraries and resources to help you implement secure authentication and session management:Auth LibrariesAuth0ClerkKindeLogtoNextAuth.jsOryStack AuthSupabaseStytchWorkOSSession Management LibrariesIron SessionJoseFurther ReadingTo continue learning about authentication and security, check out the following resources:How to think about security in Next.jsUnderstanding XSS AttacksUnderstanding CSRF AttacksThe Copenhagen BookPreviousCypressNextDeployingWas this helpful?supported.Send"
deploying,Deploying,"App RouterBuilding Your ApplicationDeployingDeployingCongratulations, it's time to ship to production.You can deploymanaged Next.js with Vercel, or self-host on a Node.js server, Docker image, or even static HTML files. When deploying usingnext start, all Next.js features are supported.Production BuildsRunningnext buildgenerates an optimized version of your application for production. HTML, CSS, and JavaScript files are created based on your pages. JavaScript iscompiledand browser bundles areminifiedusing theNext.js Compilerto help achieve the best performance and supportall modern browsers.Next.js produces a standard deployment output used by managed and self-hosted Next.js. This ensures all features are supported across both methods of deployment. In the next major version, we will be transforming this output into ourBuild Output API specification.Managed Next.js with VercelVercel, the creators and maintainers of Next.js, provide managed infrastructure and a developer experience platform for your Next.js applications.Deploying to Vercel is zero-configuration and provides additional enhancements for scalability, availability, and performance globally. However, all Next.js features are still supported when self-hosted.Learn more aboutNext.js on Vercelordeploy a template for freeto try it out.Self-HostingYou can self-host Next.js in three different ways:A Node.js serverA Docker containerA static export🎥 Watch:Learn more about self-hosting Next.js →YouTube (45 minutes).We have community maintained deployment examples with the following providers:DenoDigitalOceanFlightcontrolFly.ioGitHub PagesGoogle Cloud RunRailwayRenderSSTNode.js ServerNext.js can be deployed to any hosting provider that supports Node.js. Ensure yourpackage.jsonhas the""build""and""start""scripts:package.json{""scripts"":{""dev"":""next dev"",""build"":""next build"",""start"":""next start""}}Then, runnpm run buildto build your application. Finally, runnpm run startto start the Node.js server. This server supports all Next.js features.Docker ImageNext.js can be deployed to any hosting provider that supportsDockercontainers. You can use this approach when deploying to container orchestrators such asKubernetesor when running inside a container in any cloud provider.Install Dockeron your machineClone our example(or themulti-environment example)Build your container:docker build -t nextjs-docker .Run your container:docker run -p 3000:3000 nextjs-dockerNext.js through Docker supports all Next.js features.Static HTML ExportNext.js enables starting as a static site or Single-Page Application (SPA), then later optionally upgrading to use features that require a server.Since Next.js supports thisstatic export, it can be deployed and hosted on any web server that can serve HTML/CSS/JS static assets. This includes tools like AWS S3, Nginx, or Apache.Running as astatic exportdoes not support Next.js features that require a server.Learn more.Good to know:Server Componentsare supported with static exports.FeaturesImage OptimizationImage Optimizationthroughnext/imageworks self-hosted with zero configuration when deploying usingnext start. If you would prefer to have a separate service to optimize images, you canconfigure an image loader.Image Optimization can be used with astatic exportby defining a custom image loader innext.config.js. Note that images are optimized at runtime, not during the build.Good to know:On glibc-based Linux systems, Image Optimization may requireadditional configurationto prevent excessive memory usage.Learn more about thecaching behavior of optimized imagesand how to configure the TTL.You can alsodisable Image Optimizationand still retain other benefits of usingnext/imageif you prefer. For example, if you are optimizing images yourself separately.MiddlewareMiddlewareworks self-hosted with zero configuration when deploying usingnext start. Since it requires access to the incoming request, it is not supported when using astatic export.Middleware uses aruntimethat is a subset of all available Node.js APIs to help ensure low latency, since it may run in front of every route or asset in your application. This runtime does not require running “at the edge” and works in a single-region server. Additional configuration and infrastructure are required to run Middleware in multiple regions.If you are looking to add logic (or use an external package) that requires all Node.js APIs, you might be able to move this logic to alayoutas aServer Component. For example, checkingheadersandredirecting. You can also use headers, cookies, or query parameters toredirectorrewritethroughnext.config.js. If that does not work, you can also use acustom server.Environment VariablesNext.js can support both build time and runtime environment variables.By default, environment variables are only available on the server. To expose an environment variable to the browser, it must be prefixed withNEXT_PUBLIC_. However, these public environment variables will be inlined into the JavaScript bundle duringnext build.You safely read environment variables on the server during dynamic rendering.app/page.tsTypeScriptJavaScriptTypeScriptimport{ connection }from'next/server'exportdefaultasyncfunctionComponent() {awaitconnection()// cookies, headers, and other Dynamic APIs// will also opt into dynamic rendering, meaning// this env variable is evaluated at runtimeconstvalue=process.env.MY_VALUE// ...}This allows you to use a singular Docker image that can be promoted through multiple environments with different values.Good to know:You can run code on server startup using theregisterfunction.We do not recommend using theruntimeConfigoption, as this does not work with the standalone output mode. Instead, we recommendincrementally adoptingthe App Router.Caching and ISRNext.js can cache responses, generated static pages, build outputs, and other static assets like images, fonts, and scripts.Caching and revalidating pages (withIncremental Static Regeneration) use thesame shared cache. By default, this cache is stored to the filesystem (on disk) on your Next.js server.This works automatically when self-hostingusing both the Pages and App Router.You can configure the Next.js cache location if you want to persist cached pages and data to durable storage, or share the cache across multiple containers or instances of your Next.js application.Automatic CachingNext.js sets theCache-Controlheader ofpublic, max-age=31536000, immutableto truly immutable assets. It cannot be overridden. These immutable files contain a SHA-hash in the file name, so they can be safely cached indefinitely. For example,Static Image Imports. You canconfigure the TTLfor images.Incremental Static Regeneration (ISR) sets theCache-Controlheader ofs-maxage: <revalidate in getStaticProps>, stale-while-revalidate. This revalidation time is defined in yourgetStaticPropsfunctionin seconds. If you setrevalidate: false, it will default to a one-year cache duration.Dynamically rendered pages set aCache-Controlheader ofprivate, no-cache, no-store, max-age=0, must-revalidateto prevent user-specific data from being cached. This applies to both the App Router and Pages Router. This also includesDraft Mode.Static AssetsIf you want to host static assets on a different domain or CDN, you can use theassetPrefixconfigurationinnext.config.js. Next.js will use this asset prefix when retrieving JavaScript or CSS files. Separating your assets to a different domain does come with the downside of extra time spent on DNS and TLS resolution.Learn more aboutassetPrefix.Configuring CachingBy default, generated cache assets will be stored in memory (defaults to 50mb) and on disk. If you are hosting Next.js using a container orchestration platform like Kubernetes, each pod will have a copy of the cache. To prevent stale data from being shown since the cache is not shared between pods by default, you can configure the Next.js cache to provide a cache handler and disable in-memory caching.To configure the ISR/Data Cache location when self-hosting, you can configure a custom handler in yournext.config.jsfile:next.config.jsmodule.exports={cacheHandler:require.resolve('./cache-handler.js'),cacheMaxMemorySize:0,// disable default in-memory caching}Then, createcache-handler.jsin the root of your project, for example:cache-handler.jsconstcache=newMap()module.exports=classCacheHandler{constructor(options) {this.options=options}asyncget(key) {// This could be stored anywhere, like durable storagereturncache.get(key)}asyncset(key,data,ctx) {// This could be stored anywhere, like durable storagecache.set(key,{value:data,lastModified:Date.now(),tags:ctx.tags,})}asyncrevalidateTag(tags) {// tags is either a string or an array of stringstags=[tags].flat()// Iterate over all entries in the cachefor(let[key,value]ofcache) {// If the value's tags include the specified tag, delete this entryif(value.tags.some((tag)=>tags.includes(tag))) {cache.delete(key)}}}// If you want to have temporary in memory cache for a single request that is reset// before the next request you can leverage this methodresetRequestCache() {}}Using a custom cache handler will allow you to ensure consistency across all pods hosting your Next.js application. For instance, you can save the cached values anywhere, likeRedisor AWS S3.Good to know:revalidatePathis a convenience layer on top of cache tags. CallingrevalidatePathwill call therevalidateTagfunction with a special default tag for the provided page.Build CacheNext.js generates an ID duringnext buildto identify which version of your application is being served. The same build should be used and boot up multiple containers.If you are rebuilding for each stage of your environment, you will need to generate a consistent build ID to use between containers. Use thegenerateBuildIdcommand innext.config.js:next.config.jsmodule.exports={generateBuildId:async()=>{// This could be anything, using the latest git hashreturnprocess.env.GIT_HASH},}Version SkewNext.js will automatically mitigate most instances ofversion skewand automatically reload the application to retrieve new assets when detected. For example, if there is a mismatch in thedeploymentId, transitions between pages will perform a hard navigation versus using a prefetched value.When the application is reloaded, there may be a loss of application state if it's not designed to persist between page navigations. For example, using URL state or local storage would persist state after a page refresh. However, component state likeuseStatewould be lost in such navigations.Vercel provides additionalskew protectionfor Next.js applications to ensure assets and functions from the previous version are still available to older clients, even after the new version is deployed.You can manually configure thedeploymentIdproperty in yournext.config.jsfile to ensure each request uses either?dplquery string orx-deployment-idheader.Streaming and SuspenseThe Next.js App Router supportsstreaming responseswhen self-hosting. If you are using Nginx or a similar proxy, you will need to configure it to disable buffering to enable streaming.For example, you can disable buffering in Nginx by settingX-Accel-Bufferingtono:next.config.jsmodule.exports={asyncheaders() {return[{source:'/:path*{/}?',headers:[{key:'X-Accel-Buffering',value:'no',},],},]},}Partial PrerenderingPartial Prerendering (experimental)works by default with Next.js and is not a CDN feature. This includes deployment as a Node.js server (throughnext start) and when used with a Docker container.Usage with CDNsWhen using a CDN in front on your Next.js application, the page will includeCache-Control: privateresponse header when dynamic APIs are accessed. This ensures that the resulting HTML page is marked as non-cachable. If the page is fully prerendered to static, it will includeCache-Control: publicto allow the page to be cached on the CDN.If you don't need a mix of both static and dynamic components, you can make your entire route static and cache the output HTML on a CDN. This Automatic Static Optimization is the default behavior when runningnext buildif dynamic APIs are not used.afterafteris fully supported when self-hosting withnext start.When stopping the server, ensure a graceful shutdown by sendingSIGINTorSIGTERMsignals and waiting. This allows the Next.js server to wait until after pending callback functions or promises used insideafterhave finished.If you want to useafteron custom infrastructure, check your provider documentation to view support forafter.Reference: supportingafterfor serverless platformsUsingafterin a serverless context requires waiting for asynchronous tasks to finish after the response has been sent. In Next.js and Vercel, this is achieved using a primitive calledwaitUntil(promise), which extends the lifetime of a serverless invocation until all promises passed towaitUntilhave settled.If you want your users to be able to runafter, you will have to provide your implementation ofwaitUntilthat behaves in an analogous way.Whenafteris called, Next.js will accesswaitUntillike this:constRequestContext=globalThis[Symbol.for('@next/request-context')]constcontextValue=RequestContext?.get()constwaitUntil=contextValue?.waitUntilWhich means thatglobalThis[Symbol.for('@next/request-context')]is expected to contain an object like this:typeNextRequestContext={get():NextRequestContextValue|undefined}typeNextRequestContextValue={waitUntil?:(promise:Promise<any>)=>void}Here is an example of the implementation.import{ AsyncLocalStorage }from'node:async_hooks'constRequestContextStorage=newAsyncLocalStorage<NextRequestContextValue>()// Define and inject the accessor that next.js will useconstRequestContext:NextRequestContext={get() {returnRequestContextStorage.getStore()},}globalThis[Symbol.for('@next/request-context')]=RequestContextconsthandler=(req,res)=>{constcontextValue={ waitUntil:YOUR_WAITUNTIL}// Provide the valuereturnRequestContextStorage.run(contextValue,()=>nextJsHandler(req,res))}Production ChecklistRecommendations to ensure the best performance and user experience before taking your Next.js application to production.Static ExportsNext.js enables starting as a static site or Single-Page Application (SPA), then later optionally upgrading to use features that require a server.Multi-ZonesLearn how to build micro-frontends using Next.js Multi-Zones to deploy multiple Next.js apps under a single domain.PreviousAuthenticationNextProduction ChecklistWas this helpful?supported.Send"
production checklist,Production Checklist,"Building Your ApplicationDeployingProduction ChecklistProduction ChecklistBefore taking your Next.js application to production, there are some optimizations and patterns you should consider implementing for the best user experience, performance, and security.This page provides best practices that you can use as a reference whenbuilding your application,before going to production, andafter deployment- as well as theautomatic Next.js optimizationsyou should be aware of.Automatic optimizationsThese Next.js optimizations are enabled by default and require no configuration:Server Components:Next.js uses Server Components by default. Server Components run on the server, and don't require JavaScript to render on the client. As such, they have no impact on the size of your client-side JavaScript bundles. You can then useClient Componentsas needed for interactivity.Code-splitting:Server Components enable automatic code-splitting by route segments. You may also considerlazy loadingClient Components and third-party libraries, where appropriate.Prefetching:When a link to a new route enters the user's viewport, Next.js prefetches the route in background. This makes navigation to new routes almost instant. You can opt out of prefetching, where appropriate.Static Rendering:Next.js statically renders Server and Client Components on the server at build time and caches the rendered result to improve your application's performance. You can opt intoDynamic Renderingfor specific routes, where appropriate.Caching:Next.js caches data requests, the rendered result of Server and Client Components, static assets, and more, to reduce the number of network requests to your server, database, and backend services. You may opt out of caching, where appropriate.These defaults aim to improve your application's performance, and reduce the cost and amount of data transferred on each network request.During developmentWhile building your application, we recommend using the following features to ensure the best performance and user experience:Routing and renderingLayouts:Use layouts to share UI across pages and enablepartial renderingon navigation.<Link>component:Use the<Link>component forclient-side navigation and prefetching.Error Handling:Gracefully handlecatch-all errorsand404 errorsin production by creating custom error pages.Composition Patterns:Follow the recommended composition patterns for Server and Client Components, and check the placement of your""use client""boundariesto avoid unnecessarily increasing your client-side JavaScript bundle.Dynamic APIs:Be aware that Dynamic APIs likecookiesand thesearchParamsprop will opt the entire route intoDynamic Rendering(or your whole application if used in theRoot Layout). Ensure Dynamic API usage is intentional and wrap them in<Suspense>boundaries where appropriate.Good to know:Partial Prerendering (experimental)will allow parts of a route to be dynamic without opting the whole route into dynamic rendering.Data fetching and cachingServer Components:Leverage the benefits of fetching data on the server using Server Components.Route Handlers:Use Route Handlers to access your backend resources from Client Components. But do not call Route Handlers from Server Components to avoid an additional server request.Streaming:Use Loading UI and React Suspense to progressively send UI from the server to the client, and prevent the whole route from blocking while data is being fetched.Parallel Data Fetching:Reduce network waterfalls by fetching data in parallel, where appropriate. Also, considerpreloading datawhere appropriate.Data Caching:Verify whether your data requests are being cached or not, and opt into caching, where appropriate. Ensure requests that don't usefetcharecached.Static Images:Use thepublicdirectory to automatically cache your application's static assets, e.g. images.UI and accessibilityForms and Validation:Use Server Actions to handle form submissions, server-side validation, and handle errors.Font Module:Optimize fonts by using the Font Module, which automatically hosts your font files with other static assets, removes external network requests, and reduceslayout shift.<Image>Component:Optimize images by using the Image Component, which automatically optimizes images, prevents layout shift, and serves them in modern formats like WebP.<Script>Component:Optimize third-party scripts by using the Script Component, which automatically defers scripts and prevents them from blocking the main thread.ESLint:Use the built-ineslint-plugin-jsx-a11yplugin to catch accessibility issues early.SecurityTainting:Prevent sensitive data from being exposed to the client by tainting data objects and/or specific values.Server Actions:Ensure users are authorized to call Server Actions. Review the recommendedsecurity practices.Environment Variables:Ensure your.env.*files are added to.gitignoreand only public variables are prefixed withNEXT_PUBLIC_.Content Security Policy:Consider adding a Content Security Policy to protect your application against various security threats such as cross-site scripting, clickjacking, and other code injection attacks.Metadata and SEOMetadata API:Use the Metadata API to improve your application's Search Engine Optimization (SEO) by adding page titles, descriptions, and more.Open Graph (OG) images:Create OG images to prepare your application for social sharing.SitemapsandRobots:Help Search Engines crawl and index your pages by generating sitemaps and robots files.Type safetyTypeScript andTS Plugin:Use TypeScript and the TypeScript plugin for better type-safety, and to help you catch errors early.Before going to productionBefore going to production, you can runnext buildto build your application locally and catch any build errors, then runnext startto measure the performance of your application in a production-like environment.Core Web VitalsLighthouse:Run lighthouse in incognito to gain a better understanding of how your users will experience your site, and to identify areas for improvement. This is a simulated test and should be paired with looking at field data (such as Core Web Vitals).useReportWebVitalshook:Use this hook to sendCore Web Vitalsdata to analytics tools.Analyzing bundlesUse the@next/bundle-analyzerpluginto analyze the size of your JavaScript bundles and identify large modules and dependencies that might be impacting your application's performance.Additionally, the following tools can help you understand the impact of adding new dependencies to your application:Import CostPackage PhobiaBundle PhobiabundlejsAfter deploymentDepending on where you deploy your application, you might have access to additional tools and integrations to help you monitor and improve your application's performance.For Vercel deployments, we recommend the following:Analytics:A built-in analytics dashboard to help you understand your application's traffic, including the number of unique visitors, page views, and more.Speed Insights:Real-world performance insights based on visitor data, offering a practical view of how your website is performing in the field.Logging:Runtime and Activity logs to help you debug issues and monitor your application in production. Alternatively, see theintegrations pagefor a list of third-party tools and services.Good to know:To get a comprehensive understanding of the best practices for production deployments on Vercel, including detailed strategies for improving website performance, refer to theVercel Production Checklist.Following these recommendations will help you build a faster, more reliable, and secure application for your users.PreviousDeployingNextStatic ExportsWas this helpful?supported.Send"
static exports,Static Exports,"Building Your ApplicationDeployingStatic ExportsStatic ExportsNext.js enables starting as a static site or Single-Page Application (SPA), then later optionally upgrading to use features that require a server.When runningnext build, Next.js generates an HTML file per route. By breaking a strict SPA into individual HTML files, Next.js can avoid loading unnecessary JavaScript code on the client-side, reducing the bundle size and enabling faster page loads.Since Next.js supports this static export, it can be deployed and hosted on any web server that can serve HTML/CSS/JS static assets.ConfigurationTo enable a static export, change the output mode insidenext.config.js:next.config.js/***@type{import('next').NextConfig}*/constnextConfig={output:'export',// Optional: Change links `/me` -> `/me/` and emit `/me.html` -> `/me/index.html`// trailingSlash: true,// Optional: Prevent automatic `/me` -> `/me/`, instead preserve `href`// skipTrailingSlashRedirect: true,// Optional: Change the output directory `out` -> `dist`// distDir: 'dist',}module.exports=nextConfigAfter runningnext build, Next.js will create anoutfolder with the HTML/CSS/JS assets for your application.Supported FeaturesThe core of Next.js has been designed to support static exports.Server ComponentsWhen you runnext buildto generate a static export, Server Components consumed inside theappdirectory will run during the build, similar to traditional static-site generation.The resulting component will be rendered into static HTML for the initial page load and a static payload for client navigation between routes. No changes are required for your Server Components when using the static export, unless they consumedynamic server functions.app/page.tsxTypeScriptJavaScriptTypeScriptexportdefaultasyncfunctionPage() {// This fetch will run on the server during `next build`constres=awaitfetch('https://api.example.com/...')constdata=awaitres.json()return<main>...</main>}Client ComponentsIf you want to perform data fetching on the client, you can use a Client Component withSWRto memoize requests.app/other/page.tsxTypeScriptJavaScriptTypeScript'use client'importuseSWRfrom'swr'constfetcher=(url:string)=>fetch(url).then((r)=>r.json())exportdefaultfunctionPage() {const{data,error}=useSWR(`https://jsonplaceholder.typicode.com/posts/1`,fetcher)if(error)return'Failed to load'if(!data)return'Loading...'returndata.title}Since route transitions happen client-side, this behaves like a traditional SPA. For example, the following index route allows you to navigate to different posts on the client:app/page.tsxTypeScriptJavaScriptTypeScriptimportLinkfrom'next/link'exportdefaultfunctionPage() {return(<><h1>Index Page</h1><hr/><ul><li><Linkhref=""/post/1"">Post 1</Link></li><li><Linkhref=""/post/2"">Post 2</Link></li></ul></>)}Image OptimizationImage Optimizationthroughnext/imagecan be used with a static export by defining a custom image loader innext.config.js. For example, you can optimize images with a service like Cloudinary:next.config.js/**@type{import('next').NextConfig}*/constnextConfig={output:'export',images:{loader:'custom',loaderFile:'./my-loader.ts',},}module.exports=nextConfigThis custom loader will define how to fetch images from a remote source. For example, the following loader will construct the URL for Cloudinary:my-loader.tsTypeScriptJavaScriptTypeScriptexportdefaultfunctioncloudinaryLoader({src,width,quality,}:{src:stringwidth:numberquality?:number}) {constparams=['f_auto','c_limit',`w_${width}`,`q_${quality||'auto'}`]return`https://res.cloudinary.com/demo/image/upload/${params.join(',')}${src}`}You can then usenext/imagein your application, defining relative paths to the image in Cloudinary:app/page.tsxTypeScriptJavaScriptTypeScriptimportImagefrom'next/image'exportdefaultfunctionPage() {return<Imagealt=""turtles""src=""/turtles.jpg""width={300}height={300} />}Route HandlersRoute Handlers will render a static response when runningnext build. Only theGETHTTP verb is supported. This can be used to generate static HTML, JSON, TXT, or other files from cached or uncached data. For example:app/data.json/route.tsTypeScriptJavaScriptTypeScriptexportasyncfunctionGET() {returnResponse.json({ name:'Lee'})}The above fileapp/data.json/route.tswill render to a static file duringnext build, producingdata.jsoncontaining{ name: 'Lee' }.If you need to read dynamic values from the incoming request, you cannot use a static export.Browser APIsClient Components are pre-rendered to HTML duringnext build. BecauseWeb APIslikewindow,localStorage, andnavigatorare not available on the server, you need to safely access these APIs only when running in the browser. For example:'use client';import{ useEffect }from'react';exportdefaultfunctionClientComponent() {useEffect(()=>{// You now have access to `window`console.log(window.innerHeight);},[])return...;}Unsupported FeaturesFeatures that require a Node.js server, or dynamic logic that cannot be computed during the build process, arenotsupported:Dynamic RouteswithdynamicParams: trueDynamic RouteswithoutgenerateStaticParams()Route Handlersthat rely on RequestCookiesRewritesRedirectsHeadersMiddlewareIncremental Static RegenerationImage Optimizationwith the defaultloaderDraft ModeServer ActionsIntercepting RoutesAttempting to use any of these features withnext devwill result in an error, similar to setting thedynamicoption toerrorin the root layout.exportconstdynamic='error'DeployingWith a static export, Next.js can be deployed and hosted on any web server that can serve HTML/CSS/JS static assets.When runningnext build, Next.js generates the static export into theoutfolder. For example, let's say you have the following routes://blog/[id]After runningnext build, Next.js will generate the following files:/out/index.html/out/404.html/out/blog/post-1.html/out/blog/post-2.htmlIf you are using a static host like Nginx, you can configure rewrites from incoming requests to the correct files:nginx.confserver{listen80;server_nameacme.com;root/var/www/out;location/ {try_files$uri $uri.html $uri/=404;}# This is necessary when `trailingSlash: false`.# You can omit this when `trailingSlash: true`.location/blog/ {rewrite^/blog/(.*)$/blog/$1.htmlbreak;}error_page404 /404.html;location=/404.html{internal;}}Version HistoryVersionChangesv14.0.0next exporthas been removed in favor of""output"": ""export""v13.4.0App Router (Stable) adds enhanced static export support, including using React Server Components and Route Handlers.v13.3.0next exportis deprecated and replaced with""output"": ""export""PreviousProduction ChecklistNextMulti-ZonesWas this helpful?supported.Send"
multi-zones,Multi-Zones,"Building Your ApplicationDeployingMulti-ZonesMulti-ZonesExamplesWith ZonesMulti-Zones are an approach to micro-frontends that separate a large application on a domain into smaller Next.js applications that each serve a set of paths. This is useful when there are collections of pages unrelated to the other pages in the application. By moving those pages to a separate zone (i.e., a separate application), you can reduce the size of each application which improves build times and removes code that is only necessary for one of the zones. Since applications are decoupled, Multi-Zones also allows other applications on the domain to use their own choice of framework.For example, let's say you have the following set of pages that you would like to split up:/blog/*for all blog posts/dashboard/*for all pages when the user is logged-in to the dashboard/*for the rest of your website not covered by other zonesWith Multi-Zones support, you can create three applications that all are served on the same domain and look the same to the user, but you can develop and deploy each of the applications independently.Navigating between pages in the same zone will perform soft navigations, a navigation that does not require reloading the page. For example, in this diagram, navigating from/to/productswill be a soft navigation.Navigating from a page in one zone to a page in another zone, such as from/to/dashboard, will perform a hard navigation, unloading the resources of the current page and loading the resources of the new page. Pages that are frequently visited together should live in the same zone to avoid hard navigations.How to define a zoneA zone is a normal Next.js application where you also configure anassetPrefixto avoid conflicts with pages and static files in other zones.next.config.js/**@type{import('next').NextConfig}*/constnextConfig={assetPrefix:'/blog-static',}Next.js assets, such as JavaScript and CSS, will be prefixed withassetPrefixto make sure that they don't conflict with assets from other zones. These assets will be served under/assetPrefix/_next/...for each of the zones.The default application handling all paths not routed to another more specific zone does not need anassetPrefix.In versions older than Next.js 15, you may also need an additional rewrite to handle the static assets. This is no longer necessary in Next.js 15.next.config.js/**@type{import('next').NextConfig}*/constnextConfig={assetPrefix:'/blog-static',asyncrewrites() {return{beforeFiles:[{source:'/blog-static/_next/:path+',destination:'/_next/:path+',},],}},}How to route requests to the right zoneWith the Multi Zones set-up, you need to route the paths to the correct zone since they are served by different applications. You can use any HTTP proxy to do this, but one of the Next.js applications can also be used to route requests for the entire domain.To route to the correct zone using a Next.js application, you can userewrites. For each path served by a different zone, you would add a rewrite rule to send that path to the domain of the other zone. For example:next.config.jsasyncrewrites() {return[{source:'/blog',destination:`${process.env.BLOG_DOMAIN}/blog`,},{source:'/blog/:path+',destination:`${process.env.BLOG_DOMAIN}/blog/:path+`,}];}destinationshould be a URL that is served by the zone, including scheme and domain. This should point to the zone's production domain, but it can also be used to route requests tolocalhostin local development.Good to know: URL paths should be unique to a zone. For example, two zones trying to serve/blogwould create a routing conflict.Routing requests using middlewareRouting requests throughrewritesis recommended to minimize latency overhead for the requests, but middleware can also be used when there is a need for a dynamic decision when routing. For example, if you are using a feature flag to decide where a path should be routed such as during a migration, you can use middleware.middleware.jsexportasyncfunctionmiddleware(request) {const{pathname,search}=req.nextUrl;if(pathname==='/your-path'&&myFeatureFlag.isEnabled()) {returnNextResponse.rewrite(`${rewriteDomain}${pathname}${search});}}Linking between zonesLinks to paths in a different zone should use anatag instead of the Next.js<Link>component. This is because Next.js will try to prefetch and soft navigate to any relative path in<Link>component, which will not work across zones.Sharing codeThe Next.js applications that make up the different zones can live in any repository. However, it is often convenient to put these zones in amonorepoto more easily share code. For zones that live in different repositories, code can also be shared using public or private NPM packages.Since the pages in different zones may be released at different times, feature flags can be useful for enabling or disabling features in unison across the different zones.ForNext.js on Vercelapplications, you can use amonorepoto deploy all affected zones with a singlegit push.Server ActionsWhen usingServer Actionswith Multi-Zones, you must explicitly allow the user-facing origin since your user facing domain may serve multiple applications. In yournext.config.jsfile, add the following lines:next.config.jsconstnextConfig={experimental:{serverActions:{allowedOrigins:['your-production-domain.com'],},},}SeeserverActions.allowedOriginsfor more information.PreviousStatic ExportsNextUpgradingWas this helpful?supported.Send"
upgrading,Upgrading,App RouterBuilding Your ApplicationUpgradingUpgrade GuideUpgrade your application to newer versions of Next.js or migrate from the Pages Router to the App Router.CodemodsUse codemods to upgrade your Next.js codebase when new features are released.CanaryUpgrade your Next.js Application to canary and try out new features.Version 15Upgrade your Next.js Application from Version 14 to 15.Version 14Upgrade your Next.js Application from Version 13 to 14.App Router MigrationLearn how to upgrade your existing Next.js application from the Pages Router to the App Router.Migrating from CRALearn how to migrate your existing React application from Create React App to Next.js.Migrating from ViteLearn how to migrate your existing React application from Vite to Next.js.Single-Page AppsNext.js fully supports building Single-Page Applications (SPAs).PreviousMulti-ZonesNextCodemodsWas this helpful?supported.Send
codemods,Codemods,"Building Your ApplicationUpgradingCodemodsCodemodsCodemods are transformations that run on your codebase programmatically. This allows a large number of changes to be programmatically applied without having to manually go through every file.Next.js provides Codemod transformations to help upgrade your Next.js codebase when an API is updated or deprecated.UsageIn your terminal, navigate (cd) into your project's folder, then run:Terminalnpx@next/codemod<transform><path>Replacing<transform>and<path>with appropriate values.transform- name of transformpath- files or directory to transform--dryDo a dry-run, no code will be edited--printPrints the changed output for comparisonCodemods15.0Transform App Router Route Segment Configruntimevalue fromexperimental-edgetoedgeapp-dir-runtime-config-experimental-edgeNote: This codemod is App Router specific.Terminalnpx@next/codemod@latestapp-dir-runtime-config-experimental-edge.This codemod transformsRoute Segment Configruntimevalueexperimental-edgetoedge.For example:exportconstruntime='experimental-edge'Transforms into:exportconstruntime='edge'Migrate to async Dynamic APIsAPIs that opted into dynamic rendering that previously supported synchronous access are now asynchronous. You can read more about this breaking change in theupgrade guide.next-async-request-apiTerminalnpx@next/codemod@latestnext-async-request-api.This codemod will transform dynamic APIs (cookies(),headers()anddraftMode()fromnext/headers) that are now asynchronous to be properly awaited or wrapped withReact.use()if applicable.
When an automatic migration isn't possible, the codemod will either add a typecast (if a TypeScript file) or a comment to inform the user that it needs to be manually reviewed & updated.For example:import{ cookies,headers }from'next/headers'consttoken=cookies().get('token')functionuseToken() {consttoken=cookies().get('token')returntoken}exportdefaultfunctionPage() {constname=cookies().get('name')}functiongetHeader() {returnheaders().get('x-foo')}Transforms into:import{ use }from'react'import{cookies,headers,typeUnsafeUnwrappedCookies,typeUnsafeUnwrappedHeaders,}from'next/headers'consttoken=(cookies()asunknownasUnsafeUnwrappedCookies).get('token')functionuseToken() {consttoken=use(cookies()).get('token')returntoken}exportdefaultasyncfunctionPage() {constname=(awaitcookies()).get('name')}functiongetHeader() {return(headers()asunknownasUnsafeUnwrappedHeaders).get('x-foo')}When we detect property access on theparamsorsearchParamsprops in the page / route entries (page.js,layout.js,route.js, ordefault.js) or thegenerateMetadata/generateViewportAPIs,
it will attempt to transform the callsite from a sync to an async function, and await the property access. If it can't be made async (such as with a client component), it will useReact.useto unwrap the promise .For example:// page.tsxexportdefaultfunctionPage({params,searchParams,}:{params:{ slug:string}searchParams:{ [key:string]:string|string[]|undefined}}) {const{value}=searchParamsif(value==='foo') {// ...}}exportfunctiongenerateMetadata({ params }:{ params:{ slug:string} }) {const{slug}=paramsreturn{title:`My Page -${slug}`,}}Transforms into:// page.tsxexportdefaultasyncfunctionPage(props:{params:Promise<{ slug:string}>searchParams:Promise<{ [key:string]:string|string[]|undefined}>}) {constsearchParams=awaitprops.searchParamsconst{value}=searchParamsif(value==='foo') {// ...}}exportasyncfunctiongenerateMetadata(props:{params:Promise<{ slug:string}>}) {constparams=awaitprops.paramsconst{slug}=paramsreturn{title:`My Page -${slug}`,}}Good to know:When this codemod identifies a spot that might require manual intervention, but we aren't able to determine the exact fix, it will add a comment or typecast to the code to inform the user that it needs to be manually updated. These comments are prefixed with@next/codemod, and typecasts are prefixed withUnsafeUnwrapped.
Your build will error until these comments are explicitly removed.Read more.Replacegeoandipproperties ofNextRequestwith@vercel/functionsnext-request-geo-ipTerminalnpx@next/codemod@latestnext-request-geo-ip.This codemod installs@vercel/functionsand transformsgeoandipproperties ofNextRequestwith corresponding@vercel/functionsfeatures.For example:importtype{ NextRequest }from'next/server'exportfunctionGET(req:NextRequest) {const{geo,ip}=req}Transforms into:importtype{ NextRequest }from'next/server'import{ geolocation,ipAddress }from'@vercel/functions'exportfunctionGET(req:NextRequest) {constgeo=geolocation(req)constip=ipAddress(req)}14.0MigrateImageResponseimportsnext-og-importTerminalnpx@next/codemod@latestnext-og-import.This codemod moves transforms imports fromnext/servertonext/ogfor usage ofDynamic OG Image Generation.For example:import{ ImageResponse }from'next/server'Transforms into:import{ ImageResponse }from'next/og'Useviewportexportmetadata-to-viewport-exportTerminalnpx@next/codemod@latestmetadata-to-viewport-export.This codemod migrates certain viewport metadata toviewportexport.For example:exportconstmetadata={title:'My App',themeColor:'dark',viewport:{width:1,},}Transforms into:exportconstmetadata={title:'My App',}exportconstviewport={width:1,themeColor:'dark',}13.2Use Built-in Fontbuilt-in-next-fontTerminalnpx@next/codemod@latestbuilt-in-next-font.This codemod uninstalls the@next/fontpackage and transforms@next/fontimports into the built-innext/font.For example:import{ Inter }from'@next/font/google'Transforms into:import{ Inter }from'next/font/google'13.0Rename Next Image Importsnext-image-to-legacy-imageTerminalnpx@next/codemod@latestnext-image-to-legacy-image.Safely renamesnext/imageimports in existing Next.js 10, 11, or 12 applications tonext/legacy/imagein Next.js 13. Also renamesnext/future/imagetonext/image.For example:pages/index.jsimportImage1from'next/image'importImage2from'next/future/image'exportdefaultfunctionHome() {return(<div><Image1src=""/test.jpg""width=""200""height=""300""/><Image2src=""/test.png""width=""500""height=""400""/></div>)}Transforms into:pages/index.js// 'next/image' becomes 'next/legacy/image'importImage1from'next/legacy/image'// 'next/future/image' becomes 'next/image'importImage2from'next/image'exportdefaultfunctionHome() {return(<div><Image1src=""/test.jpg""width=""200""height=""300""/><Image2src=""/test.png""width=""500""height=""400""/></div>)}Migrate to the New Image Componentnext-image-experimentalTerminalnpx@next/codemod@latestnext-image-experimental.Dangerously migrates fromnext/legacy/imageto the newnext/imageby adding inline styles and removing unused props.Removeslayoutprop and addsstyle.RemovesobjectFitprop and addsstyle.RemovesobjectPositionprop and addsstyle.RemoveslazyBoundaryprop.RemoveslazyRootprop.Remove<a>Tags From Link Componentsnew-linkTerminalnpx@next/codemod@latestnew-link.Remove<a>tags insideLink Components, or add alegacyBehaviorprop to Links that cannot be auto-fixed.For example:<Linkhref=""/about""><a>About</a></Link>// transforms into<Linkhref=""/about"">About</Link><Linkhref=""/about""><aonClick={()=>console.log('clicked')}>About</a></Link>// transforms into<Linkhref=""/about""onClick={()=>console.log('clicked')}>About</Link>In cases where auto-fixing can't be applied, thelegacyBehaviorprop is added. This allows your app to keep functioning using the old behavior for that particular link.constComponent=()=><a>About</a><Linkhref=""/about""><Component/></Link>// becomes<Linkhref=""/about""legacyBehavior><Component/></Link>11Migrate from CRAcra-to-nextTerminalnpx@next/codemodcra-to-nextMigrates a Create React App project to Next.js; creating a Pages Router and necessary config to match behavior. Client-side only rendering is leveraged initially to prevent breaking compatibility due towindowusage during SSR and can be enabled seamlessly to allow the gradual adoption of Next.js specific features.Please share any feedback related to this transformin this discussion.10Add React importsadd-missing-react-importTerminalnpx@next/codemodadd-missing-react-importTransforms files that do not importReactto include the import in order for the newReact JSX transformto work.For example:my-component.jsexportdefaultclassHomeextendsReact.Component{render() {return<div>Hello World</div>}}Transforms into:my-component.jsimportReactfrom'react'exportdefaultclassHomeextendsReact.Component{render() {return<div>Hello World</div>}}9Transform Anonymous Components into Named Componentsname-default-componentTerminalnpx@next/codemodname-default-componentVersions 9 and above.Transforms anonymous components into named components to make sure they work withFast Refresh.For example:my-component.jsexportdefaultfunction() {return<div>Hello World</div>}Transforms into:my-component.jsexportdefaultfunctionMyComponent() {return<div>Hello World</div>}The component will have a camel-cased name based on the name of the file, and it also works with arrow functions.8Transform AMP HOC into page configwithamp-to-configTerminalnpx@next/codemodwithamp-to-configTransforms thewithAmpHOC into Next.js 9 page configuration.For example:// Beforeimport{ withAmp }from'next/amp'functionHome() {return<h1>My AMP Page</h1>}exportdefaultwithAmp(Home)// AfterexportdefaultfunctionHome() {return<h1>My AMP Page</h1>}exportconstconfig={amp:true,}6UsewithRouterurl-to-withrouterTerminalnpx@next/codemodurl-to-withrouterTransforms the deprecated automatically injectedurlproperty on top level pages to usingwithRouterand therouterproperty it injects. Read more here:https://nextjs.org/docs/messages/url-deprecatedFor example:FromimportReactfrom'react'exportdefaultclassextendsReact.Component{render() {const{pathname}=this.props.urlreturn<div>Current pathname: {pathname}</div>}}ToimportReactfrom'react'import{ withRouter }from'next/router'exportdefaultwithRouter(classextendsReact.Component{render() {const{pathname}=this.props.routerreturn<div>Current pathname: {pathname}</div>}})This is one case. All the cases that are transformed (and tested) can be found in the__testfixtures__directory.PreviousUpgradingNextCanaryWas this helpful?supported.Send"
canary,Canary,"Building Your ApplicationUpgradingCanaryHow to upgrade to Next.js CanaryThe Next.js canary channel is updated daily with the latest experimental features and bug fixes. It's a great way to try out new features andgive feedbackbefore they are released in a stable version.To upgrade to canary, make sure you're on the latest version of Next.js and everything is working as expected. See theupgrade guidesfor more information.Then, run the following command:Terminalnpminext@canary# oryarnaddnext@canary# orpnpminext@canaryFeatures available in canaryThe following features are currently available in canary:Caching:""use cache""cacheLifecacheTagdynamicIOAuthentication:forbiddenunauthorizedforbidden.jsunauthorized.jsauthInterruptsPreviousCodemodsNextVersion 15Was this helpful?supported.Send"
version 15,Version 15,"Building Your ApplicationUpgradingVersion 15Version 15Upgrading from 14 to 15To update to Next.js version 15, you can use theupgradecodemod:Terminalnpx@next/codemod@canaryupgradelatestIf you prefer to do it manually, ensure that you're installing the latest Next & React versions:Terminalnpminext@latestreact@latestreact-dom@latesteslint-config-next@latestGood to know:If you see a peer dependencies warning, you may need to updatereactandreact-domto the suggested versions, or you use the--forceor--legacy-peer-depsflag to ignore the warning. This won't be necessary once both Next.js 15 and React 19 are stable.React 19The minimum versions ofreactandreact-domis now 19.useFormStatehas been replaced byuseActionState. TheuseFormStatehook is still available in React 19, but it is deprecated and will be removed in a future release.useActionStateis recommended and includes additional properties like reading thependingstate directly.Learn more.useFormStatusnow includes additional keys likedata,method, andaction. If you are not using React 19, only thependingkey is available.Learn more.Read more in theReact 19 upgrade guide.Good to know:If you are using TypeScript, ensure you also upgrade@types/reactand@types/react-domto their latest versions.Async Request APIs (Breaking change)Previously synchronous Dynamic APIs that rely on runtime information are nowasynchronous:cookiesheadersdraftModeparamsinlayout.js,page.js,route.js,default.js,opengraph-image,twitter-image,icon, andapple-icon.searchParamsinpage.jsTo ease the burden of migration, acodemod is availableto automate the process and the APIs can temporarily be accessed synchronously.cookiesRecommended Async Usageimport{ cookies }from'next/headers'// BeforeconstcookieStore=cookies()consttoken=cookieStore.get('token')// AfterconstcookieStore=awaitcookies()consttoken=cookieStore.get('token')Temporary Synchronous Usageapp/page.tsxTypeScriptJavaScriptTypeScriptimport{ cookies,typeUnsafeUnwrappedCookies }from'next/headers'// BeforeconstcookieStore=cookies()consttoken=cookieStore.get('token')// AfterconstcookieStore=cookies()asunknownasUnsafeUnwrappedCookies// will log a warning in devconsttoken=cookieStore.get('token')headersRecommended Async Usageimport{ headers }from'next/headers'// BeforeconstheadersList=headers()constuserAgent=headersList.get('user-agent')// AfterconstheadersList=awaitheaders()constuserAgent=headersList.get('user-agent')Temporary Synchronous Usageapp/page.tsxTypeScriptJavaScriptTypeScriptimport{ headers,typeUnsafeUnwrappedHeaders }from'next/headers'// BeforeconstheadersList=headers()constuserAgent=headersList.get('user-agent')// AfterconstheadersList=headers()asunknownasUnsafeUnwrappedHeaders// will log a warning in devconstuserAgent=headersList.get('user-agent')draftModeRecommended Async Usageimport{ draftMode }from'next/headers'// Beforeconst{isEnabled}=draftMode()// Afterconst{isEnabled}=awaitdraftMode()Temporary Synchronous Usageapp/page.tsxTypeScriptJavaScriptTypeScriptimport{ draftMode,typeUnsafeUnwrappedDraftMode }from'next/headers'// Beforeconst{isEnabled}=draftMode()// After// will log a warning in devconst{isEnabled}=draftMode()asunknownasUnsafeUnwrappedDraftModeparams&searchParamsAsynchronous Layoutapp/layout.tsxTypeScriptJavaScriptTypeScript// BeforetypeParams={ slug:string}exportfunctiongenerateMetadata({ params }:{ params:Params}) {const{slug}=params}exportdefaultasyncfunctionLayout({children,params,}:{children:React.ReactNodeparams:Params}) {const{slug}=params}// AftertypeParams=Promise<{ slug:string}>exportasyncfunctiongenerateMetadata({ params }:{ params:Params}) {const{slug}=awaitparams}exportdefaultasyncfunctionLayout({children,params,}:{children:React.ReactNodeparams:Params}) {const{slug}=awaitparams}Synchronous Layoutapp/layout.tsxTypeScriptJavaScriptTypeScript// BeforetypeParams={ slug:string}exportdefaultfunctionLayout({children,params,}:{children:React.ReactNodeparams:Params}) {const{slug}=params}// Afterimport{ use }from'react'typeParams=Promise<{ slug:string}>exportdefaultfunctionLayout(props:{children:React.ReactNodeparams:Params}) {constparams=use(props.params)constslug=params.slug}Asynchronous Pageapp/page.tsxTypeScriptJavaScriptTypeScript// BeforetypeParams={ slug:string}typeSearchParams={ [key:string]:string|string[]|undefined}exportfunctiongenerateMetadata({params,searchParams,}:{params:ParamssearchParams:SearchParams}) {const{slug}=paramsconst{query}=searchParams}exportdefaultasyncfunctionPage({params,searchParams,}:{params:ParamssearchParams:SearchParams}) {const{slug}=paramsconst{query}=searchParams}// AftertypeParams=Promise<{ slug:string}>typeSearchParams=Promise<{ [key:string]:string|string[]|undefined}>exportasyncfunctiongenerateMetadata(props:{params:ParamssearchParams:SearchParams}) {constparams=awaitprops.paramsconstsearchParams=awaitprops.searchParamsconstslug=params.slugconstquery=searchParams.query}exportdefaultasyncfunctionPage(props:{params:ParamssearchParams:SearchParams}) {constparams=awaitprops.paramsconstsearchParams=awaitprops.searchParamsconstslug=params.slugconstquery=searchParams.query}Synchronous Page'use client'// BeforetypeParams={ slug:string}typeSearchParams={ [key:string]:string|string[]|undefined}exportdefaultfunctionPage({params,searchParams,}:{params:ParamssearchParams:SearchParams}) {const{slug}=paramsconst{query}=searchParams}// Afterimport{ use }from'react'typeParams=Promise<{ slug:string}>typeSearchParams=Promise<{ [key:string]:string|string[]|undefined}>exportdefaultfunctionPage(props:{params:ParamssearchParams:SearchParams}) {constparams=use(props.params)constsearchParams=use(props.searchParams)constslug=params.slugconstquery=searchParams.query}// BeforeexportdefaultfunctionPage({ params,searchParams }) {const{slug}=paramsconst{query}=searchParams}// Afterimport{ use }from""react""exportdefaultfunctionPage(props) {constparams=use(props.params)constsearchParams=use(props.searchParams)constslug=params.slugconstquery=searchParams.query}Route Handlersapp/api/route.ts// BeforetypeParams={ slug:string}exportasyncfunctionGET(request:Request,segmentData:{ params:Params}) {constparams=segmentData.paramsconstslug=params.slug}// AftertypeParams=Promise<{ slug:string}>exportasyncfunctionGET(request:Request,segmentData:{ params:Params}) {constparams=awaitsegmentData.paramsconstslug=params.slug}app/api/route.js// BeforeexportasyncfunctionGET(request,segmentData) {constparams=segmentData.paramsconstslug=params.slug}// AfterexportasyncfunctionGET(request,segmentData) {constparams=awaitsegmentData.paramsconstslug=params.slug}runtimeconfiguration (Breaking change)Theruntimesegment configurationpreviously supported a value ofexperimental-edgein addition toedge. Both configurations refer to the same thing, and to simplify the options, we will now error ifexperimental-edgeis used. To fix this, update yourruntimeconfiguration toedge. Acodemodis available to automatically do this.fetchrequestsfetchrequestsare no longer cached by default.To opt specificfetchrequests into caching, you can pass thecache: 'force-cache'option.app/layout.jsexportdefaultasyncfunctionRootLayout() {consta=awaitfetch('https://...')// Not Cachedconstb=awaitfetch('https://...',{ cache:'force-cache'})// Cached// ...}To opt allfetchrequests in a layout or page into caching, you can use theexport const fetchCache = 'default-cache'segment config option. If individualfetchrequests specify acacheoption, that will be used instead.app/layout.js// Since this is the root layout, all fetch requests in the app// that don't set their own cache option will be cached.exportconstfetchCache='default-cache'exportdefaultasyncfunctionRootLayout() {consta=awaitfetch('https://...')// Cachedconstb=awaitfetch('https://...',{ cache:'no-store'})// Not cached// ...}Route HandlersGETfunctions inRoute Handlersare no longer cached by default. To optGETmethods into caching, you can use aroute config optionsuch asexport const dynamic = 'force-static'in your Route Handler file.app/api/route.jsexportconstdynamic='force-static'exportasyncfunctionGET() {}Client-side Router CacheWhen navigating between pages via<Link>oruseRouter,pagesegments are no longer reused from the client-side router cache. However, they are still reused during browser backward and forward navigation and for shared layouts.To opt page segments into caching, you can use thestaleTimesconfig option:next.config.js/**@type{import('next').NextConfig}*/constnextConfig={experimental:{staleTimes:{dynamic:30,static:180,},},}module.exports=nextConfigLayoutsandloading statesare still cached and reused on navigation.next/fontThe@next/fontpackage has been removed in favor of the built-innext/font. Acodemod is availableto safely and automatically rename your imports.app/layout.js// Beforeimport{ Inter }from'@next/font/google'// Afterimport{ Inter }from'next/font/google'bundlePagesRouterDependenciesexperimental.bundlePagesExternalsis now stable and renamed tobundlePagesRouterDependencies.next.config.js/**@type{import('next').NextConfig}*/constnextConfig={// Beforeexperimental:{bundlePagesExternals:true,},// AfterbundlePagesRouterDependencies:true,}module.exports=nextConfigserverExternalPackagesexperimental.serverComponentsExternalPackagesis now stable and renamed toserverExternalPackages.next.config.js/**@type{import('next').NextConfig}*/constnextConfig={// Beforeexperimental:{serverComponentsExternalPackages:['package-name'],},// AfterserverExternalPackages:['package-name'],}module.exports=nextConfigSpeed InsightsAuto instrumentation for Speed Insights was removed in Next.js 15.To continue using Speed Insights, follow theVercel Speed Insights Quickstartguide.NextRequestGeolocationThegeoandipproperties onNextRequesthave been removed as these values are provided by your hosting provider. Acodemodis available to automate this migration.If you are using Vercel, you can alternatively use thegeolocationandipAddressfunctions from@vercel/functionsinstead:middleware.tsimport{ geolocation }from'@vercel/functions'importtype{ NextRequest }from'next/server'exportfunctionmiddleware(request:NextRequest) {const{city}=geolocation(request)// ...}middleware.tsimport{ ipAddress }from'@vercel/functions'importtype{ NextRequest }from'next/server'exportfunctionmiddleware(request:NextRequest) {constip=ipAddress(request)// ...}PreviousCanaryNextVersion 14Was this helpful?supported.Send"
version 14,Version 14,"Building Your ApplicationUpgradingVersion 14Version 14Upgrading from 13 to 14To update to Next.js version 14, run the following command using your preferred package manager:Terminalnpminext@next-14react@18react-dom@18&&npmieslint-config-next@next-14-DTerminalyarnaddnext@next-14react@18react-dom@18&&yarnaddeslint-config-next@next-14-DTerminalpnpminext@next-14react@18react-dom@18&&pnpmieslint-config-next@next-14-DTerminalbunaddnext@next-14react@18react-dom@18&&bunaddeslint-config-next@next-14-DGood to know:If you are using TypeScript, ensure you also upgrade@types/reactand@types/react-domto their latest versions.v14 SummaryThe minimum Node.js version has been bumped from 16.14 to 18.17, since 16.x has reached end-of-life.Thenext exportcommand has been removed in favor ofoutput: 'export'config. Please see thedocsfor more information.Thenext/serverimport forImageResponsewas renamed tonext/og. Acodemod is availableto safely and automatically rename your imports.The@next/fontpackage has been fully removed in favor of the built-innext/font. Acodemod is availableto safely and automatically rename your imports.The WASM target fornext-swchas been removed.PreviousVersion 15NextApp Router MigrationWas this helpful?supported.Send"
app router migration,App Router Migration,"Building Your ApplicationUpgradingApp Router MigrationApp Router Incremental Adoption GuideThis guide will help you:Update your Next.js application from version 12 to version 13Upgrade features that work in both thepagesand theappdirectoriesIncrementally migrate your existing application frompagestoappUpgradingNode.js VersionThe minimum Node.js version is nowv18.17. See theNode.js documentationfor more information.Next.js VersionTo update to Next.js version 13, run the following command using your preferred package manager:Terminalnpminstallnext@latestreact@latestreact-dom@latestESLint VersionIf you're using ESLint, you need to upgrade your ESLint version:Terminalnpminstall-Deslint-config-next@latestGood to know: You may need to restart the ESLint server in VS Code for the ESLint changes to take effect. Open the Command Palette (cmd+shift+pon Mac;ctrl+shift+pon Windows) and search forESLint: Restart ESLint Server.Next StepsAfter you've updated, see the following sections for next steps:Upgrade new features: A guide to help you upgrade to new features such as the improved Image and Link Components.Migrate from thepagestoappdirectory: A step-by-step guide to help you incrementally migrate from thepagesto theappdirectory.Upgrading New FeaturesNext.js 13 introduced the newApp Routerwith new features and conventions. The new Router is available in theappdirectory and co-exists with thepagesdirectory.Upgrading to Next.js 13 doesnotrequire using the App Router. You can continue usingpageswith new features that work in both directories, such as the updatedImage component,Link component,Script component, andFont optimization.<Image/>ComponentNext.js 12 introduced new improvements to the Image Component with a temporary import:next/future/image. These improvements included less client-side JavaScript, easier ways to extend and style images, better accessibility, and native browser lazy loading.In version 13, this new behavior is now the default fornext/image.There are two codemods to help you migrate to the new Image Component:next-image-to-legacy-imagecodemod: Safely and automatically renamesnext/imageimports tonext/legacy/image. Existing components will maintain the same behavior.next-image-experimentalcodemod: Dangerously adds inline styles and removes unused props. This will change the behavior of existing components to match the new defaults. To use this codemod, you need to run thenext-image-to-legacy-imagecodemod first.<Link>ComponentThe<Link>Componentno longer requires manually adding an<a>tag as a child. This behavior was added as an experimental option inversion 12.2and is now the default. In Next.js 13,<Link>always renders<a>and allows you to forward props to the underlying tag.For example:importLinkfrom'next/link'// Next.js 12: `<a>` has to be nested otherwise it's excluded<Linkhref=""/about""><a>About</a></Link>// Next.js 13: `<Link>` always renders `<a>` under the hood<Linkhref=""/about"">About</Link>To upgrade your links to Next.js 13, you can use thenew-linkcodemod.<Script>ComponentThe behavior ofnext/scripthas been updated to support bothpagesandapp, but some changes need to be made to ensure a smooth migration:Move anybeforeInteractivescripts you previously included in_document.jsto the root layout file (app/layout.tsx).The experimentalworkerstrategy does not yet work inappand scripts denoted with this strategy will either have to be removed or modified to use a different strategy (e.g.lazyOnload).onLoad,onReady, andonErrorhandlers will not work in Server Components so make sure to move them to aClient Componentor remove them altogether.Font OptimizationPreviously, Next.js helped you optimize fonts byinlining font CSS. Version 13 introduces the newnext/fontmodule which gives you the ability to customize your font loading experience while still ensuring great performance and privacy.next/fontis supported in both thepagesandappdirectories.Whileinlining CSSstill works inpages, it does not work inapp. You should usenext/fontinstead.See theFont Optimizationpage to learn how to usenext/font.Migrating frompagestoapp🎥 Watch:Learn how to incrementally adopt the App Router →YouTube (16 minutes).Moving to the App Router may be the first time using React features that Next.js builds on top of such as Server Components, Suspense, and more. When combined with new Next.js features such asspecial filesandlayouts, migration means new concepts, mental models, and behavioral changes to learn.We recommend reducing the combined complexity of these updates by breaking down your migration into smaller steps. Theappdirectory is intentionally designed to work simultaneously with thepagesdirectory to allow for incremental page-by-page migration.Theappdirectory supports nested routesandlayouts.Learn more.Use nested folders to define routes and a specialpage.jsfile to make a route segment publicly accessible.Learn more.Special file conventionsare used to create UI for each route segment. The most common special files arepage.jsandlayout.js.Usepage.jsto define UI unique to a route.Uselayout.jsto define UI that is shared across multiple routes..js,.jsx, or.tsxfile extensions can be used for special files.You can colocate other files inside theappdirectory such as components, styles, tests, and more.Learn more.Data fetching functions likegetServerSidePropsandgetStaticPropshave been replaced witha new APIinsideapp.getStaticPathshas been replaced withgenerateStaticParams.pages/_app.jsandpages/_document.jshave been replaced with a singleapp/layout.jsroot layout.Learn more.pages/_error.jshas been replaced with more granularerror.jsspecial files.Learn more.pages/404.jshas been replaced with thenot-found.jsfile.pages/api/*API Routes have been replaced with theroute.js(Route Handler) special file.Step 1: Creating theappdirectoryUpdate to the latest Next.js version (requires 13.4 or greater):npminstallnext@latestThen, create a newappdirectory at the root of your project (orsrc/directory).Step 2: Creating a Root LayoutCreate a newapp/layout.tsxfile inside theappdirectory. This is aroot layoutthat will apply to all routes insideapp.app/layout.tsxTypeScriptJavaScriptTypeScriptexportdefaultfunctionRootLayout({// Layouts must accept a children prop.// This will be populated with nested layouts or pageschildren,}:{children:React.ReactNode}) {return(<htmllang=""en""><body>{children}</body></html>)}Theappdirectorymustinclude a root layout.The root layout must define<html>, and<body>tags since Next.js does not automatically create themThe root layout replaces thepages/_app.tsxandpages/_document.tsxfiles..js,.jsx, or.tsxextensions can be used for layout files.To manage<head>HTML elements, you can use thebuilt-in SEO support:app/layout.tsxTypeScriptJavaScriptTypeScriptimporttype{ Metadata }from'next'exportconstmetadata:Metadata={title:'Home',description:'Welcome to Next.js',}Migrating_document.jsand_app.jsIf you have an existing_appor_documentfile, you can copy the contents (e.g. global styles) to the root layout (app/layout.tsx). Styles inapp/layout.tsxwillnotapply topages/*. You should keep_app/_documentwhile migrating to prevent yourpages/*routes from breaking. Once fully migrated, you can then safely delete them.If you are using any React Context providers, they will need to be moved to aClient Component.Migrating thegetLayout()pattern to Layouts (Optional)Next.js recommended adding aproperty to Page componentsto achieve per-page layouts in thepagesdirectory. This pattern can be replaced with native support fornested layoutsin theappdirectory.See before and after exampleBeforecomponents/DashboardLayout.jsexportdefaultfunctionDashboardLayout({ children }) {return(<div><h2>My Dashboard</h2>{children}</div>)}pages/dashboard/index.jsimportDashboardLayoutfrom'../components/DashboardLayout'exportdefaultfunctionPage() {return<p>My Page</p>}Page.getLayout=functiongetLayout(page) {return<DashboardLayout>{page}</DashboardLayout>}AfterRemove thePage.getLayoutproperty frompages/dashboard/index.jsand follow thesteps for migrating pagesto theappdirectory.app/dashboard/page.jsexportdefaultfunctionPage() {return<p>My Page</p>}Move the contents ofDashboardLayoutinto a newClient Componentto retainpagesdirectory behavior.app/dashboard/DashboardLayout.js'use client'// this directive should be at top of the file, before any imports.// This is a Client ComponentexportdefaultfunctionDashboardLayout({ children }) {return(<div><h2>My Dashboard</h2>{children}</div>)}Import theDashboardLayoutinto a newlayout.jsfile inside theappdirectory.app/dashboard/layout.jsimportDashboardLayoutfrom'./DashboardLayout'// This is a Server ComponentexportdefaultfunctionLayout({ children }) {return<DashboardLayout>{children}</DashboardLayout>}You can incrementally move non-interactive parts ofDashboardLayout.js(Client Component) intolayout.js(Server Component) to reduce the amount of component JavaScript you send to the client.Step 3: Migratingnext/headIn thepagesdirectory, thenext/headReact component is used to manage<head>HTML elements such astitleandmeta. In theappdirectory,next/headis replaced with the newbuilt-in SEO support.Before:pages/index.tsxTypeScriptJavaScriptTypeScriptimportHeadfrom'next/head'exportdefaultfunctionPage() {return(<><Head><title>My page title</title></Head></>)}After:app/page.tsxTypeScriptJavaScriptTypeScriptimporttype{ Metadata }from'next'exportconstmetadata:Metadata={title:'My Page Title',}exportdefaultfunctionPage() {return'...'}See all metadata options.Step 4: Migrating PagesPages in theappdirectoryareServer Componentsby default. This is different from thepagesdirectory where pages areClient Components.Data fetchinghas changed inapp.getServerSideProps,getStaticPropsandgetInitialPropshave been replaced with a simpler API.Theappdirectory uses nested folders to define routes and a specialpage.jsfile to make a route segment publicly accessible.pagesDirectoryappDirectoryRouteindex.jspage.js/about.jsabout/page.js/aboutblog/[slug].jsblog/[slug]/page.js/blog/post-1We recommend breaking down the migration of a page into two main steps:Step 1: Move the default exported Page Component into a new Client Component.Step 2: Import the new Client Component into a newpage.jsfile inside theappdirectory.Good to know: This is the easiest migration path because it has the most comparable behavior to thepagesdirectory.Step 1: Create a new Client ComponentCreate a new separate file inside theappdirectory (i.e.app/home-page.tsxor similar) that exports a Client Component. To define Client Components, add the'use client'directive to the top of the file (before any imports).Similar to the Pages Router, there is anoptimization stepto prerender Client Components to static HTML on the initial page load.Move the default exported page component frompages/index.jstoapp/home-page.tsx.app/home-page.tsxTypeScriptJavaScriptTypeScript'use client'// This is a Client Component (same as components in the `pages` directory)// It receives data as props, has access to state and effects, and is// prerendered on the server during the initial page load.exportdefaultfunctionHomePage({ recentPosts }) {return(<div>{recentPosts.map((post)=>(<divkey={post.id}>{post.title}</div>))}</div>)}Step 2: Create a new pageCreate a newapp/page.tsxfile inside theappdirectory. This is a Server Component by default.Import thehome-page.tsxClient Component into the page.If you were fetching data inpages/index.js, move the data fetching logic directly into the Server Component using the newdata fetching APIs. See thedata fetching upgrade guidefor more details.app/page.tsxTypeScriptJavaScriptTypeScript// Import your Client ComponentimportHomePagefrom'./home-page'asyncfunctiongetPosts() {constres=awaitfetch('https://...')constposts=awaitres.json()returnposts}exportdefaultasyncfunctionPage() {// Fetch data directly in a Server ComponentconstrecentPosts=awaitgetPosts()// Forward fetched data to your Client Componentreturn<HomePagerecentPosts={recentPosts} />}If your previous page useduseRouter, you'll need to update to the new routing hooks.Learn more.Start your development server and visithttp://localhost:3000. You should see your existing index route, now served through the app directory.Step 5: Migrating Routing HooksA new router has been added to support the new behavior in theappdirectory.Inapp, you should use the three new hooks imported fromnext/navigation:useRouter(),usePathname(), anduseSearchParams().The newuseRouterhook is imported fromnext/navigationand has different behavior to theuseRouterhook inpageswhich is imported fromnext/router.TheuseRouterhook imported fromnext/routeris not supported in theappdirectory but can continue to be used in thepagesdirectory.The newuseRouterdoes not return thepathnamestring. Use the separateusePathnamehook instead.The newuseRouterdoes not return thequeryobject. Search parameters and dynamic route parameters are now separate. Use theuseSearchParamsanduseParamshooks instead.You can useuseSearchParamsandusePathnametogether to listen to page changes. See theRouter Eventssection for more details.These new hooks are only supported in Client Components. They cannot be used in Server Components.app/example-client-component.tsxTypeScriptJavaScriptTypeScript'use client'import{ useRouter,usePathname,useSearchParams }from'next/navigation'exportdefaultfunctionExampleClientComponent() {constrouter=useRouter()constpathname=usePathname()constsearchParams=useSearchParams()// ...}In addition, the newuseRouterhook has the following changes:isFallbackhas been removed becausefallbackhasbeen replaced.Thelocale,locales,defaultLocales,domainLocalesvalues have been removed because built-in i18n Next.js features are no longer necessary in theappdirectory.Learn more about i18n.basePathhas been removed. The alternative will not be part ofuseRouter. It has not yet been implemented.asPathhas been removed because the concept ofashas been removed from the new router.isReadyhas been removed because it is no longer necessary. Duringstatic rendering, any component that uses theuseSearchParams()hook will skip the prerendering step and instead be rendered on the client at runtime.routehas been removed.usePathnameoruseSelectedLayoutSegments()provide an alternative.View theuseRouter()API reference.Sharing components betweenpagesandappTo keep components compatible between thepagesandapprouters, refer to theuseRouterhook fromnext/compat/router.
This is theuseRouterhook from thepagesdirectory, but intended to be used while sharing components between routers. Once you are ready to use it only on theapprouter, update to the newuseRouterfromnext/navigation.Step 6: Migrating Data Fetching MethodsThepagesdirectory usesgetServerSidePropsandgetStaticPropsto fetch data for pages. Inside theappdirectory, these previous data fetching functions are replaced with asimpler APIbuilt on top offetch()andasyncReact Server Components.app/page.tsxTypeScriptJavaScriptTypeScriptexportdefaultasyncfunctionPage() {// This request should be cached until manually invalidated.// Similar to `getStaticProps`.// `force-cache` is the default and can be omitted.conststaticData=awaitfetch(`https://...`,{ cache:'force-cache'})// This request should be refetched on every request.// Similar to `getServerSideProps`.constdynamicData=awaitfetch(`https://...`,{ cache:'no-store'})// This request should be cached with a lifetime of 10 seconds.// Similar to `getStaticProps` with the `revalidate` option.constrevalidatedData=awaitfetch(`https://...`,{next:{ revalidate:10},})return<div>...</div>}Server-side Rendering (getServerSideProps)In thepagesdirectory,getServerSidePropsis used to fetch data on the server and forward props to the default exported React component in the file. The initial HTML for the page is prerendered from the server, followed by ""hydrating"" the page in the browser (making it interactive).pages/dashboard.js// `pages` directoryexportasyncfunctiongetServerSideProps() {constres=awaitfetch(`https://...`)constprojects=awaitres.json()return{ props:{ projects } }}exportdefaultfunctionDashboard({ projects }) {return(<ul>{projects.map((project)=>(<likey={project.id}>{project.name}</li>))}</ul>)}In the App Router, we can colocate our data fetching inside our React components usingServer Components. This allows us to send less JavaScript to the client, while maintaining the rendered HTML from the server.By setting thecacheoption tono-store, we can indicate that the fetched data shouldnever be cached. This is similar togetServerSidePropsin thepagesdirectory.app/dashboard/page.tsxTypeScriptJavaScriptTypeScript// `app` directory// This function can be named anythingasyncfunctiongetProjects() {constres=awaitfetch(`https://...`,{ cache:'no-store'})constprojects=awaitres.json()returnprojects}exportdefaultasyncfunctionDashboard() {constprojects=awaitgetProjects()return(<ul>{projects.map((project)=>(<likey={project.id}>{project.name}</li>))}</ul>)}Accessing Request ObjectIn thepagesdirectory, you can retrieve request-based data based on the Node.js HTTP API.For example, you can retrieve thereqobject fromgetServerSidePropsand use it to retrieve the request's cookies and headers.pages/index.js// `pages` directoryexportasyncfunctiongetServerSideProps({ req,query }) {constauthHeader=req.getHeaders()['authorization'];consttheme=req.cookies['theme'];return{ props:{...}}}exportdefaultfunctionPage(props) {return...}Theappdirectory exposes new read-only functions to retrieve request data:headers: Based on the Web Headers API, and can be used insideServer Componentsto retrieve request headers.cookies: Based on the Web Cookies API, and can be used insideServer Componentsto retrieve cookies.app/page.tsxTypeScriptJavaScriptTypeScript// `app` directoryimport{ cookies,headers }from'next/headers'asyncfunctiongetData() {constauthHeader=(awaitheaders()).get('authorization')return'...'}exportdefaultasyncfunctionPage() {// You can use `cookies` or `headers` inside Server Components// directly or in your data fetching functionconsttheme=(awaitcookies()).get('theme')constdata=awaitgetData()return'...'}Static Site Generation (getStaticProps)In thepagesdirectory, thegetStaticPropsfunction is used to pre-render a page at build time. This function can be used to fetch data from an external API or directly from a database, and pass this data down to the entire page as it's being generated during the build.pages/index.js// `pages` directoryexportasyncfunctiongetStaticProps() {constres=awaitfetch(`https://...`)constprojects=awaitres.json()return{ props:{ projects } }}exportdefaultfunctionIndex({ projects }) {returnprojects.map((project)=><div>{project.name}</div>)}In theappdirectory, data fetching withfetch()will default tocache: 'force-cache', which will cache the request data until manually invalidated. This is similar togetStaticPropsin thepagesdirectory.app/page.js// `app` directory// This function can be named anythingasyncfunctiongetProjects() {constres=awaitfetch(`https://...`)constprojects=awaitres.json()returnprojects}exportdefaultasyncfunctionIndex() {constprojects=awaitgetProjects()returnprojects.map((project)=><div>{project.name}</div>)}Dynamic paths (getStaticPaths)In thepagesdirectory, thegetStaticPathsfunction is used to define the dynamic paths that should be pre-rendered at build time.pages/posts/[id].js// `pages` directoryimportPostLayoutfrom'@/components/post-layout'exportasyncfunctiongetStaticPaths() {return{paths:[{ params:{ id:'1'} },{ params:{ id:'2'} }],}}exportasyncfunctiongetStaticProps({ params }) {constres=awaitfetch(`https://.../posts/${params.id}`)constpost=awaitres.json()return{ props:{ post } }}exportdefaultfunctionPost({ post }) {return<PostLayoutpost={post} />}In theappdirectory,getStaticPathsis replaced withgenerateStaticParams.generateStaticParamsbehaves similarly togetStaticPaths, but has a simplified API for returning route parameters and can be used insidelayouts. The return shape ofgenerateStaticParamsis an array of segments instead of an array of nestedparamobjects or a string of resolved paths.app/posts/[id]/page.js// `app` directoryimportPostLayoutfrom'@/components/post-layout'exportasyncfunctiongenerateStaticParams() {return[{ id:'1'},{ id:'2'}]}asyncfunctiongetPost(params) {constres=awaitfetch(`https://.../posts/${(awaitparams).id}`)constpost=awaitres.json()returnpost}exportdefaultasyncfunctionPost({ params }) {constpost=awaitgetPost(params)return<PostLayoutpost={post} />}Using the namegenerateStaticParamsis more appropriate thangetStaticPathsfor the new model in theappdirectory. Thegetprefix is replaced with a more descriptivegenerate, which sits better alone now thatgetStaticPropsandgetServerSidePropsare no longer necessary. ThePathssuffix is replaced byParams, which is more appropriate for nested routing with multiple dynamic segments.ReplacingfallbackIn thepagesdirectory, thefallbackproperty returned fromgetStaticPathsis used to define the behavior of a page that isn't pre-rendered at build time. This property can be set totrueto show a fallback page while the page is being generated,falseto show a 404 page, orblockingto generate the page at request time.pages/posts/[id].js// `pages` directoryexportasyncfunctiongetStaticPaths() {return{paths:[],fallback:'blocking'};}exportasyncfunctiongetStaticProps({ params }) {...}exportdefaultfunctionPost({ post }) {return...}In theappdirectory theconfig.dynamicParamspropertycontrols how params outside ofgenerateStaticParamsare handled:true: (default) Dynamic segments not included ingenerateStaticParamsare generated on demand.false: Dynamic segments not included ingenerateStaticParamswill return a 404.This replaces thefallback: true | false | 'blocking'option ofgetStaticPathsin thepagesdirectory. Thefallback: 'blocking'option is not included indynamicParamsbecause the difference between'blocking'andtrueis negligible with streaming.app/posts/[id]/page.js// `app` directoryexportconstdynamicParams=true;exportasyncfunctiongenerateStaticParams() {return[...]}asyncfunctiongetPost(params) {...}exportdefaultasyncfunctionPost({ params }) {constpost=awaitgetPost(params);return...}WithdynamicParamsset totrue(the default), when a route segment is requested that hasn't been generated, it will be server-rendered and cached.Incremental Static Regeneration (getStaticPropswithrevalidate)In thepagesdirectory, thegetStaticPropsfunction allows you to add arevalidatefield to automatically regenerate a page after a certain amount of time.pages/index.js// `pages` directoryexportasyncfunctiongetStaticProps() {constres=awaitfetch(`https://.../posts`)constposts=awaitres.json()return{props:{ posts },revalidate:60,}}exportdefaultfunctionIndex({ posts }) {return(<Layout><PostListposts={posts} /></Layout>)}In theappdirectory, data fetching withfetch()can userevalidate, which will cache the request for the specified amount of seconds.app/page.js// `app` directoryasyncfunctiongetPosts() {constres=awaitfetch(`https://.../posts`,{ next:{ revalidate:60} })constdata=awaitres.json()returndata.posts}exportdefaultasyncfunctionPostList() {constposts=awaitgetPosts()returnposts.map((post)=><div>{post.name}</div>)}API RoutesAPI Routes continue to work in thepages/apidirectory without any changes. However, they have been replaced byRoute Handlersin theappdirectory.Route Handlers allow you to create custom request handlers for a given route using the WebRequestandResponseAPIs.app/api/route.tsTypeScriptJavaScriptTypeScriptexportasyncfunctionGET(request:Request) {}Good to know: If you previously used API routes to call an external API from the client, you can now useServer Componentsinstead to securely fetch data. Learn more aboutdata fetching.Single-Page ApplicationsIf you are also migrating to Next.js from a Single-Page Application (SPA) at the same time, see ourdocumentationto learn more.Step 7: StylingIn thepagesdirectory, global stylesheets are restricted to onlypages/_app.js. With theappdirectory, this restriction has been lifted. Global styles can be added to any layout, page, or component.CSS ModulesTailwind CSSGlobal StylesCSS-in-JSExternal StylesheetsSassTailwind CSSIf you're using Tailwind CSS, you'll need to add theappdirectory to yourtailwind.config.jsfile:tailwind.config.jsmodule.exports={content:['./app/**/*.{js,ts,jsx,tsx,mdx}',// <-- Add this line'./pages/**/*.{js,ts,jsx,tsx,mdx}','./components/**/*.{js,ts,jsx,tsx,mdx}',],}You'll also need to import your global styles in yourapp/layout.jsfile:app/layout.jsimport'../styles/globals.css'exportdefaultfunctionRootLayout({ children }) {return(<htmllang=""en""><body>{children}</body></html>)}Learn more aboutstyling with Tailwind CSSUsing App Router together with Pages RouterWhen navigating between routes served by the different Next.js routers, there will be a hard navigation. Automatic link prefetching withnext/linkwill not prefetch across routers.Instead, you canoptimize navigationsbetween App Router and Pages Router to retain the prefetched and fast page transitions.Learn more.CodemodsNext.js provides Codemod transformations to help upgrade your codebase when a feature is deprecated. SeeCodemodsfor more information.PreviousVersion 14NextMigrating from CRAWas this helpful?supported.Send"
migrating from cra,Migrating from CRA,"Building Your ApplicationUpgradingMigrating from CRAMigrating from Create React AppThis guide will help you migrate an existing Create React App (CRA) site to Next.js.Why Switch?There are several reasons why you might want to switch from Create React App to Next.js:Slow initial page loading timeCreate React App uses purely client-side React. Client-side only applications, also known assingle-page applications (SPAs), often experience slow initial page loading time. This happens due to a couple of reasons:The browser needs to wait for the React code and your entire application bundle to download and run before your code is able to send requests to load data.Your application code grows with every new feature and dependency you add.No automatic code splittingThe previous issue of slow loading times can be somewhat mitigated with code splitting. However, if you try to do code splitting manually, you can inadvertently introduce network waterfalls. Next.js provides automatic code splitting and tree-shaking built into its router and build pipeline.Network waterfallsA common cause of poor performance occurs when applications make sequential client-server requests to fetch data. One pattern for data fetching in aSPAis to render a placeholder, and then fetch data after the component has mounted. Unfortunately, a child component can only begin fetching data after its parent has finished loading its own data, resulting in a “waterfall” of requests.While client-side data fetching is supported in Next.js, Next.js also lets you move data fetching to the server. This often eliminates client-server waterfalls altogether.Fast and intentional loading statesWith built-in support forstreaming through React Suspense, you can define which parts of your UI load first and in what order, without creating network waterfalls.This enables you to build pages that are faster to load and eliminatelayout shifts.Choose the data fetching strategyDepending on your needs, Next.js allows you to choose your data fetching strategy on a page or component-level basis. For example, you could fetch data from your CMS and render blog posts at build time (SSG) for quick load speeds, or fetch data at request time (SSR) when necessary.MiddlewareNext.js Middlewareallows you to run code on the server before a request is completed. For instance, you can avoid a flash of unauthenticated content by redirecting a user to a login page in the middleware for authenticated-only pages. You can also use it for features like A/B testing, experimentation, andinternationalization.Built-in OptimizationsImages,fonts, andthird-party scriptsoften have a large impact on an application’s performance. Next.js includes specialized components and APIs that automatically optimize them for you.Migration StepsOur goal is to get a working Next.js application as quickly as possible so that you can then adopt Next.js features incrementally. To begin with, we’ll treat your application as a purely client-side application (SPA) without immediately replacing your existing router. This reduces complexity and merge conflicts.Note: If you are using advanced CRA configurations such as a customhomepagefield in yourpackage.json, a custom service worker, or specific Babel/webpack tweaks, please see theAdditional Considerationssection at the end of this guide for tips on replicating or adapting these features in Next.js.Step 1: Install the Next.js DependencyInstall Next.js in your existing project:Terminalnpminstallnext@latestStep 2: Create the Next.js Configuration FileCreate anext.config.tsat the root of your project (same level as yourpackage.json). This file holds yourNext.js configuration options.next.config.tsimporttype{ NextConfig }from'next'constnextConfig:NextConfig={output:'export',// Outputs a Single-Page Application (SPA)distDir:'build',// Changes the build output directory to `build`}exportdefaultnextConfigNote: Usingoutput: 'export'means you’re doing a static export. You willnothave access to server-side features like SSR or APIs. You can remove this line to leverage Next.js server features.Step 3: Create the Root LayoutA Next.jsApp Routerapplication must include aroot layoutfile, which is aReact Server Componentthat will wrap all your pages.The closest equivalent of the root layout file in a CRA application ispublic/index.html, which includes your<html>,<head>, and<body>tags.Create a newappdirectory inside yoursrcdirectory (or at your project root if you preferappat the root).Inside theappdirectory, create alayout.tsx(orlayout.js) file:app/layout.tsxTypeScriptJavaScriptTypeScriptexportdefaultfunctionRootLayout({children,}:{children:React.ReactNode}) {return'...'}Now copy the content of your oldindex.htmlinto this<RootLayout>component. Replacebody div#root(andbody noscript) with<div id=""root"">{children}</div>.app/layout.tsxTypeScriptJavaScriptTypeScriptexportdefaultfunctionRootLayout({children,}:{children:React.ReactNode}) {return(<htmllang=""en""><head><metacharSet=""UTF-8""/><linkrel=""icon""href=""%PUBLIC_URL%/favicon.ico""/><metaname=""viewport""content=""width=device-width, initial-scale=1""/><title>React App</title><metaname=""description""content=""Web site created...""/></head><body><divid=""root"">{children}</div></body></html>)}Good to know: Next.js ignores CRA’spublic/manifest.json, additional iconography, andtesting configurationby default. If you need these, Next.js has support with itsMetadata APIandTestingsetup.Step 4: MetadataNext.js automatically includes the<meta charset=""UTF-8"" />and<meta name=""viewport"" content=""width=device-width, initial-scale=1"" />tags, so you can remove them from<head>:app/layout.tsxTypeScriptJavaScriptTypeScriptexportdefaultfunctionRootLayout({children,}:{children:React.ReactNode}) {return(<htmllang=""en""><head><linkrel=""icon""href=""%PUBLIC_URL%/favicon.ico""/><title>React App</title><metaname=""description""content=""Web site created...""/></head><body><divid=""root"">{children}</div></body></html>)}Anymetadata filessuch asfavicon.ico,icon.png,robots.txtare automatically added to the application<head>tag as long as you have them placed into the top level of theappdirectory. After movingall supported filesinto theappdirectory you can safely delete their<link>tags:app/layout.tsxTypeScriptJavaScriptTypeScriptexportdefaultfunctionRootLayout({children,}:{children:React.ReactNode}) {return(<htmllang=""en""><head><title>React App</title><metaname=""description""content=""Web site created...""/></head><body><divid=""root"">{children}</div></body></html>)}Finally, Next.js can manage your last<head>tags with theMetadata API. Move your final metadata info into an exportedmetadataobject:app/layout.tsxTypeScriptJavaScriptTypeScriptimporttype{ Metadata }from'next'exportconstmetadata:Metadata={title:'React App',description:'Web site created with Next.js.',}exportdefaultfunctionRootLayout({children,}:{children:React.ReactNode}) {return(<htmllang=""en""><body><divid=""root"">{children}</div></body></html>)}With the above changes, you shifted from declaring everything in yourindex.htmlto using Next.js' convention-based approach built into the framework (Metadata API). This approach enables you to more easily improve your SEO and web shareability of your pages.Step 5: StylesLike CRA, Next.js supportsCSS Modulesout of the box. It also supportsglobal CSS imports.If you have a global CSS file, import it into yourapp/layout.tsx:app/layout.tsxTypeScriptJavaScriptTypeScriptimport'../index.css'exportconstmetadata={title:'React App',description:'Web site created with Next.js.',}exportdefaultfunctionRootLayout({children,}:{children:React.ReactNode}) {return(<htmllang=""en""><body><divid=""root"">{children}</div></body></html>)}If you’re using Tailwind CSS, see ourinstallation docs.Step 6: Create the Entrypoint PageCreate React App usessrc/index.tsx(orindex.js) as the entry point. In Next.js (App Router), each folder inside theappdirectory corresponds to a route, and each folder should have apage.tsx.Since we want to keep the app as an SPA for now and interceptallroutes, we’ll use anoptional catch-all route.Create a[[...slug]]directory insideapp.app┣[[...slug]]┃┗page.tsx┣layout.tsxAdd the following topage.tsx:app/[[...slug]]/page.tsxTypeScriptJavaScriptTypeScriptexportfunctiongenerateStaticParams() {return[{ slug:[''] }]}exportdefaultfunctionPage() {return'...'// We'll update this}This tells Next.js to generate a single route for the empty slug (/), effectively mappingallroutes to the same page. This page is aServer Component, prerendered into static HTML.Step 7: Add a Client-Only EntrypointNext, we’ll embed your CRA’s root App component inside aClient Componentso that all logic remains client-side. If this is your first time using Next.js, it's worth knowing that clients components (by default) are still prerendered on the server. You can think about them as having the additional capability of running client-side JavaScript.Create aclient.tsx(orclient.js) inapp/[[...slug]]/:app/[[...slug]]/client.tsxTypeScriptJavaScriptTypeScript'use client'importdynamicfrom'next/dynamic'constApp=dynamic(()=>import('../../App'),{ ssr:false})exportfunctionClientOnly() {return<App/>}The'use client'directive makes this file aClient Component.Thedynamicimport withssr: falsedisables server-side rendering for the<App />component, making it truly client-only (SPA).Now update yourpage.tsx(orpage.js) to use your new component:app/[[...slug]]/page.tsxTypeScriptJavaScriptTypeScriptimport{ ClientOnly }from'./client'exportfunctiongenerateStaticParams() {return[{ slug:[''] }]}exportdefaultfunctionPage() {return<ClientOnly/>}Step 8: Update Static Image ImportsIn CRA, importing an image file returns its public URL as a string:importimagefrom'./img.png'exportdefaultfunctionApp() {return<imgsrc={image} />}With Next.js, static image imports return an object. The object can then be used directly with the Next.js<Image>component, or you can use the object'ssrcproperty with your existing<img>tag.The<Image>component has the added benefits ofautomatic image optimization. The<Image>component automatically sets thewidthandheightattributes of the resulting<img>based on the image's dimensions. This prevents layout shifts when the image loads. However, this can cause issues if your app contains images with only one of their dimensions being styled without the other styled toauto. When not styled toauto, the dimension will default to the<img>dimension attribute's value, which can cause the image to appear distorted.Keeping the<img>tag will reduce the amount of changes in your application and prevent the above issues. You can then optionally later migrate to the<Image>component to take advantage of optimizing images byconfiguring a loader, or moving to the default Next.js server which has automatic image optimization.Convert absolute import paths for images imported from/publicinto relative imports:// Beforeimportlogofrom'/logo.png'// Afterimportlogofrom'../public/logo.png'Pass the imagesrcproperty instead of the whole image object to your<img>tag:// Before<imgsrc={logo} />// After<imgsrc={logo.src} />Alternatively, you can reference the public URL for the image asset based on the filename. For example,public/logo.pngwill serve the image at/logo.pngfor your application, which would be thesrcvalue.Warning:If you're using TypeScript, you might encounter type errors when accessing thesrcproperty. To fix them, you need to addnext-env.d.tsto theincludearrayof yourtsconfig.jsonfile. Next.js will automatically generate this file when you run your application on step 9.Step 9: Migrate Environment VariablesNext.js supportsenvironment variablessimilarly to CRA butrequiresaNEXT_PUBLIC_prefix for any variable you want to expose in the browser.The main difference is the prefix used to expose environment variables on the client-side. Change all environment variables with theREACT_APP_prefix toNEXT_PUBLIC_.Step 10: Update Scripts inpackage.jsonUpdate yourpackage.jsonscripts to use Next.js commands. Also, add.nextandnext-env.d.tsto your.gitignore:package.json{""scripts"":{""dev"":""next dev --turbopack"",""build"":""next build"",""start"":""npx serve@latest ./build""}}.gitignore# ....nextnext-env.d.tsNow you can run:npmrundevOpenhttp://localhost:3000. You should see your application now running on Next.js (in SPA mode).Step 11: Clean UpYou can now remove artifacts that are specific to Create React App:public/index.htmlsrc/index.tsxsrc/react-app-env.d.tsThereportWebVitalssetupThereact-scriptsdependency (uninstall it frompackage.json)Additional ConsiderationsUsing a Customhomepagein CRAIf you used thehomepagefield in your CRApackage.jsonto serve the app under a specific subpath, you can replicate that in Next.js using thebasePathconfigurationinnext.config.ts:next.config.tsimport{ NextConfig }from'next'constnextConfig:NextConfig={basePath:'/my-subpath',// ...}exportdefaultnextConfigHandling a CustomService WorkerIf you used CRA’s service worker (e.g.,serviceWorker.jsfromcreate-react-app), you can learn how to createProgressive Web Applications (PWAs)with Next.js.Proxying API RequestsIf your CRA app used theproxyfield inpackage.jsonto forward requests to a backend server, you can replicate this withNext.js rewritesinnext.config.ts:next.config.tsimport{ NextConfig }from'next'constnextConfig:NextConfig={asyncrewrites() {return[{source:'/api/:path*',destination:'https://your-backend.com/:path*',},]},}Custom Webpack / Babel ConfigIf you had a custom webpack or Babel configuration in CRA, you can extend Next.js’s config innext.config.ts:next.config.tsimport{ NextConfig }from'next'constnextConfig:NextConfig={webpack:(config,{ isServer })=>{// Modify the webpack config herereturnconfig},}exportdefaultnextConfigNote: This will require disabling Turbopack by removing--turbopackfrom yourdevscript.TypeScript SetupNext.js automatically sets up TypeScript if you have atsconfig.json. Make surenext-env.d.tsis listed in yourtsconfig.jsonincludearray:{""include"":[""next-env.d.ts"",""app/**/*"",""src/**/*""]}Bundler CompatibilityBoth Create React App and Next.js default to webpack for bundling. Next.js also offersTurbopackfor faster local development with:nextdev--turbopackYou can still provide acustom webpack configurationif you need to migrate advanced webpack settings from CRA.Next StepsIf everything worked, you now have a functioning Next.js application running as a single-page application. You aren’t yet leveraging Next.js features like server-side rendering or file-based routing, but you can now do so incrementally:Migrate from React Routerto theNext.js App Routerfor:Automatic code splittingStreaming server renderingReact Server ComponentsOptimize imageswith the<Image>componentOptimize fontswithnext/fontOptimize third-party scriptswith the<Script>componentEnable ESLintwith Next.js recommended rules by runningnpx next lintand configuring it to match your project’s needsNote: Using a static export (output: 'export')does not currently supporttheuseParamshook or other server features. To use all Next.js features, removeoutput: 'export'from yournext.config.ts.PreviousApp Router MigrationNextMigrating from ViteWas this helpful?supported.Send"
migrating from vite,Migrating from Vite,"Building Your ApplicationUpgradingMigrating from ViteMigrating from ViteThis guide will help you migrate an existing Vite application to Next.js.Why Switch?There are several reasons why you might want to switch from Vite to Next.js:Slow initial page loading timeIf you have built your application with thedefault Vite plugin for React, your application is a purely client-side application. Client-side only applications, also known as single-page applications (SPAs), often experience slow initial page loading time. This happens due to a couple of reasons:The browser needs to wait for the React code and your entire application bundle to download and run before your code is able to send requests to load some data.Your application code grows with every new feature and extra dependency you add.No automatic code splittingThe previous issue of slow loading times can be somewhat managed with code splitting. However, if you try to do code splitting manually, you'll often make performance worse. It's easy to inadvertently introduce network waterfalls when code-splitting manually. Next.js provides automatic code splitting built into its router.Network waterfallsA common cause of poor performance occurs when applications make sequential client-server requests to fetch data. One common pattern for data fetching in an SPA is to initially render a placeholder, and then fetch data after the component has mounted. Unfortunately, this means that a child component that fetches data can't start fetching until the parent component has finished loading its own data.While fetching data on the client is supported with Next.js, it also gives you the option to shift data fetching to the server, which can eliminate client-server waterfalls.Fast and intentional loading statesWith built-in support forstreaming through React Suspense, you can be more intentional about which parts of your UI you want to load first and in what order without introducing network waterfalls.This enables you to build pages that are faster to load and eliminatelayout shifts.Choose the data fetching strategyDepending on your needs, Next.js allows you to choose your data fetching strategy on a page and component basis. You can decide to fetch at build time, at request time on the server, or on the client. For example, you can fetch data from your CMS and render your blog posts at build time, which can then be efficiently cached on a CDN.MiddlewareNext.js Middlewareallows you to run code on the server before a request is completed. This is especially useful to avoid having a flash of unauthenticated content when the user visits an authenticated-only page by redirecting the user to a login page. The middleware is also useful for experimentation andinternationalization.Built-in OptimizationsImages,fonts, andthird-party scriptsoften have significant impact on an application's performance. Next.js comes with built-in components that automatically optimize those for you.Migration StepsOur goal with this migration is to get a working Next.js application as quickly as possible, so that
you can then adopt Next.js features incrementally. To begin with, we'll keep it as a purely
client-side application (SPA) without migrating your existing router. This helps minimize the
chances of encountering issues during the migration process and reduces merge conflicts.Step 1: Install the Next.js DependencyThe first thing you need to do is to installnextas a dependency:Terminalnpminstallnext@latestStep 2: Create the Next.js Configuration FileCreate anext.config.mjsat the root of your project. This file will hold yourNext.js configuration options.next.config.mjs/**@type{import('next').NextConfig}*/constnextConfig={output:'export',// Outputs a Single-Page Application (SPA).distDir:'./dist',// Changes the build output directory to `./dist/`.}exportdefaultnextConfigGood to know:You can use either.jsor.mjsfor your Next.js configuration file.Step 3: Update TypeScript ConfigurationIf you're using TypeScript, you need to update yourtsconfig.jsonfile with the following changes
to make it compatible with Next.js. If you're not using TypeScript, you can skip this step.Remove theproject referencetotsconfig.node.jsonAdd./dist/types/**/*.tsand./next-env.d.tsto theincludearrayAdd./node_modulesto theexcludearrayAdd{ ""name"": ""next"" }to thepluginsarray incompilerOptions:""plugins"": [{ ""name"": ""next"" }]SetesModuleInteroptotrue:""esModuleInterop"": trueSetjsxtopreserve:""jsx"": ""preserve""SetallowJstotrue:""allowJs"": trueSetforceConsistentCasingInFileNamestotrue:""forceConsistentCasingInFileNames"": trueSetincrementaltotrue:""incremental"": trueHere's an example of a workingtsconfig.jsonwith those changes:tsconfig.json{""compilerOptions"":{""target"":""ES2020"",""useDefineForClassFields"":true,""lib"":[""ES2020"",""DOM"",""DOM.Iterable""],""module"":""ESNext"",""esModuleInterop"":true,""skipLibCheck"":true,""moduleResolution"":""bundler"",""allowImportingTsExtensions"":true,""resolveJsonModule"":true,""isolatedModules"":true,""noEmit"":true,""jsx"":""preserve"",""strict"":true,""noUnusedLocals"":true,""noUnusedParameters"":true,""noFallthroughCasesInSwitch"":true,""allowJs"":true,""forceConsistentCasingInFileNames"":true,""incremental"":true,""plugins"":[{""name"":""next""}]},""include"":[""./src"",""./dist/types/**/*.ts"",""./next-env.d.ts""],""exclude"":[""./node_modules""]}You can find more information about configuring TypeScript on theNext.js docs.Step 4: Create the Root LayoutA Next.jsApp Routerapplication must include aroot layoutfile, which is aReact Server Componentthat will wrap all pages in your application. This file is defined at the top level of theappdirectory.The closest equivalent to the root layout file in a Vite application is theindex.htmlfile, which contains your<html>,<head>, and<body>tags.In this step, you'll convert yourindex.htmlfile into a root layout file:Create a newappdirectory in yoursrcdirectory.Create a newlayout.tsxfile inside thatappdirectory:app/layout.tsxTypeScriptJavaScriptTypeScriptexportdefaultfunctionRootLayout({children,}:{children:React.ReactNode}) {return'...'}Good to know:.js,.jsx, or.tsxextensions can be used for Layout files.Copy the content of yourindex.htmlfile into the previously created<RootLayout>component while
replacing thebody.div#rootandbody.scripttags with<div id=""root"">{children}</div>:app/layout.tsxTypeScriptJavaScriptTypeScriptexportdefaultfunctionRootLayout({children,}:{children:React.ReactNode}) {return(<htmllang=""en""><head><metacharset=""UTF-8""/><linkrel=""icon""type=""image/svg+xml""href=""/icon.svg""/><metaname=""viewport""content=""width=device-width, initial-scale=1.0""/><title>My App</title><metaname=""description""content=""My App is a...""/></head><body><divid=""root"">{children}</div></body></html>)}Next.js already includes by default themeta charsetandmeta viewporttags, so you
can safely remove those from your<head>:app/layout.tsxTypeScriptJavaScriptTypeScriptexportdefaultfunctionRootLayout({children,}:{children:React.ReactNode}) {return(<htmllang=""en""><head><linkrel=""icon""type=""image/svg+xml""href=""/icon.svg""/><title>My App</title><metaname=""description""content=""My App is a...""/></head><body><divid=""root"">{children}</div></body></html>)}Anymetadata filessuch asfavicon.ico,icon.png,robots.txtare automatically added to the application<head>tag as long as you have them placed into the top level of theappdirectory. After
movingall supported filesinto theappdirectory you can safely delete their<link>tags:app/layout.tsxTypeScriptJavaScriptTypeScriptexportdefaultfunctionRootLayout({children,}:{children:React.ReactNode}) {return(<htmllang=""en""><head><title>My App</title><metaname=""description""content=""My App is a...""/></head><body><divid=""root"">{children}</div></body></html>)}Finally, Next.js can manage your last<head>tags with theMetadata API. Move your final metadata
info into an exportedmetadataobject:app/layout.tsxTypeScriptJavaScriptTypeScriptimporttype{ Metadata }from'next'exportconstmetadata:Metadata={title:'My App',description:'My App is a...',}exportdefaultfunctionRootLayout({children,}:{children:React.ReactNode}) {return(<htmllang=""en""><body><divid=""root"">{children}</div></body></html>)}With the above changes, you shifted from declaring everything in yourindex.htmlto using Next.js'
convention-based approach built into the framework
(Metadata API). This approach enables you
to more easily improve your SEO and web shareability of your pages.Step 5: Create the Entrypoint PageOn Next.js you declare an entrypoint for your application by creating apage.tsxfile. The
closest equivalent of this file on Vite is yourmain.tsxfile. In this step, you’ll set up the
entrypoint of your application.Create a[[...slug]]directory in yourappdirectory.Since in this guide we're aiming first to set up our Next.js as an SPA (Single Page Application), you need your page entrypoint to catch all possible routes of your application. For that, create a new[[...slug]]directory in yourappdirectory.This directory is what is called anoptional catch-all route segment. Next.js uses a file-system based router where folders are used to define routes. This special directory will make sure that all routes of your application will be directed to its containingpage.tsxfile.Create a newpage.tsxfile inside theapp/[[...slug]]directory with the following content:app/[[...slug]]/page.tsxTypeScriptJavaScriptTypeScriptimport'../../index.css'exportfunctiongenerateStaticParams() {return[{ slug:[''] }]}exportdefaultfunctionPage() {return'...'// We'll update this}Good to know:.js,.jsx, or.tsxextensions can be used for Page files.This file is aServer Component. When you runnext build, the file is prerendered into a static asset. It doesnotrequire any dynamic code.This file imports our global CSS and tellsgenerateStaticParamswe are only going to generate one route, the index route at/.Now, let's move the rest of our Vite application which will run client-only.app/[[...slug]]/client.tsxTypeScriptJavaScriptTypeScript'use client'importReactfrom'react'importdynamicfrom'next/dynamic'constApp=dynamic(()=>import('../../App'),{ ssr:false})exportfunctionClientOnly() {return<App/>}This file is aClient Component, defined by the'use client'directive. Client Components are stillprerendered to HTMLon the server before being sent to the client.Since we want a client-only application to start, we can configure Next.js to disable prerendering from theAppcomponent down.constApp=dynamic(()=>import('../../App'),{ ssr:false})Now, update your entrypoint page to use the new component:app/[[...slug]]/page.tsxTypeScriptJavaScriptTypeScriptimport'../../index.css'import{ ClientOnly }from'./client'exportfunctiongenerateStaticParams() {return[{ slug:[''] }]}exportdefaultfunctionPage() {return<ClientOnly/>}Step 6: Update Static Image ImportsNext.js handles static image imports slightly different from Vite. With Vite, importing an image
file will return its public URL as a string:App.tsximportimagefrom'./img.png'// `image` will be '/assets/img.2d8efhg.png' in productionexportdefaultfunctionApp() {return<imgsrc={image} />}With Next.js, static image imports return an object. The object can then be used directly with the
Next.js<Image>component, or you can use the object'ssrcproperty with your existing<img>tag.The<Image>component has the added benefits ofautomatic image optimization. The<Image>component automatically sets thewidthandheightattributes of the resulting<img>based on
the image's dimensions. This prevents layout shifts when the image loads. However, this can cause
issues if your app contains images with only one of their dimensions being styled without the other
styled toauto. When not styled toauto, the dimension will default to the<img>dimension
attribute's value, which can cause the image to appear distorted.Keeping the<img>tag will reduce the amount of changes in your application and prevent the above
issues. You can then optionally later migrate to the<Image>component to take advantage of optimizing images byconfiguring a loader, or moving to the default Next.js server which has automatic image optimization.Convert absolute import paths for images imported from/publicinto relative imports:// Beforeimportlogofrom'/logo.png'// Afterimportlogofrom'../public/logo.png'Pass the imagesrcproperty instead of the whole image object to your<img>tag:// Before<imgsrc={logo} />// After<imgsrc={logo.src} />Alternatively, you can reference the public URL for the image asset based on the filename. For example,public/logo.pngwill serve the image at/logo.pngfor your application, which would be thesrcvalue.Warning:If you're using TypeScript, you might encounter type errors when accessing thesrcproperty. You can safely ignore those for now. They will be fixed by the end of this guide.Step 7: Migrate the Environment VariablesNext.js has support for.envenvironment variablessimilar to Vite. The main difference is the prefix used to expose environment variables on the
client-side.Change all environment variables with theVITE_prefix toNEXT_PUBLIC_.Vite exposes a few built-in environment variables on the specialimport.meta.envobject which
aren’t supported by Next.js. You need to update their usage as follows:import.meta.env.MODE⇒process.env.NODE_ENVimport.meta.env.PROD⇒process.env.NODE_ENV === 'production'import.meta.env.DEV⇒process.env.NODE_ENV !== 'production'import.meta.env.SSR⇒typeof window !== 'undefined'Next.js also doesn't provide a built-inBASE_URLenvironment variable. However, you can still
configure one, if you need it:Add the following to your.envfile:.env# ...NEXT_PUBLIC_BASE_PATH=""/some-base-path""SetbasePathtoprocess.env.NEXT_PUBLIC_BASE_PATHin yournext.config.mjsfile:next.config.mjs/**@type{import('next').NextConfig}*/constnextConfig={output:'export',// Outputs a Single-Page Application (SPA).distDir:'./dist',// Changes the build output directory to `./dist/`.basePath:process.env.NEXT_PUBLIC_BASE_PATH,// Sets the base path to `/some-base-path`.}exportdefaultnextConfigUpdateimport.meta.env.BASE_URLusages toprocess.env.NEXT_PUBLIC_BASE_PATHStep 8: Update Scripts inpackage.jsonYou should now be able to run your application to test if you successfully migrated to Next.js. But
before that, you need to update yourscriptsin yourpackage.jsonwith Next.js related commands,
and add.nextandnext-env.d.tsto your.gitignore:package.json{""scripts"":{""dev"":""next dev"",""build"":""next build"",""start"":""next start""}}.gitignore# ....nextnext-env.d.tsdistNow runnpm run dev, and openhttp://localhost:3000. You should see your application now running on Next.js.Example:Check outthis pull requestfor a
working example of a Vite application migrated to Next.js.Step 9: Clean UpYou can now clean up your codebase from Vite related artifacts:Deletemain.tsxDeleteindex.htmlDeletevite-env.d.tsDeletetsconfig.node.jsonDeletevite.config.tsUninstall Vite dependenciesNext StepsIf everything went according to plan, you now have a functioning Next.js application running as a
single-page application. However, you aren't yet taking advantage of most of Next.js' benefits, but
you can now start making incremental changes to reap all the benefits. Here's what you might want to
do next:Migrate from React Router to theNext.js App Routerto get:Automatic code splittingStreaming Server-RenderingReact Server ComponentsOptimize images with the<Image>componentOptimize fonts withnext/fontOptimize third-party scripts with the<Script>componentUpdate your ESLint configuration to support Next.js rulesPreviousMigrating from CRANextSingle-Page AppsWas this helpful?supported.Send"
single-page apps,Single-Page Apps,"Building Your ApplicationUpgradingSingle-Page AppsSingle-Page Applications with Next.jsNext.js fully supports building Single-Page Applications (SPAs).This includes fast route transitions with prefetching, client-side data fetching, using browser APIs, integrating with third-party client libraries, creating static routes, and more.If you have an existing SPA, you can migrate to Next.js without large changes to your code. Next.js then allows you to progressively add server features as needed.What is a Single-Page Application?The definition of a SPA varies. We’ll define a “strict SPA” as:Client-side rendering (CSR): The app is served by one HTML file (e.g.index.html). Every route, page transition, and data fetch is handled by JavaScript in the browser.No full-page reloads: Rather than requesting a new document for each route, client-side JavaScript manipulates the current page’s DOM and fetches data as needed.Strict SPAs often require large amounts of JavaScript to load before the page can be interactive. Further, client data waterfalls can be challenging to manage. Building SPAs with Next.js can address these issues.Why use Next.js for SPAs?Next.js can automatically code split your JavaScript bundles, and generate multiple HTML entry points into different routes. This avoids loading unnecessary JavaScript code on the client-side, reducing the bundle size and enabling faster page loads.Thenext/linkcomponent automaticallyprefetchesroutes, giving you the fast page transitions of a strict SPA, but with the advantage of persisting application routing state to the URL for linking and sharing.Next.js can start as a static site or even a strict SPA where everything is rendered client-side. If your project grows, Next.js allows you to progressively add more server features (e.g.React Server Components,Server Actions, and more) as needed.ExamplesLet's explore common patterns used to build SPAs and how Next.js solves them.Using React’susewithin a Context ProviderWe recommend fetching data in a parent component (or layout), returning the Promise, and then unwrapping the value in a client component with React’susehook.Next.js can start data fetching early on the server. In this example, that’s the root layout — the entry point to your application. The server can immediately begin streaming a response to the client.By “hoisting” your data fetching to the root layout, Next.js starts the specified requests on the server early before any other components in your application. This eliminates client waterfalls and prevents having multiple roundtrips between client and server. It can also significantly improve performance, as your server is closer (and ideally colocated) to where your database is located.For example, update your root layout to call the Promise, but donotawait it.app/layout.tsxTypeScriptJavaScriptTypeScriptimport{ UserProvider }from'./user-provider'import{ getUser }from'./user'// some server-side functionexportdefaultfunctionRootLayout({children,}:{children:React.ReactNode}) {letuserPromise=getUser()// do NOT awaitreturn(<htmllang=""en""><body><UserProvideruserPromise={userPromise}>{children}</UserProvider></body></html>)}While you candefer and pass a single Promiseas a prop to a client component, we generally see this pattern paired with a React context provider. This enables easier access from client components with a custom React hook.You can forward a Promise to the React context provider:app/user-provider.tsTypeScriptJavaScriptTypeScript'use client';import{ createContext,useContext,ReactNode }from'react';typeUser=any;typeUserContextType={userPromise:Promise<User|null>;};constUserContext=createContext<UserContextType|null>(null);exportfunctionuseUser():UserContextType{letcontext=useContext(UserContext);if(context===null) {thrownewError('useUser must be used within a UserProvider');}returncontext;}exportfunctionUserProvider({children,userPromise}:{children:ReactNode;userPromise:Promise<User|null>;}) {return(<UserContext.Provider value={{ userPromise }}>{children}</UserContext.Provider>);}Finally, you can call theuseUser()custom hook in any client component and unwrap the Promise:app/profile.tsxTypeScriptJavaScriptTypeScript'use client'import{ use }from'react'import{ useUser }from'./user-provider'exportfunctionProfile() {const{userPromise}=useUser()constuser=use(userPromise)return'...'}The component that consumes the Promise (e.g.Profileabove) will be suspended. This enables partial hydration. You can see the streamed and prerendered HTML before JavaScript has finished loading.SPAs with SWRSWRis a popular React library for data fetching.With SWR 2.3.0 (and React 19+), you can gradually adopt server features alongside your existing SWR-based client data fetching code. This is an abstraction of the aboveuse()pattern. This means you can move data fetching between the client and server-side, or use both:Client-only:useSWR(key, fetcher)Server-only:useSWR(key)+ RSC-provided dataMixed:useSWR(key, fetcher)+ RSC-provided dataFor example, wrap your application with<SWRConfig>and afallback:app/layout.tsxTypeScriptJavaScriptTypeScriptimport{ SWRConfig }from'swr'import{ getUser }from'./user'// some server-side functionexportdefaultfunctionRootLayout({children,}:{children:React.ReactNode}) {return(<SWRConfigvalue={{fallback:{// We do NOT await getUser() here// Only components that read this data will suspend'/api/user':getUser(),},}}>{children}</SWRConfig>)}Because this is a server component,getUser()can securely read cookies, headers, or talk to your database. No separate API route is needed. Client components below the<SWRConfig>can calluseSWR()with the same key to retrieve the user data. The component code withuseSWRdoes not require any changesfrom your existing client-fetching solution.app/profile.tsxTypeScriptJavaScriptTypeScript'use client'importuseSWRfrom'swr'exportfunctionProfile() {constfetcher=(url)=>fetch(url).then((res)=>res.json())// The same SWR pattern you already knowconst{data,error}=useSWR('/api/user',fetcher)return'...'}Thefallbackdata can be prerendered and included in the initial HTML response, then immediately read in the child components usinguseSWR. SWR’s polling, revalidation, and caching still runclient-side only, so it preserves all the interactivity you rely on for an SPA.Since the initialfallbackdata is automatically handled by Next.js, you can now delete any conditional logic previously needed to check ifdatawasundefined. When the data is loading, the closest<Suspense>boundary will be suspended.SWRRSCRSC + SWRSSR dataStreaming while SSRDeduplicate requestsClient-side featuresSPAs with React QueryYou can use React Query with Next.js on both the client and server. This enables you to build both strict SPAs, as well as take advantage of server features in Next.js paired with React Query.Learn more in theReact Query documentation.Rendering components only in the browserClient components areprerenderedduringnext build. If you want to disable prerendering for a client component and only load it in the browser environment, you can usenext/dynamic:importdynamicfrom'next/dynamic'constClientOnlyComponent=dynamic(()=>import('./component'),{ssr:false,})This can be useful for third-party libraries that rely on browser APIs likewindowordocument. You can also add auseEffectthat checks for the existence of these APIs, and if they do not exist, returnnullor a loading state which would be prerendered.Shallow routing on the clientIf you are migrating from a strict SPA likeCreate React ApporVite, you might have existing code which shallow routes to update the URL state. This can be useful for manual transitions between views in your applicationwithoutusing the default Next.js file-system routing.Next.js allows you to use the nativewindow.history.pushStateandwindow.history.replaceStatemethods to update the browser's history stack without reloading the page.pushStateandreplaceStatecalls integrate into the Next.js Router, allowing you to sync withusePathnameanduseSearchParams.'use client'import{ useSearchParams }from'next/navigation'exportdefaultfunctionSortProducts() {constsearchParams=useSearchParams()functionupdateSorting(sortOrder:string) {consturlSearchParams=newURLSearchParams(searchParams.toString())urlSearchParams.set('sort',sortOrder)window.history.pushState(null,'',`?${urlSearchParams.toString()}`)}return(<><buttononClick={()=>updateSorting('asc')}>Sort Ascending</button><buttononClick={()=>updateSorting('desc')}>Sort Descending</button></>)}Learn more about howrouting and navigationwork in Next.js.Using Server Actions in client componentsYou can progressively adopt Server Actions while still using client components. This allows you to remove boilerplate code to call an API route, and instead use React features likeuseActionStateto handle loading and error states.For example, create your first Server Action:app/actions.tsTypeScriptJavaScriptTypeScript'use server'exportasyncfunctioncreate() {}You can import and use a Server Action from the client, similar to calling a JavaScript function. You do not need to create an API endpoint manually:app/button.tsxTypeScriptJavaScriptTypeScript'use client'import{ create }from'./actions'exportfunctionButton() {return<buttononClick={()=>create()}>Create</button>}Learn more aboutmutating data with Server Actions.Static export (optional)Next.js also supports generating a fullystatic site. This has some advantages over strict SPAs:Automatic code-splitting: Instead of shipping a singleindex.html, Next.js will generate an HTML file per route, so your visitors get the content faster without waiting for the client JavaScript bundle.Improved user experience:Instead of a minimal skeleton for all routes, you get fully rendered pages for each route. When users navigate client side, transitions remain instant and SPA-like.To enable a static export, update your configuration:next.config.tsimporttype{ NextConfig }from'next'constnextConfig:NextConfig={output:'export',}exportdefaultnextConfigAfter runningnext build, Next.js will create anoutfolder with the HTML/CSS/JS assets for your application.Note:Next.js server features are not supported with static exports.Learn more.Migrating existing projects to Next.jsYou can incrementally migrate to Next.js by following our guides:Migrating from Create React AppMigrating from ViteIf you are already using a SPA with the Pages Router, you can learn how toincrementally adopt the App Router.PreviousMigrating from ViteNextAPI ReferenceWas this helpful?supported.Send"
api reference,API Reference,"IntroductionApp RouterAPI ReferenceAPI ReferenceThe Next.js API reference is divided into the following sections:DirectivesDirectives are used to modify the behavior of your Next.js application.ComponentsAPI Reference for Next.js built-in components.File ConventionsAPI Reference for Next.js File Conventions.FunctionsAPI Reference for Next.js Functions and Hooks.ConfigurationLearn how to configure Next.js applications.CLIAPI Reference for the Next.js Command Line Interface (CLI) tools.Edge RuntimeAPI Reference for the Edge Runtime.TurbopackTurbopack is an incremental bundler optimized for JavaScript and TypeScript, written in Rust, and built into Next.js.PreviousSingle-Page AppsNextDirectivesWas this helpful?supported.Send"
directives,Directives,App RouterAPI ReferenceDirectivesDirectivesThe following directives are available:use cacheLearn how to use the use cache directive to cache data in your Next.js application.use clientLearn how to use the use client directive to render a component on the client.use serverLearn how to use the use server directive to execute code on the server.PreviousAPI ReferenceNextuse cacheWas this helpful?supported.Send
use cache,use cache,"API ReferenceDirectivesuse cacheuse cacheThis feature is currently available in the canary channel and subject to change. Try it out byupgrading Next.js, and share your feedback onGitHub.Theuse cachedirective designates a component and/or a function to be cached. It can be used at the top of a file to indicate that all exports in the file are cacheable, or inline at the top of a function or component to inform Next.js the return value should be cached and reused for subsequent requests. This is an experimental Next.js feature, and not a native React feature likeuse clientoruse server.UsageEnable support for theuse cachedirective with theuseCacheflag in yournext.config.tsfile:next.config.tsTypeScriptJavaScriptTypeScriptimporttype{ NextConfig }from'next'constnextConfig:NextConfig={experimental:{useCache:true,},}exportdefaultnextConfigAdditionally,use cachedirectives are also enabled when thedynamicIOflag is set.Then, you can use theuse cachedirective at the file, component, or function level:// File level'use cache'exportdefaultasyncfunctionPage() {// ...}// Component levelexportasyncfunctionMyComponent() {'use cache'return<></>}// Function levelexportasyncfunctiongetData() {'use cache'constdata=awaitfetch('/api/data')returndata}Good to knowuse cacheis an experimental Next.js feature, and not a native React feature likeuse clientoruse server.Anyserializablearguments (or props) passed to the cached function, as well as any serializable values it reads from the parent scope, will be converted to a format like JSON and automatically become a part of the cache key.Any non-serializable arguments, props, or closed-over values will turn into opaque references inside the cached function, and can be only passed through and not inspected nor modified. These non-serializable values will be filled in at the request time and won't become a part of the cache key.For example, a cached function can take in JSX as achildrenprop and return<div>{children}</div>, but it won't be able to introspect the actualchildrenobject.The return value of the cacheable function must also be serializable. This ensures that the cached data can be stored and retrieved correctly.Functions that use theuse cachedirective must not have any side-effects, such as modifying state, directly manipulating the DOM, or setting timers to execute code at intervals.If used alongsidePartial Prerendering, segments that haveuse cachewill be prerendered as part of the static HTML shell.Unlikeunstable_cachewhich only supports JSON data,use cachecan cache any serializable data React can render, including the render output of components.ExamplesCaching entire routes withuse cacheTo prerender an entire route, adduse cacheto the top ofboththelayoutandpagefiles. Each of these segments are treated as separate entry points in your application, and will be cached independently.app/layout.tsxTypeScriptJavaScriptTypeScript'use cache'exportdefaultfunctionLayout({ children }:{ children:ReactNode}) {return<div>{children}</div>}Any components imported and nested inpagefile will inherit the cache behavior ofpage.app/page.tsxTypeScriptJavaScriptTypeScript'use cache'asyncfunctionUsers() {constusers=awaitfetch('/api/users')// loop through users}exportdefaultfunctionPage() {return(<main><Users/></main>)}This is recommended for applications that previously used theexport const dynamic = ""force-static""option, and will ensure the entire route is prerendered.Caching component output withuse cacheYou can useuse cacheat the component level to cache any fetches or computations performed within that component. When you reuse the component throughout your application it can share the same cache entry as long as the props maintain the same structure.The props are serialized and form part of the cache key, and the cache entry will be reused as long as the serialized props produce the same value in each instance.app/components/bookings.tsxTypeScriptJavaScriptTypeScriptexportasyncfunctionBookings({ type='haircut'}:BookingsProps) {'use cache'asyncfunctiongetBookingsData() {constdata=awaitfetch(`/api/bookings?type=${encodeURIComponent(type)}`)returndata}return//...}interfaceBookingsProps{type:string}Caching function output withuse cacheSince you can adduse cacheto any asynchronous function, you aren't limited to caching components or routes only. You might want to cache a network request or database query or compute something that is very slow. By addinguse cacheto a function containing this type of work it becomes cacheable, and when reused, will share the same cache entry.app/actions.tsTypeScriptJavaScriptTypeScriptexportasyncfunctiongetData() {'use cache'constdata=awaitfetch('/api/data')returndata}RevalidatingBy default, Next.js sets arevalidation periodof 15 minuteswhen you use theuse cachedirective. Next.js sets a near-infinite expiration duration, meaning it's suitable for content that doesn't need frequent updates.While this revalidation period may be useful for content you don't expect to change often, you can use thecacheLifeandcacheTagAPIs to configure the cache behavior:cacheLife: For time-based revalidation periods.cacheTag: For on-demand revalidation.Both of these APIs integrate across the client and server caching layers, meaning you can configure your caching semantics in one place and have them apply everywhere.See thecacheLifeandcacheTagdocs for more information.InterleavingIf you need to pass non-serializable arguments to a cacheable function, you can pass them aschildren. This means thechildrenreference can change without affecting the cache entry.app/page.tsxTypeScriptJavaScriptTypeScriptexportdefaultasyncfunctionPage() {constuncachedData=awaitgetData()return(<CacheComponent><DynamicComponentdata={uncachedData} /></CacheComponent>)}asyncfunctionCacheComponent({ children }:{ children:ReactNode}) {'use cache'constcachedData=awaitfetch('/api/cached-data')return(<div><PrerenderedComponentdata={cachedData} />{children}</div>)}You can also pass Server Actions through cached components to Client Components without invoking them inside the cacheable function.app/page.tsxTypeScriptJavaScriptTypeScriptimportClientComponentfrom'./ClientComponent'exportdefaultasyncfunctionPage() {constperformUpdate=async()=>{'use server'// Perform some server-side updateawaitdb.update(...)}return<CacheComponentperformUpdate={performUpdate} />}asyncfunctionCachedComponent({performUpdate,}:{performUpdate:()=>Promise<void>}) {'use cache'// Do not call performUpdate herereturn<ClientComponentaction={performUpdate} />}app/ClientComponent.tsxTypeScriptJavaScriptTypeScript'use client'exportdefaultfunctionClientComponent({action,}:{action:()=>Promise<void>}) {return<buttononClick={action}>Update</button>}RelatedView related API references.useCacheLearn how to enable the useCache flag in Next.js.dynamicIOLearn how to enable the dynamicIO flag in Next.js.cacheLifeLearn how to set up cacheLife configurations in Next.js.cacheTagLearn how to use the cacheTag function to manage cache invalidation in your Next.js application.cacheLifeLearn how to use the cacheLife function to set the cache expiration time for a cached function or component.revalidateTagAPI Reference for the revalidateTag function.PreviousDirectivesNextuse clientWas this helpful?supported.Send"
use client,use client,"API ReferenceDirectivesuse clientuse clientTheuse clientdirective designates a component to be rendered on theclient sideand should be used when creating interactive user interfaces (UI) that require client-side JavaScript capabilities, such as state management, event handling, and access to browser APIs. This is a React feature.UsageTo designate a component as a Client Component, add theuse clientdirectiveat the top of the file, before any imports:app/components/counter.tsxTypeScriptJavaScriptTypeScript'use client'import{ useState }from'react'exportdefaultfunctionCounter() {const[count,setCount]=useState(0)return(<div><p>Count: {count}</p><buttononClick={()=>setCount(count+1)}>Increment</button></div>)}Nesting Client Components within Server ComponentsCombining Server and Client Components allows you to build applications that are both performant and interactive:Server Components: Use for static content, data fetching, and SEO-friendly elements.Client Components: Use for interactive elements that require state, effects, or browser APIs.Component composition: Nest Client Components within Server Components as needed for a clear separation of server and client logic.In the following example:Headeris a Server Component handling static content.Counteris a Client Component enabling interactivity within the page.app/page.tsxTypeScriptJavaScriptTypeScriptimportHeaderfrom'./header'importCounterfrom'./counter'// This is a Client ComponentexportdefaultfunctionPage() {return(<div><Header/><Counter/></div>)}ReferenceSee theReact documentationfor more information onuse client.Previoususe cacheNextuse serverWas this helpful?supported.Send"
use server,use server,"API ReferenceDirectivesuse serveruse serverTheuse serverdirective designates a function or file to be executed on theserver side. It can be used at the top of a file to indicate that all functions in the file are server-side, or inline at the top of a function to mark the function as aServer Function. This is a React feature.Usinguse serverat the top of a fileThe following example shows a file with ause serverdirective at the top. All functions in the file are executed on the server.app/actions.tsTypeScriptJavaScriptTypeScript'use server'import{ db }from'@/lib/db'// Your database clientexportasyncfunctioncreateUser(data:{ name:string; email:string}) {constuser=awaitdb.user.create({ data })returnuser}Using Server Functions in a Client ComponentTo use Server Functions in Client Components you need to create your Server Functions in a dedicated file using theuse serverdirective at the top of the file. These Server Functions can then be imported into Client and Server Components and executed.Assuming you have afetchUsersServer Function inactions.ts:app/actions.tsTypeScriptJavaScriptTypeScript'use server'import{ db }from'@/lib/db'// Your database clientexportasyncfunctionfetchUsers() {constusers=awaitdb.user.findMany()returnusers}Then you can import thefetchUsersServer Function into a Client Component and execute it on the client-side.app/components/my-button.tsxTypeScriptJavaScriptTypeScript'use client'import{ fetchUsers }from'../actions'exportdefaultfunctionMyButton() {return<buttononClick={()=>fetchUsers()}>Fetch Users</button>}Usinguse serverinlineIn the following example,use serveris used inline at the top of a function to mark it as aServer Function:app/page.tsxTypeScriptJavaScriptTypeScriptimport{ db }from'@/lib/db'// Your database clientexportdefaultfunctionUserList() {asyncfunctionfetchUsers() {'use server'constusers=awaitdb.user.findMany()returnusers}return<buttononClick={()=>fetchUsers()}>Fetch Users</button>}Security considerationsWhen using theuse serverdirective, it's important to ensure that all server-side logic is secure and that sensitive data remains protected.Authentication and authorizationAlways authenticate and authorize users before performing sensitive server-side operations.app/actions.tsTypeScriptJavaScriptTypeScript'use server'import{ db }from'@/lib/db'// Your database clientimport{ authenticate }from'@/lib/auth'// Your authentication libraryexportasyncfunctioncreateUser(data:{ name:string; email:string},token:string) {constuser=authenticate(token)if(!user) {thrownewError('Unauthorized')}constnewUser=awaitdb.user.create({ data })returnnewUser}ReferenceSee theReact documentationfor more information onuse server.Previoususe clientNextComponentsWas this helpful?supported.Send"
components,Components,App RouterAPI ReferenceComponentsComponentsFontOptimizing loading web fonts with the built-in `next/font` loaders.FormLearn how to use the `<Form>` component to handle form submissions and search params updates with client-side navigation.ImageOptimize Images in your Next.js Application using the built-in `next/image` Component.LinkEnable fast client-side navigation with the built-in `next/link` component.ScriptOptimize third-party scripts in your Next.js application using the built-in `next/script` Component.Previoususe serverNextFontWas this helpful?supported.Send
font,Font,"API ReferenceComponentsFontFont ModuleThis API reference will help you understand how to usenext/font/googleandnext/font/local. For features and usage, please see theOptimizing Fontspage.Font Function ArgumentsFor usage, reviewGoogle FontsandLocal Fonts.Keyfont/googlefont/localTypeRequiredsrcString or Array of ObjectsYesweightString or ArrayRequired/OptionalstyleString or Array-subsetsArray of Strings-axesArray of Strings-displayString-preloadBoolean-fallbackArray of Strings-adjustFontFallbackBoolean or String-variableString-declarationsArray of Objects-srcThe path of the font file as a string or an array of objects (with typeArray<{path: string, weight?: string, style?: string}>) relative to the directory where the font loader function is called.Used innext/font/localRequiredExamples:src:'./fonts/my-font.woff2'wheremy-font.woff2is placed in a directory namedfontsinside theappdirectorysrc:[{path: './inter/Inter-Thin.ttf', weight: '100',},{path: './inter/Inter-Regular.ttf',weight: '400',},{path: './inter/Inter-Bold-Italic.ttf', weight: '700',style: 'italic',},]if the font loader function is called inapp/page.tsxusingsrc:'../styles/fonts/my-font.ttf', thenmy-font.ttfis placed instyles/fontsat the root of the projectweightThe fontweightwith the following possibilities:A string with possible values of the weights available for the specific font or a range of values if it's avariablefontAn array of weight values if the font is not avariable google font. It applies tonext/font/googleonly.Used innext/font/googleandnext/font/localRequired if the font being used isnotvariableExamples:weight: '400': A string for a single weight value - for the fontInter, the possible values are'100','200','300','400','500','600','700','800','900'or'variable'where'variable'is the default)weight: '100 900': A string for the range between100and900for a variable fontweight: ['100','400','900']: An array of 3 possible values for a non variable fontstyleThe fontstylewith the following possibilities:A stringvaluewith default value of'normal'An array of style values if the font is not avariable google font. It applies tonext/font/googleonly.Used innext/font/googleandnext/font/localOptionalExamples:style: 'italic': A string - it can benormaloritalicfornext/font/googlestyle: 'oblique': A string - it can take any value fornext/font/localbut is expected to come fromstandard font stylesstyle: ['italic','normal']: An array of 2 values fornext/font/google- the values are fromnormalanditalicsubsetsThe fontsubsetsdefined by an array of string values with the names of each subset you would like to bepreloaded. Fonts specified viasubsetswill have a link preload tag injected into the head when thepreloadoption is true, which is the default.Used innext/font/googleOptionalExamples:subsets: ['latin']: An array with the subsetlatinYou can find a list of all subsets on the Google Fonts page for your font.axesSome variable fonts have extraaxesthat can be included. By default, only the font weight is included to keep the file size down. The possible values ofaxesdepend on the specific font.Used innext/font/googleOptionalExamples:axes: ['slnt']: An array with valueslntfor theIntervariable font which hasslntas additionalaxesas shownhere. You can find the possibleaxesvalues for your font by using the filter on theGoogle variable fonts pageand looking for axes other thanwghtdisplayThe fontdisplaywith possible stringvaluesof'auto','block','swap','fallback'or'optional'with default value of'swap'.Used innext/font/googleandnext/font/localOptionalExamples:display: 'optional': A string assigned to theoptionalvaluepreloadA boolean value that specifies whether the font should bepreloadedor not. The default istrue.Used innext/font/googleandnext/font/localOptionalExamples:preload: falsefallbackThe fallback font to use if the font cannot be loaded. An array of strings of fallback fonts with no default.OptionalUsed innext/font/googleandnext/font/localExamples:fallback: ['system-ui', 'arial']: An array setting the fallback fonts tosystem-uiorarialadjustFontFallbackFornext/font/google: A boolean value that sets whether an automatic fallback font should be used to reduceCumulative Layout Shift. The default istrue.Fornext/font/local: A string or booleanfalsevalue that sets whether an automatic fallback font should be used to reduceCumulative Layout Shift. The possible values are'Arial','Times New Roman'orfalse. The default is'Arial'.Used innext/font/googleandnext/font/localOptionalExamples:adjustFontFallback: false: fornext/font/googleadjustFontFallback: 'Times New Roman': fornext/font/localvariableA string value to define the CSS variable name to be used if the style is applied with theCSS variable method.Used innext/font/googleandnext/font/localOptionalExamples:variable: '--my-font': The CSS variable--my-fontis declareddeclarationsAn array of font facedescriptorkey-value pairs that define the generated@font-facefurther.Used innext/font/localOptionalExamples:declarations: [{ prop: 'ascent-override', value: '90%' }]Applying StylesYou can apply the font styles in three ways:classNamestyleCSS VariablesclassNameReturns a read-only CSSclassNamefor the loaded font to be passed to an HTML element.<pclassName={inter.className}>Hello, Next.js!</p>styleReturns a read-only CSSstyleobject for the loaded font to be passed to an HTML element, includingstyle.fontFamilyto access the font family name and fallback fonts.<pstyle={inter.style}>Hello World</p>CSS VariablesIf you would like to set your styles in an external style sheet and specify additional options there, use the CSS variable method.In addition to importing the font, also import the CSS file where the CSS variable is defined and set the variable option of the font loader object as follows:app/page.tsxTypeScriptJavaScriptTypeScriptimport{ Inter }from'next/font/google'importstylesfrom'../styles/component.module.css'constinter=Inter({variable:'--font-inter',})To use the font, set theclassNameof the parent container of the text you would like to style to the font loader'svariablevalue and theclassNameof the text to thestylesproperty from the external CSS file.app/page.tsxTypeScriptJavaScriptTypeScript<mainclassName={inter.variable}><pclassName={styles.text}>Hello World</p></main>Define thetextselector class in thecomponent.module.cssCSS file as follows:styles/component.module.css.text{font-family:var(--font-inter);font-weight:200;font-style:italic;}In the example above, the textHello Worldis styled using theInterfont and the generated font fallback withfont-weight: 200andfont-style: italic.Using a font definitions fileEvery time you call thelocalFontor Google font function, that font will be hosted as one instance in your application. Therefore, if you need to use the same font in multiple places, you should load it in one place and import the related font object where you need it. This is done using a font definitions file.For example, create afonts.tsfile in astylesfolder at the root of your app directory.Then, specify your font definitions as follows:styles/fonts.tsTypeScriptJavaScriptTypeScriptimport{ Inter,Lora,Source_Sans_3 }from'next/font/google'importlocalFontfrom'next/font/local'// define your variable fontsconstinter=Inter()constlora=Lora()// define 2 weights of a non-variable fontconstsourceCodePro400=Source_Sans_3({ weight:'400'})constsourceCodePro700=Source_Sans_3({ weight:'700'})// define a custom local font where GreatVibes-Regular.ttf is stored in the styles folderconstgreatVibes=localFont({ src:'./GreatVibes-Regular.ttf'})export{ inter,lora,sourceCodePro400,sourceCodePro700,greatVibes }You can now use these definitions in your code as follows:app/page.tsxTypeScriptJavaScriptTypeScriptimport{ inter,lora,sourceCodePro700,greatVibes }from'../styles/fonts'exportdefaultfunctionPage() {return(<div><pclassName={inter.className}>Hello world using Inter font</p><pstyle={lora.style}>Hello world using Lora font</p><pclassName={sourceCodePro700.className}>Hello world using Source_Sans_3 font with weight 700</p><pclassName={greatVibes.className}>My title in Great Vibes font</p></div>)}To make it easier to access the font definitions in your code, you can define a path alias in yourtsconfig.jsonorjsconfig.jsonfiles as follows:tsconfig.json{""compilerOptions"":{""paths"":{""@/fonts"":[""./styles/fonts""]}}}You can now import any font definition as follows:app/about/page.tsxTypeScriptJavaScriptTypeScriptimport{ greatVibes,sourceCodePro400 }from'@/fonts'Version ChangesVersionChangesv13.2.0@next/fontrenamed tonext/font. Installation no longer required.v13.0.0@next/fontwas added.PreviousComponentsNextFormWas this helpful?supported.Send"
form,Form,"API ReferenceComponentsFormFormThe<Form>component extends the HTML<form>element to provideprefetchingofloading UI,client-side navigationon submission, andprogressive enhancement.It's useful for forms that update URL search params as it reduces the boilerplate code needed to achieve the above.Basic usage:/app/ui/search.tsxTypeScriptJavaScriptTypeScriptimportFormfrom'next/form'exportdefaultfunctionPage() {return(<Formaction=""/search"">{/* On submission, the input value will beappended tothe URL, e.g. /search?query=abc */}<inputname=""query""/><buttontype=""submit"">Submit</button></Form>)}ReferenceThe behavior of the<Form>component depends on whether theactionprop is passed astringorfunction.Whenactionis astring, the<Form>behaves like a native HTML form that uses aGETmethod. The form data is encoded into the URL as search params, and when the form is submitted, it navigates to the specified URL. In addition, Next.js:Prefetchesthe path when the form becomes visible, this preloads shared UI (e.g.layout.jsandloading.js), resulting in faster navigation.Performs aclient-side navigationinstead of a full page reload when the form is submitted. This retains shared UI and client-side state.Whenactionis afunction(Server Action),<Form>behaves like aReact form, executing the action when the form is submitted.action(string) PropsWhenactionis a string, the<Form>component supports the following props:PropExampleTypeRequiredactionaction=""/search""string(URL or relative path)Yesreplacereplace={false}boolean-scrollscroll={true}boolean-prefetchprefetch={true}boolean-action: The URL or path to navigate to when the form is submitted.An empty string""""will navigate to the same route with updated search params.replace: Replaces the current history state instead of pushing a new one to thebrowser's historystack. Default isfalse.scroll: Controls the scroll behavior during navigation. Defaults totrue, this means it will scroll to the top of the new route, and maintain the scroll position for backwards and forwards navigation.prefetch: Controls whether the path should be prefetched when the form becomes visible in the user's viewport. Defaults totrue.action(function) PropsWhenactionis a function, the<Form>component supports the following prop:PropExampleTypeRequiredactionaction={myAction}function(Server Action)Yesaction: The Server Action to be called when the form is submitted. See theReact docsfor more.Good to know: Whenactionis a function, thereplaceandscrollprops are ignored.CaveatsformAction: Can be used in a<button>or<input type=""submit"">fields to override theactionprop. Next.js will perform a client-side navigation, however, this approach doesn't support prefetching.When usingbasePath, you must also include it in theformActionpath. e.g.formAction=""/base-path/search"".key: Passing akeyprop to a stringactionis not supported. If you'd like to trigger a re-render or perform a mutation, consider using a functionactioninstead.onSubmit: Can be used to handle form submission logic. However, callingevent.preventDefault()will override<Form>behavior such as navigating to the specified URL.method,encType,target: Are not supported as they override<Form>behavior.Similarly,formMethod,formEncType, andformTargetcan be used to override themethod,encType, andtargetprops respectively, and using them will fallback to native browser behavior.If you need to use these props, use the HTML<form>element instead.<input type=""file"">: Using this input type when theactionis a string will match browser behavior by submitting the filename instead of the file object.ExamplesSearch form that leads to a search result pageYou can create a search form that navigates to a search results page by passing the path as anaction:/app/page.tsxTypeScriptJavaScriptTypeScriptimportFormfrom'next/form'exportdefaultfunctionPage() {return(<Formaction=""/search""><inputname=""query""/><buttontype=""submit"">Submit</button></Form>)}When the user updates the query input field and submits the form, the form data will be encoded into the URL as search params, e.g./search?query=abc.Good to know: If you pass an empty string""""toaction, the form will navigate to the same route with updated search params.On the results page, you can access the query using thesearchParamspage.jsprop and use it to fetch data from an external source./app/search/page.tsxTypeScriptJavaScriptTypeScriptimport{ getSearchResults }from'@/lib/search'exportdefaultasyncfunctionSearchPage({searchParams,}:{searchParams:Promise<{ [key:string]:string|string[]|undefined}>}) {constresults=awaitgetSearchResults((awaitsearchParams).query)return<div>...</div>}When the<Form>becomes visible in the user's viewport, shared UI (such aslayout.jsandloading.js) on the/searchpage will be prefetched. On submission, the form will immediately navigate to the new route and show loading UI while the results are being fetched. You can design the fallback UI usingloading.js:/app/search/loading.tsxTypeScriptJavaScriptTypeScriptexportdefaultfunctionLoading() {return<div>Loading...</div>}To cover cases when shared UI hasn't yet loaded, you can show instant feedback to the user usinguseFormStatus.First, create a component that displays a loading state when the form is pending:/app/ui/search-button.tsxTypeScriptJavaScriptTypeScript'use client'import{ useFormStatus }from'react-dom'exportdefaultfunctionSearchButton() {conststatus=useFormStatus()return(<buttontype=""submit"">{status.pending?'Searching...':'Search'}</button>)}Then, update the search form page to use theSearchButtoncomponent:/app/page.tsxTypeScriptJavaScriptTypeScriptimportFormfrom'next/form'import{ SearchButton }from'@/ui/search-button'exportdefaultfunctionPage() {return(<Formaction=""/search""><inputname=""query""/><SearchButton/></Form>)}Mutations with Server ActionsYou can perform mutations by passing a function to theactionprop./app/posts/create/page.tsxTypeScriptJavaScriptTypeScriptimportFormfrom'next/form'import{ createPost }from'@/posts/actions'exportdefaultfunctionPage() {return(<Formaction={createPost}><inputname=""title""/>{/* ... */}<buttontype=""submit"">Create Post</button></Form>)}After a mutation, it's common to redirect to the new resource. You can use theredirectfunction fromnext/navigationto navigate to the new post page.Good to know: Since the ""destination"" of the form submission is not known until the action is executed,<Form>cannot automatically prefetch shared UI./app/posts/actions.tsTypeScriptJavaScriptTypeScript'use server'import{ redirect }from'next/navigation'exportasyncfunctioncreatePost(formData:FormData) {// Create a new post// ...// Redirect to the new postredirect(`/posts/${data.id}`)}Then, in the new page, you can fetch data using theparamsprop:/app/posts/[id]/page.tsxTypeScriptJavaScriptTypeScriptimport{ getPost }from'@/posts/data'exportdefaultasyncfunctionPostPage({params,}:{params:Promise<{ id:string}>}) {constdata=awaitgetPost((awaitparams).id)return(<div><h1>{data.title}</h1>{/* ... */}</div>)}See theServer Actionsdocs for more examples.PreviousFontNextImageWas this helpful?supported.Send"
image,Image,"API ReferenceComponentsImageImageExamplesImage ComponentThis API reference will help you understand how to usepropsandconfiguration optionsavailable for the Image Component. For features and usage, please see theImage Componentpage.app/page.jsimportImagefrom'next/image'exportdefaultfunctionPage() {return(<Imagesrc=""/profile.png""width={500}height={500}alt=""Picture of the author""/>)}PropsHere's a summary of the props available for the Image Component:PropExampleTypeStatussrcsrc=""/profile.png""StringRequiredwidthwidth={500}Integer (px)Requiredheightheight={500}Integer (px)Requiredaltalt=""Picture of the author""StringRequiredloaderloader={imageLoader}Function-fillfill={true}Boolean-sizessizes=""(max-width: 768px) 100vw, 33vw""String-qualityquality={80}Integer (1-100)-prioritypriority={true}Boolean-placeholderplaceholder=""blur""String-stylestyle={{objectFit: ""contain""}}Object-onLoadingCompleteonLoadingComplete={img => done())}FunctionDeprecatedonLoadonLoad={event => done())}Function-onErroronError(event => fail()}Function-loadingloading=""lazy""String-blurDataURLblurDataURL=""data:image/jpeg...""String-overrideSrcoverrideSrc=""/seo.png""String-Required PropsThe Image Component requires the following properties:src,alt,widthandheight(orfill).app/page.jsimportImagefrom'next/image'exportdefaultfunctionPage() {return(<div><Imagesrc=""/profile.png""width={500}height={500}alt=""Picture of the author""/></div>)}srcMust be one of the following:Astatically importedimage fileA path string. This can be either an absolute external URL, or an internal path depending on theloaderprop.When using the defaultloader, also consider the following for source images:When src is an external URL, you must also configureremotePatternsWhen src isanimatedor not a known format (JPEG, PNG, WebP, AVIF, GIF, TIFF) the image will be served as-isWhen src is SVG format, it will be blocked unlessunoptimizedordangerouslyAllowSVGis enabledwidthThewidthproperty represents theintrinsicimage width in pixels. This property is used to infer the correct aspect ratio of the image and avoid layout shift during loading. It does not determine the rendered size of the image, which is controlled by CSS, similar to thewidthattribute in the HTML<img>tag.Required, except forstatically imported imagesor images with thefillproperty.heightTheheightproperty represents theintrinsicimage height in pixels. This property is used to infer the correct aspect ratio of the image and avoid layout shift during loading. It does not determine the rendered size of the image, which is controlled by CSS, similar to theheightattribute in the HTML<img>tag.Required, except forstatically imported imagesor images with thefillproperty.Good to know:Combined, bothwidthandheightproperties are used to determine the aspect ratio of the image which used by browsers to reserve space for the image before it loads.The intrinsic size does not always mean the rendered size in the browser, which will be determined by the parent container. For example, if the parent container is smaller than the intrinsic size, the image will be scaled down to fit the container.You can use thefillproperty when the width and height are unknown.altThealtproperty is used to describe the image for screen readers and search engines. It is also the fallback text if images have been disabled or an error occurs while loading the image.It should contain text that could replace the imagewithout changing the meaning of the page. It is not meant to supplement the image and should not repeat information that is already provided in the captions above or below the image.If the image ispurely decorativeornot intended for the user, thealtproperty should be an empty string (alt="""").Learn moreOptional PropsThe<Image />component accepts a number of additional properties beyond those which are required. This section describes the most commonly-used properties of the Image component. Find details about more rarely-used properties in theAdvanced Propssection.loaderA custom function used to resolve image URLs.Aloaderis a function returning a URL string for the image, given the following parameters:srcwidthqualityHere is an example of using a custom loader:'use client'importImagefrom'next/image'constimageLoader=({ src,width,quality })=>{return`https://example.com/${src}?w=${width}&q=${quality||75}`}exportdefaultfunctionPage() {return(<Imageloader={imageLoader}src=""me.png""alt=""Picture of the author""width={500}height={500}/>)}Good to know: Using props likeloader, which accept a function, requires usingClient Componentsto serialize the provided function.Alternatively, you can use theloaderFileconfiguration innext.config.jsto configure every instance ofnext/imagein your application, without passing a prop.fillfill={true}// {true} | {false}A boolean that causes the image to fill the parent element, which is useful when thewidthandheightare unknown.The parent elementmustassignposition: ""relative"",position: ""fixed"", orposition: ""absolute""style.By default, the img element will automatically be assigned theposition: ""absolute""style.If no styles are applied to the image, the image will stretch to fit the container. You may prefer to setobject-fit: ""contain""for an image which is letterboxed to fit the container and preserve aspect ratio.Alternatively,object-fit: ""cover""will cause the image to fill the entire container and be cropped to preserve aspect ratio.For more information, see also:positionobject-fitobject-positionsizesA string, similar to a media query, that provides information about how wide the image will be at different breakpoints. The value ofsizeswill greatly affect performance for images usingfillor which arestyled to have a responsive size.Thesizesproperty serves two important purposes related to image performance:First, the value ofsizesis used by the browser to determine which size of the image to download, fromnext/image's automatically generatedsrcset. When the browser chooses, it does not yet know the size of the image on the page, so it selects an image that is the same size or larger than the viewport. Thesizesproperty allows you to tell the browser that the image will actually be smaller than full screen. If you don't specify asizesvalue in an image with thefillproperty, a default value of100vw(full screen width) is used.Second, thesizesproperty changes the behavior of the automatically generatedsrcsetvalue. If nosizesvalue is present, a smallsrcsetis generated, suitable for a fixed-size image (1x/2x/etc). Ifsizesis defined, a largesrcsetis generated, suitable for a responsive image (640w/750w/etc). If thesizesproperty includes sizes such as50vw, which represent a percentage of the viewport width, then thesrcsetis trimmed to not include any values which are too small to ever be necessary.For example, if you know your styling will cause an image to be full-width on mobile devices, in a 2-column layout on tablets, and a 3-column layout on desktop displays, you should include a sizes property such as the following:importImagefrom'next/image'exportdefaultfunctionPage() {return(<divclassName=""grid-element""><Imagefillsrc=""/example.png""sizes=""(max-width: 768px) 100vw, (max-width: 1200px) 50vw, 33vw""/></div>)}This examplesizescould have a dramatic effect on performance metrics. Without the33vwsizes, the image selected from the server would be 3 times as wide as it needs to be. Because file size is proportional to the square of the width, withoutsizesthe user would download an image that's 9 times larger than necessary.Learn more aboutsrcsetandsizes:web.devmdnqualityquality={75}// {number 1-100}The quality of the optimized image, an integer between1and100, where100is the best quality and therefore largest file size. Defaults to75.If thequalitiesconfiguration is defined innext.config.js, thequalityprop must match one of the values defined in the configuration.Good to know: If the original source image was already low quality, setting the quality prop too high could cause the resulting optimized image to be larger than the original source image.prioritypriority={false}// {false} | {true}When true, Next.js willpreloadthe image. Lazy loading is automatically disabled for images usingpriority. If theloadingproperty is also used and set tolazy, thepriorityproperty can't be used. Theloadingproperty is only meant for advanced use cases. Removeloadingwhenpriorityis needed.You should use thepriorityproperty on any image detected as theLargest Contentful Paint (LCP)element. It may be appropriate to have multiple priority images, as different images may be the LCP element for different viewport sizes.Should only be used when the image is visible above the fold. Defaults tofalse.placeholderplaceholder='empty'// ""empty"" | ""blur"" | ""data:image/...""A placeholder to use while the image is loading. Possible values areblur,empty, ordata:image/.... Defaults toempty.Whenblur, theblurDataURLproperty will be used as the placeholder. Ifsrcis an object from astatic importand the imported image is.jpg,.png,.webp, or.avif, thenblurDataURLwill be automatically populated, except when the image is detected to be animated.For dynamic images, you must provide theblurDataURLproperty. Solutions such asPlaiceholdercan help withbase64generation.Whendata:image/..., theData URLwill be used as the placeholder while the image is loading.Whenempty, there will be no placeholder while the image is loading, only empty space.Try it out:Demo theblurplaceholderDemo the shimmer effect with data URLplaceholderpropDemo the color effect withblurDataURLpropAdvanced PropsIn some cases, you may need more advanced usage. The<Image />component optionally accepts the following advanced properties.styleAllows passing CSS styles to the underlying image element.components/ProfileImage.jsconstimageStyle={borderRadius:'50%',border:'1px solid #fff',}exportdefaultfunctionProfileImage() {return<Imagesrc=""...""style={imageStyle} />}Remember that the required width and height props can interact with your styling. If you use styling to modify an image's width, you should also style its height toautoto preserve its intrinsic aspect ratio, or your image will be distorted.onLoadingComplete'use client'<ImageonLoadingComplete={(img)=>console.log(img.naturalWidth)} />Warning: Deprecated since Next.js 14 in favor ofonLoad.A callback function that is invoked once the image is completely loaded and theplaceholderhas been removed.The callback function will be called with one argument, a reference to the underlying<img>element.Good to know: Using props likeonLoadingComplete, which accept a function, requires usingClient Componentsto serialize the provided function.onLoad<ImageonLoad={(e)=>console.log(e.target.naturalWidth)} />A callback function that is invoked once the image is completely loaded and theplaceholderhas been removed.The callback function will be called with one argument, the Event which has atargetthat references the underlying<img>element.Good to know: Using props likeonLoad, which accept a function, requires usingClient Componentsto serialize the provided function.onError<ImageonError={(e)=>console.error(e.target.id)} />A callback function that is invoked if the image fails to load.Good to know: Using props likeonError, which accept a function, requires usingClient Componentsto serialize the provided function.loadingloading='lazy'// {lazy} | {eager}The loading behavior of the image. Defaults tolazy.Whenlazy, defer loading the image until it reaches a calculated distance from
the viewport.Wheneager, load the image immediately.Learn more about theloadingattribute.blurDataURLAData URLto
be used as a placeholder image before thesrcimage successfully loads. Only takes effect when combined
withplaceholder=""blur"".Must be a base64-encoded image. It will be enlarged and blurred, so a very small image (10px or
less) is recommended. Including larger images as placeholders may harm your application performance.Try it out:Demo the defaultblurDataURLpropDemo the color effect withblurDataURLpropYou can alsogenerate a solid color Data URLto match the image.unoptimizedunoptimized={false}// {false} | {true}When true, the source image will be served as-is from thesrcinstead of changing quality, size, or format. Defaults tofalse.This is useful for images that do not benefit from optimization such as small images (less than 1KB), vector images (SVG), or animated images (GIF).importImagefrom'next/image'constUnoptimizedImage=(props)=>{return<Image{...props}unoptimized/>}Since Next.js 12.3.0, this prop can be assigned to all images by updatingnext.config.jswith the following configuration:next.config.jsmodule.exports={images:{unoptimized:true,},}overrideSrcWhen providing thesrcprop to the<Image>component, both thesrcsetandsrcattributes are generated automatically for the resulting<img>.input.js<Imagesrc=""/me.jpg""/>output.html<imgsrcset=""/_next/image?url=%2Fme.jpg&w=640&q=75 1x,/_next/image?url=%2Fme.jpg&w=828&q=75 2x""src=""/_next/image?url=%2Fme.jpg&w=828&q=75""/>In some cases, it is not desirable to have thesrcattribute generated and you may wish to override it using theoverrideSrcprop.For example, when upgrading an existing website from<img>to<Image>, you may wish to maintain the samesrcattribute for SEO purposes such as image ranking or avoiding recrawl.input.js<Imagesrc=""/me.jpg""overrideSrc=""/override.jpg""/>output.html<imgsrcset=""/_next/image?url=%2Fme.jpg&w=640&q=75 1x,/_next/image?url=%2Fme.jpg&w=828&q=75 2x""src=""/override.jpg""/>decodingA hint to the browser indicating if it should wait for the image to be decoded before presenting other content updates or not. Defaults toasync.Possible values are the following:async- Asynchronously decode the image and allow other content to be rendered before it completes.sync- Synchronously decode the image for atomic presentation with other content.auto- No preference for the decoding mode; the browser decides what's best.Learn more about thedecodingattribute.Other PropsOther properties on the<Image />component will be passed to the underlyingimgelement with the exception of the following:srcSet. UseDevice Sizesinstead.Configuration OptionsIn addition to props, you can configure the Image Component innext.config.js. The following options are available:localPatternsYou can optionally configurelocalPatternsin yournext.config.jsfile in order to allow specific paths to be optimized and block all others paths.next.config.jsmodule.exports={images:{localPatterns:[{pathname:'/assets/images/**',search:'',},],},}Good to know: The example above will ensure thesrcproperty ofnext/imagemust start with/assets/images/and must not have a query string. Attempting to optimize any other path will respond with 400 Bad Request.remotePatternsTo protect your application from malicious users, configuration is required in order to use external images. This ensures that only external images from your account can be served from the Next.js Image Optimization API. These external images can be configured with theremotePatternsproperty in yournext.config.jsfile, as shown below:next.config.jsmodule.exports={images:{remotePatterns:[{protocol:'https',hostname:'example.com',port:'',pathname:'/account123/**',search:'',},],},}Good to know: The example above will ensure thesrcproperty ofnext/imagemust start withhttps://example.com/account123/and must not have a query string. Any other protocol, hostname, port, or unmatched path will respond with 400 Bad Request.Below is an example of theremotePatternsproperty in thenext.config.jsfile using a wildcard pattern in thehostname:next.config.jsmodule.exports={images:{remotePatterns:[{protocol:'https',hostname:'**.example.com',port:'',search:'',},],},}Good to know: The example above will ensure thesrcproperty ofnext/imagemust start withhttps://img1.example.comorhttps://me.avatar.example.comor any number of subdomains. It cannot have a port or query string. Any other protocol or unmatched hostname will respond with 400 Bad Request.Wildcard patterns can be used for bothpathnameandhostnameand have the following syntax:*match a single path segment or subdomain**match any number of path segments at the end or subdomains at the beginningThe**syntax does not work in the middle of the pattern.Good to know: When omittingprotocol,port,pathname, orsearchthen the wildcard**is implied. This is not recommended because it may allow malicious actors to optimize urls you did not intend.Below is an example of theremotePatternsproperty in thenext.config.jsfile usingsearch:next.config.jsmodule.exports={images:{remotePatterns:[{protocol:'https',hostname:'assets.example.com',search:'?v=1727111025337',},],},}Good to know: The example above will ensure thesrcproperty ofnext/imagemust start withhttps://assets.example.comand must have the exact query string?v=1727111025337. Any other protocol or query string will respond with 400 Bad Request.domainsWarning: Deprecated since Next.js 14 in favor of strictremotePatternsin order to protect your application from malicious users. Only usedomainsif you own all the content served from the domain.Similar toremotePatterns, thedomainsconfiguration can be used to provide a list of allowed hostnames for external images.However, thedomainsconfiguration does not support wildcard pattern matching and it cannot restrict protocol, port, or pathname.Below is an example of thedomainsproperty in thenext.config.jsfile:next.config.jsmodule.exports={images:{domains:['assets.acme.com'],},}loaderFileIf you want to use a cloud provider to optimize images instead of using the Next.js built-in Image Optimization API, you can configure theloaderFilein yournext.config.jslike the following:next.config.jsmodule.exports={images:{loader:'custom',loaderFile:'./my/image/loader.js',},}This must point to a file relative to the root of your Next.js application. The file must export a default function that returns a string, for example:my/image/loader.js'use client'exportdefaultfunctionmyImageLoader({ src,width,quality }) {return`https://example.com/${src}?w=${width}&q=${quality||75}`}Alternatively, you can use theloaderpropto configure each instance ofnext/image.Examples:Custom Image Loader ConfigurationGood to know: Customizing the image loader file, which accepts a function, requires usingClient Componentsto serialize the provided function.AdvancedThe following configuration is for advanced use cases and is usually not necessary. If you choose to configure the properties below, you will override any changes to the Next.js defaults in future updates.deviceSizesIf you know the expected device widths of your users, you can specify a list of device width breakpoints using thedeviceSizesproperty innext.config.js. These widths are used when thenext/imagecomponent usessizesprop to ensure the correct image is served for user's device.If no configuration is provided, the default below is used.next.config.jsmodule.exports={images:{deviceSizes:[640,750,828,1080,1200,1920,2048,3840],},}imageSizesYou can specify a list of image widths using theimages.imageSizesproperty in yournext.config.jsfile. These widths are concatenated with the array ofdevice sizesto form the full array of sizes used to generate imagesrcsets.The reason there are two separate lists is that imageSizes is only used for images which provide asizesprop, which indicates that the image is less than the full width of the screen.Therefore, the sizes in imageSizes should all be smaller than the smallest size in deviceSizes.If no configuration is provided, the default below is used.next.config.jsmodule.exports={images:{imageSizes:[16,32,48,64,96,128,256,384],},}qualitiesThe defaultImage Optimization APIwill automatically allow all qualities from 1 to 100. If you wish to restrict the allowed qualities, you can add configuration tonext.config.js.next.config.jsmodule.exports={images:{qualities:[25,50,75],},}In this example above, only three qualities are allowed: 25, 50, and 75. If thequalityprop does not match a value in this array, the image will fail with 400 Bad Request.formatsThe defaultImage Optimization APIwill automatically detect the browser's supported image formats via the request'sAcceptheader in order to determine the best output format.If theAcceptheader matches more than one of the configured formats, the first match in the array is used. Therefore, the array order matters. If there is no match (or the source image isanimated), the Image Optimization API will fallback to the original image's format.If no configuration is provided, the default below is used.next.config.jsmodule.exports={images:{formats:['image/webp'],},}You can enable AVIF support, which will fallback to the original format of the src image if the browserdoes not support AVIF:next.config.jsmodule.exports={images:{formats:['image/avif'],},}Good to know:We still recommend using WebP for most use cases.AVIF generally takes 50% longer to encode but it compresses 20% smaller compared to WebP. This means that the first time an image is requested, it will typically be slower and then subsequent requests that are cached will be faster.If you self-host with a Proxy/CDN in front of Next.js, you must configure the Proxy to forward theAcceptheader.Caching BehaviorThe following describes the caching algorithm for the defaultloader. For all other loaders, please refer to your cloud provider's documentation.Images are optimized dynamically upon request and stored in the<distDir>/cache/imagesdirectory. The optimized image file will be served for subsequent requests until the expiration is reached. When a request is made that matches a cached but expired file, the expired image is served stale immediately. Then the image is optimized again in the background (also called revalidation) and saved to the cache with the new expiration date.The cache status of an image can be determined by reading the value of thex-nextjs-cacheresponse header. The possible values are the following:MISS- the path is not in the cache (occurs at most once, on the first visit)STALE- the path is in the cache but exceeded the revalidate time so it will be updated in the backgroundHIT- the path is in the cache and has not exceeded the revalidate timeThe expiration (or rather Max Age) is defined by either theminimumCacheTTLconfiguration or the upstream imageCache-Controlheader, whichever is larger. Specifically, themax-agevalue of theCache-Controlheader is used. If boths-maxageandmax-ageare found, thens-maxageis preferred. Themax-ageis also passed-through to any downstream clients including CDNs and browsers.You can configureminimumCacheTTLto increase the cache duration when the upstream image does not includeCache-Controlheader or the value is very low.You can configuredeviceSizesandimageSizesto reduce the total number of possible generated images.You can configureformatsto disable multiple formats in favor of a single image format.minimumCacheTTLYou can configure the Time to Live (TTL) in seconds for cached optimized images. In many cases, it's better to use aStatic Image Importwhich will automatically hash the file contents and cache the image forever with aCache-Controlheader ofimmutable.next.config.jsmodule.exports={images:{minimumCacheTTL:60,},}The expiration (or rather Max Age) of the optimized image is defined by either theminimumCacheTTLor the upstream imageCache-Controlheader, whichever is larger.If you need to change the caching behavior per image, you can configureheadersto set theCache-Controlheader on the upstream image (e.g./some-asset.jpg, not/_next/imageitself).There is no mechanism to invalidate the cache at this time, so its best to keepminimumCacheTTLlow. Otherwise you may need to manually change thesrcprop or delete<distDir>/cache/images.disableStaticImagesThe default behavior allows you to import static files such asimport icon from './icon.png'and then pass that to thesrcproperty.In some cases, you may wish to disable this feature if it conflicts with other plugins that expect the import to behave differently.You can disable static image imports inside yournext.config.js:next.config.jsmodule.exports={images:{disableStaticImages:true,},}dangerouslyAllowSVGThe defaultloaderdoes not optimize SVG images for a few reasons. First, SVG is a vector format meaning it can be resized losslessly. Second, SVG has many of the same features as HTML/CSS, which can lead to vulnerabilities without properContent Security Policy (CSP) headers.Therefore, we recommended using theunoptimizedprop when thesrcprop is known to be SVG. This happens automatically whensrcends with"".svg"".However, if you need to serve SVG images with the default Image Optimization API, you can setdangerouslyAllowSVGinside yournext.config.js:next.config.jsmodule.exports={images:{dangerouslyAllowSVG:true,contentDispositionType:'attachment',contentSecurityPolicy:""default-src 'self'; script-src 'none'; sandbox;"",},}In addition, it is strongly recommended to also setcontentDispositionTypeto force the browser to download the image, as well ascontentSecurityPolicyto prevent scripts embedded in the image from executing.contentDispositionTypeThe defaultloadersets theContent-Dispositionheader toattachmentfor added protection since the API can serve arbitrary remote images.The default value isattachmentwhich forces the browser to download the image when visiting directly. This is particularly important whendangerouslyAllowSVGis true.You can optionally configureinlineto allow the browser to render the image when visiting directly, without downloading it.next.config.jsmodule.exports={images:{contentDispositionType:'inline',},}Animated ImagesThe defaultloaderwill automatically bypass Image Optimization for animated images and serve the image as-is.Auto-detection for animated files is best-effort and supports GIF, APNG, and WebP. If you want to explicitly bypass Image Optimization for a given animated image, use theunoptimizedprop.Responsive ImagesThe default generatedsrcsetcontains1xand2ximages in order to support different device pixel ratios. However, you may wish to render a responsive image that stretches with the viewport. In that case, you'll need to setsizesas well asstyle(orclassName).You can render a responsive image using one of the following methods below.Responsive image using a static importIf the source image is not dynamic, you can statically import to create a responsive image:components/author.jsimportImagefrom'next/image'importmefrom'../photos/me.jpg'exportdefaultfunctionAuthor() {return(<Imagesrc={me}alt=""Picture of the author""sizes=""100vw""style={{width:'100%',height:'auto',}}/>)}Try it out:Demo the image responsive to viewportResponsive image with aspect ratioIf the source image is a dynamic or a remote url, you will also need to providewidthandheightto set the correct aspect ratio of the responsive image:components/page.jsimportImagefrom'next/image'exportdefaultfunctionPage({ photoUrl }) {return(<Imagesrc={photoUrl}alt=""Picture of the author""sizes=""100vw""style={{width:'100%',height:'auto',}}width={500}height={300}/>)}Try it out:Demo the image responsive to viewportResponsive image withfillIf you don't know the aspect ratio, you will need to set thefillprop and setposition: relativeon the parent. Optionally, you can setobject-fitstyle depending on the desired stretch vs crop behavior:app/page.jsimportImagefrom'next/image'exportdefaultfunctionPage({ photoUrl }) {return(<divstyle={{ position:'relative',width:'300px',height:'500px'}}><Imagesrc={photoUrl}alt=""Picture of the author""sizes=""300px""fillstyle={{objectFit:'contain',}}/></div>)}Try it out:Demo thefillpropTheme Detection CSSIf you want to display a different image for light and dark mode, you can create a new component that wraps two<Image>components and reveals the correct one based on a CSS media query.components/theme-image.module.css.imgDark{display:none;}@media(prefers-color-scheme:dark) {.imgLight{display:none;}.imgDark{display:unset;}}components/theme-image.tsxTypeScriptJavaScriptTypeScriptimportstylesfrom'./theme-image.module.css'importImage,{ ImageProps }from'next/image'typeProps=Omit<ImageProps,'src'|'priority'|'loading'>&{srcLight:stringsrcDark:string}constThemeImage=(props:Props)=>{const{srcLight,srcDark,...rest}=propsreturn(<><Image{...rest}src={srcLight}className={styles.imgLight} /><Image{...rest}src={srcDark}className={styles.imgDark} /></>)}Good to know: The default behavior ofloading=""lazy""ensures that only the correct image is loaded. You cannot usepriorityorloading=""eager""because that would cause both images to load. Instead, you can usefetchPriority=""high"".Try it out:Demo light/dark mode theme detectiongetImagePropsFor more advanced use cases, you can callgetImageProps()to get the props that would be passed to the underlying<img>element, and instead pass to them to another component, style, canvas, etc.This also avoid calling ReactuseState()so it can lead to better performance, but it cannot be used with theplaceholderprop because the placeholder will never be removed.Theme Detection PictureIf you want to display a different image for light and dark mode, you can use the<picture>element to display a different image based on the user'spreferred color scheme.app/page.jsimport{ getImageProps }from'next/image'exportdefaultfunctionPage() {constcommon={ alt:'Theme Example',width:800,height:400}const{props: { srcSet:dark},}=getImageProps({...common,src:'/dark.png'})const{props: { srcSet:light,...rest},}=getImageProps({...common,src:'/light.png'})return(<picture><sourcemedia=""(prefers-color-scheme: dark)""srcSet={dark} /><sourcemedia=""(prefers-color-scheme: light)""srcSet={light} /><img{...rest} /></picture>)}Art DirectionIf you want to display a different image for mobile and desktop, sometimes calledArt Direction, you can provide differentsrc,width,height, andqualityprops togetImageProps().app/page.jsimport{ getImageProps }from'next/image'exportdefaultfunctionHome() {constcommon={ alt:'Art Direction Example',sizes:'100vw'}const{props: { srcSet:desktop},}=getImageProps({...common,width:1440,height:875,quality:80,src:'/desktop.jpg',})const{props: { srcSet:mobile,...rest},}=getImageProps({...common,width:750,height:1334,quality:70,src:'/mobile.jpg',})return(<picture><sourcemedia=""(min-width: 1000px)""srcSet={desktop} /><sourcemedia=""(min-width: 500px)""srcSet={mobile} /><img{...rest}style={{ width:'100%',height:'auto'}} /></picture>)}Background CSSYou can even convert thesrcSetstring to theimage-set()CSS function to optimize a background image.app/page.jsimport{ getImageProps }from'next/image'functiongetBackgroundImage(srcSet='') {constimageSet=srcSet.split(', ').map((str)=>{const[url,dpi]=str.split(' ')return`url(""${url}"")${dpi}`}).join(', ')return`image-set(${imageSet})`}exportdefaultfunctionHome() {const{props: {srcSet},}=getImageProps({ alt:'',width:128,height:128,src:'/img.png'})constbackgroundImage=getBackgroundImage(srcSet)conststyle={ height:'100vh',width:'100vw',backgroundImage }return(<mainstyle={style}><h1>Hello World</h1></main>)}Known Browser BugsThisnext/imagecomponent uses browser nativelazy loading, which may fallback to eager loading for older browsers before Safari 15.4. When using the blur-up placeholder, older browsers before Safari 12 will fallback to empty placeholder. When using styles withwidth/heightofauto, it is possible to causeLayout Shifton older browsers before Safari 15 that don'tpreserve the aspect ratio. For more details, seethis MDN video.Safari 15 - 16.3display a gray border while loading. Safari 16.4fixed this issue. Possible solutions:Use CSS@supports (font: -apple-system-body) and (-webkit-appearance: none) { img[loading=""lazy""] { clip-path: inset(0.6px) } }Usepriorityif the image is above the foldFirefox 67+displays a white background while loading. Possible solutions:EnableAVIFformatsUseplaceholderVersion HistoryVersionChangesv15.0.0contentDispositionTypeconfiguration default changed toattachment.v14.2.23qualitiesconfiguration added.v14.2.15decodingprop added andlocalPatternsconfiguration added.v14.2.14remotePatterns.searchprop added.v14.2.0overrideSrcprop added.v14.1.0getImageProps()is stable.v14.0.0onLoadingCompleteprop anddomainsconfig deprecated.v13.4.14placeholderprop support fordata:/image...v13.2.0contentDispositionTypeconfiguration added.v13.0.6refprop added.v13.0.0Thenext/imageimport was renamed tonext/legacy/image. Thenext/future/imageimport was renamed tonext/image. Acodemod is availableto safely and automatically rename your imports.<span>wrapper removed.layout,objectFit,objectPosition,lazyBoundary,lazyRootprops removed.altis required.onLoadingCompletereceives reference toimgelement. Built-in loader config removed.v12.3.0remotePatternsandunoptimizedconfiguration is stable.v12.2.0ExperimentalremotePatternsand experimentalunoptimizedconfiguration added.layout=""raw""removed.v12.1.1styleprop added. Experimental support forlayout=""raw""added.v12.1.0dangerouslyAllowSVGandcontentSecurityPolicyconfiguration added.v12.0.9lazyRootprop added.v12.0.0formatsconfiguration added.AVIF support added.Wrapper<div>changed to<span>.v11.1.0onLoadingCompleteandlazyBoundaryprops added.v11.0.0srcprop support for static import.placeholderprop added.blurDataURLprop added.v10.0.5loaderprop added.v10.0.1layoutprop added.v10.0.0next/imageintroduced.PreviousFormNextLinkWas this helpful?supported.Send"
link,Link,"API ReferenceComponentsLinkLink<Link>is a React component that extends the HTML<a>element to provideprefetchingand client-side navigation between routes. It is the primary way to navigate between routes in Next.js.Basic usage:app/page.tsxTypeScriptJavaScriptTypeScriptimportLinkfrom'next/link'exportdefaultfunctionPage() {return<Linkhref=""/dashboard"">Dashboard</Link>}ReferenceThe following props can be passed to the<Link>component:PropExampleTypeRequiredhrefhref=""/dashboard""String or ObjectYesreplacereplace={false}Boolean-scrollscroll={false}Boolean-prefetchprefetch={false}Boolean or null-Good to know:<a>tag attributes such asclassNameortarget=""_blank""can be added to<Link>as props and will be passed to the underlying<a>element.href(required)The path or URL to navigate to.app/page.tsxTypeScriptJavaScriptTypeScriptimportLinkfrom'next/link'// Navigate to /about?name=testexportdefaultfunctionPage() {return(<Linkhref={{pathname:'/about',query:{ name:'test'},}}>About</Link>)}replaceDefaults tofalse.Whentrue,next/linkwill replace the current history state instead of adding a new URL into thebrowser's historystack.app/page.tsxTypeScriptJavaScriptTypeScriptimportLinkfrom'next/link'exportdefaultfunctionPage() {return(<Linkhref=""/dashboard""replace>Dashboard</Link>)}scrollDefaults totrue.The default scrolling behavior of<Link>in Next.jsis to maintain scroll position, similar to how browsers handle back and forwards navigation. When you navigate to a newPage, scroll position will stay the same as long as the Page is visible in the viewport. However, if the Page is not visible in the viewport, Next.js will scroll to the top of the first Page element.Whenscroll = {false}, Next.js will not attempt to scroll to the first Page element.Good to know: Next.js checks ifscroll: falsebefore managing scroll behavior. If scrolling is enabled, it identifies the relevant DOM node for navigation and inspects each top-level element. All non-scrollable elements and those without rendered HTML are bypassed, this includes sticky or fixed positioned elements, and non-visible elements such as those calculated withgetBoundingClientRect. Next.js then continues through siblings until it identifies a scrollable element that is visible in the viewport.app/page.tsxTypeScriptJavaScriptTypeScriptimportLinkfrom'next/link'exportdefaultfunctionPage() {return(<Linkhref=""/dashboard""scroll={false}>Dashboard</Link>)}prefetchPrefetching happens when a<Link />component enters the user's viewport (initially or through scroll). Next.js prefetches and loads the linked route (denoted by thehref) and its data in the background to improve the performance of client-side navigations. If the prefetched data has expired by the time the user hovers over a<Link />, Next.js will attempt to prefetch it again.Prefetching is only enabled in production.The following values can be passed to theprefetchprop:null(default): Prefetch behavior depends on whether the route is static or dynamic. For static routes, the full route will be prefetched (including all its data). For dynamic routes, the partial route down to the nearest segment with aloading.jsboundary will be prefetched.true: The full route will be prefetched for both static and dynamic routes.false: Prefetching will never happen both on entering the viewport and on hover.app/page.tsxTypeScriptJavaScriptTypeScriptimportLinkfrom'next/link'exportdefaultfunctionPage() {return(<Linkhref=""/dashboard""prefetch={false}>Dashboard</Link>)}ExamplesThe following examples demonstrate how to use the<Link>component in different scenarios.Linking to dynamic segmentsWhen linking todynamic segments, you can usetemplate literals and interpolationto generate a list of links. For example, to generate a list of blog posts:app/blog/post-list.tsxTypeScriptJavaScriptTypeScriptimportLinkfrom'next/link'interfacePost{id:numbertitle:stringslug:string}exportdefaultfunctionPostList({ posts }:{ posts:Post[] }) {return(<ul>{posts.map((post)=>(<likey={post.id}><Linkhref={`/blog/${post.slug}`}>{post.title}</Link></li>))}</ul>)}Checking active linksYou can useusePathname()to determine if a link is active. For example, to add a class to the active link, you can check if the currentpathnamematches thehrefof the link:app/ui/nav-links.tsxTypeScriptJavaScriptTypeScript'use client'import{ usePathname }from'next/navigation'importLinkfrom'next/link'exportfunctionLinks() {constpathname=usePathname()return(<nav><LinkclassName={`link${pathname==='/'?'active':''}`}href=""/"">Home</Link><LinkclassName={`link${pathname==='/about'?'active':''}`}href=""/about"">About</Link></nav>)}Scrolling to anidIf you'd like to scroll to a specificidon navigation, you can append your URL with a#hash link or just pass a hash link to thehrefprop. This is possible since<Link>renders to an<a>element.<Linkhref=""/dashboard#settings"">Settings</Link>// Output<ahref=""/dashboard#settings"">Settings</a>Good to know:Next.js will scroll to thePageif it is not visible in the viewport upon navigation.Linking to dynamic route segmentsFordynamic route segments, it can be handy to use template literals to create the link's path.For example, you can generate a list of links to the dynamic routeapp/blog/[slug]/page.js:app/blog/page.tsxTypeScriptJavaScriptTypeScriptimportLinkfrom'next/link'exportdefaultfunctionPage({ posts }) {return(<ul>{posts.map((post)=>(<likey={post.id}><Linkhref={`/blog/${post.slug}`}>{post.title}</Link></li>))}</ul>)}If the child is a custom component that wraps an<a>tagIf the child ofLinkis a custom component that wraps an<a>tag, you must addpassHreftoLink. This is necessary if you’re using libraries likestyled-components. Without this, the<a>tag will not have thehrefattribute, which hurts your site's accessibility and might affect SEO. If you're usingESLint, there is a built-in rulenext/link-passhrefto ensure correct usage ofpassHref.components/nav-link.tsxTypeScriptJavaScriptTypeScriptimportLinkfrom'next/link'importstyledfrom'styled-components'// This creates a custom component that wraps an <a> tagconstRedLink=styled.a`color: red;`functionNavLink({ href,name }) {return(<Linkhref={href}passHreflegacyBehavior><RedLink>{name}</RedLink></Link>)}exportdefaultNavLinkIf you’re usingemotion’s JSX pragma feature (@jsx jsx), you must usepassHrefeven if you use an<a>tag directly.The component should supportonClickproperty to trigger navigation correctly.Nesting a functional componentIf the child ofLinkis a functional component, in addition to usingpassHrefandlegacyBehavior, you must wrap the component inReact.forwardRef:app/page.tsxTypeScriptJavaScriptTypeScriptimportLinkfrom'next/link'importReactfrom'react'// Define the props type for MyButtoninterfaceMyButtonProps{onClick?:React.MouseEventHandler<HTMLAnchorElement>href?:string}// Use React.ForwardRefRenderFunction to properly type the forwarded refconstMyButton:React.ForwardRefRenderFunction<HTMLAnchorElement,MyButtonProps>=({ onClick,href },ref)=>{return(<ahref={href}onClick={onClick}ref={ref}>Click Me</a>)}// Use React.forwardRef to wrap the componentconstForwardedMyButton=React.forwardRef(MyButton)exportdefaultfunctionPage() {return(<Linkhref=""/about""passHreflegacyBehavior><ForwardedMyButton/></Link>)}Replace the URL instead of pushThe default behavior of theLinkcomponent is topusha new URL into thehistorystack. You can use thereplaceprop to prevent adding a new entry, as in the following example:app/page.jsTypeScriptJavaScriptTypeScriptimportLinkfrom'next/link'exportdefaultfunctionPage() {return(<Linkhref=""/about""replace>About us</Link>)}Disable scrolling to the top of the pageThe default scrolling behavior of<Link>in Next.jsis to maintain scroll position, similar to how browsers handle back and forwards navigation. When you navigate to a newPage, scroll position will stay the same as long as the Page is visible in the viewport.However, if the Page is not visible in the viewport, Next.js will scroll to the top of the first Page element. If you'd like to disable this behavior, you can passscroll={false}to the<Link>component, orscroll: falsetorouter.push()orrouter.replace().app/page.tsxTypeScriptJavaScriptTypeScriptimportLinkfrom'next/link'exportdefaultfunctionPage() {return(<Linkhref=""/#hashid""scroll={false}>Disables scrolling to the top</Link>)}Usingrouter.push()orrouter.replace():// useRouterimport{ useRouter }from'next/navigation'constrouter=useRouter()router.push('/dashboard',{ scroll:false})Prefetching links in MiddlewareIt's common to useMiddlewarefor authentication or other purposes that involve rewriting the user to a different page. In order for the<Link />component to properly prefetch links with rewrites via Middleware, you need to tell Next.js both the URL to display and the URL to prefetch. This is required to avoid un-necessary fetches to middleware to know the correct route to prefetch.For example, if you want to serve a/dashboardroute that has authenticated and visitor views, you can add the following in your Middleware to redirect the user to the correct page:middleware.tsTypeScriptJavaScriptTypeScriptimport{ NextResponse }from'next/server'exportfunctionmiddleware(request:Request) {constnextUrl=request.nextUrlif(nextUrl.pathname==='/dashboard') {if(request.cookies.authToken) {returnNextResponse.rewrite(newURL('/auth/dashboard',request.url))}else{returnNextResponse.rewrite(newURL('/public/dashboard',request.url))}}}In this case, you would want to use the following code in your<Link />component:app/page.tsxTypeScriptJavaScriptTypeScript'use client'importLinkfrom'next/link'importuseIsAuthedfrom'./hooks/useIsAuthed'// Your auth hookexportdefaultfunctionPage() {constisAuthed=useIsAuthed()constpath=isAuthed?'/auth/dashboard':'/public/dashboard'return(<Linkas=""/dashboard""href={path}>Dashboard</Link>)}Version historyVersionChangesv13.0.0No longer requires a child<a>tag. Acodemodis provided to automatically update your codebase.v10.0.0hrefprops pointing to a dynamic route are automatically resolved and no longer require anasprop.v8.0.0Improved prefetching performance.v1.0.0next/linkintroduced.PreviousImageNextScriptWas this helpful?supported.Send"
script,Script,"API ReferenceComponentsScriptScriptThis API reference will help you understand how to usepropsavailable for the Script Component. For features and usage, please see theOptimizing Scriptspage.app/dashboard/page.tsxTypeScriptJavaScriptTypeScriptimportScriptfrom'next/script'exportdefaultfunctionDashboard() {return(<><Scriptsrc=""https://example.com/script.js""/></>)}PropsHere's a summary of the props available for the Script Component:PropExampleTypeRequiredsrcsrc=""http://example.com/script""StringRequired unless inline script is usedstrategystrategy=""lazyOnload""String-onLoadonLoad={onLoadFunc}Function-onReadyonReady={onReadyFunc}Function-onErroronError={onErrorFunc}Function-Required PropsThe<Script />component requires the following properties.srcA path string specifying the URL of an external script. This can be either an absolute external URL or an internal path. Thesrcproperty is required unless an inline script is used.Optional PropsThe<Script />component accepts a number of additional properties beyond those which are required.strategyThe loading strategy of the script. There are four different strategies that can be used:beforeInteractive: Load before any Next.js code and before any page hydration occurs.afterInteractive: (default) Load early but after some hydration on the page occurs.lazyOnload: Load during browser idle time.worker: (experimental) Load in a web worker.beforeInteractiveScripts that load with thebeforeInteractivestrategy are injected into the initial HTML from the server, downloaded before any Next.js module, and executed in the order they are placed beforeanyhydration occurs on the page.Scripts denoted with this strategy are preloaded and fetched before any first-party code, but their execution does not block page hydration from occurring.beforeInteractivescripts must be placed inside the root layout (app/layout.tsx) and are designed to load scripts that are needed by the entire site (i.e. the script will load when any page in the application has been loaded server-side).This strategy should only be used for critical scripts that need to be fetched before any part of the page becomes interactive.app/layout.tsxTypeScriptJavaScriptTypeScriptimportScriptfrom'next/script'exportdefaultfunctionRootLayout({children,}:{children:React.ReactNode}) {return(<htmllang=""en""><body>{children}<Scriptsrc=""https://example.com/script.js""strategy=""beforeInteractive""/></body></html>)}Good to know: Scripts withbeforeInteractivewill always be injected inside theheadof the HTML document regardless of where it's placed in the component.Some examples of scripts that should be loaded as soon as possible withbeforeInteractiveinclude:Bot detectorsCookie consent managersafterInteractiveScripts that use theafterInteractivestrategy are injected into the HTML client-side and will load after some (or all) hydration occurs on the page.This is the default strategyof the Script component and should be used for any script that needs to load as soon as possible but not before any first-party Next.js code.afterInteractivescripts can be placed inside of any page or layout and will only load and execute when that page (or group of pages) is opened in the browser.app/page.jsimportScriptfrom'next/script'exportdefaultfunctionPage() {return(<><Scriptsrc=""https://example.com/script.js""strategy=""afterInteractive""/></>)}Some examples of scripts that are good candidates forafterInteractiveinclude:Tag managersAnalyticslazyOnloadScripts that use thelazyOnloadstrategy are injected into the HTML client-side during browser idle time and will load after all resources on the page have been fetched. This strategy should be used for any background or low priority scripts that do not need to load early.lazyOnloadscripts can be placed inside of any page or layout and will only load and execute when that page (or group of pages) is opened in the browser.app/page.jsimportScriptfrom'next/script'exportdefaultfunctionPage() {return(<><Scriptsrc=""https://example.com/script.js""strategy=""lazyOnload""/></>)}Examples of scripts that do not need to load immediately and can be fetched withlazyOnloadinclude:Chat support pluginsSocial media widgetsworkerWarning:Theworkerstrategy is not yet stable and does not yet work with the App Router. Use with caution.Scripts that use theworkerstrategy are off-loaded to a web worker in order to free up the main thread and ensure that only critical, first-party resources are processed on it. While this strategy can be used for any script, it is an advanced use case that is not guaranteed to support all third-party scripts.To useworkeras a strategy, thenextScriptWorkersflag must be enabled innext.config.js:next.config.jsmodule.exports={experimental:{nextScriptWorkers:true,},}workerscripts canonly currently be used in thepages/directory:pages/home.tsxTypeScriptJavaScriptTypeScriptimportScriptfrom'next/script'exportdefaultfunctionHome() {return(<><Scriptsrc=""https://example.com/script.js""strategy=""worker""/></>)}onLoadWarning:onLoaddoes not yet work with Server Components and can only be used in Client Components. Further,onLoadcan't be used withbeforeInteractive– consider usingonReadyinstead.Some third-party scripts require users to run JavaScript code once after the script has finished loading in order to instantiate content or call a function. If you are loading a script with eitherafterInteractiveorlazyOnloadas a loading strategy, you can execute code after it has loaded using theonLoadproperty.Here's an example of executing a lodash method only after the library has been loaded.app/page.tsxTypeScriptJavaScriptTypeScript'use client'importScriptfrom'next/script'exportdefaultfunctionPage() {return(<><Scriptsrc=""https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.17.20/lodash.min.js""onLoad={()=>{console.log(_.sample([1,2,3,4]))}}/></>)}onReadyWarning:onReadydoes not yet work with Server Components and can only be used in Client Components.Some third-party scripts require users to run JavaScript code after the script has finished loading and every time the component is mounted (after a route navigation for example). You can execute code after the script's load event when it first loads and then after every subsequent component re-mount using theonReadyproperty.Here's an example of how to re-instantiate a Google Maps JS embed every time the component is mounted:app/page.tsxTypeScriptJavaScriptTypeScript'use client'import{ useRef }from'react'importScriptfrom'next/script'exportdefaultfunctionPage() {constmapRef=useRef()return(<><divref={mapRef}></div><Scriptid=""google-maps""src=""https://maps.googleapis.com/maps/api/js""onReady={()=>{newgoogle.maps.Map(mapRef.current,{center:{ lat:-34.397,lng:150.644},zoom:8,})}}/></>)}onErrorWarning:onErrordoes not yet work with Server Components and can only be used in Client Components.onErrorcannot be used with thebeforeInteractiveloading strategy.Sometimes it is helpful to catch when a script fails to load. These errors can be handled with theonErrorproperty:app/page.tsxTypeScriptJavaScriptTypeScript'use client'importScriptfrom'next/script'exportdefaultfunctionPage() {return(<><Scriptsrc=""https://example.com/script.js""onError={(e:Error)=>{console.error('Script failed to load',e)}}/></>)}Version HistoryVersionChangesv13.0.0beforeInteractiveandafterInteractiveis modified to supportapp.v12.2.4onReadyprop added.v12.2.2Allownext/scriptwithbeforeInteractiveto be placed in_document.v11.0.0next/scriptintroduced.PreviousLinkNextFile ConventionsWas this helpful?supported.Send"
file conventions,File Conventions,App RouterAPI ReferenceFile ConventionsFile Conventionsdefault.jsAPI Reference for the default.js file.error.jsAPI reference for the error.js special file.forbidden.jsAPI reference for the forbidden.js special file.instrumentation.jsAPI reference for the instrumentation.js file.layout.jsAPI reference for the layout.js file.loading.jsAPI reference for the loading.js file.mdx-components.jsAPI reference for the mdx-components.js file.middleware.jsAPI reference for the middleware.js file.not-found.jsAPI reference for the not-found.js file.page.jsAPI reference for the page.js file.route.jsAPI reference for the route.js special file.Route Segment ConfigLearn about how to configure options for Next.js route segments.template.jsAPI Reference for the template.js file.unauthorized.jsAPI reference for the unauthorized.js special file.Metadata FilesAPI documentation for the metadata file conventions.PreviousScriptNextdefault.jsWas this helpful?supported.Send
default.js,default.js,"API ReferenceFile Conventionsdefault.jsdefault.jsThedefault.jsfile is used to render a fallback withinParallel Routeswhen Next.js cannot recover aslot'sactive state after a full-page load.Duringsoft navigation, Next.js keeps track of the activestate(subpage) for each slot. However, for hard navigations (full-page load), Next.js cannot recover the active state. In this case, adefault.jsfile can be rendered for subpages that don't match the current URL.Consider the following folder structure. The@teamslot has asettingspage, but@analyticsdoes not.When navigating to/settings, the@teamslot will render thesettingspage while maintaining the currently active page for the@analyticsslot.On refresh, Next.js will render adefault.jsfor@analytics. Ifdefault.jsdoesn't exist, a404is rendered instead.Additionally, sincechildrenis an implicit slot, you also need to create adefault.jsfile to render a fallback forchildrenwhen Next.js cannot recover the active state of the parent page.Referenceparams(optional)A promise that resolves to an object containing thedynamic route parametersfrom the root segment down to the slot's subpages. For example:app/[artist]/@sidebar/default.jsTypeScriptJavaScriptTypeScriptexportdefaultasyncfunctionDefault({params,}:{params:Promise<{ artist:string}>}) {constartist=(awaitparams).artist}ExampleURLparamsapp/[artist]/@sidebar/default.js/zackPromise<{ artist: 'zack' }>app/[artist]/[album]/@sidebar/default.js/zack/nextPromise<{ artist: 'zack', album: 'next' }>Since theparamsprop is a promise. You must useasync/awaitor React'susefunction to access the values.In version 14 and earlier,paramswas a synchronous prop. To help with backwards compatibility, you can still access it synchronously in Next.js 15, but this behavior will be deprecated in the future.Learn more about Parallel RoutesParallel RoutesSimultaneously render one or more pages in the same view that can be navigated independently. A pattern for highly dynamic applications.PreviousFile ConventionsNexterror.jsWas this helpful?supported.Send"
error.js,error.js,"API ReferenceFile Conventionserror.jserror.jsAnerrorfile allows you to handle unexpected runtime errors and display fallback UI.app/dashboard/error.tsxTypeScriptJavaScriptTypeScript'use client'// Error boundaries must be Client Componentsimport{ useEffect }from'react'exportdefaultfunctionError({error,reset,}:{error:Error&{ digest?:string}reset:()=>void}) {useEffect(()=>{// Log the error to an error reporting serviceconsole.error(error)},[error])return(<div><h2>Something went wrong!</h2><buttononClick={// Attempt to recover by trying to re-render the segment()=>reset()}>Try again</button></div>)}error.jswraps a route segment and its nested children in aReact Error Boundary. When an error throws within the boundary, theerrorcomponent shows as the fallback UI.Good to know:TheReact DevToolsallow you to toggle error boundaries to test error states.If you want errors to bubble up to the parent error boundary, you canthrowwhen rendering theerrorcomponent.ReferencePropserrorAn instance of anErrorobject forwarded to theerror.jsClient Component.Good to know:During development, theErrorobject forwarded to the client will be serialized and include themessageof the original error for easier debugging. However,this behavior is different in productionto avoid leaking potentially sensitive details included in the error to the client.error.messageErrors forwarded from Client Components show the originalErrormessage.Errors forwarded from Server Components show a generic message with an identifier. This is to prevent leaking sensitive details. You can use the identifier, undererrors.digest, to match the corresponding server-side logs.error.digestAn automatically generated hash of the error thrown. It can be used to match the corresponding error in server-side logs.resetThe cause of an error can sometimes be temporary. In these cases, trying again might resolve the issue.An error component can use thereset()function to prompt the user to attempt to recover from the error. When executed, the function will try to re-render the error boundary's contents. If successful, the fallback error component is replaced with the result of the re-render.app/dashboard/error.tsxTypeScriptJavaScriptTypeScript'use client'// Error boundaries must be Client ComponentsexportdefaultfunctionError({error,reset,}:{error:Error&{ digest?:string}reset:()=>void}) {return(<div><h2>Something went wrong!</h2><buttononClick={()=>reset()}>Try again</button></div>)}ExamplesGlobal ErrorWhile less common, you can handle errors in the root layout or template usingglobal-error.js, located in the root app directory, even when leveraginginternationalization. Global error UI must define its own<html>and<body>tags. This file replaces the root layout or template when active.app/global-error.tsxTypeScriptJavaScriptTypeScript'use client'// Error boundaries must be Client ComponentsexportdefaultfunctionGlobalError({error,reset,}:{error:Error&{ digest?:string}reset:()=>void}) {return(// global-error must include html and body tags<html><body><h2>Something went wrong!</h2><buttononClick={()=>reset()}>Try again</button></body></html>)}Good to know:global-error.jsis always displayed In development, error overlay will show instead.Version HistoryVersionChangesv15.2.0displayglobal-erroralso in development.v13.1.0global-errorintroduced.v13.0.0errorintroduced.Learn more about error handlingError HandlingLearn how to display expected errors and handle uncaught exceptions.Previousdefault.jsNextforbidden.jsWas this helpful?supported.Send"
forbidden.js,forbidden.js,"API ReferenceFile Conventionsforbidden.jsforbidden.jsThis feature is currently experimental and subject to change, it's not recommended for production. Try it out and share your feedback onGitHub.Theforbiddenfile is used to render UI when theforbiddenfunction is invoked during authentication. Along with allowing you to customize the UI, Next.js will return a403status code.app/forbidden.tsxTypeScriptJavaScriptTypeScriptimportLinkfrom'next/link'exportdefaultfunctionForbidden() {return(<div><h2>Forbidden</h2><p>You are not authorized to access this resource.</p><Linkhref=""/"">Return Home</Link></div>)}ReferencePropsforbidden.jscomponents do not accept any props.Version HistoryVersionChangesv15.1.0forbidden.jsintroduced.Next StepsforbiddenAPI Reference for the forbidden function.Previouserror.jsNextinstrumentation.jsWas this helpful?supported.Send"
instrumentation.js,instrumentation.js,"API ReferenceFile Conventionsinstrumentation.jsinstrumentation.jsTheinstrumentation.js|tsfile is used to integrate observability tools into your application, allowing you to track the performance and behavior, and to debug issues in production.To use it, place the file in therootof your application or inside asrcfolderif using one.Exportsregister(optional)The file exports aregisterfunction that is calledoncewhen a new Next.js server instance is initiated.registercan be an async function.instrumentation.tsTypeScriptJavaScriptTypeScriptimport{ registerOTel }from'@vercel/otel'exportfunctionregister() {registerOTel('next-app')}onRequestError(optional)You can optionally export anonRequestErrorfunction to trackservererrors to any custom observability provider.If you're running any async tasks inonRequestError, make sure they're awaited.onRequestErrorwill be triggered when the Next.js server captures the error.Theerrorinstance might not be the original error instance thrown, as it may be processed by React if encountered during Server Components rendering. If this happens, you can usedigestproperty on an error to identify the actual error type.instrumentation.tsTypeScriptJavaScriptTypeScriptimport{typeInstrumentation }from'next'exportconstonRequestError:Instrumentation.onRequestError=async(err,request,context)=>{awaitfetch('https://.../report-error',{method:'POST',body:JSON.stringify({message:err.message,request,context,}),headers:{'Content-Type':'application/json',},})}ParametersThe function accepts three parameters:error,request, andcontext.TypesexportfunctiononRequestError(error:{ digest:string}&Error,request:{path:string// resource path, e.g. /blog?name=foomethod:string// request method. e.g. GET, POST, etcheaders:{ [key:string]:string}},context:{routerKind:'Pages Router'|'App Router'// the router typeroutePath:string// the route file path, e.g. /app/blog/[dynamic]routeType:'render'|'route'|'action'|'middleware'// the context in which the error occurredrenderSource:|'react-server-components'|'react-server-components-payload'|'server-rendering'revalidateReason:'on-demand'|'stale'|undefined// undefined is a normal request without revalidationrenderType:'dynamic'|'dynamic-resume'// 'dynamic-resume' for PPR}):void|Promise<void>error: The caught error itself (type is alwaysError), and adigestproperty which is the unique ID of the error.request: Read-only request information associated with the error.context: The context in which the error occurred. This can be the type of router (App or Pages Router), and/or (Server Components ('render'), Route Handlers ('route'), Server Actions ('action'), or Middleware ('middleware')).Specifying the runtimeTheinstrumentation.jsfile works in both the Node.js and Edge runtime, however, you can useprocess.env.NEXT_RUNTIMEto target a specific runtime.instrumentation.jsexportfunctionregister() {if(process.env.NEXT_RUNTIME==='edge') {returnrequire('./register.edge')}else{returnrequire('./register.node')}}exportfunctiononRequestError() {if(process.env.NEXT_RUNTIME==='edge') {returnrequire('./on-request-error.edge')}else{returnrequire('./on-request-error.node')}}Version HistoryVersionChangesv15.0.0-RConRequestErrorintroduced,instrumentationstablev14.0.4Turbopack support forinstrumentationv13.2.0instrumentationintroduced as an experimental featureLearn more about InstrumentationInstrumentationLearn how to use instrumentation to run code at server startup in your Next.js appPreviousforbidden.jsNextlayout.jsWas this helpful?supported.Send"
layout.js,layout.js,"API ReferenceFile Conventionslayout.jslayout.jsThelayoutfile is used to define a layout in your Next.js application.app/dashboard/layout.tsxTypeScriptJavaScriptTypeScriptexportdefaultfunctionDashboardLayout({children,}:{children:React.ReactNode}) {return<section>{children}</section>}Aroot layoutis the top-most layout in the rootappdirectory. It is used to define the<html>and<body>tags and other globally shared UI.app/layout.tsxTypeScriptJavaScriptTypeScriptexportdefaultfunctionRootLayout({children,}:{children:React.ReactNode}) {return(<htmllang=""en""><body>{children}</body></html>)}ReferencePropschildren(required)Layout components should accept and use achildrenprop. During rendering,childrenwill be populated with the route segments the layout is wrapping. These will primarily be the component of a childLayout(if it exists) orPage, but could also be other special files likeLoadingorErrorwhen applicable.params(optional)A promise that resolves to an object containing thedynamic route parametersobject from the root segment down to that layout.app/dashboard/[team]/layout.tsxTypeScriptJavaScriptTypeScriptexportdefaultasyncfunctionLayout({params,}:{params:Promise<{ team:string}>}) {constteam=(awaitparams).team}Example RouteURLparamsapp/dashboard/[team]/layout.js/dashboard/1Promise<{ team: '1' }>app/shop/[tag]/[item]/layout.js/shop/1/2Promise<{ tag: '1', item: '2' }>app/blog/[...slug]/layout.js/blog/1/2Promise<{ slug: ['1', '2'] }>Since theparamsprop is a promise. You must useasync/awaitor React'susefunction to access the values.In version 14 and earlier,paramswas a synchronous prop. To help with backwards compatibility, you can still access it synchronously in Next.js 15, but this behavior will be deprecated in the future.Root LayoutsTheappdirectorymustinclude a rootapp/layout.js.app/layout.tsxTypeScriptJavaScriptTypeScriptexportdefaultfunctionRootLayout({children,}:{children:React.ReactNode}) {return(<html><body>{children}</body></html>)}The root layoutmustdefine<html>and<body>tags.You shouldnotmanually add<head>tags such as<title>and<meta>to root layouts. Instead, you should use theMetadata APIwhich automatically handles advanced requirements such as streaming and de-duplicating<head>elements.You can useroute groupsto create multiple root layouts.Navigatingacross multiple root layoutswill cause afull page load(as opposed to a client-side navigation). For example, navigating from/cartthat usesapp/(shop)/layout.jsto/blogthat usesapp/(marketing)/layout.jswill cause a full page load. Thisonlyapplies to multiple root layouts.CaveatsLayouts do not receivesearchParamsUnlikePages, Layout componentsdo notreceive thesearchParamsprop. This is because a shared layout isnot re-rendered during navigationwhich could lead to stalesearchParamsbetween navigations.When using client-side navigation, Next.js automatically only renders the part of the page below the common layout between two routes.For example, in the following directory structure,dashboard/layout.tsxis the common layout for both/dashboard/settingsand/dashboard/analytics:When navigating from/dashboard/settingsto/dashboard/analytics,page.tsxin/dashboard/analyticswill rerender on the server, whiledashboard/layout.tsxwillnotrerender because it's a common UI shared between the two routes.This performance optimization allows navigation between pages that share a layout to be quicker as only the data fetching and rendering for the page has to run, instead of the entire route that could include shared layouts that fetch their own data.Becausedashboard/layout.tsxdoesn't re-render, thesearchParamsprop in the layout Server Component might becomestaleafter navigation.Instead, use the PagesearchParamsprop or theuseSearchParamshook in a Client Component within the layout, which is rerendered on the client with the latestsearchParams.Layouts cannot accesspathnameLayouts cannot accesspathname. This is because layouts are Server Components by default, anddon't rerender during client-side navigation, which could lead topathnamebecoming stale between navigations. To prevent staleness, Next.js would need to refetch all segments of a route, losing the benefits of caching and increasing theRSC payloadsize on navigation.Instead, you can extract the logic that depends on pathname into a Client Component and import it into your layouts. Since Client Components rerender (but are not refetched) during navigation, you can use Next.js hooks such asusePathnameto access the current pathname and prevent staleness.app/dashboard/layout.tsxTypeScriptJavaScriptTypeScriptimport{ ClientComponent }from'@/app/ui/ClientComponent'exportdefaultfunctionLayout({ children }:{ children:React.ReactNode}) {return(<><ClientComponent/>{/* Other Layout UI */}<main>{children}</main></>)}Commonpathnamepatterns can also be implemented withparamsprop.See theexamplessection for more information.ExamplesDisplaying content based onparamsUsingdynamic route segments, you can display or fetch specific content based on theparamsprop.app/dashboard/layout.tsxTypeScriptJavaScriptTypeScriptexportdefaultasyncfunctionDashboardLayout({children,params,}:{children:React.ReactNodeparams:Promise<{ team:string}>}) {const{team}=awaitparamsreturn(<section><header><h1>Welcome to {team}'s Dashboard</h1></header><main>{children}</main></section>)}Readingparamsin Client ComponentsTo useparamsin a Client Component (which cannot beasync), you can use React'susefunction to read the promise:app/page.tsxTypeScriptJavaScriptTypeScript'use client'import{ use }from'react'exportdefaultfunctionPage({params,}:{params:Promise<{ slug:string}>}) {const{slug}=use(params)}Version HistoryVersionChangesv15.0.0-RCparamsis now a promise. Acodemodis available.v13.0.0layoutintroduced.Previousinstrumentation.jsNextloading.jsWas this helpful?supported.Send"
loading.js,loading.js,"API ReferenceFile Conventionsloading.jsloading.jsAloadingfile can create instant loading states built onSuspense.By default, this file is aServer Component- but can also be used as a Client Component through the""use client""directive.app/feed/loading.tsxTypeScriptJavaScriptTypeScriptexportdefaultfunctionLoading() {// Or a custom loading skeleton componentreturn<p>Loading...</p>}Loading UI components do not accept any parameters.Good to know:While designing loading UI, you may find it helpful to use theReact Developer Toolsto manually toggle Suspense boundaries.Version HistoryVersionChangesv13.0.0loadingintroduced.Previouslayout.jsNextmdx-components.jsWas this helpful?supported.Send"
mdx-components.js,mdx-components.js,"API ReferenceFile Conventionsmdx-components.jsmdx-components.jsThemdx-components.js|tsxfile isrequiredto use@next/mdxwith App Routerand will not work without it. Additionally, you can use it tocustomize styles.Use the filemdx-components.tsx(or.js) in the root of your project to define MDX Components. For example, at the same level aspagesorapp, or insidesrcif applicable.mdx-components.tsxTypeScriptJavaScriptTypeScriptimporttype{ MDXComponents }from'mdx/types'exportfunctionuseMDXComponents(components:MDXComponents):MDXComponents{return{...components,}}ExportsuseMDXComponentsfunctionThe file must export a single function, either as a default export or nameduseMDXComponents.mdx-components.tsxTypeScriptJavaScriptTypeScriptimporttype{ MDXComponents }from'mdx/types'exportfunctionuseMDXComponents(components:MDXComponents):MDXComponents{return{...components,}}ParamscomponentsWhen defining MDX Components, the export function accepts a single parameter,components. This parameter is an instance ofMDXComponents.The key is the name of the HTML element to override.The value is the component to render instead.Good to know: Remember to pass all other components (i.e....components) that do not have overrides.Version HistoryVersionChangesv13.1.2MDX Components addedLearn more about MDX ComponentsMDXLearn how to configure MDX and use it in your Next.js apps.Previousloading.jsNextmiddleware.jsWas this helpful?supported.Send"
middleware.js,middleware.js,"API ReferenceFile Conventionsmiddleware.jsmiddleware.jsThemiddleware.js|tsfile is used to writeMiddlewareand run code on the server before a request is completed. Then, based on the incoming request, you can modify the response by rewriting, redirecting, modifying the request or response headers, or responding directly.Middleware executes before routes are rendered. It's particularly useful for implementing custom server-side logic like authentication, logging, or handling redirects.Use the filemiddleware.ts(or .js) in the root of your project to define Middleware. For example, at the same level asapporpages, or insidesrcif applicable.middleware.tsTypeScriptJavaScriptTypeScriptimport{ NextResponse,NextRequest }from'next/server'// This function can be marked `async` if using `await` insideexportfunctionmiddleware(request:NextRequest) {returnNextResponse.redirect(newURL('/home',request.url))}exportconstconfig={matcher:'/about/:path*',}ExportsMiddleware functionThe file must export a single function, either as a default export or namedmiddleware. Note that multiple middleware from the same file are not supported.middleware.js// Example of default exportexportdefaultfunctionmiddleware(request) {// Middleware logic}Config object (optional)Optionally, a config object can be exported alongside the Middleware function. This object includes thematcherto specify paths where the Middleware applies.MatcherThematcheroption allows you to target specific paths for the Middleware to run on. You can specify these paths in several ways:For a single path: Directly use a string to define the path, like'/about'.For multiple paths: Use an array to list multiple paths, such asmatcher: ['/about', '/contact'], which applies the Middleware to both/aboutand/contact.Additionally,matchersupports complex path specifications through regular expressions, such asmatcher: ['/((?!api|_next/static|_next/image|.*\\.png$).*)'], enabling precise control over which paths to include or exclude.Thematcheroption also accepts an array of objects with the following keys:source: The path or pattern used to match the request paths. It can be a string for direct path matching or a pattern for more complex matching.regexp(optional): A regular expression string that fine-tunes the matching based on the source. It provides additional control over which paths are included or excluded.locale(optional): A boolean that, when set tofalse, ignores locale-based routing in path matching.has(optional): Specifies conditions based on the presence of specific request elements such as headers, query parameters, or cookies.missing(optional): Focuses on conditions where certain request elements are absent, like missing headers or cookies.middleware.jsexportconstconfig={matcher:[{source:'/api/*',regexp:'^/api/(.*)',locale:false,has:[{ type:'header',key:'Authorization',value:'Bearer Token'},{ type:'query',key:'userId',value:'123'},],missing:[{ type:'cookie',key:'session',value:'active'}],},],}ParamsrequestWhen defining Middleware, the default export function accepts a single parameter,request. This parameter is an instance ofNextRequest, which represents the incoming HTTP request.middleware.tsTypeScriptJavaScriptTypeScriptimporttype{ NextRequest }from'next/server'exportfunctionmiddleware(request:NextRequest) {// Middleware logic goes here}Good to know:NextRequestis a type that represents incoming HTTP requests in Next.js Middleware, whereasNextResponseis a class used to manipulate and send back HTTP responses.NextResponseMiddleware can use theNextResponseobject which extends theWeb Response API. By returning aNextResponseobject, you can directly manipulate cookies, set headers, implement redirects, and rewrite paths.Good to know: For redirects, you can also useResponse.redirectinstead ofNextResponse.redirect.RuntimeMiddleware only supports theEdge runtime. The Node.js runtime cannot be used.Version HistoryVersionChangesv13.1.0Advanced Middleware flags addedv13.0.0Middleware can modify request headers, response headers, and send responsesv12.2.0Middleware is stable, please see theupgrade guidev12.0.9Enforce absolute URLs in Edge Runtime (PR)v12.0.0Middleware (Beta) addedLearn more about MiddlewareMiddlewareLearn how to use Middleware to run code before a request is completed.Previousmdx-components.jsNextnot-found.jsWas this helpful?supported.Send"
not-found.js,not-found.js,"API ReferenceFile Conventionsnot-found.jsnot-found.jsThenot-foundfile is used to render UI when thenotFoundfunction is thrown within a route segment. Along with serving a custom UI, Next.js will return a200HTTP status code for streamed responses, and404for non-streamed responses.app/not-found.tsxTypeScriptJavaScriptTypeScriptimportLinkfrom'next/link'exportdefaultfunctionNotFound() {return(<div><h2>Not Found</h2><p>Could not find requested resource</p><Linkhref=""/"">Return Home</Link></div>)}ReferencePropsnot-found.jscomponents do not accept any props.Good to know: In addition to catching expectednotFound()errors, the rootapp/not-found.jsfile also handles any unmatched URLs for your whole application. This means users that visit a URL that is not handled by your app will be shown the UI exported by theapp/not-found.jsfile.ExamplesData FetchingBy default,not-foundis a Server Component. You can mark it asasyncto fetch and display data:app/not-found.tsxTypeScriptJavaScriptTypeScriptimportLinkfrom'next/link'import{ headers }from'next/headers'exportdefaultasyncfunctionNotFound() {constheadersList=awaitheaders()constdomain=headersList.get('host')constdata=awaitgetSiteData(domain)return(<div><h2>Not Found: {data.name}</h2><p>Could not find requested resource</p><p>View <Linkhref=""/blog"">all posts</Link></p></div>)}If you need to use Client Component hooks likeusePathnameto display content based on the path, you must fetch data on the client-side instead.Version HistoryVersionChangesv13.3.0Rootapp/not-foundhandles global unmatched URLs.v13.0.0not-foundintroduced.Previousmiddleware.jsNextpage.jsWas this helpful?supported.Send"
page.js,page.js,"API ReferenceFile Conventionspage.jspage.jsThepagefile allows you to define UI that isuniqueto a route. You can create a page by default exporting a component from the file:app/blog/[slug]/page.tsxTypeScriptJavaScriptTypeScriptexportdefaultfunctionPage({params,searchParams,}:{params:Promise<{ slug:string}>searchParams:Promise<{ [key:string]:string|string[]|undefined}>}) {return<h1>My Page</h1>}Good to knowThe.js,.jsx, or.tsxfile extensions can be used forpage.Apageis always theleafof the route subtree.Apagefile is required to make a route segmentpublicly accessible.Pages areServer Componentsby default, but can be set to aClient Component.ReferencePropsparams(optional)A promise that resolves to an object containing thedynamic route parametersfrom the root segment down to that page.app/shop/[slug]/page.tsxTypeScriptJavaScriptTypeScriptexportdefaultasyncfunctionPage({params,}:{params:Promise<{ slug:string}>}) {constslug=(awaitparams).slug}Example RouteURLparamsapp/shop/[slug]/page.js/shop/1Promise<{ slug: '1' }>app/shop/[category]/[item]/page.js/shop/1/2Promise<{ category: '1', item: '2' }>app/shop/[...slug]/page.js/shop/1/2Promise<{ slug: ['1', '2'] }>Since theparamsprop is a promise. You must useasync/awaitor React'susefunction to access the values.In version 14 and earlier,paramswas a synchronous prop. To help with backwards compatibility, you can still access it synchronously in Next.js 15, but this behavior will be deprecated in the future.searchParams(optional)A promise that resolves to an object containing thesearch parametersof the current URL. For example:app/shop/page.tsxTypeScriptJavaScriptTypeScriptexportdefaultasyncfunctionPage({searchParams,}:{searchParams:Promise<{ [key:string]:string|string[]|undefined}>}) {constfilters=(awaitsearchParams).filters}Example URLsearchParams/shop?a=1Promise<{ a: '1' }>/shop?a=1&b=2Promise<{ a: '1', b: '2' }>/shop?a=1&a=2Promise<{ a: ['1', '2'] }>Since thesearchParamsprop is a promise. You must useasync/awaitor React'susefunction to access the values.In version 14 and earlier,searchParamswas a synchronous prop. To help with backwards compatibility, you can still access it synchronously in Next.js 15, but this behavior will be deprecated in the future.searchParamsis aDynamic APIwhose values cannot be known ahead of time. Using it will opt the page intodynamic renderingat request time.searchParamsis a plain JavaScript object, not aURLSearchParamsinstance.ExamplesDisplaying content based onparamsUsingdynamic route segments, you can display or fetch specific content for the page based on theparamsprop.app/blog/[slug]/page.tsxTypeScriptJavaScriptTypeScriptexportdefaultasyncfunctionPage({params,}:{params:Promise<{ slug:string}>}) {const{slug}=awaitparamsreturn<h1>Blog Post: {slug}</h1>}Handling filtering withsearchParamsYou can use thesearchParamsprop to handle filtering, pagination, or sorting based on the query string of the URL.app/shop/page.tsxTypeScriptJavaScriptTypeScriptexportdefaultasyncfunctionPage({searchParams,}:{searchParams:Promise<{ [key:string]:string|string[]|undefined}>}) {const{page='1',sort='asc',query=''}=awaitsearchParamsreturn(<div><h1>Product Listing</h1><p>Search query: {query}</p><p>Current page: {page}</p><p>Sort order: {sort}</p></div>)}ReadingsearchParamsandparamsin Client ComponentsTo usesearchParamsandparamsin a Client Component (which cannot beasync), you can use React'susefunction to read the promise:app/page.tsxTypeScriptJavaScriptTypeScript'use client'import{ use }from'react'exportdefaultfunctionPage({params,searchParams,}:{params:Promise<{ slug:string}>searchParams:Promise<{ [key:string]:string|string[]|undefined}>}) {const{slug}=use(params)const{query}=use(searchParams)}Version HistoryVersionChangesv15.0.0-RCparamsandsearchParamsare now promises. Acodemodis available.v13.0.0pageintroduced.Previousnot-found.jsNextroute.jsWas this helpful?supported.Send"
route.js,route.js,"API ReferenceFile Conventionsroute.jsroute.jsRoute Handlers allow you to create custom request handlers for a given route using the WebRequestandResponseAPIs.route.tsTypeScriptJavaScriptTypeScriptexportasyncfunctionGET() {returnResponse.json({ message:'Hello World'})}ReferenceHTTP MethodsAroutefile allows you to create custom request handlers for a given route. The followingHTTP methodsare supported:GET,POST,PUT,PATCH,DELETE,HEAD, andOPTIONS.route.tsTypeScriptJavaScriptTypeScriptexportasyncfunctionGET(request:Request) {}exportasyncfunctionHEAD(request:Request) {}exportasyncfunctionPOST(request:Request) {}exportasyncfunctionPUT(request:Request) {}exportasyncfunctionDELETE(request:Request) {}exportasyncfunctionPATCH(request:Request) {}// If `OPTIONS` is not defined, Next.js will automatically implement `OPTIONS` and set the appropriate Response `Allow` header depending on the other methods defined in the Route Handler.exportasyncfunctionOPTIONS(request:Request) {}Parametersrequest(optional)Therequestobject is aNextRequestobject, which is an extension of the WebRequestAPI.NextRequestgives you further control over the incoming request, including easily accessingcookiesand an extended, parsed, URL objectnextUrl.route.tsTypeScriptJavaScriptTypeScriptimporttype{ NextRequest }from'next/server'exportasyncfunctionGET(request:NextRequest) {consturl=request.nextUrl}context(optional)params: a promise that resolves to an object containing thedynamic route parametersfor the current route.app/dashboard/[team]/route.tsTypeScriptJavaScriptTypeScriptexportasyncfunctionGET(request:Request,{ params }:{ params:Promise<{ team:string}> }) {constteam=(awaitparams).team}ExampleURLparamsapp/dashboard/[team]/route.js/dashboard/1Promise<{ team: '1' }>app/shop/[tag]/[item]/route.js/shop/1/2Promise<{ tag: '1', item: '2' }>app/blog/[...slug]/route.js/blog/1/2Promise<{ slug: ['1', '2'] }>ExamplesHandling cookiesroute.tsTypeScriptJavaScriptTypeScriptimport{ cookies }from'next/headers'exportasyncfunctionGET(request:NextRequest) {constcookieStore=awaitcookies()consta=cookieStore.get('a')constb=cookieStore.set('b','1')constc=cookieStore.delete('c')}Version HistoryVersionChangesv15.0.0-RCcontext.paramsis now a promise. Acodemodis availablev15.0.0-RCThe default caching forGEThandlers was changed from static to dynamicv13.2.0Route Handlers are introduced.Previouspage.jsNextRoute Segment ConfigWas this helpful?supported.Send"
route segment config,Route Segment Config,"API ReferenceFile ConventionsRoute Segment ConfigRoute Segment ConfigThe options outlined on this page are disabled if thedynamicIOflag is on, and will eventually be deprecated in the future.The Route Segment options allows you to configure the behavior of aPage,Layout, orRoute Handlerby directly exporting the following variables:OptionTypeDefaultexperimental_pprbooleandynamic'auto' | 'force-dynamic' | 'error' | 'force-static''auto'dynamicParamsbooleantruerevalidatefalse | 0 | numberfalsefetchCache'auto' | 'default-cache' | 'only-cache' | 'force-cache' | 'force-no-store' | 'default-no-store' | 'only-no-store''auto'runtime'nodejs' | 'edge''nodejs'preferredRegion'auto' | 'global' | 'home' | string | string[]'auto'maxDurationnumberSet by deployment platformOptionsexperimental_pprEnablePartial Prerendering (PPR)for a layout or page.layout.tsx | page.tsxTypeScriptJavaScriptTypeScriptexportconstexperimental_ppr=true// true | falsedynamicChange the dynamic behavior of a layout or page to fully static or fully dynamic.layout.tsx | page.tsx | route.tsTypeScriptJavaScriptTypeScriptexportconstdynamic='auto'// 'auto' | 'force-dynamic' | 'error' | 'force-static'Good to know: The new model in theappdirectory favors granular caching control at thefetchrequest level over the binary all-or-nothing model ofgetServerSidePropsandgetStaticPropsat the page-level in thepagesdirectory. Thedynamicoption is a way to opt back in to the previous model as a convenience and provides a simpler migration path.'auto'(default): The default option to cache as much as possible without preventing any components from opting into dynamic behavior.'force-dynamic': Forcedynamic rendering, which will result in routes being rendered for each user at request time. This option is equivalent to:Setting the option of everyfetch()request in a layout or page to{ cache: 'no-store', next: { revalidate: 0 } }.Setting the segment config toexport const fetchCache = 'force-no-store''error': Force static rendering and cache the data of a layout or page by causing an error if any components useDynamic APIsor uncached data. This option is equivalent to:getStaticProps()in thepagesdirectory.Setting the option of everyfetch()request in a layout or page to{ cache: 'force-cache' }.Setting the segment config tofetchCache = 'only-cache', dynamicParams = false.dynamic = 'error'changes the default ofdynamicParamsfromtruetofalse. You can opt back into dynamically rendering pages for dynamic params not generated bygenerateStaticParamsby manually settingdynamicParams = true.'force-static': Force static rendering and cache the data of a layout or page by forcingcookies,headers()anduseSearchParams()to return empty values.Good to know:Instructions onhow to migratefromgetServerSidePropsandgetStaticPropstodynamic: 'force-dynamic'anddynamic: 'error'can be found in theupgrade guide.dynamicParamsControl what happens when a dynamic segment is visited that was not generated withgenerateStaticParams.layout.tsx | page.tsxTypeScriptJavaScriptTypeScriptexportconstdynamicParams=true// true | false,true(default): Dynamic segments not included ingenerateStaticParamsare generated on demand.false: Dynamic segments not included ingenerateStaticParamswill return a 404.Good to know:This option replaces thefallback: true | false | blockingoption ofgetStaticPathsin thepagesdirectory.To statically render all paths the first time they're visited, you'll need to return an empty array ingenerateStaticParamsor utilizeexport const dynamic = 'force-static'.WhendynamicParams = true, the segment usesStreaming Server Rendering.If thedynamic = 'error'anddynamic = 'force-static'are used, it'll change the default ofdynamicParamstofalse.revalidateSet the default revalidation time for a layout or page. This option does not override therevalidatevalue set by individualfetchrequests.layout.tsx | page.tsx | route.tsTypeScriptJavaScriptTypeScriptexportconstrevalidate=false// false | 0 | numberfalse(default): The default heuristic to cache anyfetchrequests that set theircacheoption to'force-cache'or are discovered before aDynamic APIis used. Semantically equivalent torevalidate: Infinitywhich effectively means the resource should be cached indefinitely. It is still possible for individualfetchrequests to usecache: 'no-store'orrevalidate: 0to avoid being cached and make the route dynamically rendered. Or setrevalidateto a positive number lower than the route default to increase the revalidation frequency of a route.0: Ensure a layout or page is alwaysdynamically renderedeven if no Dynamic APIs or uncached data fetches are discovered. This option changes the default offetchrequests that do not set acacheoption to'no-store'but leavesfetchrequests that opt into'force-cache'or use a positiverevalidateas is.number: (in seconds) Set the default revalidation frequency of a layout or page tonseconds.Good to know:The revalidate value needs to be statically analyzable. For examplerevalidate = 600is valid, butrevalidate = 60 * 10is not.The revalidate value is not available when usingruntime = 'edge'.In Development, Pages arealwaysrendered on-demand and are never cached. This allows you to see changes immediately without waiting for a revalidation period to pass.Revalidation FrequencyThe lowestrevalidateacross each layout and page of a single route will determine the revalidation frequency of theentireroute. This ensures that child pages are revalidated as frequently as their parent layouts.Individualfetchrequests can set a lowerrevalidatethan the route's defaultrevalidateto increase the revalidation frequency of the entire route. This allows you to dynamically opt-in to more frequent revalidation for certain routes based on some criteria.fetchCacheThis is an advanced option that should only be used if you specifically need to override the default behavior.By default, Next.jswill cacheanyfetch()requests that are reachablebeforeanyDynamic APIsare used andwill not cachefetchrequests that are discoveredafterDynamic APIs are used.fetchCacheallows you to override the defaultcacheoption of allfetchrequests in a layout or page.layout.tsx | page.tsx | route.tsTypeScriptJavaScriptTypeScriptexportconstfetchCache='auto'// 'auto' | 'default-cache' | 'only-cache'// 'force-cache' | 'force-no-store' | 'default-no-store' | 'only-no-store''auto'(default): The default option to cachefetchrequests before Dynamic APIs with thecacheoption they provide and not cachefetchrequests after Dynamic APIs.'default-cache': Allow anycacheoption to be passed tofetchbut if no option is provided then set thecacheoption to'force-cache'. This means that evenfetchrequests after Dynamic APIs are considered static.'only-cache': Ensure allfetchrequests opt into caching by changing the default tocache: 'force-cache'if no option is provided and causing an error if anyfetchrequests usecache: 'no-store'.'force-cache': Ensure allfetchrequests opt into caching by setting thecacheoption of allfetchrequests to'force-cache'.'default-no-store': Allow anycacheoption to be passed tofetchbut if no option is provided then set thecacheoption to'no-store'. This means that evenfetchrequests before Dynamic APIs are considered dynamic.'only-no-store': Ensure allfetchrequests opt out of caching by changing the default tocache: 'no-store'if no option is provided and causing an error if anyfetchrequests usecache: 'force-cache''force-no-store': Ensure allfetchrequests opt out of caching by setting thecacheoption of allfetchrequests to'no-store'. This forces allfetchrequests to be re-fetched every request even if they provide a'force-cache'option.Cross-route segment behaviorAny options set across each layout and page of a single route need to be compatible with each other.If both the'only-cache'and'force-cache'are provided, then'force-cache'wins. If both'only-no-store'and'force-no-store'are provided, then'force-no-store'wins. The force option changes the behavior across the route so a single segment with'force-*'would prevent any errors caused by'only-*'.The intention of the'only-*'and'force-*'options is to guarantee the whole route is either fully static or fully dynamic. This means:A combination of'only-cache'and'only-no-store'in a single route is not allowed.A combination of'force-cache'and'force-no-store'in a single route is not allowed.A parent cannot provide'default-no-store'if a child provides'auto'or'*-cache'since that could make the same fetch have different behavior.It is generally recommended to leave shared parent layouts as'auto'and customize the options where child segments diverge.runtimeWe recommend using the Node.js runtime for rendering your application, and the Edge runtime for Middleware (only supported option).layout.tsx | page.tsx | route.tsTypeScriptJavaScriptTypeScriptexportconstruntime='nodejs'// 'nodejs' | 'edge''nodejs'(default)'edge'Learn more about thedifferent runtimes.preferredRegionlayout.tsx | page.tsx | route.tsTypeScriptJavaScriptTypeScriptexportconstpreferredRegion='auto'// 'auto' | 'global' | 'home' | ['iad1', 'sfo1']Support forpreferredRegion, and regions supported, is dependent on your deployment platform.Good to know:If apreferredRegionis not specified, it will inherit the option of the nearest parent layout.The root layout defaults toallregions.maxDurationBy default, Next.js does not limit the execution of server-side logic (rendering a page or handling an API).
Deployment platforms can usemaxDurationfrom the Next.js build output to add specific execution limits.
For example, onVercel.Note: This setting requires Next.js13.4.10or higher.layout.tsx | page.tsx | route.tsTypeScriptJavaScriptTypeScriptexportconstmaxDuration=5Good to know:If usingServer Actions, set themaxDurationat the page level to change the default timeout of all Server Actions used on the page.generateStaticParamsThegenerateStaticParamsfunction can be used in combination withdynamic route segmentsto define the list of route segment parameters that will be statically generated at build time instead of on-demand at request time.See theAPI referencefor more details.Version HistoryVersionv15.0.0-RCexport const runtime = ""experimental-edge""deprecated. Acodemodis available.Previousroute.jsNexttemplate.jsWas this helpful?supported.Send"
template.js,template.js,"API ReferenceFile Conventionstemplate.jstemplate.jsAtemplatefile is similar to alayoutin that it wraps a layout or page. Unlike layouts that persist across routes and maintain state, templates are given a unique key, meaning children Client Components reset their state on navigation.app/template.tsxTypeScriptJavaScriptTypeScriptexportdefaultfunctionTemplate({ children }:{ children:React.ReactNode}) {return<div>{children}</div>}While less common, you might choose to use a template over a layout if you want:Features that rely onuseEffect(e.g logging page views) anduseState(e.g a per-page feedback form).To change the default framework behavior. For example, Suspense Boundaries inside layouts only show the fallback the first time the Layout is loaded and not when switching pages. For templates, the fallback is shown on each navigation.Propschildren(required)Template accepts achildrenprop. For example:Output<Layout>{/* Note that the template is automatically given a unique key. */}<Templatekey={routeParam}>{children}</Template></Layout>Good to know:By default,templateis aServer Component, but can also be used as aClient Componentthrough the""use client""directive.When a user navigates between routes that share atemplate, a new instance of the component is mounted, DOM elements are recreated, state isnotpreserved in Client Components, and effects are re-synchronized.Version HistoryVersionChangesv13.0.0templateintroduced.PreviousRoute Segment ConfigNextunauthorized.jsWas this helpful?supported.Send"
unauthorized.js,unauthorized.js,"API ReferenceFile Conventionsunauthorized.jsunauthorized.jsThis feature is currently experimental and subject to change, it's not recommended for production. Try it out and share your feedback onGitHub.Theunauthorizedfile is used to render UI when theunauthorizedfunction is invoked during authentication. Along with allowing you to customize the UI, Next.js will return a401status code.app/unauthorized.tsxTypeScriptJavaScriptTypeScriptimportLoginfrom'@/app/components/Login'exportdefaultfunctionUnauthorized() {return(<main><h1>401 - Unauthorized</h1><p>Please log in to access this page.</p><Login/></main>)}ReferencePropsunauthorized.jscomponents do not accept any props.ExamplesDisplaying login UI to unauthenticated usersYou can useunauthorizedfunction to render theunauthorized.jsfile with a login UI.app/dashboard/page.tsxTypeScriptJavaScriptTypeScriptimport{ verifySession }from'@/app/lib/dal'import{ unauthorized }from'next/navigation'exportdefaultasyncfunctionDashboardPage() {constsession=awaitverifySession()if(!session) {unauthorized()}return<div>Dashboard</div>}app/unauthorized.tsxTypeScriptJavaScriptTypeScriptimportLoginfrom'@/app/components/Login'exportdefaultfunctionUnauthorizedPage() {return(<main><h1>401 - Unauthorized</h1><p>Please log in to access this page.</p><Login/></main>)}Version HistoryVersionChangesv15.1.0unauthorized.jsintroduced.Next StepsunauthorizedAPI Reference for the unauthorized function.Previoustemplate.jsNextMetadata FilesWas this helpful?supported.Send"
metadata files,Metadata Files,"API ReferenceFile ConventionsMetadata FilesMetadata Files API ReferenceThis section of the docs coversMetadata file conventions. File-based metadata can be defined by adding special metadata files to route segments.Each file convention can be defined using a static file (e.g.opengraph-image.jpg), or a dynamic variant that uses code to generate the file (e.g.opengraph-image.js).Once a file is defined, Next.js will automatically serve the file (with hashes in production for caching) and update the relevant head elements with the correct metadata, such as the asset's URL, file type, and image size.Good to know:Special Route Handlers likesitemap.ts,opengraph-image.tsx, andicon.tsx, and othermetadata filesare cached by default.If using along withmiddleware.ts,configure the matcherto exclude the metadata files.favicon, icon, and apple-iconAPI Reference for the Favicon, Icon and Apple Icon file conventions.manifest.jsonAPI Reference for manifest.json file.opengraph-image and twitter-imageAPI Reference for the Open Graph Image and Twitter Image file conventions.robots.txtAPI Reference for robots.txt file.sitemap.xmlAPI Reference for the sitemap.xml file.Previousunauthorized.jsNextfavicon, icon, and apple-iconWas this helpful?supported.Send"
"favicon, icon, and apple-icon","favicon, icon, and apple-icon","File ConventionsMetadata Filesfavicon, icon, and apple-iconfavicon, icon, and apple-iconThefavicon,icon, orapple-iconfile conventions allow you to set icons for your application.They are useful for adding app icons that appear in places like web browser tabs, phone home screens, and search engine results.There are two ways to set app icons:Using image files (.ico, .jpg, .png)Using code to generate an icon (.js, .ts, .tsx)Image files (.ico, .jpg, .png)Use an image file to set an app icon by placing afavicon,icon, orapple-iconimage file within your/appdirectory.
Thefaviconimage can only be located in the top level ofapp/.Next.js will evaluate the file and automatically add the appropriate tags to your app's<head>element.File conventionSupported file typesValid locationsfavicon.icoapp/icon.ico,.jpg,.jpeg,.png,.svgapp/**/*apple-icon.jpg,.jpeg,.pngapp/**/*faviconAdd afavicon.icoimage file to the root/approute segment.<head> output<linkrel=""icon""href=""/favicon.ico""sizes=""any""/>iconAdd anicon.(ico|jpg|jpeg|png|svg)image file.<head> output<linkrel=""icon""href=""/icon?<generated>""type=""image/<generated>""sizes=""<generated>""/>apple-iconAdd anapple-icon.(jpg|jpeg|png)image file.<head> output<linkrel=""apple-touch-icon""href=""/apple-icon?<generated>""type=""image/<generated>""sizes=""<generated>""/>Good to know:You can set multiple icons by adding a number suffix to the file name. For example,icon1.png,icon2.png, etc. Numbered files will sort lexically.Favicons can only be set in the root/appsegment. If you need more granularity, you can useicon.The appropriate<link>tags and attributes such asrel,href,type, andsizesare determined by the icon type and metadata of the evaluated file.For example, a 32 by 32px.pngfile will havetype=""image/png""andsizes=""32x32""attributes.sizes=""any""is added to icons when the extension is.svgor the image size of the file is not determined. More details in thisfavicon handbook.Generate icons using code (.js, .ts, .tsx)In addition to usingliteral image files, you can programmaticallygenerateicons using code.Generate an app icon by creating aniconorapple-iconroute that default exports a function.File conventionSupported file typesicon.js,.ts,.tsxapple-icon.js,.ts,.tsxThe easiest way to generate an icon is to use theImageResponseAPI fromnext/og.app/icon.tsxTypeScriptJavaScriptTypeScriptimport{ ImageResponse }from'next/og'// Image metadataexportconstsize={width:32,height:32,}exportconstcontentType='image/png'// Image generationexportdefaultfunctionIcon() {returnnewImageResponse((// ImageResponse JSX element<divstyle={{fontSize:24,background:'black',width:'100%',height:'100%',display:'flex',alignItems:'center',justifyContent:'center',color:'white',}}>A</div>),// ImageResponse options{// For convenience, we can re-use the exported icons size metadata// config to also set the ImageResponse's width and height....size,})}<head> output<linkrel=""icon""href=""/icon?<generated>""type=""image/png""sizes=""32x32""/>Good to know:By default, generated icons arestatically optimized(generated at build time and cached) unless they useDynamic APIsor uncached data.You can generate multiple icons in the same file usinggenerateImageMetadata.You cannot generate afaviconicon. Useiconor afavicon.icofile instead.App icons are special Route Handlers that is cached by default unless it uses aDynamic APIordynamic configoption.PropsThe default export function receives the following props:params(optional)An object containing thedynamic route parametersobject from the root segment down to the segmenticonorapple-iconis colocated in.app/shop/[slug]/icon.tsxTypeScriptJavaScriptTypeScriptexportdefaultfunctionIcon({ params }:{ params:{ slug:string} }) {// ...}RouteURLparamsapp/shop/icon.js/shopundefinedapp/shop/[slug]/icon.js/shop/1{ slug: '1' }app/shop/[tag]/[item]/icon.js/shop/1/2{ tag: '1', item: '2' }ReturnsThe default export function should return aBlob|ArrayBuffer|TypedArray|DataView|ReadableStream|Response.Good to know:ImageResponsesatisfies this return type.Config exportsYou can optionally configure the icon's metadata by exportingsizeandcontentTypevariables from theiconorapple-iconroute.OptionTypesize{ width: number; height: number }contentTypestring-image MIME typesizeicon.tsx | apple-icon.tsxTypeScriptJavaScriptTypeScriptexportconstsize={ width:32,height:32}exportdefaultfunctionIcon() {}<head> output<linkrel=""icon""sizes=""32x32""/>contentTypeicon.tsx | apple-icon.tsxTypeScriptJavaScriptTypeScriptexportconstcontentType='image/png'exportdefaultfunctionIcon() {}<head> output<linkrel=""icon""type=""image/png""/>Route Segment Configiconandapple-iconare specializedRoute Handlersthat can use the sameroute segment configurationoptions as Pages and Layouts.Version HistoryVersionChangesv13.3.0faviconiconandapple-iconintroducedPreviousMetadata FilesNextmanifest.jsonWas this helpful?supported.Send"
manifest.json,manifest.json,"File ConventionsMetadata Filesmanifest.jsonmanifest.jsonAdd or generate amanifest.(json|webmanifest)file that matches theWeb Manifest Specificationin therootofappdirectory to provide information about your web application for the browser.Static Manifest fileapp/manifest.json | app/manifest.webmanifest{""name"":""My Next.js Application"",""short_name"":""Next.js App"",""description"":""An application built with Next.js"",""start_url"":""/""// ...}Generate a Manifest fileAdd amanifest.jsormanifest.tsfile that returns aManifestobject.Good to know:manifest.jsis special Route Handlers that is cached by default unless it uses aDynamic APIordynamic configoption.app/manifest.tsTypeScriptJavaScriptTypeScriptimporttype{ MetadataRoute }from'next'exportdefaultfunctionmanifest():MetadataRoute.Manifest{return{name:'Next.js App',short_name:'Next.js App',description:'Next.js App',start_url:'/',display:'standalone',background_color:'#fff',theme_color:'#fff',icons:[{src:'/favicon.ico',sizes:'any',type:'image/x-icon',},],}}Manifest ObjectThe manifest object contains an extensive list of options that may be updated due to new web standards. For information on all the current options, refer to theMetadataRoute.Manifesttype in your code editor if usingTypeScriptor see theMDNdocs.Previousfavicon, icon, and apple-iconNextopengraph-image and twitter-imageWas this helpful?supported.Send"
opengraph-image and twitter-image,opengraph-image and twitter-image,"File ConventionsMetadata Filesopengraph-image and twitter-imageopengraph-image and twitter-imageTheopengraph-imageandtwitter-imagefile conventions allow you to set Open Graph and Twitter images for a route segment.They are useful for setting the images that appear on social networks and messaging apps when a user shares a link to your site.There are two ways to set Open Graph and Twitter images:Using image files (.jpg, .png, .gif)Using code to generate images (.js, .ts, .tsx)Image files (.jpg, .png, .gif)Use an image file to set a route segment's shared image by placing anopengraph-imageortwitter-imageimage file in the segment.Next.js will evaluate the file and automatically add the appropriate tags to your app's<head>element.File conventionSupported file typesopengraph-image.jpg,.jpeg,.png,.giftwitter-image.jpg,.jpeg,.png,.gifopengraph-image.alt.txttwitter-image.alt.txtGood to know:Thetwitter-imagefile size must not exceed5MB, and theopengraph-imagefile size must not exceed8MB. If the image file size exceeds these limits, the build will fail.opengraph-imageAdd anopengraph-image.(jpg|jpeg|png|gif)image file to any route segment.<head> output<metaproperty=""og:image""content=""<generated>""/><metaproperty=""og:image:type""content=""<generated>""/><metaproperty=""og:image:width""content=""<generated>""/><metaproperty=""og:image:height""content=""<generated>""/>twitter-imageAdd atwitter-image.(jpg|jpeg|png|gif)image file to any route segment.<head> output<metaname=""twitter:image""content=""<generated>""/><metaname=""twitter:image:type""content=""<generated>""/><metaname=""twitter:image:width""content=""<generated>""/><metaname=""twitter:image:height""content=""<generated>""/>opengraph-image.alt.txtAdd an accompanyingopengraph-image.alt.txtfile in the same route segment as theopengraph-image.(jpg|jpeg|png|gif)image it's alt text.opengraph-image.alt.txtAbout Acme<head> output<metaproperty=""og:image:alt""content=""About Acme""/>twitter-image.alt.txtAdd an accompanyingtwitter-image.alt.txtfile in the same route segment as thetwitter-image.(jpg|jpeg|png|gif)image it's alt text.twitter-image.alt.txtAbout Acme<head> output<metaproperty=""twitter:image:alt""content=""About Acme""/>Generate images using code (.js, .ts, .tsx)In addition to usingliteral image files, you can programmaticallygenerateimages using code.Generate a route segment's shared image by creating anopengraph-imageortwitter-imageroute that default exports a function.File conventionSupported file typesopengraph-image.js,.ts,.tsxtwitter-image.js,.ts,.tsxGood to know:By default, generated images arestatically optimized(generated at build time and cached) unless they useDynamic APIsor uncached data.You can generate multiple Images in the same file usinggenerateImageMetadata.opengraph-image.jsandtwitter-image.jsare special Route Handlers that is cached by default unless it uses aDynamic APIordynamic configoption.The easiest way to generate an image is to use theImageResponseAPI fromnext/og.app/about/opengraph-image.tsxTypeScriptJavaScriptTypeScriptimport{ ImageResponse }from'next/og'import{ readFile }from'node:fs/promises'import{ join }from'node:path'// Image metadataexportconstalt='About Acme'exportconstsize={width:1200,height:630,}exportconstcontentType='image/png'// Image generationexportdefaultasyncfunctionImage() {// Font loading, process.cwd() is Next.js project directoryconstinterSemiBold=awaitreadFile(join(process.cwd(),'assets/Inter-SemiBold.ttf'))returnnewImageResponse((// ImageResponse JSX element<divstyle={{fontSize:128,background:'white',width:'100%',height:'100%',display:'flex',alignItems:'center',justifyContent:'center',}}>About Acme</div>),// ImageResponse options{// For convenience, we can re-use the exported opengraph-image// size config to also set the ImageResponse's width and height....size,fonts:[{name:'Inter',data:interSemiBold,style:'normal',weight:400,},],})}<head> output<metaproperty=""og:image""content=""<generated>""/><metaproperty=""og:image:alt""content=""About Acme""/><metaproperty=""og:image:type""content=""image/png""/><metaproperty=""og:image:width""content=""1200""/><metaproperty=""og:image:height""content=""630""/>PropsThe default export function receives the following props:params(optional)An object containing thedynamic route parametersobject from the root segment down to the segmentopengraph-imageortwitter-imageis colocated in.app/shop/[slug]/opengraph-image.tsxTypeScriptJavaScriptTypeScriptexportdefaultfunctionImage({ params }:{ params:{ slug:string} }) {// ...}RouteURLparamsapp/shop/opengraph-image.js/shopundefinedapp/shop/[slug]/opengraph-image.js/shop/1{ slug: '1' }app/shop/[tag]/[item]/opengraph-image.js/shop/1/2{ tag: '1', item: '2' }ReturnsThe default export function should return aBlob|ArrayBuffer|TypedArray|DataView|ReadableStream|Response.Good to know:ImageResponsesatisfies this return type.Config exportsYou can optionally configure the image's metadata by exportingalt,size, andcontentTypevariables fromopengraph-imageortwitter-imageroute.OptionTypealtstringsize{ width: number; height: number }contentTypestring-image MIME typealtopengraph-image.tsx | twitter-image.tsxTypeScriptJavaScriptTypeScriptexportconstalt='My images alt text'exportdefaultfunctionImage() {}<head> output<metaproperty=""og:image:alt""content=""My images alt text""/>sizeopengraph-image.tsx | twitter-image.tsxTypeScriptJavaScriptTypeScriptexportconstsize={ width:1200,height:630}exportdefaultfunctionImage() {}<head> output<metaproperty=""og:image:width""content=""1200""/><metaproperty=""og:image:height""content=""630""/>contentTypeopengraph-image.tsx | twitter-image.tsxTypeScriptJavaScriptTypeScriptexportconstcontentType='image/png'exportdefaultfunctionImage() {}<head> output<metaproperty=""og:image:type""content=""image/png""/>Route Segment Configopengraph-imageandtwitter-imageare specializedRoute Handlersthat can use the sameroute segment configurationoptions as Pages and Layouts.ExamplesUsing external dataThis example uses theparamsobject and external data to generate the image.Good to know:
By default, this generated image will bestatically optimized. You can configure the individualfetchoptionsor route segmentsoptionsto change this behavior.app/posts/[slug]/opengraph-image.tsxTypeScriptJavaScriptTypeScriptimport{ ImageResponse }from'next/og'exportconstalt='About Acme'exportconstsize={width:1200,height:630,}exportconstcontentType='image/png'exportdefaultasyncfunctionImage({ params }:{ params:{ slug:string} }) {constpost=awaitfetch(`https://.../posts/${params.slug}`).then((res)=>res.json())returnnewImageResponse((<divstyle={{fontSize:48,background:'white',width:'100%',height:'100%',display:'flex',alignItems:'center',justifyContent:'center',}}>{post.title}</div>),{...size,})}Using Node.js runtime with local assetsThis example uses the Node.js runtime to fetch a local image on the file system and passes it as anArrayBufferto thesrcattribute of an<img>element. The local asset should be placed relative to the root of your project, rather than the location of the example source file.app/opengraph-image.tsxTypeScriptJavaScriptTypeScriptimport{ ImageResponse }from'next/og'import{ join }from'node:path'import{ readFile }from'node:fs/promises'exportdefaultasyncfunctionImage() {constlogoData=awaitreadFile(join(process.cwd(),'logo.png'))constlogoSrc=Uint8Array.from(logoData).bufferreturnnewImageResponse((<divstyle={{display:'flex',alignItems:'center',justifyContent:'center',}}><imgsrc={logoSrc}height=""100""/></div>))}Version HistoryVersionChangesv13.3.0opengraph-imageandtwitter-imageintroduced.Previousmanifest.jsonNextrobots.txtWas this helpful?supported.Send"
robots.txt,robots.txt,"File ConventionsMetadata Filesrobots.txtrobots.txtAdd or generate arobots.txtfile that matches theRobots Exclusion Standardin therootofappdirectory to tell search engine crawlers which URLs they can access on your site.Staticrobots.txtapp/robots.txtUser-Agent: *Allow: /Disallow: /private/Sitemap: https://acme.com/sitemap.xmlGenerate a Robots fileAdd arobots.jsorrobots.tsfile that returns aRobotsobject.Good to know:robots.jsis a special Route Handlers that is cached by default unless it uses aDynamic APIordynamic configoption.app/robots.tsTypeScriptJavaScriptTypeScriptimporttype{ MetadataRoute }from'next'exportdefaultfunctionrobots():MetadataRoute.Robots{return{rules:{userAgent:'*',allow:'/',disallow:'/private/',},sitemap:'https://acme.com/sitemap.xml',}}Output:User-Agent: *Allow: /Disallow: /private/Sitemap: https://acme.com/sitemap.xmlCustomizing specific user agentsYou can customise how individual search engine bots crawl your site by passing an array of user agents to therulesproperty. For example:app/robots.tsTypeScriptJavaScriptTypeScriptimporttype{ MetadataRoute }from'next'exportdefaultfunctionrobots():MetadataRoute.Robots{return{rules:[{userAgent:'Googlebot',allow:['/'],disallow:'/private/',},{userAgent:['Applebot','Bingbot'],disallow:['/'],},],sitemap:'https://acme.com/sitemap.xml',}}Output:User-Agent: GooglebotAllow: /Disallow: /private/User-Agent: ApplebotDisallow: /User-Agent: BingbotDisallow: /Sitemap: https://acme.com/sitemap.xmlRobots objecttypeRobots={rules:|{userAgent?:string|string[]allow?:string|string[]disallow?:string|string[]crawlDelay?:number}|Array<{userAgent:string|string[]allow?:string|string[]disallow?:string|string[]crawlDelay?:number}>sitemap?:string|string[]host?:string}Version HistoryVersionChangesv13.3.0robotsintroduced.Previousopengraph-image and twitter-imageNextsitemap.xmlWas this helpful?supported.Send"
sitemap.xml,sitemap.xml,"File ConventionsMetadata Filessitemap.xmlsitemap.xmlsitemap.(xml|js|ts)is a special file that matches theSitemaps XML formatto help search engine crawlers index your site more efficiently.Sitemap files (.xml)For smaller applications, you can create asitemap.xmlfile and place it in the root of yourappdirectory.app/sitemap.xml<urlsetxmlns=""http://www.sitemaps.org/schemas/sitemap/0.9""><url><loc>https://acme.com</loc><lastmod>2023-04-06T15:02:24.021Z</lastmod><changefreq>yearly</changefreq><priority>1</priority></url><url><loc>https://acme.com/about</loc><lastmod>2023-04-06T15:02:24.021Z</lastmod><changefreq>monthly</changefreq><priority>0.8</priority></url><url><loc>https://acme.com/blog</loc><lastmod>2023-04-06T15:02:24.021Z</lastmod><changefreq>weekly</changefreq><priority>0.5</priority></url></urlset>Generating a sitemap using code (.js, .ts)You can use thesitemap.(js|ts)file convention to programmaticallygeneratea sitemap by exporting a default function that returns an array of URLs. If using TypeScript, aSitemaptype is available.Good to know:sitemap.jsis a special Route Handler that is cached by default unless it uses aDynamic APIordynamic configoption.app/sitemap.tsTypeScriptJavaScriptTypeScriptimporttype{ MetadataRoute }from'next'exportdefaultfunctionsitemap():MetadataRoute.Sitemap{return[{url:'https://acme.com',lastModified:newDate(),changeFrequency:'yearly',priority:1,},{url:'https://acme.com/about',lastModified:newDate(),changeFrequency:'monthly',priority:0.8,},{url:'https://acme.com/blog',lastModified:newDate(),changeFrequency:'weekly',priority:0.5,},]}Output:acme.com/sitemap.xml<urlsetxmlns=""http://www.sitemaps.org/schemas/sitemap/0.9""><url><loc>https://acme.com</loc><lastmod>2023-04-06T15:02:24.021Z</lastmod><changefreq>yearly</changefreq><priority>1</priority></url><url><loc>https://acme.com/about</loc><lastmod>2023-04-06T15:02:24.021Z</lastmod><changefreq>monthly</changefreq><priority>0.8</priority></url><url><loc>https://acme.com/blog</loc><lastmod>2023-04-06T15:02:24.021Z</lastmod><changefreq>weekly</changefreq><priority>0.5</priority></url></urlset>Image SitemapsYou can useimagesproperty to create image sitemaps. Learn more details in theGoogle Developer Docs.app/sitemap.tsTypeScriptJavaScriptTypeScriptimporttype{ MetadataRoute }from'next'exportdefaultfunctionsitemap():MetadataRoute.Sitemap{return[{url:'https://example.com',lastModified:'2021-01-01',changeFrequency:'weekly',priority:0.5,images:['https://example.com/image.jpg'],},]}Output:acme.com/sitemap.xml<?xmlversion=""1.0""encoding=""UTF-8""?><urlsetxmlns=""http://www.sitemaps.org/schemas/sitemap/0.9""xmlns:image=""http://www.google.com/schemas/sitemap-image/1.1""><url><loc>https://example.com</loc><image:image><image:loc>https://example.com/image.jpg</image:loc></image:image><lastmod>2021-01-01</lastmod><changefreq>weekly</changefreq><priority>0.5</priority></url></urlset>Video SitemapsYou can usevideosproperty to create video sitemaps. Learn more details in theGoogle Developer Docs.app/sitemap.tsTypeScriptJavaScriptTypeScriptimporttype{ MetadataRoute }from'next'exportdefaultfunctionsitemap():MetadataRoute.Sitemap{return[{url:'https://example.com',lastModified:'2021-01-01',changeFrequency:'weekly',priority:0.5,videos:[{title:'example',thumbnail_loc:'https://example.com/image.jpg',description:'this is the description',},],},]}Output:acme.com/sitemap.xml<?xmlversion=""1.0""encoding=""UTF-8""?><urlsetxmlns=""http://www.sitemaps.org/schemas/sitemap/0.9""xmlns:video=""http://www.google.com/schemas/sitemap-video/1.1""><url><loc>https://example.com</loc><video:video><video:title>example</video:title><video:thumbnail_loc>https://example.com/image.jpg</video:thumbnail_loc><video:description>this is the description</video:description></video:video><lastmod>2021-01-01</lastmod><changefreq>weekly</changefreq><priority>0.5</priority></url></urlset>Generate a localized Sitemapapp/sitemap.tsTypeScriptJavaScriptTypeScriptimporttype{ MetadataRoute }from'next'exportdefaultfunctionsitemap():MetadataRoute.Sitemap{return[{url:'https://acme.com',lastModified:newDate(),alternates:{languages:{es:'https://acme.com/es',de:'https://acme.com/de',},},},{url:'https://acme.com/about',lastModified:newDate(),alternates:{languages:{es:'https://acme.com/es/about',de:'https://acme.com/de/about',},},},{url:'https://acme.com/blog',lastModified:newDate(),alternates:{languages:{es:'https://acme.com/es/blog',de:'https://acme.com/de/blog',},},},]}Output:acme.com/sitemap.xml<urlsetxmlns=""http://www.sitemaps.org/schemas/sitemap/0.9""xmlns:xhtml=""http://www.w3.org/1999/xhtml""><url><loc>https://acme.com</loc><xhtml:linkrel=""alternate""hreflang=""es""href=""https://acme.com/es""/><xhtml:linkrel=""alternate""hreflang=""de""href=""https://acme.com/de""/><lastmod>2023-04-06T15:02:24.021Z</lastmod></url><url><loc>https://acme.com/about</loc><xhtml:linkrel=""alternate""hreflang=""es""href=""https://acme.com/es/about""/><xhtml:linkrel=""alternate""hreflang=""de""href=""https://acme.com/de/about""/><lastmod>2023-04-06T15:02:24.021Z</lastmod></url><url><loc>https://acme.com/blog</loc><xhtml:linkrel=""alternate""hreflang=""es""href=""https://acme.com/es/blog""/><xhtml:linkrel=""alternate""hreflang=""de""href=""https://acme.com/de/blog""/><lastmod>2023-04-06T15:02:24.021Z</lastmod></url></urlset>Generating multiple sitemapsWhile a single sitemap will work for most applications. For large web applications, you may need to split a sitemap into multiple files.There are two ways you can create multiple sitemaps:By nestingsitemap.(xml|js|ts)inside multiple route segments e.g.app/sitemap.xmlandapp/products/sitemap.xml.By using thegenerateSitemapsfunction.For example, to split a sitemap usinggenerateSitemaps, return an array of objects with the sitemapid. Then, use theidto generate the unique sitemaps.app/product/sitemap.tsTypeScriptJavaScriptTypeScriptimporttype{ MetadataRoute }from'next'import{ BASE_URL }from'@/app/lib/constants'exportasyncfunctiongenerateSitemaps() {// Fetch the total number ofproducts and calculate the number of sitemaps neededreturn[{ id:0},{ id:1},{ id:2},{ id:3}]}exportdefaultasyncfunctionsitemap({id,}:{id:number}):Promise<MetadataRoute.Sitemap> {// Google's limit is 50,000 URLs per sitemapconststart=id*50000constend=start+50000constproducts=awaitgetProducts(`SELECT id, date FROMproducts WHERE id BETWEEN${start}AND${end}`)returnproducts.map((product)=>({url:`${BASE_URL}/product/${product.id}`,lastModified:product.date,}))}Your generated sitemaps will be available at/.../sitemap/[id]. For example,/product/sitemap/1.xml.See thegenerateSitemapsAPI referencefor more information.ReturnsThe default function exported fromsitemap.(xml|ts|js)should return an array of objects with the following properties:typeSitemap=Array<{url:stringlastModified?:string|DatechangeFrequency?:|'always'|'hourly'|'daily'|'weekly'|'monthly'|'yearly'|'never'priority?:numberalternates?:{languages?:Languages<string>}}>Version HistoryVersionChangesv14.2.0Add localizations support.v13.4.14AddchangeFrequencyandpriorityattributes to sitemaps.v13.3.0sitemapintroduced.Next StepsLearn how to use the generateSitemaps function.generateSitemapsLearn how to use the generateSiteMaps function to create multiple sitemaps for your application.Previousrobots.txtNextFunctionsWas this helpful?supported.Send"
functions,Functions,App RouterAPI ReferenceFunctionsFunctionsafterAPI Reference for the after function.cacheLifeLearn how to use the cacheLife function to set the cache expiration time for a cached function or component.cacheTagLearn how to use the cacheTag function to manage cache invalidation in your Next.js application.connectionAPI Reference for the connection function.cookiesAPI Reference for the cookies function.draftModeAPI Reference for the draftMode function.fetchAPI reference for the extended fetch function.forbiddenAPI Reference for the forbidden function.generateImageMetadataLearn how to generate multiple images in a single Metadata API special file.generateMetadataLearn how to add Metadata to your Next.js application for improved search engine optimization (SEO) and web shareability.generateSitemapsLearn how to use the generateSiteMaps function to create multiple sitemaps for your application.generateStaticParamsAPI reference for the generateStaticParams function.generateViewportAPI Reference for the generateViewport function.headersAPI reference for the headers function.ImageResponseAPI Reference for the ImageResponse constructor.NextRequestAPI Reference for NextRequest.NextResponseAPI Reference for NextResponse.notFoundAPI Reference for the notFound function.permanentRedirectAPI Reference for the permanentRedirect function.redirectAPI Reference for the redirect function.revalidatePathAPI Reference for the revalidatePath function.revalidateTagAPI Reference for the revalidateTag function.unauthorizedAPI Reference for the unauthorized function.unstable_cacheAPI Reference for the unstable_cache function.unstable_noStoreAPI Reference for the unstable_noStore function.unstable_rethrowAPI Reference for the unstable_rethrow function.useParamsAPI Reference for the useParams hook.usePathnameAPI Reference for the usePathname hook.useReportWebVitalsAPI Reference for the useReportWebVitals function.useRouterAPI reference for the useRouter hook.useSearchParamsAPI Reference for the useSearchParams hook.useSelectedLayoutSegmentAPI Reference for the useSelectedLayoutSegment hook.useSelectedLayoutSegmentsAPI Reference for the useSelectedLayoutSegments hook.userAgentThe userAgent helper extends the Web Request API with additional properties and methods to interact with the user agent object from the request.Previoussitemap.xmlNextafterWas this helpful?supported.Send
after,after,"API ReferenceFunctionsafterafterafterallows you to schedule work to be executed after a response (or prerender) is finished. This is useful for tasks and other side effects that should not block the response, such as logging and analytics.It can be used inServer Components(includinggenerateMetadata),Server Actions,Route Handlers, andMiddleware.The function accepts a callback that will be executed after the response (or prerender) is finished:app/layout.tsxTypeScriptJavaScriptTypeScriptimport{ after }from'next/server'// Custom logging functionimport{ log }from'@/app/utils'exportdefaultfunctionLayout({ children }:{ children:React.ReactNode}) {after(()=>{// Execute after the layout is rendered and sent to the userlog()})return<>{children}</>}Good to know:afteris not aDynamic APIand calling it does not cause a route to become dynamic. If it's used within a static page, the callback will execute at build time, or whenever a page is revalidated.ReferenceParametersA callback function which will be executed after the response (or prerender) is finished.Durationafterwill run for the platform's default or configured max duration of your route. If your platform supports it, you can configure the timeout limit using themaxDurationroute segment config.Good to knowafterwill be executed even if the response didn't complete successfully. Including when an error is thrown or whennotFoundorredirectis called.You can use Reactcacheto deduplicate functions called insideafter.aftercan be nested inside otheraftercalls, for example, you can create utility functions that wrapaftercalls to add additional functionality.AlternativesThe use case forafteris to process secondary tasks without blocking the primary response. It's similar to using the platform'swaitUntil()or removingawaitfrom a promise, but with the following differences:waitUntil(): accepts a promise and enqueues a task to be executed during the lifecycle of the request, whereasafteraccepts a callback that will be executedafterthe response is finished.Removingawait: starts executing during the response, which uses resources. It's also not reliable in serverless environments as the function stops computation immediately after the response is sent, potentially interrupting the task.We recommend usingafteras it has been designed to consider other Next.js APIs and contexts.ExamplesWith request APIsYou can use request APIs such ascookiesandheadersinsideafterinServer ActionsandRoute Handlers. This is useful for logging activity after a mutation. For example:app/api/route.tsTypeScriptJavaScriptTypeScriptimport{ after }from'next/server'import{ cookies,headers }from'next/headers'import{ logUserAction }from'@/app/utils'exportasyncfunctionPOST(request:Request) {// Perform mutation// ...// Log user activity for analyticsafter(async()=>{constuserAgent=(awaitheaders().get('user-agent'))||'unknown'constsessionCookie=(awaitcookies().get('session-id'))?.value||'anonymous'logUserAction({ sessionCookie,userAgent })})returnnewResponse(JSON.stringify({ status:'success'}),{status:200,headers:{'Content-Type':'application/json'},})}However, you cannot use these request APIs insideafterinServer Components. This is because Next.js needs to know which part of the tree access the request APIs to supportPartial Prerendering, butafterruns after React's rendering lifecycle.Version HistoryDescriptionv15.1.0afterbecame stable.v15.0.0-rcunstable_afterintroduced.PreviousFunctionsNextcacheLifeWas this helpful?supported.Send"
cachelife,cacheLife,"API ReferenceFunctionscacheLifecacheLifeThis feature is currently available in the canary channel and subject to change. Try it out byupgrading Next.js, and share your feedback onGitHub.ThecacheLifefunction is used to set the cache lifetime of a function or component. It should be used alongside theuse cachedirective, and within the scope of the function or component.UsageTo usecacheLife, enable thedynamicIOflagin yournext.config.jsfile:next.config.tsTypeScriptJavaScriptTypeScriptimporttype{ NextConfig }from'next'constnextConfig:NextConfig={experimental:{dynamicIO:true,},}exportdefaultnextConfigThen, import and invoke thecacheLifefunction within the scope of the function or component:app/page.tsxTypeScriptJavaScriptTypeScript'use cache'import{ unstable_cacheLifeascacheLife }from'next/cache'exportdefaultasyncfunctionPage() {cacheLife('hours')return<div>Page</div>}ReferenceDefault cache profilesNext.js provides a set of named cache profiles modeled on various timescales. If you don't specify a cache profile in thecacheLifefunction alongside theuse cachedirective, Next.js will automatically apply the “default” cache profile.However, we recommend always adding a cache profile when using theuse cachedirective to explicitly define caching behavior.ProfileStaleRevalidateExpireDescriptiondefaultundefined15 minutesINFINITE_CACHEDefault profile, suitable for content that doesn't need frequent updatessecondsundefined1 second1 minuteFor rapidly changing content requiring near real-time updatesminutes5 minutes1 minute1 hourFor content that updates frequently within an hourhours5 minutes1 hour1 dayFor content that updates daily but can be slightly staledays5 minutes1 day1 weekFor content that updates weekly but can be a day oldweeks5 minutes1 week1 monthFor content that updates monthly but can be a week oldmax5 minutes1 monthINFINITE_CACHEFor very stable content that rarely needs updatingThe string values used to reference cache profiles don't carry inherent meaning; instead they serve as semantic labels. This allows you to better understand and manage your cached content within your codebase.Custom cache profilesYou can configure custom cache profiles by adding them to thecacheLifeoption in yournext.config.tsfile.Cache profiles are objects that contain the following properties:PropertyValueDescriptionRequirementstalenumberDuration the client should cache a value without checking the server.OptionalrevalidatenumberFrequency at which the cache should refresh on the server; stale values may be served while revalidating.OptionalexpirenumberMaximum duration for which a value can remain stale before switching to dynamic fetching; must be longer thanrevalidate.Optional - Must be longer thanrevalidateThe ""stale"" property differs from thestaleTimessetting in that it specifically controls client-side router caching. WhilestaleTimesis a global setting that affects all instances of both dynamic and static data, thecacheLifeconfiguration allows you to define ""stale"" times on a per-function or per-route basis.Good to know: The “stale” property does not set theCache-control: max-ageheader. It instead controls the client-side router cache.ExamplesDefining reusable cache profilesYou can create a reusable cache profile by defining them in yournext.config.tsfile. Choose a name that suits your use case and set values for thestale,revalidate, andexpireproperties. You can create as many custom cache profiles as needed. Each profile can be referenced by its name as a string value passed to thecacheLifefunction.next.config.tsTypeScriptJavaScriptTypeScriptimporttype{ NextConfig }from'next'constnextConfig:NextConfig={experimental:{dynamicIO:true,cacheLife:{biweekly:{stale:60*60*24*14,// 14 daysrevalidate:60*60*24,// 1 dayexpire:60*60*24*14,// 14 days},},},}module.exports=nextConfigThe example above caches for 14 days, checks for updates daily, and expires the cache after 14 days. You can then reference this profile throughout your application by its name:app/page.tsx'use cache'import{ unstable_cacheLifeascacheLife }from'next/cache'exportdefaultasyncfunctionPage() {cacheLife('biweekly')return<div>Page</div>}Overriding the default cache profilesWhile the default cache profiles provide a useful way to think about how fresh or stale any given part of cacheable output can be, you may prefer different named profiles to better align with your applications caching strategies.You can override the default named cache profiles by creating a new configuration with the same name as the defaults.The example below shows how to override the default “days” cache profile:next.config.tsconstnextConfig={experimental:{dynamicIO:true,cacheLife:{days:{stale:3600,// 1 hourrevalidate:900,// 15 minutesexpire:86400,// 1 day},},},}module.exports=nextConfigDefining cache profiles inlineFor specific use cases, you can set a custom cache profile by passing an object to thecacheLifefunction:app/page.tsxTypeScriptJavaScriptTypeScript'use cache'import{ unstable_cacheLifeascacheLife }from'next/cache'exportdefaultasyncfunctionPage() {cacheLife({stale:3600,// 1 hourrevalidate:900,// 15 minutesexpire:86400,// 1 day})return<div>Page</div>}This inline cache profile will only be applied to the function or file it was created in. If you want to reuse the same profile throughout your application, you canadd the configurationto thecacheLifeproperty of yournext.config.tsfile.Nested usage ofuse cacheandcacheLifeWhen defining multiple caching behaviors in the same route or component tree, if the inner caches specify their owncacheLifeprofile, the outer cache will respect the shortest cache duration among them.This applies only if the outer cache does not have its own explicitcacheLifeprofile defined.For example, if you add theuse cachedirective to your page, without specifying a cache profile, the default cache profile will be applied implicitly (cacheLife(”default”)). If a component imported into the page also uses theuse cachedirective with its own cache profile, the outer and inner cache profiles are compared, and shortest duration set in the profiles will be applied.app/components/parent.tsx// Parent componentimport{ unstable_cacheLifeascacheLife }from'next/cache'import{ ChildComponent }from'./child'exportasyncfunctionParentComponent() {'use cache'cacheLife('days')return(<div><ChildComponent/></div>)}And in a separate file, we defined the Child component that was imported:app/components/child.tsx// Child componentimport{ unstable_cacheLifeascacheLife }from'next/cache'exportasyncfunctionChildComponent() {'use cache'cacheLife('hours')return<div>Child Content</div>// This component's cache will respect the shorter 'hours' profile}RelatedView related API references.dynamicIOLearn how to enable the dynamicIO flag in Next.js.use cacheLearn how to use the use cache directive to cache data in your Next.js application.revalidateTagAPI Reference for the revalidateTag function.cacheTagLearn how to use the cacheTag function to manage cache invalidation in your Next.js application.PreviousafterNextcacheTagWas this helpful?supported.Send"
cachetag,cacheTag,"API ReferenceFunctionscacheTagcacheTagThis feature is currently available in the canary channel and subject to change. Try it out byupgrading Next.js, and share your feedback onGitHub.ThecacheTagfunction allows you to tag cached data for on-demand invalidation. By associating tags with cache entries, you can selectively purge or revalidate specific cache entries without affecting other cached data.UsageTo usecacheTag, enable thedynamicIOflagin yournext.config.jsfile:next.config.tsTypeScriptJavaScriptTypeScriptimporttype{ NextConfig }from'next'constnextConfig:NextConfig={experimental:{dynamicIO:true,},}exportdefaultnextConfigThecacheTagfunction takes a single string value, or a string array.app/data.tsTypeScriptJavaScriptTypeScriptimport{ unstable_cacheTagascacheTag }from'next/cache'exportasyncfunctiongetData() {'use cache'cacheTag('my-data')constdata=awaitfetch('/api/data')returndata}You can then purge the cache on-demand usingrevalidateTagAPI in another function, for example, aroute handlerorServer Action:app/action.tsTypeScriptJavaScriptTypeScript'use server'import{ revalidateTag }from'next/cache'exportdefaultasyncfunctionsubmit() {awaitaddPost()revalidateTag('my-data')}Good to knowIdempotent Tags: Applying the same tag multiple times has no additional effect.Multiple Tags: You can assign multiple tags to a single cache entry by passing an array tocacheTag.cacheTag('tag-one','tag-two')ExamplesTagging components or functionsTag your cached data by callingcacheTagwithin a cached function or component:app/components/bookings.tsxTypeScriptJavaScriptTypeScriptimport{ unstable_cacheTagascacheTag }from'next/cache'interfaceBookingsProps{type:string}exportasyncfunctionBookings({ type='haircut'}:BookingsProps) {'use cache'cacheTag('bookings-data')asyncfunctiongetBookingsData() {constdata=awaitfetch(`/api/bookings?type=${encodeURIComponent(type)}`)returndata}return//...}Creating tags from external dataYou can use the data returned from an async function to tag the cache entry.app/components/bookings.tsxTypeScriptJavaScriptTypeScriptimport{ unstable_cacheTagascacheTag }from'next/cache'interfaceBookingsProps{type:string}exportasyncfunctionBookings({ type='haircut'}:BookingsProps) {asyncfunctiongetBookingsData() {'use cache'constdata=awaitfetch(`/api/bookings?type=${encodeURIComponent(type)}`)cacheTag('bookings-data',data.id)returndata}return//...}Invalidating tagged cacheUsingrevalidateTag, you can invalidate the cache for a specific tag when needed:app/actions.tsTypeScriptJavaScriptTypeScript'use server'import{ revalidateTag }from'next/cache'exportasyncfunctionupdateBookings() {awaitupdateBookingData()revalidateTag('bookings-data')}RelatedView related API references.dynamicIOLearn how to enable the dynamicIO flag in Next.js.use cacheLearn how to use the use cache directive to cache data in your Next.js application.revalidateTagAPI Reference for the revalidateTag function.cacheLifeLearn how to use the cacheLife function to set the cache expiration time for a cached function or component.PreviouscacheLifeNextconnectionWas this helpful?supported.Send"
connection,connection,"API ReferenceFunctionsconnectionconnectionTheconnection()function allows you to indicate rendering should wait for an incoming user request before continuing.It's useful when a component doesn’t useDynamic APIs, but you want it to be dynamically rendered at runtime and not statically rendered at build time. This usually occurs when you access external information that you intentionally want to change the result of a render, such asMath.random()ornew Date().app/page.tsxTypeScriptJavaScriptTypeScriptimport{ connection }from'next/server'exportdefaultasyncfunctionPage() {awaitconnection()// Everything below will be excluded from prerenderingconstrand=Math.random()return<span>{rand}</span>}ReferenceTypefunctionconnection():Promise<void>ParametersThe function does not accept any parameters.ReturnsThe function returns avoidPromise. It is not meant to be consumed.Good to knowconnectionreplacesunstable_noStoreto better align with the future of Next.js.The function is only necessary when dynamic rendering is required and common Dynamic APIs are not used.Version HistoryVersionChangesv15.0.0connectionstabilized.v15.0.0-RCconnectionintroduced.PreviouscacheTagNextcookiesWas this helpful?supported.Send"
cookies,cookies,"API ReferenceFunctionscookiescookiescookiesis anasyncfunction that allows you to read the HTTP incoming request cookies inServer Components, and read/write outgoing request cookies inServer ActionsorRoute Handlers.app/page.tsxTypeScriptJavaScriptTypeScriptimport{ cookies }from'next/headers'exportdefaultasyncfunctionPage() {constcookieStore=awaitcookies()consttheme=cookieStore.get('theme')return'...'}ReferenceMethodsThe following methods are available:MethodReturn TypeDescriptionget('name')ObjectAccepts a cookie name and returns an object with the name and value.getAll()Array of objectsReturns a list of all the cookies with a matching name.has('name')BooleanAccepts a cookie name and returns a boolean based on if the cookie exists.set(name, value, options)-Accepts a cookie name, value, and options and sets the outgoing request cookie.delete(name)-Accepts a cookie name and deletes the cookie.clear()-Deletes all cookies.toString()StringReturns a string representation of the cookies.OptionsWhen setting a cookie, the following properties from theoptionsobject are supported:OptionTypeDescriptionnameStringSpecifies the name of the cookie.valueStringSpecifies the value to be stored in the cookie.expiresDateDefines the exact date when the cookie will expire.maxAgeNumberSets the cookie’s lifespan in seconds.domainStringSpecifies the domain where the cookie is available.pathString, default:'/'Limits the cookie's scope to a specific path within the domain.secureBooleanEnsures the cookie is sent only over HTTPS connections for added security.httpOnlyBooleanRestricts the cookie to HTTP requests, preventing client-side access.sameSiteBoolean,'lax','strict','none'Controls the cookie's cross-site request behavior.priorityString (""low"",""medium"",""high"")Specifies the cookie's priorityencode('value')FunctionSpecifies a function that will be used to encode a cookie's value.partitionedBooleanIndicates whether the cookie ispartitioned.The only option with a default value ispath.To learn more about these options, see theMDN docs.Good to knowcookiesis anasynchronousfunction that returns a promise. You must useasync/awaitor React'susefunction to access cookies.In version 14 and earlier,cookieswas a synchronous function. To help with backwards compatibility, you can still access it synchronously in Next.js 15, but this behavior will be deprecated in the future.cookiesis aDynamic APIwhose returned values cannot be known ahead of time. Using it in a layout or page will opt a route intodynamic rendering.The.deletemethod can only be called:In aServer ActionorRoute Handler.If it belongs to the same domain from which.setis called. For wildcard domains, the specific subdomain must be an exact match. Additionally, the code must be executed on the same protocol (HTTP or HTTPS) as the cookie you want to delete.HTTP does not allow setting cookies after streaming starts, so you must use.setin aServer ActionorRoute Handler.Understanding Cookie Behavior in Server ComponentsWhen working with cookies in Server Components, it's important to understand that cookies are fundamentally a client-side storage mechanism:Reading cookiesworks in Server Components because you're accessing the cookie data that the client's browser sends to the server in the HTTP request headers.Setting cookiescannot be done directly in a Server Component, even when using a Route Handler or Server Action. This is because cookies are actually stored by the browser, not the server.The server can only send instructions (viaSet-Cookieheaders) to tell the browser to store cookies - the actual storage happens on the client side. This is why cookie operations that modify state (.set,.delete,.clear) must be performed in a Route Handler or Server Action where the response headers can be properly set.ExamplesGetting a cookieYou can use the(await cookies()).get('name')method to get a single cookie:app/page.tsxTypeScriptJavaScriptTypeScriptimport{ cookies }from'next/headers'exportdefaultasyncfunctionPage() {constcookieStore=awaitcookies()consttheme=cookieStore.get('theme')return'...'}Getting all cookiesYou can use the(await cookies()).getAll()method to get all cookies with a matching name. Ifnameis unspecified, it returns all the available cookies.app/page.tsxTypeScriptJavaScriptTypeScriptimport{ cookies }from'next/headers'exportdefaultasyncfunctionPage() {constcookieStore=awaitcookies()returncookieStore.getAll().map((cookie)=>(<divkey={cookie.name}><p>Name: {cookie.name}</p><p>Value: {cookie.value}</p></div>))}Setting a cookieYou can use the(await cookies()).set(name, value, options)method in aServer ActionorRoute Handlerto set a cookie. Theoptionsobjectis optional.app/actions.tsTypeScriptJavaScriptTypeScript'use server'import{ cookies }from'next/headers'exportasyncfunctioncreate(data) {constcookieStore=awaitcookies()cookieStore.set('name','lee')// orcookieStore.set('name','lee',{ secure:true})// orcookieStore.set({name:'name',value:'lee',httpOnly:true,path:'/',})}Checking if a cookie existsYou can use the(await cookies()).has(name)method to check if a cookie exists:app/page.tsTypeScriptJavaScriptTypeScriptimport{ cookies }from'next/headers'exportdefaultasyncfunctionPage() {constcookieStore=awaitcookies()consthasCookie=cookieStore.has('theme')return'...'}Deleting cookiesThere are three ways you can delete a cookie.Using thedelete()method:app/actions.tsTypeScriptJavaScriptTypeScript'use server'import{ cookies }from'next/headers'exportasyncfunctiondelete(data) {(awaitcookies()).delete('name')}Setting a new cookie with the same name and an empty value:app/actions.tsTypeScriptJavaScriptTypeScript'use server'import{ cookies }from'next/headers'exportasyncfunctiondelete(data) {(awaitcookies()).set('name','')}Setting themaxAgeto 0 will immediately expire a cookie.maxAgeaccepts a value in seconds.app/actions.tsTypeScriptJavaScriptTypeScript'use server'import{ cookies }from'next/headers'exportasyncfunctiondelete(data) {(awaitcookies()).set('name','value',{ maxAge:0})}Version HistoryVersionChangesv15.0.0-RCcookiesis now an async function. Acodemodis available.v13.0.0cookiesintroduced.PreviousconnectionNextdraftModeWas this helpful?supported.Send"
draftmode,draftMode,"API ReferenceFunctionsdraftModedraftModedraftModeis anasyncfunction allows you to enable and disableDraft Mode, as well as check if Draft Mode is enabled in aServer Component.app/page.tsTypeScriptJavaScriptTypeScriptimport{ draftMode }from'next/headers'exportdefaultasyncfunctionPage() {const{isEnabled}=awaitdraftMode()}ReferenceThe following methods and properties are available:MethodDescriptionisEnabledA boolean value that indicates if Draft Mode is enabled.enable()Enables Draft Mode in a Route Handler by setting a cookie (__prerender_bypass).disable()Disables Draft Mode in a Route Handler by deleting a cookie.Good to knowdraftModeis anasynchronousfunction that returns a promise. You must useasync/awaitor React'susefunction.In version 14 and earlier,draftModewas a synchronous function. To help with backwards compatibility, you can still access it synchronously in Next.js 15, but this behavior will be deprecated in the future.A new bypass cookie value will be generated each time you runnext build. This ensures that the bypass cookie can’t be guessed.To test Draft Mode locally over HTTP, your browser will need to allow third-party cookies and local storage access.ExamplesEnabling Draft ModeTo enable Draft Mode, create a newRoute Handlerand call theenable()method:app/draft/route.tsTypeScriptJavaScriptTypeScriptimport{draftMode }from'next/headers'exportasyncfunctionGET(request:Request) {constdraft=awaitdraftMode()draft.enable()returnnewResponse('Draft mode is enabled')}Disabling Draft ModeBy default, the Draft Mode session ends when the browser is closed.To disable Draft Mode manually, call thedisable()method in yourRoute Handler:app/draft/route.tsTypeScriptJavaScriptTypeScriptimport{draftMode }from'next/headers'exportasyncfunctionGET(request:Request) {constdraft=awaitdraftMode()draft.disable()returnnewResponse('Draft mode is disabled')}Then, send a request to invoke the Route Handler. If calling the route using the<Link>component, you must passprefetch={false}to prevent accidentally deleting the cookie on prefetch.Checking if Draft Mode is enabledYou can check if Draft Mode is enabled in a Server Component with theisEnabledproperty:app/page.tsTypeScriptJavaScriptTypeScriptimport{ draftMode }from'next/headers'exportdefaultasyncfunctionPage() {const{isEnabled}=awaitdraftMode()return(<main><h1>My Blog Post</h1><p>Draft Mode is currently {isEnabled?'Enabled':'Disabled'}</p></main>)}Version HistoryVersionChangesv15.0.0-RCdraftModeis now an async function. Acodemodis available.v13.4.0draftModeintroduced.Next StepsLearn how to use Draft Mode with this step-by-step guide.Draft ModeNext.js has draft mode to toggle between static and dynamic pages. You can learn how it works with App Router here.PreviouscookiesNextfetchWas this helpful?supported.Send"
fetch,fetch,"API ReferenceFunctionsfetchfetchNext.js extends theWebfetch()APIto allow each request on the server to set its own persistent caching and revalidation semantics.In the browser, thecacheoption indicates how a fetch request will interact with thebrowser'sHTTP cache. With this extension,cacheindicates how aserver-sidefetch request will interact with the framework's persistentData Cache.You can callfetchwithasyncandawaitdirectly within Server Components.app/page.tsxTypeScriptJavaScriptTypeScriptexportdefaultasyncfunctionPage() {letdata=awaitfetch('https://api.vercel.app/blog')letposts=awaitdata.json()return(<ul>{posts.map((post)=>(<likey={post.id}>{post.title}</li>))}</ul>)}fetch(url, options)Since Next.js extends theWebfetch()API, you can use any of thenative options available.options.cacheConfigure how the request should interact with Next.jsData Cache.fetch(`https://...`,{ cache:'force-cache'|'no-store'})auto no cache(default): Next.js fetches the resource from the remote server on every request in development, but will fetch once duringnext buildbecause the route will be statically prerendered. IfDynamic APIsare detected on the route, Next.js will fetch the resource on every request.no-store: Next.js fetches the resource from the remote server on every request, even if Dynamic APIs are not detected on the route.force-cache: Next.js looks for a matching request in its Data Cache.If there is a match and it is fresh, it will be returned from the cache.If there is no match or a stale match, Next.js will fetch the resource from the remote server and update the cache with the downloaded resource.options.next.revalidatefetch(`https://...`,{ next:{ revalidate:false|0|number } })Set the cache lifetime of a resource (in seconds).false- Cache the resource indefinitely. Semantically equivalent torevalidate: Infinity. The HTTP cache may evict older resources over time.0- Prevent the resource from being cached.number- (in seconds) Specify the resource should have a cache lifetime of at mostnseconds.Good to know:If an individualfetch()request sets arevalidatenumber lower than thedefaultrevalidateof a route, the whole route revalidation interval will be decreased.If two fetch requests with the same URL in the same route have differentrevalidatevalues, the lower value will be used.As a convenience, it is not necessary to set thecacheoption ifrevalidateis set to a number.Conflicting options such as{ revalidate: 3600, cache: 'no-store' }will cause an error.options.next.tagsfetch(`https://...`,{ next:{ tags:['collection'] } })Set the cache tags of a resource. Data can then be revalidated on-demand usingrevalidateTag. The max length for a custom tag is 256 characters and the max tag items is 128.TroubleshootingFetch defaultauto no storeandcache: 'no-store'not showing fresh data in developmentNext.js cachesfetchresponses in Server Components across Hot Module Replacement (HMR) in local development for faster responses and to reduce costs for billed API calls.By default, theHMR cacheapplies to all fetch requests, including those with the defaultauto no cacheandcache: 'no-store'option. This means uncached requests will not show fresh data between HMR refreshes. However, the cache will be cleared on navigation or full-page reloads.See theserverComponentsHmrCachedocs for more information.Version HistoryVersionChangesv13.0.0fetchintroduced.PreviousdraftModeNextforbiddenWas this helpful?supported.Send"
forbidden,forbidden,"API ReferenceFunctionsforbiddenforbiddenThis feature is currently experimental and subject to change, it's not recommended for production. Try it out and share your feedback onGitHub.Theforbiddenfunction throws an error that renders a Next.js 403 error page. It's useful for handling authorization errors in your application. You can customize the UI using theforbidden.jsfile.To start usingforbidden, enable the experimentalauthInterruptsconfiguration option in yournext.config.jsfile:next.config.tsTypeScriptJavaScriptTypeScriptimporttype{ NextConfig }from'next'constnextConfig:NextConfig={experimental:{authInterrupts:true,},}exportdefaultnextConfigforbiddencan be invoked inServer Components,Server Actions, andRoute Handlers.app/auth/page.tsxTypeScriptJavaScriptTypeScriptimport{ verifySession }from'@/app/lib/dal'import{ forbidden }from'next/navigation'exportdefaultasyncfunctionAdminPage() {constsession=awaitverifySession()// Check if the user has the 'admin' roleif(session.role!=='admin') {forbidden()}// Render the admin page forauthorized usersreturn<></>}Good to knowTheforbiddenfunction cannot be called in theroot layout.ExamplesRole-based route protectionYou can useforbiddento restrict access to certain routes based on user roles. This ensures that users who are authenticated but lack the required permissions cannot access the route.app/admin/page.tsxTypeScriptJavaScriptTypeScriptimport{ verifySession }from'@/app/lib/dal'import{ forbidden }from'next/navigation'exportdefaultasyncfunctionAdminPage() {constsession=awaitverifySession()// Check if the user has the 'admin' roleif(session.role!=='admin') {forbidden()}// Render theadminpage for authorized usersreturn(<main><h1>Admin Dashboard</h1><p>Welcome, {session.user.name}!</p></main>)}Mutations with Server ActionsWhen implementing mutations in Server Actions, you can useforbiddento only allow users with a specific role to update sensitive data.app/actions/update-role.tsTypeScriptJavaScriptTypeScript'use server'import{ verifySession }from'@/app/lib/dal'import{ forbidden }from'next/navigation'importdbfrom'@/app/lib/db'exportasyncfunctionupdateRole(formData:FormData) {constsession=awaitverifySession()// Ensure only admins can update rolesif(session.role!=='admin') {forbidden()}// Perform the role update for authorized users// ...}Version HistoryVersionChangesv15.1.0forbiddenintroduced.Next Stepsforbidden.jsAPI reference for the forbidden.js special file.PreviousfetchNextgenerateImageMetadataWas this helpful?supported.Send"
generateimagemetadata,generateImageMetadata,"API ReferenceFunctionsgenerateImageMetadatagenerateImageMetadataYou can usegenerateImageMetadatato generate different versions of one image or return multiple images for one route segment. This is useful for when you want to avoid hard-coding metadata values, such as for icons.ParametersgenerateImageMetadatafunction accepts the following parameters:params(optional)An object containing thedynamic route parametersobject from the root segment down to the segmentgenerateImageMetadatais called from.icon.tsxTypeScriptJavaScriptTypeScriptexportfunctiongenerateImageMetadata({params,}:{params:{ slug:string}}) {// ...}RouteURLparamsapp/shop/icon.js/shopundefinedapp/shop/[slug]/icon.js/shop/1{ slug: '1' }app/shop/[tag]/[item]/icon.js/shop/1/2{ tag: '1', item: '2' }ReturnsThegenerateImageMetadatafunction should return anarrayof objects containing the image's metadata such asaltandsize. In addition, each itemmustinclude anidvalue which will be passed to the props of the image generating function.Image Metadata ObjectTypeidstring(required)altstringsize{ width: number; height: number }contentTypestringicon.tsxTypeScriptJavaScriptTypeScriptimport{ ImageResponse }from'next/og'exportfunctiongenerateImageMetadata() {return[{contentType:'image/png',size:{ width:48,height:48},id:'small',},{contentType:'image/png',size:{ width:72,height:72},id:'medium',},]}exportdefaultfunctionIcon({ id }:{ id:string}) {returnnewImageResponse((<divstyle={{width:'100%',height:'100%',display:'flex',alignItems:'center',justifyContent:'center',fontSize:88,background:'#000',color:'#fafafa',}}>Icon {id}</div>))}ExamplesUsing external dataThis example uses theparamsobject and external data to generate multipleOpen Graph imagesfor a route segment.app/products/[id]/opengraph-image.tsxTypeScriptJavaScriptTypeScriptimport{ ImageResponse }from'next/og'import{ getCaptionForImage,getOGImages }from'@/app/utils/images'exportasyncfunctiongenerateImageMetadata({params,}:{params:{ id:string}}) {constimages=awaitgetOGImages(params.id)returnimages.map((image,idx)=>({id:idx,size:{ width:1200,height:600},alt:image.text,contentType:'image/png',}))}exportdefaultasyncfunctionImage({params,id,}:{params:{ id:string}id:number}) {constproductId=(awaitparams).idconstimageId=idconsttext=awaitgetCaptionForImage(productId,imageId)returnnewImageResponse((<divstyle={{// ...}}>{text}</div>))}Version HistoryVersionChangesv13.3.0generateImageMetadataintroduced.Next StepsView all the Metadata API options.Metadata FilesAPI documentation for the metadata file conventions.MetadataUse the Metadata API to define metadata in any layout or page.PreviousforbiddenNextgenerateMetadataWas this helpful?supported.Send"
generatemetadata,generateMetadata,"API ReferenceFunctionsgenerateMetadatagenerateMetadataThis page covers allConfig-based Metadataoptions withgenerateMetadataand the static metadata object.layout.tsx | page.tsxTypeScriptJavaScriptTypeScriptimporttype{ Metadata }from'next'// either Static metadataexportconstmetadata:Metadata={title:'...',}// or Dynamic metadataexportasyncfunctiongenerateMetadata({ params }) {return{title:'...',}}Good to know:Themetadataobject andgenerateMetadatafunction exports areonly supported in Server Components.You cannot export both themetadataobject andgenerateMetadatafunction from the same route segment.ThemetadataobjectTo define static metadata, export aMetadataobjectfrom alayout.jsorpage.jsfile.layout.tsx | page.tsxTypeScriptJavaScriptTypeScriptimporttype{ Metadata }from'next'exportconstmetadata:Metadata={title:'...',description:'...',}exportdefaultfunctionPage() {}See theMetadata Fieldsfor a complete list of supported options.generateMetadatafunctionDynamic metadata depends ondynamic information, such as the current route parameters, external data, ormetadatain parent segments, can be set by exporting agenerateMetadatafunction that returns aMetadataobject.app/products/[id]/page.tsxTypeScriptJavaScriptTypeScriptimporttype{ Metadata,ResolvingMetadata }from'next'typeProps={params:Promise<{ id:string}>searchParams:Promise<{ [key:string]:string|string[]|undefined}>}exportasyncfunctiongenerateMetadata({ params,searchParams }:Props,parent:ResolvingMetadata):Promise<Metadata> {// read route paramsconstid=(awaitparams).id// fetch dataconstproduct=awaitfetch(`https://.../${id}`).then((res)=>res.json())// optionally access and extend (rather than replace) parent metadataconstpreviousImages=(awaitparent).openGraph?.images||[]return{title:product.title,openGraph:{images:['/some-specific-page-image.jpg',...previousImages],},}}exportdefaultfunctionPage({ params,searchParams }:Props) {}ParametersgenerateMetadatafunction accepts the following parameters:props- An object containing the parameters of the current route:params- An object containing thedynamic route parametersobject from the root segment down to the segmentgenerateMetadatais called from. Examples:RouteURLparamsapp/shop/[slug]/page.js/shop/1{ slug: '1' }app/shop/[tag]/[item]/page.js/shop/1/2{ tag: '1', item: '2' }app/shop/[...slug]/page.js/shop/1/2{ slug: ['1', '2'] }searchParams- An object containing the current URL'ssearch params. Examples:URLsearchParams/shop?a=1{ a: '1' }/shop?a=1&b=2{ a: '1', b: '2' }/shop?a=1&a=2{ a: ['1', '2'] }parent- A promise of the resolved metadata from parent route segments.ReturnsgenerateMetadatashould return aMetadataobjectcontaining one or more metadata fields.Good to know:If metadata doesn't depend on runtime information, it should be defined using the staticmetadataobjectrather thangenerateMetadata.fetchrequests are automaticallymemoizedfor the same data acrossgenerateMetadata,generateStaticParams, Layouts, Pages, and Server Components. Reactcachecan be usediffetchis unavailable.searchParamsare only available inpage.jssegments.Theredirect()andnotFound()Next.js methods can also be used insidegenerateMetadata.Metadata FieldstitleThetitleattribute is used to set the title of the document. It can be defined as a simplestringor an optionaltemplate object.Stringlayout.js | page.jsexportconstmetadata={title:'Next.js',}<head> output<title>Next.js</title>Template objectapp/layout.tsxTypeScriptJavaScriptTypeScriptimporttype{ Metadata }from'next'exportconstmetadata:Metadata={title:{template:'...',default:'...',absolute:'...',},}Defaulttitle.defaultcan be used to provide afallback titleto child route segments that don't define atitle.app/layout.tsximporttype{ Metadata }from'next'exportconstmetadata:Metadata={title:{default:'Acme',},}app/about/page.tsximporttype{ Metadata }from'next'exportconstmetadata:Metadata={}// Output: <title>Acme</title>Templatetitle.templatecan be used to add a prefix or a suffix totitlesdefined inchildroute segments.app/layout.tsxTypeScriptJavaScriptTypeScriptimporttype{ Metadata }from'next'exportconstmetadata:Metadata={title:{template:'%s | Acme',default:'Acme',// a default is required when creating a template},}app/about/page.tsxTypeScriptJavaScriptTypeScriptimporttype{ Metadata }from'next'exportconstmetadata:Metadata={title:'About',}// Output: <title>About | Acme</title>Good to know:title.templateapplies tochildroute segments andnotthe segment it's defined in. This means:title.defaultisrequiredwhen you add atitle.template.title.templatedefined inlayout.jswill not apply to atitledefined in apage.jsof the same route segment.title.templatedefined inpage.jshas no effect because a page is always the terminating segment (it doesn't have any children route segments).title.templatehasno effectif a route has not defined atitleortitle.default.Absolutetitle.absolutecan be used to provide a title thatignorestitle.templateset in parent segments.app/layout.tsxTypeScriptJavaScriptTypeScriptimporttype{ Metadata }from'next'exportconstmetadata:Metadata={title:{template:'%s | Acme',},}app/about/page.tsxTypeScriptJavaScriptTypeScriptimporttype{ Metadata }from'next'exportconstmetadata:Metadata={title:{absolute:'About',},}// Output: <title>About</title>Good to know:layout.jstitle(string) andtitle.defaultdefine the default title for child segments (that do not define their owntitle). It will augmenttitle.templatefrom the closest parent segment if it exists.title.absolutedefines the default title for child segments. It ignorestitle.templatefrom parent segments.title.templatedefines a new title template for child segments.page.jsIf a page does not define its own title the closest parents resolved title will be used.title(string) defines the routes title. It will augmenttitle.templatefrom the closest parent segment if it exists.title.absolutedefines the route title. It ignorestitle.templatefrom parent segments.title.templatehas no effect inpage.jsbecause a page is always the terminating segment of a route.descriptionlayout.js | page.jsexportconstmetadata={description:'The React Framework for the Web',}<head> output<metaname=""description""content=""The React Framework for the Web""/>Basic Fieldslayout.js | page.jsexportconstmetadata={generator:'Next.js',applicationName:'Next.js',referrer:'origin-when-cross-origin',keywords:['Next.js','React','JavaScript'],authors:[{ name:'Seb'},{ name:'Josh',url:'https://nextjs.org'}],creator:'Jiachi Liu',publisher:'Sebastian Markbåge',formatDetection:{email:false,address:false,telephone:false,},}<head> output<metaname=""application-name""content=""Next.js""/><metaname=""author""content=""Seb""/><linkrel=""author""href=""https://nextjs.org""/><metaname=""author""content=""Josh""/><metaname=""generator""content=""Next.js""/><metaname=""keywords""content=""Next.js,React,JavaScript""/><metaname=""referrer""content=""origin-when-cross-origin""/><metaname=""color-scheme""content=""dark""/><metaname=""creator""content=""Jiachi Liu""/><metaname=""publisher""content=""Sebastian Markbåge""/><metaname=""format-detection""content=""telephone=no, address=no, email=no""/>metadataBasemetadataBaseis a convenience option to set a base URL prefix formetadatafields that require a fully qualified URL.metadataBaseallows URL-basedmetadatafields defined in thecurrent route segment and belowto use arelative pathinstead of an otherwise required absolute URL.The field's relative path will be composed withmetadataBaseto form a fully qualified URL.If not configured,metadataBaseisautomatically populatedwith adefault value.layout.js | page.jsexportconstmetadata={metadataBase:newURL('https://acme.com'),alternates:{canonical:'/',languages:{'en-US':'/en-US','de-DE':'/de-DE',},},openGraph:{images:'/og-image.png',},}<head> output<linkrel=""canonical""href=""https://acme.com""/><linkrel=""alternate""hreflang=""en-US""href=""https://acme.com/en-US""/><linkrel=""alternate""hreflang=""de-DE""href=""https://acme.com/de-DE""/><metaproperty=""og:image""content=""https://acme.com/og-image.png""/>Good to know:metadataBaseis typically set in rootapp/layout.jsto apply to URL-basedmetadatafields across all routes.All URL-basedmetadatafields that require absolute URLs can be configured with ametadataBaseoption.metadataBasecan contain a subdomain e.g.https://app.acme.comor base path e.g.https://acme.com/start/from/hereIf ametadatafield provides an absolute URL,metadataBasewill be ignored.Using a relative path in a URL-basedmetadatafield without configuring ametadataBasewill cause a build error.Next.js will normalize duplicate slashes betweenmetadataBase(e.g.https://acme.com/) and a relative field (e.g./path) to a single slash (e.g.https://acme.com/path)Default valueIf not configured,metadataBasehas adefault value.On Vercel:For production deployments,VERCEL_PROJECT_PRODUCTION_URLwill be used.For preview deployments,VERCEL_BRANCH_URLwill take priority, and fallback toVERCEL_URLif it's not present.If these values are present they will be used as thedefault valueofmetadataBase, otherwise it falls back tohttp://localhost:${process.env.PORT || 3000}. This allows Open Graph images to work on both local build and Vercel preview and production deployments. When overriding the default, we recommend using environment variables to compute the URL. This allows configuring a URL for local development, staging, and production environments.See more details about these environment variables in theSystem Environment Variablesdocs.URL CompositionURL composition favors developer intent over default directory traversal semantics.Trailing slashes betweenmetadataBaseandmetadatafields are normalized.An ""absolute"" path in ametadatafield (that typically would replace the whole URL path) is treated as a ""relative"" path (starting from the end ofmetadataBase).For example, given the followingmetadataBase:app/layout.tsxTypeScriptJavaScriptTypeScriptimporttype{ Metadata }from'next'exportconstmetadata:Metadata={metadataBase:newURL('https://acme.com'),}Anymetadatafields that inherit the abovemetadataBaseand set their own value will be resolved as follows:metadatafieldResolved URL/https://acme.com./https://acme.compaymentshttps://acme.com/payments/paymentshttps://acme.com/payments./paymentshttps://acme.com/payments../paymentshttps://acme.com/paymentshttps://beta.acme.com/paymentshttps://beta.acme.com/paymentsopenGraphlayout.js | page.jsexportconstmetadata={openGraph:{title:'Next.js',description:'The React Framework for the Web',url:'https://nextjs.org',siteName:'Next.js',images:[{url:'https://nextjs.org/og.png',// Must be an absolute URLwidth:800,height:600,},{url:'https://nextjs.org/og-alt.png',// Must be an absolute URLwidth:1800,height:1600,alt:'My custom alt',},],videos:[{url:'https://nextjs.org/video.mp4',// Must be an absolute URLwidth:800,height:600,},],audio:[{url:'https://nextjs.org/audio.mp3',// Must be an absolute URL},],locale:'en_US',type:'website',},}<head> output<metaproperty=""og:title""content=""Next.js""/><metaproperty=""og:description""content=""The React Framework for the Web""/><metaproperty=""og:url""content=""https://nextjs.org/""/><metaproperty=""og:site_name""content=""Next.js""/><metaproperty=""og:locale""content=""en_US""/><metaproperty=""og:image""content=""https://nextjs.org/og.png""/><metaproperty=""og:image:width""content=""800""/><metaproperty=""og:image:height""content=""600""/><metaproperty=""og:image""content=""https://nextjs.org/og-alt.png""/><metaproperty=""og:image:width""content=""1800""/><metaproperty=""og:image:height""content=""1600""/><metaproperty=""og:image:alt""content=""My custom alt""/><metaproperty=""og:video""content=""https://nextjs.org/video.mp4""/><metaproperty=""og:video:width""content=""800""/><metaproperty=""og:video:height""content=""600""/><metaproperty=""og:audio""content=""https://nextjs.org/audio.mp3""/><metaproperty=""og:type""content=""website""/>layout.js | page.jsexportconstmetadata={openGraph:{title:'Next.js',description:'The React Framework for the Web',type:'article',publishedTime:'2023-01-01T00:00:00.000Z',authors:['Seb','Josh'],},}<head> output<metaproperty=""og:title""content=""Next.js""/><metaproperty=""og:description""content=""The React Framework for the Web""/><metaproperty=""og:type""content=""article""/><metaproperty=""article:published_time""content=""2023-01-01T00:00:00.000Z""/><metaproperty=""article:author""content=""Seb""/><metaproperty=""article:author""content=""Josh""/>Good to know:It may be more convenient to use thefile-based Metadata APIfor Open Graph images. Rather than having to sync the config export with actual files, the file-based API will automatically generate the correct metadata for you.robotslayout.tsx | page.tsximporttype{ Metadata }from'next'exportconstmetadata:Metadata={robots:{index:true,follow:true,nocache:false,googleBot:{index:true,follow:true,noimageindex:false,'max-video-preview':-1,'max-image-preview':'large','max-snippet':-1,},},}<head> output<metaname=""robots""content=""index, follow""/><metaname=""googlebot""content=""index, follow, max-video-preview:-1, max-image-preview:large, max-snippet:-1""/>iconsGood to know: We recommend using thefile-based Metadata APIfor icons where possible. Rather than having to sync the config export with actual files, the file-based API will automatically generate the correct metadata for you.layout.js | page.jsexportconstmetadata={icons:{icon:'/icon.png',shortcut:'/shortcut-icon.png',apple:'/apple-icon.png',other:{rel:'apple-touch-icon-precomposed',url:'/apple-touch-icon-precomposed.png',},},}<head> output<linkrel=""shortcut icon""href=""/shortcut-icon.png""/><linkrel=""icon""href=""/icon.png""/><linkrel=""apple-touch-icon""href=""/apple-icon.png""/><linkrel=""apple-touch-icon-precomposed""href=""/apple-touch-icon-precomposed.png""/>layout.js | page.jsexportconstmetadata={icons:{icon:[{ url:'/icon.png'},newURL('/icon.png','https://example.com'),{ url:'/icon-dark.png',media:'(prefers-color-scheme: dark)'},],shortcut:['/shortcut-icon.png'],apple:[{ url:'/apple-icon.png'},{ url:'/apple-icon-x3.png',sizes:'180x180',type:'image/png'},],other:[{rel:'apple-touch-icon-precomposed',url:'/apple-touch-icon-precomposed.png',},],},}<head> output<linkrel=""shortcut icon""href=""/shortcut-icon.png""/><linkrel=""icon""href=""/icon.png""/><linkrel=""icon""href=""https://example.com/icon.png""/><linkrel=""icon""href=""/icon-dark.png""media=""(prefers-color-scheme: dark)""/><linkrel=""apple-touch-icon""href=""/apple-icon.png""/><linkrel=""apple-touch-icon-precomposed""href=""/apple-touch-icon-precomposed.png""/><linkrel=""apple-touch-icon""href=""/apple-icon-x3.png""sizes=""180x180""type=""image/png""/>Good to know: Themsapplication-*meta tags are no longer supported in Chromium builds of Microsoft Edge, and thus no longer needed.themeColorDeprecated: ThethemeColoroption inmetadatais deprecated as of Next.js 14. Please use theviewportconfigurationinstead.colorSchemeDeprecated: ThecolorSchemeoption inmetadatais deprecated as of Next.js 14. Please use theviewportconfigurationinstead.manifestA web application manifest, as defined in theWeb Application Manifest specification.layout.js | page.jsexportconstmetadata={manifest:'https://nextjs.org/manifest.json',}<head> output<linkrel=""manifest""href=""https://nextjs.org/manifest.json""/>twitterThe Twitter specification is (surprisingly) used for more than just X (formerly known as Twitter).Learn more about theTwitter Card markup reference.layout.js | page.jsexportconstmetadata={twitter:{card:'summary_large_image',title:'Next.js',description:'The React Framework for the Web',siteId:'1467726470533754880',creator:'@nextjs',creatorId:'1467726470533754880',images:['https://nextjs.org/og.png'],// Must be an absolute URL},}<head> output<metaname=""twitter:card""content=""summary_large_image""/><metaname=""twitter:site:id""content=""1467726470533754880""/><metaname=""twitter:creator""content=""@nextjs""/><metaname=""twitter:creator:id""content=""1467726470533754880""/><metaname=""twitter:title""content=""Next.js""/><metaname=""twitter:description""content=""The React Framework for the Web""/><metaname=""twitter:image""content=""https://nextjs.org/og.png""/>layout.js | page.jsexportconstmetadata={twitter:{card:'app',title:'Next.js',description:'The React Framework for the Web',siteId:'1467726470533754880',creator:'@nextjs',creatorId:'1467726470533754880',images:{url:'https://nextjs.org/og.png',alt:'Next.js Logo',},app:{name:'twitter_app',id:{iphone:'twitter_app://iphone',ipad:'twitter_app://ipad',googleplay:'twitter_app://googleplay',},url:{iphone:'https://iphone_url',ipad:'https://ipad_url',},},},}<head> output<metaname=""twitter:site:id""content=""1467726470533754880""/><metaname=""twitter:creator""content=""@nextjs""/><metaname=""twitter:creator:id""content=""1467726470533754880""/><metaname=""twitter:title""content=""Next.js""/><metaname=""twitter:description""content=""The React Framework for the Web""/><metaname=""twitter:card""content=""app""/><metaname=""twitter:image""content=""https://nextjs.org/og.png""/><metaname=""twitter:image:alt""content=""Next.js Logo""/><metaname=""twitter:app:name:iphone""content=""twitter_app""/><metaname=""twitter:app:id:iphone""content=""twitter_app://iphone""/><metaname=""twitter:app:id:ipad""content=""twitter_app://ipad""/><metaname=""twitter:app:id:googleplay""content=""twitter_app://googleplay""/><metaname=""twitter:app:url:iphone""content=""https://iphone_url""/><metaname=""twitter:app:url:ipad""content=""https://ipad_url""/><metaname=""twitter:app:name:ipad""content=""twitter_app""/><metaname=""twitter:app:name:googleplay""content=""twitter_app""/>viewportDeprecated: Theviewportoption inmetadatais deprecated as of Next.js 14. Please use theviewportconfigurationinstead.verificationlayout.js | page.jsexportconstmetadata={verification:{google:'google',yandex:'yandex',yahoo:'yahoo',other:{me:['my-email','my-link'],},},}<head> output<metaname=""google-site-verification""content=""google""/><metaname=""y_key""content=""yahoo""/><metaname=""yandex-verification""content=""yandex""/><metaname=""me""content=""my-email""/><metaname=""me""content=""my-link""/>appleWebApplayout.js | page.jsexportconstmetadata={itunes:{appId:'myAppStoreID',appArgument:'myAppArgument',},appleWebApp:{title:'Apple Web App',statusBarStyle:'black-translucent',startupImage:['/assets/startup/apple-touch-startup-image-768x1004.png',{url:'/assets/startup/apple-touch-startup-image-1536x2008.png',media:'(device-width: 768px) and (device-height: 1024px)',},],},}<head> output<metaname=""apple-itunes-app""content=""app-id=myAppStoreID, app-argument=myAppArgument""/><metaname=""mobile-web-app-capable""content=""yes""/><metaname=""apple-mobile-web-app-title""content=""Apple Web App""/><linkhref=""/assets/startup/apple-touch-startup-image-768x1004.png""rel=""apple-touch-startup-image""/><linkhref=""/assets/startup/apple-touch-startup-image-1536x2008.png""media=""(device-width: 768px) and (device-height: 1024px)""rel=""apple-touch-startup-image""/><metaname=""apple-mobile-web-app-status-bar-style""content=""black-translucent""/>alternateslayout.js | page.jsexportconstmetadata={alternates:{canonical:'https://nextjs.org',languages:{'en-US':'https://nextjs.org/en-US','de-DE':'https://nextjs.org/de-DE',},media:{'only screen and (max-width: 600px)':'https://nextjs.org/mobile',},types:{'application/rss+xml':'https://nextjs.org/rss',},},}<head> output<linkrel=""canonical""href=""https://nextjs.org""/><linkrel=""alternate""hreflang=""en-US""href=""https://nextjs.org/en-US""/><linkrel=""alternate""hreflang=""de-DE""href=""https://nextjs.org/de-DE""/><linkrel=""alternate""media=""only screen and (max-width: 600px)""href=""https://nextjs.org/mobile""/><linkrel=""alternate""type=""application/rss+xml""href=""https://nextjs.org/rss""/>appLinkslayout.js | page.jsexportconstmetadata={appLinks:{ios:{url:'https://nextjs.org/ios',app_store_id:'app_store_id',},android:{package:'com.example.android/package',app_name:'app_name_android',},web:{url:'https://nextjs.org/web',should_fallback:true,},},}<head> output<metaproperty=""al:ios:url""content=""https://nextjs.org/ios""/><metaproperty=""al:ios:app_store_id""content=""app_store_id""/><metaproperty=""al:android:package""content=""com.example.android/package""/><metaproperty=""al:android:app_name""content=""app_name_android""/><metaproperty=""al:web:url""content=""https://nextjs.org/web""/><metaproperty=""al:web:should_fallback""content=""true""/>archivesDescribes a collection of records, documents, or other materials of historical interest (source).layout.js | page.jsexportconstmetadata={archives:['https://nextjs.org/13'],}<head> output<linkrel=""archives""href=""https://nextjs.org/13""/>assetslayout.js | page.jsexportconstmetadata={assets:['https://nextjs.org/assets'],}<head> output<linkrel=""assets""href=""https://nextjs.org/assets""/>bookmarkslayout.js | page.jsexportconstmetadata={bookmarks:['https://nextjs.org/13'],}<head> output<linkrel=""bookmarks""href=""https://nextjs.org/13""/>categorylayout.js | page.jsexportconstmetadata={category:'technology',}<head> output<metaname=""category""content=""technology""/>facebookYou can connect a Facebook app or Facebook account to you webpage for certain Facebook Social PluginsFacebook DocumentationGood to know: You can specify either appId or admins, but not both.layout.js | page.jsexportconstmetadata={facebook:{appId:'12345678',},}<head> output<metaproperty=""fb:app_id""content=""12345678""/>layout.js | page.jsexportconstmetadata={facebook:{admins:'12345678',},}<head> output<metaproperty=""fb:admins""content=""12345678""/>If you want to generate multiple fb:admins meta tags you can use array value.layout.js | page.jsexportconstmetadata={facebook:{admins:['12345678','87654321'],},}<head> output<metaproperty=""fb:admins""content=""12345678""/><metaproperty=""fb:admins""content=""87654321""/>otherAll metadata options should be covered using the built-in support. However, there may be custom metadata tags specific to your site, or brand new metadata tags just released. You can use theotheroption to render any custom metadata tag.layout.js | page.jsexportconstmetadata={other:{custom:'meta',},}<head> output<metaname=""custom""content=""meta""/>If you want to generate multiple same key meta tags you can use array value.layout.js | page.jsexportconstmetadata={other:{custom:['meta1','meta2'],},}<head> output<metaname=""custom""content=""meta1""/> <metaname=""custom""content=""meta2""/>Unsupported MetadataThe following metadata types do not currently have built-in support. However, they can still be rendered in the layout or page itself.MetadataRecommendation<meta http-equiv=""..."">Use appropriate HTTP Headers viaredirect(),Middleware,Security Headers<base>Render the tag in the layout or page itself.<noscript>Render the tag in the layout or page itself.<style>Learn more aboutstyling in Next.js.<script>Learn more aboutusing scripts.<link rel=""stylesheet"" />importstylesheets directly in the layout or page itself.<link rel=""preload />UseReactDOM preload method<link rel=""preconnect"" />UseReactDOM preconnect method<link rel=""dns-prefetch"" />UseReactDOM prefetchDNS methodResource hintsThe<link>element has a number ofrelkeywords that can be used to hint to the browser that an external resource is likely to be needed. The browser uses this information to apply preloading optimizations depending on the keyword.While the Metadata API doesn't directly support these hints, you can use newReactDOMmethodsto safely insert them into the<head>of the document.app/preload-resources.tsxTypeScriptJavaScriptTypeScript'use client'importReactDOMfrom'react-dom'exportfunctionPreloadResources() {ReactDOM.preload('...',{ as:'...'})ReactDOM.preconnect('...',{ crossOrigin:'...'})ReactDOM.prefetchDNS('...')return'...'}<link rel=""preload"">Start loading a resource early in the page rendering (browser) lifecycle.MDN Docs.ReactDOM.preload(href: string,options: { as:string })<head> output<linkrel=""preload""href=""...""as=""...""/><link rel=""preconnect"">Preemptively initiate a connection to an origin.MDN Docs.ReactDOM.preconnect(href: string,options?:{ crossOrigin?:string })<head> output<linkrel=""preconnect""href=""...""crossorigin/><link rel=""dns-prefetch"">Attempt to resolve a domain name before resources get requested.MDN Docs.ReactDOM.prefetchDNS(href: string)<head> output<linkrel=""dns-prefetch""href=""...""/>Good to know:These methods are currently only supported in Client Components, which are still Server Side Rendered on initial page load.Next.js in-built features such asnext/font,next/imageandnext/scriptautomatically handle relevant resource hints.TypesYou can add type safety to your metadata by using theMetadatatype. If you are using thebuilt-in TypeScript pluginin your IDE, you do not need to manually add the type, but you can still explicitly add it if you want.metadataobjectlayout.tsx | page.tsximporttype{ Metadata }from'next'exportconstmetadata:Metadata={title:'Next.js',}generateMetadatafunctionRegular functionlayout.tsx | page.tsximporttype{ Metadata }from'next'exportfunctiongenerateMetadata():Metadata{return{title:'Next.js',}}Async functionlayout.tsx | page.tsximporttype{ Metadata }from'next'exportasyncfunctiongenerateMetadata():Promise<Metadata> {return{title:'Next.js',}}With segment propslayout.tsx | page.tsximporttype{ Metadata }from'next'typeProps={params:Promise<{ id:string}>searchParams:Promise<{ [key:string]:string|string[]|undefined}>}exportfunctiongenerateMetadata({ params,searchParams }:Props):Metadata{return{title:'Next.js',}}exportdefaultfunctionPage({ params,searchParams }:Props) {}With parent metadatalayout.tsx | page.tsximporttype{ Metadata,ResolvingMetadata }from'next'exportasyncfunctiongenerateMetadata({ params,searchParams }:Props,parent:ResolvingMetadata):Promise<Metadata> {return{title:'Next.js',}}JavaScript ProjectsFor JavaScript projects, you can use JSDoc to add type safety.layout.js | page.js/**@type{import(""next"").Metadata}*/exportconstmetadata={title:'Next.js',}Streaming MetadataStarting from v15.2, metadata returned bygenerateMetadatawill be streamed to the client. This allows Next.js to inject metadata into the HTML as soon as it's resolved.Since page metadata often primarily targets bots & crawlers, Next.js will continue to block the render until the metadata is resolved forHTML-limited bots.Some bots, likeGooglebot, can execute JavaScript and are able to inspect the full page DOM, meaning theydon'trequire blocking metadata. However, bots likeTwitterbotcannotexecute JavaScript while crawling a page—they fall into theHTML-limitedcategory.Next.js automatically detects the user agent of incoming requests to determine whether to serve streaming metadata or fallback to blocking metadata.If you need to customize this list, you can define them manually using thehtmlLimitedBotsoption innext.config.js. Next.js will ensure user agents matching this regex receive blocking metadata when requesting your web page.
Specifying ahtmlLimitedBotsconfig will override the Next.js' default list, allowing you full control over what user agents should opt into this behavior. This is advanced behavior, and the default should be sufficient for most cases.next.config.jsmodule.exports={htmlLimitedBots:'MySpecialBot|MyAnotherSpecialBot|SimpleCrawler',}Note:Next.js includesa default list of HTML limited botsVersion HistoryVersionChangesv15.2.0introduced streaming support togenerateMetadata.v13.2.0viewport,themeColor, andcolorSchemedeprecated in favor of theviewportconfiguration.v13.2.0metadataandgenerateMetadataintroduced.Next StepsView all the Metadata API options.Metadata FilesAPI documentation for the metadata file conventions.generateViewportAPI Reference for the generateViewport function.MetadataUse the Metadata API to define metadata in any layout or page.PreviousgenerateImageMetadataNextgenerateSitemapsWas this helpful?supported.Send"
generatesitemaps,generateSitemaps,"API ReferenceFunctionsgenerateSitemapsgenerateSitemapsYou can use thegenerateSitemapsfunction to generate multiple sitemaps for your application.ReturnsThegenerateSitemapsreturns an array of objects with anidproperty.URLsYour generated sitemaps will be available at/.../sitemap/[id].xml. For example,/product/sitemap/1.xml.ExampleFor example, to split a sitemap usinggenerateSitemaps, return an array of objects with the sitemapid. Then, use theidto generate the unique sitemaps.app/product/sitemap.tsTypeScriptJavaScriptTypeScriptimport{ BASE_URL }from'@/app/lib/constants'exportasyncfunctiongenerateSitemaps() {// Fetch the total number ofproducts and calculate the number of sitemaps neededreturn[{ id:0},{ id:1},{ id:2},{ id:3}]}exportdefaultasyncfunctionsitemap({id,}:{id:number}):Promise<MetadataRoute.Sitemap> {// Google's limit is 50,000 URLs per sitemapconststart=id*50000constend=start+50000constproducts=awaitgetProducts(`SELECT id, date FROMproducts WHERE id BETWEEN${start}AND${end}`)returnproducts.map((product)=>({url:`${BASE_URL}/product/${product.id}`,lastModified:product.date,}))}Version HistoryVersionChangesv15.0.0generateSitemapsnow generates consistent URLs between development and productionv13.3.2generateSitemapsintroduced. In development, you can view the generated sitemap on/.../sitemap.xml/[id]. For example,/product/sitemap.xml/1.Next StepsLearn how to create sitemaps for your Next.js application.sitemap.xmlAPI Reference for the sitemap.xml file.PreviousgenerateMetadataNextgenerateStaticParamsWas this helpful?supported.Send"
generatestaticparams,generateStaticParams,"API ReferenceFunctionsgenerateStaticParamsgenerateStaticParamsThegenerateStaticParamsfunction can be used in combination withdynamic route segmentstostatically generateroutes at build time instead of on-demand at request time.app/blog/[slug]/page.tsxTypeScriptJavaScriptTypeScript// Return a list of `params` to populate the [slug] dynamic segmentexportasyncfunctiongenerateStaticParams() {constposts=awaitfetch('https://.../posts').then((res)=>res.json())returnposts.map((post)=>({slug:post.slug,}))}// Multiple versions of this page will be statically generated// using the `params` returned by `generateStaticParams`exportdefaultasyncfunctionPage({params,}:{params:Promise<{ slug:string}>}) {const{slug}=awaitparams// ...}Good to know:You can use thedynamicParamssegment config option to control what happens when a dynamic segment is visited that was not generated withgenerateStaticParams.You must returnan empty array fromgenerateStaticParamsor utilizeexport const dynamic = 'force-static'in order to revalidate (ISR)paths at runtime.Duringnext dev,generateStaticParamswill be called when you navigate to a route.Duringnext build,generateStaticParamsruns before the corresponding Layouts or Pages are generated.During revalidation (ISR),generateStaticParamswill not be called again.generateStaticParamsreplaces thegetStaticPathsfunction in the Pages Router.Parametersoptions.params(optional)If multiple dynamic segments in a route usegenerateStaticParams, the childgenerateStaticParamsfunction is executed once for each set ofparamsthe parent generates.Theparamsobject contains the populatedparamsfrom the parentgenerateStaticParams, which can be used togenerate theparamsin a child segment.ReturnsgenerateStaticParamsshould return an array of objects where each object represents the populated dynamic segments of a single route.Each property in the object is a dynamic segment to be filled in for the route.The properties name is the segment's name, and the properties value is what that segment should be filled in with.Example RoutegenerateStaticParamsReturn Type/product/[id]{ id: string }[]/products/[category]/[product]{ category: string, product: string }[]/products/[...slug]{ slug: string[] }[]Single Dynamic Segmentapp/product/[id]/page.tsxTypeScriptJavaScriptTypeScriptexportfunctiongenerateStaticParams() {return[{ id:'1'},{ id:'2'},{ id:'3'}]}// Three versions of this page will be statically generated// using the `params` returned by `generateStaticParams`// - /product/1// - /product/2// - /product/3exportdefaultasyncfunctionPage({params,}:{params:Promise<{ id:string}>}) {const{id}=awaitparams// ...}Multiple Dynamic Segmentsapp/products/[category]/[product]/page.tsxTypeScriptJavaScriptTypeScriptexportfunctiongenerateStaticParams() {return[{ category:'a',product:'1'},{ category:'b',product:'2'},{ category:'c',product:'3'},]}// Three versions of this page will be statically generated// using the `params` returned by `generateStaticParams`// - /products/a/1// - /products/b/2// - /products/c/3exportdefaultasyncfunctionPage({params,}:{params:Promise<{ category:string; product:string}>}) {const{category,product}=awaitparams// ...}Catch-all Dynamic Segmentapp/product/[...slug]/page.tsxTypeScriptJavaScriptTypeScriptexportfunctiongenerateStaticParams() {return[{ slug:['a','1'] },{ slug:['b','2'] },{ slug:['c','3'] }]}// Three versions of this page will be statically generated// using the `params` returned by `generateStaticParams`// - /product/a/1// - /product/b/2// - /product/c/3exportdefaultasyncfunctionPage({params,}:{params:Promise<{ slug:string[] }>}) {const{slug}=awaitparams// ...}ExamplesStatic RenderingAll paths at build timeTo statically render all paths at build time, supply the full list of paths togenerateStaticParams:app/blog/[slug]/page.tsxTypeScriptJavaScriptTypeScriptexportasyncfunctiongenerateStaticParams() {constposts=awaitfetch('https://.../posts').then((res)=>res.json())returnposts.map((post)=>({slug:post.slug,}))}Subset of paths at build timeTo statically render a subset of paths at build time, and the rest the first time they're visited at runtime, return a partial list of paths:app/blog/[slug]/page.tsxTypeScriptJavaScriptTypeScriptexportasyncfunctiongenerateStaticParams() {constposts=awaitfetch('https://.../posts').then((res)=>res.json())// Render the first 10 posts at build timereturnposts.slice(0,10).map((post)=>({slug:post.slug,}))}Then, by using thedynamicParamssegment config option, you can control what happens when a dynamic segment is visited that was not generated withgenerateStaticParams.app/blog/[slug]/page.tsxTypeScriptJavaScriptTypeScript// All posts besides the top 10 will be a 404exportconstdynamicParams=falseexportasyncfunctiongenerateStaticParams() {constposts=awaitfetch('https://.../posts').then((res)=>res.json())consttopPosts=posts.slice(0,10)returntopPosts.map((post)=>({slug:post.slug,}))}All paths at runtimeTo statically render all paths the first time they're visited, return an empty array (no paths will be rendered at build time) or utilizeexport const dynamic = 'force-static':app/blog/[slug]/page.jsexportasyncfunctiongenerateStaticParams() {return[]}Good to know:You must always return an array fromgenerateStaticParams, even if it's empty. Otherwise, the route will be dynamically rendered.app/changelog/[slug]/page.jsexportconstdynamic='force-static'Disable rendering for unspecified pathsTo prevent unspecified paths from being statically rendered at runtime, add theexport const dynamicParams = falseoption in a route segment. When this config option is used, only paths provided bygenerateStaticParamswill be served, and unspecified routes will 404 or match (in the case ofcatch-all routes).Multiple Dynamic Segments in a RouteYou can generate params for dynamic segments above the current layout or page, butnot below. For example, given theapp/products/[category]/[product]route:app/products/[category]/[product]/page.jscan generate params forboth[category]and[product].app/products/[category]/layout.jscanonlygenerate params for[category].There are two approaches to generating params for a route with multiple dynamic segments:Generate params from the bottom upGenerate multiple dynamic segments from the child route segment.app/products/[category]/[product]/page.tsxTypeScriptJavaScriptTypeScript// Generate segments for both [category] and [product]exportasyncfunctiongenerateStaticParams() {constproducts=awaitfetch('https://.../products').then((res)=>res.json())returnproducts.map((product)=>({category:product.category.slug,product:product.id,}))}exportdefaultfunctionPage({params,}:{params:Promise<{ category:string; product:string}>}) {// ...}Generate params from the top downGenerate the parent segments first and use the result to generate the child segments.app/products/[category]/layout.tsxTypeScriptJavaScriptTypeScript// Generate segments for [category]exportasyncfunctiongenerateStaticParams() {constproducts=awaitfetch('https://.../products').then((res)=>res.json())returnproducts.map((product)=>({category:product.category.slug,}))}exportdefaultfunctionLayout({params,}:{params:Promise<{ category:string}>}) {// ...}A child route segment'sgenerateStaticParamsfunction is executed once for each segment a parentgenerateStaticParamsgenerates.The childgenerateStaticParamsfunction can use theparamsreturned from the parentgenerateStaticParamsfunction to dynamically generate its own segments.app/products/[category]/[product]/page.tsxTypeScriptJavaScriptTypeScript// Generate segments for [product] using the `params` passed from// the parent segment's `generateStaticParams` functionexportasyncfunctiongenerateStaticParams({params: { category },}:{params:{ category:string}}) {constproducts=awaitfetch(`https://.../products?category=${category}`).then((res)=>res.json())returnproducts.map((product)=>({product:product.id,}))}exportdefaultfunctionPage({params,}:{params:Promise<{ category:string; product:string}>}) {// ...}Good to know:fetchrequests are automaticallymemoizedfor the same data across allgenerate-prefixed functions, Layouts, Pages, and Server Components. Reactcachecan be usediffetchis unavailable.Version HistoryVersionChangesv13.0.0generateStaticParamsintroduced.PreviousgenerateSitemapsNextgenerateViewportWas this helpful?supported.Send"
generateviewport,generateViewport,"API ReferenceFunctionsgenerateViewportgenerateViewportYou can customize the initial viewport of the page with the staticviewportobject or the dynamicgenerateViewportfunction.Good to know:Theviewportobject andgenerateViewportfunction exports areonly supported in Server Components.You cannot export both theviewportobject andgenerateViewportfunction from the same route segment.If you're coming from migratingmetadataexports, you can usemetadata-to-viewport-export codemodto update your changes.TheviewportobjectTo define the viewport options, export aviewportobject from alayout.jsxorpage.jsxfile.layout.tsx | page.tsxTypeScriptJavaScriptTypeScriptimporttype{ Viewport }from'next'exportconstviewport:Viewport={themeColor:'black',}exportdefaultfunctionPage() {}generateViewportfunctiongenerateViewportshould return aViewportobjectcontaining one or more viewport fields.layout.tsx | page.tsxTypeScriptJavaScriptTypeScriptexportfunctiongenerateViewport({ params }) {return{themeColor:'...',}}Good to know:If the viewport doesn't depend on runtime information, it should be defined using the staticviewportobjectrather thangenerateViewport.Viewport FieldsthemeColorLearn more abouttheme-color.Simple theme colorlayout.tsx | page.tsxTypeScriptJavaScriptTypeScriptimporttype{ Viewport }from'next'exportconstviewport:Viewport={themeColor:'black',}<head> output<metaname=""theme-color""content=""black""/>With media attributelayout.tsx | page.tsxTypeScriptJavaScriptTypeScriptimporttype{ Viewport }from'next'exportconstviewport:Viewport={themeColor:[{ media:'(prefers-color-scheme: light)',color:'cyan'},{ media:'(prefers-color-scheme: dark)',color:'black'},],}<head> output<metaname=""theme-color""media=""(prefers-color-scheme: light)""content=""cyan""/><metaname=""theme-color""media=""(prefers-color-scheme: dark)""content=""black""/>width,initialScale,maximumScaleanduserScalableGood to know: Theviewportmeta tag is automatically set, and manual configuration is usually unnecessary as the default is sufficient. However, the information is provided for completeness.layout.tsx | page.tsxTypeScriptJavaScriptTypeScriptimporttype{ Viewport }from'next'exportconstviewport:Viewport={width:'device-width',initialScale:1,maximumScale:1,userScalable:false,// Also supported but less commonly used// interactiveWidget: 'resizes-visual',}<head> output<metaname=""viewport""content=""width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no""/>colorSchemeLearn more aboutcolor-scheme.layout.tsx | page.tsxTypeScriptJavaScriptTypeScriptimporttype{ Viewport }from'next'exportconstviewport:Viewport={colorScheme:'dark',}<head> output<metaname=""color-scheme""content=""dark""/>TypesYou can add type safety to your viewport object by using theViewporttype. If you are using thebuilt-in TypeScript pluginin your IDE, you do not need to manually add the type, but you can still explicitly add it if you want.viewportobjectimporttype{ Viewport }from'next'exportconstviewport:Viewport={themeColor:'black',}generateViewportfunctionRegular functionimporttype{ Viewport }from'next'exportfunctiongenerateViewport():Viewport{return{themeColor:'black',}}With segment propsimporttype{ Viewport }from'next'typeProps={params:Promise<{ id:string}>searchParams:Promise<{ [key:string]:string|string[]|undefined}>}exportfunctiongenerateViewport({ params,searchParams }:Props):Viewport{return{themeColor:'black',}}exportdefaultfunctionPage({ params,searchParams }:Props) {}JavaScript ProjectsFor JavaScript projects, you can use JSDoc to add type safety./**@type{import(""next"").Viewport}*/exportconstviewport={themeColor:'black',}Version HistoryVersionChangesv14.0.0viewportandgenerateViewportintroduced.Next StepsView all the Metadata API options.Metadata FilesAPI documentation for the metadata file conventions.MetadataUse the Metadata API to define metadata in any layout or page.PreviousgenerateStaticParamsNextheadersWas this helpful?supported.Send"
headers,headers,"API ReferenceFunctionsheadersheadersheadersis anasyncfunction that allows you toreadthe HTTP incoming request headers from aServer Component.app/page.tsxTypeScriptJavaScriptTypeScriptimport{ headers }from'next/headers'exportdefaultasyncfunctionPage() {constheadersList=awaitheaders()constuserAgent=headersList.get('user-agent')}ReferenceParametersheadersdoes not take any parameters.Returnsheadersreturns aread-onlyWeb Headersobject.Headers.entries(): Returns aniteratorallowing to go through all key/value pairs contained in this object.Headers.forEach(): Executes a provided function once for each key/value pair in thisHeadersobject.Headers.get(): Returns aStringsequence of all the values of a header within aHeadersobject with a given name.Headers.has(): Returns a boolean stating whether aHeadersobject contains a certain header.Headers.keys(): Returns aniteratorallowing you to go through all keys of the key/value pairs contained in this object.Headers.values(): Returns aniteratorallowing you to go through all values of the key/value pairs contained in this object.Good to knowheadersis anasynchronousfunction that returns a promise. You must useasync/awaitor React'susefunction.In version 14 and earlier,headerswas a synchronous function. To help with backwards compatibility, you can still access it synchronously in Next.js 15, but this behavior will be deprecated in the future.Sinceheadersis read-only, you cannotsetordeletethe outgoing request headers.headersis aDynamic APIwhose returned values cannot be known ahead of time. Using it in will opt a route intodynamic rendering.ExamplesUsing the Authorization headerapp/page.jsimport{ headers }from'next/headers'exportdefaultasyncfunctionPage() {constauthorization=(awaitheaders()).get('authorization')constres=awaitfetch('...',{headers:{ authorization },// Forward the authorization header})constuser=awaitres.json()return<h1>{user.name}</h1>}Version HistoryVersionChangesv15.0.0-RCheadersis now an async function. Acodemodis available.v13.0.0headersintroduced.PreviousgenerateViewportNextImageResponseWas this helpful?supported.Send"
imageresponse,ImageResponse,"API ReferenceFunctionsImageResponseImageResponseTheImageResponseconstructor allows you to generate dynamic images using JSX and CSS. This is useful for generating social media images such as Open Graph images, Twitter cards, and more.The following options are available forImageResponse:import{ ImageResponse }from'next/og'newImageResponse(element: ReactElement,options: {width?:number=1200height?:number=630emoji?:'twemoji'|'blobmoji'|'noto'|'openmoji'='twemoji',fonts?:{name:string,data:ArrayBuffer,weight:number,style:'normal'|'italic'}[]debug?:boolean=false// Options that will be passed to the HTTP responsestatus?:number=200statusText?:stringheaders?:Record<string,string>},)Supported CSS PropertiesPlease refer toSatori’s documentationfor a list of supported HTML and CSS features.Version HistoryVersionChangesv14.0.0ImageResponsemoved fromnext/servertonext/ogv13.3.0ImageResponsecan be imported fromnext/server.v13.0.0ImageResponseintroduced via@vercel/ogpackage.PreviousheadersNextNextRequestWas this helpful?supported.Send"
nextrequest,NextRequest,"API ReferenceFunctionsNextRequestNextRequestNextRequest extends theWeb Request APIwith additional convenience methods.cookiesRead or mutate theSet-Cookieheader of the request.set(name, value)Given a name, set a cookie with the given value on the request.// Given incoming request /home// Set a cookie to hide the banner// request will have a `Set-Cookie:show-banner=false;path=/home` headerrequest.cookies.set('show-banner','false')get(name)Given a cookie name, return the value of the cookie. If the cookie is not found,undefinedis returned. If multiple cookies are found, the first one is returned.// Given incoming request /home// { name: 'show-banner', value: 'false', Path: '/home' }request.cookies.get('show-banner')getAll()Given a cookie name, return the values of the cookie. If no name is given, return all cookies on the request.// Given incoming request /home// [//   { name: 'experiments', value: 'new-pricing-page', Path: '/home' },//   { name: 'experiments', value: 'winter-launch', Path: '/home' },// ]request.cookies.getAll('experiments')// Alternatively, get all cookies for the requestrequest.cookies.getAll()delete(name)Given a cookie name, delete the cookie from the request.// Returns true for deleted, false is nothing is deletedrequest.cookies.delete('experiments')has(name)Given a cookie name, returntrueif the cookie exists on the request.// Returns true if cookie exists, false if it does notrequest.cookies.has('experiments')clear()Remove theSet-Cookieheader from the request.request.cookies.clear()nextUrlExtends the nativeURLAPI with additional convenience methods, including Next.js specific properties.// Given a request to /home, pathname is /homerequest.nextUrl.pathname// Given a request to /home?name=lee, searchParams is { 'name': 'lee' }request.nextUrl.searchParamsThe following options are available:PropertyTypeDescriptionbasePathstringThebase pathof the URL.buildIdstring|undefinedThe build identifier of the Next.js application. Can becustomized.pathnamestringThe pathname of the URL.searchParamsObjectThe search parameters of the URL.Note:The internationalization properties from the Pages Router are not available for usage in the App Router. Learn more aboutinternationalization with the App Router.Version HistoryVersionChangesv15.0.0ipandgeoremoved.PreviousImageResponseNextNextResponseWas this helpful?supported.Send"
nextresponse,NextResponse,"API ReferenceFunctionsNextResponseNextResponseNextResponse extends theWeb Response APIwith additional convenience methods.cookiesRead or mutate theSet-Cookieheader of the response.set(name, value)Given a name, set a cookie with the given value on the response.// Given incoming request /homeletresponse=NextResponse.next()// Set a cookie to hide the bannerresponse.cookies.set('show-banner','false')// Response will have a `Set-Cookie:show-banner=false;path=/home` headerreturnresponseget(name)Given a cookie name, return the value of the cookie. If the cookie is not found,undefinedis returned. If multiple cookies are found, the first one is returned.// Given incoming request /homeletresponse=NextResponse.next()// { name: 'show-banner', value: 'false', Path: '/home' }response.cookies.get('show-banner')getAll()Given a cookie name, return the values of the cookie. If no name is given, return all cookies on the response.// Given incoming request /homeletresponse=NextResponse.next()// [//   { name: 'experiments', value: 'new-pricing-page', Path: '/home' },//   { name: 'experiments', value: 'winter-launch', Path: '/home' },// ]response.cookies.getAll('experiments')// Alternatively, get all cookies for the responseresponse.cookies.getAll()delete(name)Given a cookie name, delete the cookie from the response.// Given incoming request /homeletresponse=NextResponse.next()// Returns true for deleted, false is nothing is deletedresponse.cookies.delete('experiments')json()Produce a response with the given JSON body.app/api/route.tsTypeScriptJavaScriptTypeScriptimport{ NextResponse }from'next/server'exportasyncfunctionGET(request:Request) {returnNextResponse.json({ error:'Internal Server Error'},{ status:500})}redirect()Produce a response that redirects to aURL.import{ NextResponse }from'next/server'returnNextResponse.redirect(newURL('/new',request.url))TheURLcan be created and modified before being used in theNextResponse.redirect()method. For example, you can use therequest.nextUrlproperty to get the current URL, and then modify it to redirect to a different URL.import{ NextResponse }from'next/server'// Given an incoming request...constloginUrl=newURL('/login',request.url)// Add ?from=/incoming-url to the /login URLloginUrl.searchParams.set('from',request.nextUrl.pathname)// And redirect to the new URLreturnNextResponse.redirect(loginUrl)rewrite()Produce a response that rewrites (proxies) the givenURLwhile preserving the original URL.import{ NextResponse }from'next/server'// Incoming request: /about, browser shows /about// Rewritten request: /proxy, browser shows /aboutreturnNextResponse.rewrite(newURL('/proxy',request.url))next()Thenext()method is useful for Middleware, as it allows you to return early and continue routing.import{ NextResponse }from'next/server'returnNextResponse.next()You can also forwardheaderswhen producing the response:import{ NextResponse }from'next/server'// Given an incoming request...constnewHeaders=newHeaders(request.headers)// Add a new headernewHeaders.set('x-version','123')// And produce a response with the new headersreturnNextResponse.next({request:{// New request headersheaders:newHeaders,},})PreviousNextRequestNextnotFoundWas this helpful?supported.Send"
notfound,notFound,"API ReferenceFunctionsnotFoundnotFoundThenotFoundfunction allows you to render thenot-found filewithin a route segment as well as inject a<meta name=""robots"" content=""noindex"" />tag.notFound()Invoking thenotFound()function throws aNEXT_NOT_FOUNDerror and terminates rendering of the route segment in which it was thrown. Specifying anot-foundfileallows you to gracefully handle such errors by rendering a Not Found UI within the segment.app/user/[id]/page.jsimport{ notFound }from'next/navigation'asyncfunctionfetchUser(id) {constres=awaitfetch('https://...')if(!res.ok)returnundefinedreturnres.json()}exportdefaultasyncfunctionProfile({ params }) {constuser=awaitfetchUser((awaitparams).id)if(!user) {notFound()}// ...}Good to know:notFound()does not require you to usereturn notFound()due to using the TypeScriptnevertype.Version HistoryVersionChangesv13.0.0notFoundintroduced.PreviousNextResponseNextpermanentRedirectWas this helpful?supported.Send"
permanentredirect,permanentRedirect,"API ReferenceFunctionspermanentRedirectpermanentRedirectThepermanentRedirectfunction allows you to redirect the user to another URL.permanentRedirectcan be used in Server Components, Client Components,Route Handlers, andServer Actions.When used in a streaming context, this will insert a meta tag to emit the redirect on the client side. When used in a server action, it will serve a 303 HTTP redirect response to the caller. Otherwise, it will serve a 308 (Permanent) HTTP redirect response to the caller.If a resource doesn't exist, you can use thenotFoundfunctioninstead.Good to know: If you prefer to return a 307 (Temporary) HTTP redirect instead of 308 (Permanent), you can use theredirectfunctioninstead.ParametersThepermanentRedirectfunction accepts two arguments:permanentRedirect(path,type)ParameterTypeDescriptionpathstringThe URL to redirect to. Can be a relative or absolute path.type'replace'(default) or'push'(default in Server Actions)The type of redirect to perform.By default,permanentRedirectwill usepush(adding a new entry to the browser history stack) inServer Actionsandreplace(replacing the current URL in the browser history stack) everywhere else. You can override this behavior by specifying thetypeparameter.Thetypeparameter has no effect when used in Server Components.ReturnspermanentRedirectdoes not return a value.ExampleInvoking thepermanentRedirect()function throws aNEXT_REDIRECTerror and terminates rendering of the route segment in which it was thrown.app/team/[id]/page.jsimport{ permanentRedirect }from'next/navigation'asyncfunctionfetchTeam(id) {constres=awaitfetch('https://...')if(!res.ok)returnundefinedreturnres.json()}exportdefaultasyncfunctionProfile({ params }) {constteam=awaitfetchTeam((awaitparams).id)if(!team) {permanentRedirect('/login')}// ...}Good to know:permanentRedirectdoes not require you to usereturn permanentRedirect()as it uses the TypeScriptnevertype.Next StepsredirectAPI Reference for the redirect function.PreviousnotFoundNextredirectWas this helpful?supported.Send"
redirect,redirect,"API ReferenceFunctionsredirectredirectTheredirectfunction allows you to redirect the user to another URL.redirectcan be used inServer Components,Route Handlers, andServer Actions.When used in astreaming context, this will insert a meta tag to emit the redirect on the client side. When used in a server action, it will serve a 303 HTTP redirect response to the caller. Otherwise, it will serve a 307 HTTP redirect response to the caller.If a resource doesn't exist, you can use thenotFoundfunctioninstead.Good to know:In Server Actions and Route Handlers,redirectshould be called after thetry/catchblock.If you prefer to return a 308 (Permanent) HTTP redirect instead of 307 (Temporary), you can use thepermanentRedirectfunctioninstead.ParametersTheredirectfunction accepts two arguments:redirect(path,type)ParameterTypeDescriptionpathstringThe URL to redirect to. Can be a relative or absolute path.type'replace'(default) or'push'(default in Server Actions)The type of redirect to perform.By default,redirectwill usepush(adding a new entry to the browser history stack) inServer Actionsandreplace(replacing the current URL in the browser history stack) everywhere else. You can override this behavior by specifying thetypeparameter.Thetypeparameter has no effect when used in Server Components.Returnsredirectdoes not return a value.ExampleServer ComponentInvoking theredirect()function throws aNEXT_REDIRECTerror and terminates rendering of the route segment in which it was thrown.app/team/[id]/page.tsxTypeScriptJavaScriptTypeScriptimport{ redirect }from'next/navigation'asyncfunctionfetchTeam(id:string) {constres=awaitfetch('https://...')if(!res.ok)returnundefinedreturnres.json()}exportdefaultasyncfunctionProfile({params,}:{params:Promise<{ id:string}>}) {const{id}=awaitparamsconstteam=awaitfetchTeam(id)if(!team) {redirect('/login')}// ...}Good to know:redirectdoes not require you to usereturn redirect()as it uses the TypeScriptnevertype.Client Componentredirectcan be used in a Client Component through a Server Action. If you need to use an event handler to redirect the user, you can use theuseRouterhook.app/client-redirect.tsxTypeScriptJavaScriptTypeScript'use client'import{ navigate }from'./actions'exportfunctionClientRedirect() {return(<formaction={navigate}><inputtype=""text""name=""id""/><button>Submit</button></form>)}app/actions.tsTypeScriptJavaScriptTypeScript'use server'import{ redirect }from'next/navigation'exportasyncfunctionnavigate(data:FormData) {redirect(`/posts/${data.get('id')}`)}FAQWhy doesredirectuse 307 and 308?When usingredirect()you may notice that the status codes used are307for a temporary redirect, and308for a permanent redirect. While traditionally a302was used for a temporary redirect, and a301for a permanent redirect, many browsers changed the request method of the redirect, from aPOSTtoGETrequest when using a302, regardless of the origins request method.Taking the following example of a redirect from/usersto/people, if you make aPOSTrequest to/usersto create a new user, and are conforming to a302temporary redirect, the request method will be changed from aPOSTto aGETrequest. This doesn't make sense, as to create a new user, you should be making aPOSTrequest to/people, and not aGETrequest.The introduction of the307status code means that the request method is preserved asPOST.302- Temporary redirect, will change the request method fromPOSTtoGET307- Temporary redirect, will preserve the request method asPOSTTheredirect()method uses a307by default, instead of a302temporary redirect, meaning your requests willalwaysbe preserved asPOSTrequests.Learn moreabout HTTP Redirects.Version HistoryVersionChangesv13.0.0redirectintroduced.Next StepspermanentRedirectAPI Reference for the permanentRedirect function.PreviouspermanentRedirectNextrevalidatePathWas this helpful?supported.Send"
revalidatepath,revalidatePath,"API ReferenceFunctionsrevalidatePathrevalidatePathrevalidatePathallows you to purgecached dataon-demand for a specific path.Good to know:revalidatePathonly invalidates the cache when the included path is next visited. This means callingrevalidatePathwith a dynamic route segment will not immediately trigger many revalidations at once. The invalidation only happens when the path is next visited.Currently,revalidatePathinvalidates all the routes in theclient-side Router Cachewhen used in a server action. This behavior is temporary and will be updated in the future to apply only to the specific path.UsingrevalidatePathinvalidatesonly the specific pathin theserver-side Route Cache.ParametersrevalidatePath(path: string,type?:'page'|'layout'):void;path: Either a string representing the filesystem path associated with the data you want to revalidate (for example,/product/[slug]/page), or the literal route segment (for example,/product/123). Must be less than 1024 characters. This value is case-sensitive.type: (optional)'page'or'layout'string to change the type of path to revalidate. Ifpathcontains a dynamic segment (for example,/product/[slug]/page), this parameter is required. If path refers to the literal route segment, e.g.,/product/1for a dynamic page (e.g.,/product/[slug]/page), you should not providetype.ReturnsrevalidatePathdoes not return a value.ExamplesRevalidating A Specific URLimport{ revalidatePath }from'next/cache'revalidatePath('/blog/post-1')This will revalidate one specific URL on the next page visit.Revalidating A Page Pathimport{ revalidatePath }from'next/cache'revalidatePath('/blog/[slug]','page')// or with route groupsrevalidatePath('/(main)/blog/[slug]','page')This will revalidate any URL that matches the providedpagefile on the next page visit. This willnotinvalidate pages beneath the specific page. For example,/blog/[slug]won't invalidate/blog/[slug]/[author].Revalidating A Layout Pathimport{ revalidatePath }from'next/cache'revalidatePath('/blog/[slug]','layout')// or with route groupsrevalidatePath('/(main)/post/[slug]','layout')This will revalidate any URL that matches the providedlayoutfile on the next page visit. This will cause pages beneath with the same layout to revalidate on the next visit. For example, in the above case,/blog/[slug]/[another]would also revalidate on the next visit.Revalidating All Dataimport{ revalidatePath }from'next/cache'revalidatePath('/','layout')This will purge the Client-side Router Cache, and revalidate the Data Cache on the next page visit.Server Actionapp/actions.tsTypeScriptJavaScriptTypeScript'use server'import{ revalidatePath }from'next/cache'exportdefaultasyncfunctionsubmit() {awaitsubmitForm()revalidatePath('/')}Route Handlerapp/api/revalidate/route.tsTypeScriptJavaScriptTypeScriptimport{ revalidatePath }from'next/cache'importtype{ NextRequest }from'next/server'exportasyncfunctionGET(request:NextRequest) {constpath=request.nextUrl.searchParams.get('path')if(path) {revalidatePath(path)returnResponse.json({ revalidated:true,now:Date.now() })}returnResponse.json({revalidated:false,now:Date.now(),message:'Missing path to revalidate',})}PreviousredirectNextrevalidateTagWas this helpful?supported.Send"
revalidatetag,revalidateTag,"API ReferenceFunctionsrevalidateTagrevalidateTagrevalidateTagallows you to purgecached dataon-demand for a specific cache tag.Good to know:revalidateTagonly invalidates the cache when the path is next visited. This means callingrevalidateTagwith a dynamic route segment will not immediately trigger many revalidations at once. The invalidation only happens when the path is next visited.ParametersrevalidateTag(tag: string):void;tag: A string representing the cache tag associated with the data you want to revalidate. Must be less than or equal to 256 characters. This value is case-sensitive.You can add tags tofetchas follows:fetch(url,{ next:{ tags:[...] } });ReturnsrevalidateTagdoes not return a value.ExamplesServer Actionapp/actions.tsTypeScriptJavaScriptTypeScript'use server'import{ revalidateTag }from'next/cache'exportdefaultasyncfunctionsubmit() {awaitaddPost()revalidateTag('posts')}Route Handlerapp/api/revalidate/route.tsTypeScriptJavaScriptTypeScriptimporttype{ NextRequest }from'next/server'import{ revalidateTag }from'next/cache'exportasyncfunctionGET(request:NextRequest) {consttag=request.nextUrl.searchParams.get('tag')revalidateTag(tag)returnResponse.json({ revalidated:true,now:Date.now() })}PreviousrevalidatePathNextunauthorizedWas this helpful?supported.Send"
unauthorized,unauthorized,"API ReferenceFunctionsunauthorizedunauthorizedThis feature is currently experimental and subject to change, it's not recommended for production. Try it out and share your feedback onGitHub.Theunauthorizedfunction throws an error that renders a Next.js 401 error page. It's useful for handling authorization errors in your application. You can customize the UI using theunauthorized.jsfile.To start usingunauthorized, enable the experimentalauthInterruptsconfiguration option in yournext.config.jsfile:next.config.tsTypeScriptJavaScriptTypeScriptimporttype{ NextConfig }from'next'constnextConfig:NextConfig={experimental:{authInterrupts:true,},}exportdefaultnextConfigunauthorizedcan be invoked inServer Components,Server Actions, andRoute Handlers.app/dashboard/page.tsxTypeScriptJavaScriptTypeScriptimport{ verifySession }from'@/app/lib/dal'import{ unauthorized }from'next/navigation'exportdefaultasyncfunctionDashboardPage() {constsession=awaitverifySession()if(!session) {unauthorized()}// Render thedashboardfor authenticated usersreturn(<main><h1>Welcome to the Dashboard</h1><p>Hi, {session.user.name}.</p></main>)}Good to knowTheunauthorizedfunction cannot be called in theroot layout.ExamplesDisplaying login UI to unauthenticated usersYou can useunauthorizedfunction to display theunauthorized.jsfile with a login UI.app/dashboard/page.tsxTypeScriptJavaScriptTypeScriptimport{ verifySession }from'@/app/lib/dal'import{ unauthorized }from'next/navigation'exportdefaultasyncfunctionDashboardPage() {constsession=awaitverifySession()if(!session) {unauthorized()}return<div>Dashboard</div>}app/unauthorized.tsxTypeScriptJavaScriptTypeScriptimportLoginfrom'@/app/components/Login'exportdefaultfunctionUnauthorizedPage() {return(<main><h1>401 - Unauthorized</h1><p>Please log in to access this page.</p><Login/></main>)}Mutations with Server ActionsYou can invokeunauthorizedin Server Actions to ensure only authenticated users can perform specific mutations.app/actions/update-profile.tsTypeScriptJavaScriptTypeScript'use server'import{ verifySession }from'@/app/lib/dal'import{ unauthorized }from'next/navigation'importdbfrom'@/app/lib/db'exportasyncfunctionupdateProfile(data:FormData) {constsession=awaitverifySession()// If the user is not authenticated, return a 401if(!session) {unauthorized()}// Proceed with mutation// ...}Fetching data with Route HandlersYou can useunauthorizedin Route Handlers to ensure only authenticated users can access the endpoint.app/api/profile/route.tsTypeScriptJavaScriptTypeScriptimport{ NextRequest,NextResponse }from'next/server'import{ verifySession }from'@/app/lib/dal'import{ unauthorized }from'next/navigation'exportasyncfunctionGET(req:NextRequest):Promise<NextResponse> {// Verify the user's sessionconstsession=awaitverifySession()// If no session exists, return a 401 and render unauthorized.tsxif(!session) {unauthorized()}// Fetch data// ...}Version HistoryVersionChangesv15.1.0unauthorizedintroduced.Next Stepsunauthorized.jsAPI reference for the unauthorized.js special file.PreviousrevalidateTagNextunstable_cacheWas this helpful?supported.Send"
unstable_cache,unstable_cache,"API ReferenceFunctionsunstable_cacheunstable_cacheNote:This API will be replaced byuse cachewhen it reaches stability.unstable_cacheallows you to cache the results of expensive operations, like database queries, and reuse them across multiple requests.import{ getUser }from'./data';import{ unstable_cache }from'next/cache';constgetCachedUser=unstable_cache(async(id)=>getUser(id),['my-app-user']);exportdefaultasyncfunctionComponent({ userID }) {constuser=awaitgetCachedUser(userID);...}Good to know:Accessing dynamic data sources such asheadersorcookiesinside a cache scope is not supported. If you need this data inside a cached function useheadersoutside of the cached function and pass the required dynamic data in as an argument.This API uses Next.js' built-inData Cacheto persist the result across requests and deployments.Warning: This API is unstable and may change in the future. We will provide migration documentation and codemods, if needed, as this API stabilizes.Parametersconstdata=unstable_cache(fetchData,keyParts,options)()fetchData: This is an asynchronous function that fetches the data you want to cache. It must be a function that returns aPromise.keyParts: This is an extra array of keys that further adds identification to the cache. By default,unstable_cachealready uses the arguments and the stringified version of your function as the cache key. It is optional in most cases; the only time you need to use it is when you use external variables without passing them as parameters. However, it is important to add closures used within the function if you do not pass them as parameters.options: This is an object that controls how the cache behaves. It can contain the following properties:tags: An array of tags that can be used to control cache invalidation. Next.js will not use this to uniquely identify the function.revalidate: The number of seconds after which the cache should be revalidated. Omit or passfalseto cache indefinitely or until matchingrevalidateTag()orrevalidatePath()methods are called.Returnsunstable_cachereturns a function that when invoked, returns a Promise that resolves to the cached data. If the data is not in the cache, the provided function will be invoked, and its result will be cached and returned.Exampleapp/page.tsxTypeScriptJavaScriptTypeScriptimport{ unstable_cache }from'next/cache'exportdefaultasyncfunctionPage({params,}:{params:Promise<{ userId:string}>}) {constuserId=(awaitparams).userIdconstgetCachedUser=unstable_cache(async()=>{return{ id:userId }},[userId],// add the user ID to the cache key{tags:['users'],revalidate:60,})//...}Version HistoryVersionChangesv14.0.0unstable_cacheintroduced.PreviousunauthorizedNextunstable_noStoreWas this helpful?supported.Send"
unstable_nostore,unstable_noStore,"API ReferenceFunctionsunstable_noStoreunstable_noStoreThis is a legacy API and no longer recommended. It's still supported for backward compatibility.In version 15, we recommend usingconnectioninstead ofunstable_noStore.unstable_noStorecan be used to declaratively opt out of static rendering and indicate a particular component should not be cached.import{ unstable_noStoreasnoStore }from'next/cache';exportdefaultasyncfunctionServerComponent() {noStore();constresult=awaitdb.query(...);...}Good to know:unstable_noStoreis equivalent tocache: 'no-store'on afetchunstable_noStoreis preferred overexport const dynamic = 'force-dynamic'as it is more granular and can be used on a per-component basisUsingunstable_noStoreinsideunstable_cachewill not opt out of static generation. Instead, it will defer to the cache configuration to determine whether to cache the result or not.UsageIf you prefer not to pass additional options tofetch, likecache: 'no-store',next: { revalidate: 0 }or in cases wherefetchis not available, you can usenoStore()as a replacement for all of these use cases.import{ unstable_noStoreasnoStore }from'next/cache';exportdefaultasyncfunctionServerComponent() {noStore();constresult=awaitdb.query(...);...}Version HistoryVersionChangesv15.0.0unstable_noStoredeprecated forconnection.v14.0.0unstable_noStoreintroduced.Previousunstable_cacheNextunstable_rethrowWas this helpful?supported.Send"
unstable_rethrow,unstable_rethrow,"API ReferenceFunctionsunstable_rethrowunstable_rethrowThis feature is currently unstable and subject to change, it's not recommended for production. Try it out and share your feedback onGitHub.unstable_rethrowcan be used to avoid catching internal errors thrown by Next.js when attempting to handle errors thrown in your application code.For example, calling thenotFoundfunction will throw an internal Next.js error and render thenot-found.jscomponent. However, if used inside atry/catchblock, the error will be caught, preventingnot-found.jsfrom rendering:@/app/ui/component.tsximport{ notFound }from'next/navigation'exportdefaultasyncfunctionPage() {try{constpost=awaitfetch('https://.../posts/1').then((res)=>{if(res.status===404)notFound()if(!res.ok)thrownewError(res.statusText)returnres.json()})}catch(err) {console.error(err)}}You can useunstable_rethrowAPI to re-throw the internal error and continue with the expected behavior:@/app/ui/component.tsximport{ notFound,unstable_rethrow }from'next/navigation'exportdefaultasyncfunctionPage() {try{constpost=awaitfetch('https://.../posts/1').then((res)=>{if(res.status===404)notFound()if(!res.ok)thrownewError(res.statusText)returnres.json()})}catch(err) {unstable_rethrow(err)console.error(err)}}The following Next.js APIs rely on throwing an error which should be rethrown and handled by Next.js itself:notFound()redirect()permanentRedirect()If a route segment is marked to throw an error unless it's static, a Dynamic API call will also throw an error that should similarly not be caught by the developer. Note that Partial Prerendering (PPR) affects this behavior as well. These APIs are:cookiesheaderssearchParamsfetch(..., { cache: 'no-store' })fetch(..., { next: { revalidate: 0 } })Good to know:This method should be called at the top of the catch block, passing the error object as its only argument. It can also be used within a.catchhandler of a promise.If you ensure that your calls to APIs that throw are not wrapped in a try/catch then you don't need to useunstable_rethrowAny resource cleanup (like clearing intervals, timers, etc) would have to either happen prior to the call tounstable_rethrowor within afinallyblock.Previousunstable_noStoreNextuseParamsWas this helpful?supported.Send"
useparams,useParams,"API ReferenceFunctionsuseParamsuseParamsuseParamsis aClient Componenthook that lets you read a route'sdynamic paramsfilled in by the current URL.app/example-client-component.tsxTypeScriptJavaScriptTypeScript'use client'import{ useParams }from'next/navigation'exportdefaultfunctionExampleClientComponent() {constparams=useParams<{ tag:string; item:string}>()// Route -> /shop/[tag]/[item]// URL -> /shop/shoes/nike-air-max-97// `params` -> { tag: 'shoes', item: 'nike-air-max-97' }console.log(params)return'...'}Parametersconstparams=useParams()useParamsdoes not take any parameters.ReturnsuseParamsreturns an object containing the current route's filled indynamic parameters.Each property in the object is an active dynamic segment.The properties name is the segment's name, and the properties value is what the segment is filled in with.The properties value will either be astringor array ofstring's depending on thetype of dynamic segment.If the route contains no dynamic parameters,useParamsreturns an empty object.If used in Pages Router,useParamswill returnnullon the initial render and updates with properties following the rules above once the router is ready.For example:RouteURLuseParams()app/shop/page.js/shop{}app/shop/[slug]/page.js/shop/1{ slug: '1' }app/shop/[tag]/[item]/page.js/shop/1/2{ tag: '1', item: '2' }app/shop/[...slug]/page.js/shop/1/2{ slug: ['1', '2'] }Version HistoryVersionChangesv13.3.0useParamsintroduced.Previousunstable_rethrowNextusePathnameWas this helpful?supported.Send"
usepathname,usePathname,"API ReferenceFunctionsusePathnameusePathnameusePathnameis aClient Componenthook that lets you read the current URL'spathname.app/example-client-component.tsxTypeScriptJavaScriptTypeScript'use client'import{ usePathname }from'next/navigation'exportdefaultfunctionExampleClientComponent() {constpathname=usePathname()return<p>Current pathname: {pathname}</p>}usePathnameintentionally requires using aClient Component. It's important to note Client Components are not a de-optimization. They are an integral part of theServer Componentsarchitecture.For example, a Client Component withusePathnamewill be rendered into HTML on the initial page load. When navigating to a new route, this component does not need to be re-fetched. Instead, the component is downloaded once (in the client JavaScript bundle), and re-renders based on the current state.Good to know:Reading the current URL from aServer Componentis not supported. This design is intentional to support layout state being preserved across page navigations.Compatibility mode:usePathnamecan returnnullwhen afallback routeis being rendered or when apagesdirectory page has beenautomatically statically optimizedby Next.js and the router is not ready.When usingusePathnamewith rewrites innext.configorMiddleware,useStateanduseEffectmust also be used in order to avoid hydration mismatch errors. See therewrites examplefor more information.Next.js will automatically update your types if it detects both anappandpagesdirectory in your project.Parametersconstpathname=usePathname()usePathnamedoes not take any parameters.ReturnsusePathnamereturns a string of the current URL's pathname. For example:URLReturned value/'/'/dashboard'/dashboard'/dashboard?v=2'/dashboard'/blog/hello-world'/blog/hello-world'ExamplesDo something in response to a route changeapp/example-client-component.tsxTypeScriptJavaScriptTypeScript'use client'import{ usePathname,useSearchParams }from'next/navigation'functionExampleClientComponent() {constpathname=usePathname()constsearchParams=useSearchParams()useEffect(()=>{// Do something here...},[pathname,searchParams])}VersionChangesv13.0.0usePathnameintroduced.PrevioususeParamsNextuseReportWebVitalsWas this helpful?supported.Send"
usereportwebvitals,useReportWebVitals,"API ReferenceFunctionsuseReportWebVitalsuseReportWebVitalsTheuseReportWebVitalshook allows you to reportCore Web Vitals, and can be used in combination with your analytics service.app/_components/web-vitals.js'use client'import{ useReportWebVitals }from'next/web-vitals'exportfunctionWebVitals() {useReportWebVitals((metric)=>{console.log(metric)})returnnull}app/layout.jsimport{ WebVitals }from'./_components/web-vitals'exportdefaultfunctionLayout({ children }) {return(<html><body><WebVitals/>{children}</body></html>)}Since theuseReportWebVitalshook requires the""use client""directive, the most performant approach is to create a separate component that the root layout imports. This confines the client boundary exclusively to theWebVitalscomponent.useReportWebVitalsThemetricobject passed as the hook's argument consists of a number of properties:id: Unique identifier for the metric in the context of the current page loadname: The name of the performance metric. Possible values include names ofWeb Vitalsmetrics (TTFB, FCP, LCP, FID, CLS) specific to a web application.delta: The difference between the current value and the previous value of the metric. The value is typically in milliseconds and represents the change in the metric's value over time.entries: An array ofPerformance Entriesassociated with the metric. These entries provide detailed information about the performance events related to the metric.navigationType: Indicates thetype of navigationthat triggered the metric collection. Possible values include""navigate"",""reload"",""back_forward"", and""prerender"".rating: A qualitative rating of the metric value, providing an assessment of the performance. Possible values are""good"",""needs-improvement"", and""poor"". The rating is typically determined by comparing the metric value against predefined thresholds that indicate acceptable or suboptimal performance.value: The actual value or duration of the performance entry, typically in milliseconds. The value provides a quantitative measure of the performance aspect being tracked by the metric. The source of the value depends on the specific metric being measured and can come from variousPerformance APIs.Web VitalsWeb Vitalsare a set of useful metrics that aim to capture the user
experience of a web page. The following web vitals are all included:Time to First Byte(TTFB)First Contentful Paint(FCP)Largest Contentful Paint(LCP)First Input Delay(FID)Cumulative Layout Shift(CLS)Interaction to Next Paint(INP)You can handle all the results of these metrics using thenameproperty.app/components/web-vitals.tsxTypeScriptJavaScriptTypeScript'use client'import{ useReportWebVitals }from'next/web-vitals'exportfunctionWebVitals() {useReportWebVitals((metric)=>{switch(metric.name) {case'FCP': {// handle FCP results}case'LCP': {// handle LCP results}// ...}})}Usage on VercelVercel Speed Insightsdoes notuseReportWebVitals, but@vercel/speed-insightspackage instead.useReportWebVitalshook is useful in local development, or if you're using a different service for collecting Web Vitals.Sending results to external systemsYou can send results to any endpoint to measure and track
real user performance on your site. For example:useReportWebVitals((metric)=>{constbody=JSON.stringify(metric)consturl='https://example.com/analytics'// Use `navigator.sendBeacon()` if available, falling back to `fetch()`.if(navigator.sendBeacon) {navigator.sendBeacon(url,body)}else{fetch(url,{ body,method:'POST',keepalive:true})}})Good to know: If you useGoogle Analytics, using theidvalue can allow you to construct metric distributions manually (to calculate percentiles,
etc.)useReportWebVitals(metric=>{// Use `window.gtag` if you initialized Google Analytics as this example:// https://github.com/vercel/next.js/blob/canary/examples/with-google-analyticswindow.gtag('event',metric.name,{value:Math.round(metric.name==='CLS'?metric.value*1000:metric.value),// values must be integersevent_label:metric.id,// id unique to current page loadnon_interaction:true,// avoids affecting bounce rate.});}Read more aboutsending results to Google Analytics.PrevioususePathnameNextuseRouterWas this helpful?supported.Send"
userouter,useRouter,"API ReferenceFunctionsuseRouteruseRouterTheuseRouterhook allows you to programmatically change routes insideClient Components.Recommendation:Use the<Link>componentfor navigation unless you have a specific requirement for usinguseRouter.app/example-client-component.tsxTypeScriptJavaScriptTypeScript'use client'import{ useRouter }from'next/navigation'exportdefaultfunctionPage() {constrouter=useRouter()return(<buttontype=""button""onClick={()=>router.push('/dashboard')}>Dashboard</button>)}useRouter()router.push(href: string, { scroll: boolean }): Perform a client-side navigation to the provided route. Adds a new entry into thebrowser’s historystack.router.replace(href: string, { scroll: boolean }): Perform a client-side navigation to the provided route without adding a new entry into thebrowser’s history stack.router.refresh(): Refresh the current route. Making a new request to the server, re-fetching data requests, and re-rendering Server Components. The client will merge the updated React Server Component payload without losing unaffected client-side React (e.g.useState) or browser state (e.g. scroll position).router.prefetch(href: string):Prefetchthe provided route for faster client-side transitions.router.back(): Navigate back to the previous route in the browser’s history stack.router.forward(): Navigate forwards to the next page in the browser’s history stack.Good to know:You must not send untrusted or unsanitized URLs torouter.pushorrouter.replace, as this can open your site to cross-site scripting (XSS) vulnerabilities. For example,javascript:URLs sent torouter.pushorrouter.replacewill be executed in the context of your page.The<Link>component automatically prefetch routes as they become visible in the viewport.refresh()could re-produce the same result if fetch requests are cached. Other Dynamic APIs likecookiesandheaderscould also change the response.Migrating fromnext/routerTheuseRouterhook should be imported fromnext/navigationand notnext/routerwhen using the App RouterThepathnamestring has been removed and is replaced byusePathname()Thequeryobject has been removed and is replaced byuseSearchParams()router.eventshas been replaced.See below.View the full migration guide.ExamplesRouter eventsYou can listen for page changes by composing other Client Component hooks likeusePathnameanduseSearchParams.app/components/navigation-events.js'use client'import{ useEffect }from'react'import{ usePathname,useSearchParams }from'next/navigation'exportfunctionNavigationEvents() {constpathname=usePathname()constsearchParams=useSearchParams()useEffect(()=>{consturl=`${pathname}?${searchParams}`console.log(url)// You can now use the current URL// ...},[pathname,searchParams])return'...'}Which can be imported into a layout.app/layout.jsimport{ Suspense }from'react'import{ NavigationEvents }from'./components/navigation-events'exportdefaultfunctionLayout({ children }) {return(<htmllang=""en""><body>{children}<Suspensefallback={null}><NavigationEvents/></Suspense></body></html>)}Good to know:<NavigationEvents>is wrapped in aSuspenseboundarybecauseuseSearchParams()causes client-side rendering up to the closestSuspenseboundary duringstatic rendering.Learn more.Disabling scroll to topBy default, Next.js will scroll to the top of the page when navigating to a new route. You can disable this behavior by passingscroll: falsetorouter.push()orrouter.replace().app/example-client-component.tsxTypeScriptJavaScriptTypeScript'use client'import{ useRouter }from'next/navigation'exportdefaultfunctionPage() {constrouter=useRouter()return(<buttontype=""button""onClick={()=>router.push('/dashboard',{ scroll:false})}>Dashboard</button>)}Version HistoryVersionChangesv13.0.0useRouterfromnext/navigationintroduced.PrevioususeReportWebVitalsNextuseSearchParamsWas this helpful?supported.Send"
usesearchparams,useSearchParams,"API ReferenceFunctionsuseSearchParamsuseSearchParamsuseSearchParamsis aClient Componenthook that lets you read the current URL'squery string.useSearchParamsreturns aread-onlyversion of theURLSearchParamsinterface.app/dashboard/search-bar.tsxTypeScriptJavaScriptTypeScript'use client'import{ useSearchParams }from'next/navigation'exportdefaultfunctionSearchBar() {constsearchParams=useSearchParams()constsearch=searchParams.get('search')// URL -> `/dashboard?search=my-project`// `search` -> 'my-project'return<>Search: {search}</>}ParametersconstsearchParams=useSearchParams()useSearchParamsdoes not take any parameters.ReturnsuseSearchParamsreturns aread-onlyversion of theURLSearchParamsinterface, which includes utility methods for reading the URL's query string:URLSearchParams.get(): Returns the first value associated with the search parameter. For example:URLsearchParams.get(""a"")/dashboard?a=1'1'/dashboard?a=''/dashboard?b=3null/dashboard?a=1&a=2'1'- usegetAll()to get all valuesURLSearchParams.has(): Returns a boolean value indicating if the given parameter exists. For example:URLsearchParams.has(""a"")/dashboard?a=1true/dashboard?b=3falseLearn more about otherread-onlymethods ofURLSearchParams, including thegetAll(),keys(),values(),entries(),forEach(), andtoString().Good to know:useSearchParamsis aClient Componenthook and isnot supportedinServer Componentsto prevent stale values duringpartial rendering.If an application includes the/pagesdirectory,useSearchParamswill returnReadonlyURLSearchParams | null. Thenullvalue is for compatibility during migration since search params cannot be known during pre-rendering of a page that doesn't usegetServerSidePropsBehaviorStatic RenderingIf a route isstatically rendered, callinguseSearchParamswill cause the Client Component tree up to the closestSuspenseboundaryto be client-side rendered.This allows a part of the route to be statically rendered while the dynamic part that usesuseSearchParamsis client-side rendered.We recommend wrapping the Client Component that usesuseSearchParamsin a<Suspense/>boundary. This will allow any Client Components above it to be statically rendered and sent as part of initial HTML.Example.For example:app/dashboard/search-bar.tsxTypeScriptJavaScriptTypeScript'use client'import{ useSearchParams }from'next/navigation'exportdefaultfunctionSearchBar() {constsearchParams=useSearchParams()constsearch=searchParams.get('search')// This will not be logged on the server when using static renderingconsole.log(search)return<>Search: {search}</>}app/dashboard/page.tsxTypeScriptJavaScriptTypeScriptimport{ Suspense }from'react'importSearchBarfrom'./search-bar'// This component passed as a fallback to the Suspense boundary// will be rendered in place of the search bar in the initial HTML.// When the value is available during React hydration the fallback// will be replaced with the `<SearchBar>` component.functionSearchBarFallback() {return<>placeholder</>}exportdefaultfunctionPage() {return(<><nav><Suspensefallback={<SearchBarFallback/>}><SearchBar/></Suspense></nav><h1>Dashboard</h1></>)}Dynamic RenderingIf a route isdynamically rendered,useSearchParamswill be available on the server during the initial server render of the Client Component.For example:app/dashboard/search-bar.tsxTypeScriptJavaScriptTypeScript'use client'import{ useSearchParams }from'next/navigation'exportdefaultfunctionSearchBar() {constsearchParams=useSearchParams()constsearch=searchParams.get('search')// This will be logged on the server during the initial render// and on the client on subsequent navigations.console.log(search)return<>Search: {search}</>}app/dashboard/page.tsxTypeScriptJavaScriptTypeScriptimportSearchBarfrom'./search-bar'exportconstdynamic='force-dynamic'exportdefaultfunctionPage() {return(<><nav><SearchBar/></nav><h1>Dashboard</h1></>)}Good to know: Setting thedynamicroute segment config optiontoforce-dynamiccan be used to force dynamic rendering.Server ComponentsPagesTo access search params inPages(Server Components), use thesearchParamsprop.LayoutsUnlike Pages,Layouts(Server Components)do notreceive thesearchParamsprop. This is because a shared layout isnot re-rendered during navigationwhich could lead to stalesearchParamsbetween navigations. Viewdetailed explanation.Instead, use the PagesearchParamsprop or theuseSearchParamshook in a Client Component, which is re-rendered on the client with the latestsearchParams.ExamplesUpdatingsearchParamsYou can useuseRouterorLinkto set newsearchParams. After a navigation is performed, the currentpage.jswill receive an updatedsearchParamsprop.app/example-client-component.tsxTypeScriptJavaScriptTypeScript'use client'exportdefaultfunctionExampleClientComponent() {constrouter=useRouter()constpathname=usePathname()constsearchParams=useSearchParams()// Get a new searchParams string by merging the current// searchParams with a provided key/value pairconstcreateQueryString=useCallback((name:string,value:string)=>{constparams=newURLSearchParams(searchParams.toString())params.set(name,value)returnparams.toString()},[searchParams])return(<><p>Sort By</p>{/* using useRouter */}<buttononClick={()=>{// <pathname>?sort=ascrouter.push(pathname+'?'+createQueryString('sort','asc'))}}>ASC</button>{/* using <Link> */}<Linkhref={// <pathname>?sort=descpathname+'?'+createQueryString('sort','desc')}>DESC</Link></>)}Version HistoryVersionChangesv13.0.0useSearchParamsintroduced.PrevioususeRouterNextuseSelectedLayoutSegmentWas this helpful?supported.Send"
useselectedlayoutsegment,useSelectedLayoutSegment,"API ReferenceFunctionsuseSelectedLayoutSegmentuseSelectedLayoutSegmentuseSelectedLayoutSegmentis aClient Componenthook that lets you read the active route segmentone level belowthe Layout it is called from.It is useful for navigation UI, such as tabs inside a parent layout that change style depending on the active child segment.app/example-client-component.tsxTypeScriptJavaScriptTypeScript'use client'import{ useSelectedLayoutSegment }from'next/navigation'exportdefaultfunctionExampleClientComponent() {constsegment=useSelectedLayoutSegment()return<p>Active segment: {segment}</p>}Good to know:SinceuseSelectedLayoutSegmentis aClient Componenthook, and Layouts areServer Componentsby default,useSelectedLayoutSegmentis usually called via a Client Component that is imported into a Layout.useSelectedLayoutSegmentonly returns the segment one level down. To return all active segments, seeuseSelectedLayoutSegmentsParametersconstsegment=useSelectedLayoutSegment(parallelRoutesKey?:string)useSelectedLayoutSegmentoptionallyaccepts aparallelRoutesKey, which allows you to read the active route segment within that slot.ReturnsuseSelectedLayoutSegmentreturns a string of the active segment ornullif one doesn't exist.For example, given the Layouts and URLs below, the returned segment would be:LayoutVisited URLReturned Segmentapp/layout.js/nullapp/layout.js/dashboard'dashboard'app/dashboard/layout.js/dashboardnullapp/dashboard/layout.js/dashboard/settings'settings'app/dashboard/layout.js/dashboard/analytics'analytics'app/dashboard/layout.js/dashboard/analytics/monthly'analytics'ExamplesCreating an active link componentYou can useuseSelectedLayoutSegmentto create an active link component that changes style depending on the active segment. For example, a featured posts list in the sidebar of a blog:app/blog/blog-nav-link.tsxTypeScriptJavaScriptTypeScript'use client'importLinkfrom'next/link'import{ useSelectedLayoutSegment }from'next/navigation'// This *client* component will be imported into abloglayoutexportdefaultfunctionBlogNavLink({slug,children,}:{slug:stringchildren:React.ReactNode}) {// Navigating to `/blog/hello-world` will return 'hello-world'// for the selected layout segmentconstsegment=useSelectedLayoutSegment()constisActive=slug===segmentreturn(<Linkhref={`/blog/${slug}`}// Change style depending on whether the link is activestyle={{ fontWeight:isActive?'bold':'normal'}}>{children}</Link>)}app/blog/layout.tsxTypeScriptJavaScriptTypeScript// Import the Client Component into a parent Layout (Server Component)import{ BlogNavLink }from'./blog-nav-link'importgetFeaturedPostsfrom'./get-featured-posts'exportdefaultasyncfunctionLayout({children,}:{children:React.ReactNode}) {constfeaturedPosts=awaitgetFeaturedPosts()return(<div>{featuredPosts.map((post)=>(<divkey={post.id}><BlogNavLinkslug={post.slug}>{post.title}</BlogNavLink></div>))}<div>{children}</div></div>)}Version HistoryVersionChangesv13.0.0useSelectedLayoutSegmentintroduced.PrevioususeSearchParamsNextuseSelectedLayoutSegmentsWas this helpful?supported.Send"
useselectedlayoutsegments,useSelectedLayoutSegments,"API ReferenceFunctionsuseSelectedLayoutSegmentsuseSelectedLayoutSegmentsuseSelectedLayoutSegmentsis aClient Componenthook that lets you read the active route segmentsbelowthe Layout it is called from.It is useful for creating UI in parent Layouts that need knowledge of active child segments such as breadcrumbs.app/example-client-component.tsxTypeScriptJavaScriptTypeScript'use client'import{ useSelectedLayoutSegments }from'next/navigation'exportdefaultfunctionExampleClientComponent() {constsegments=useSelectedLayoutSegments()return(<ul>{segments.map((segment,index)=>(<likey={index}>{segment}</li>))}</ul>)}Good to know:SinceuseSelectedLayoutSegmentsis aClient Componenthook, and Layouts areServer Componentsby default,useSelectedLayoutSegmentsis usually called via a Client Component that is imported into a Layout.The returned segments includeRoute Groups, which you might not want to be included in your UI. You can use thefilter()array method to remove items that start with a bracket.Parametersconstsegments=useSelectedLayoutSegments(parallelRoutesKey?:string)useSelectedLayoutSegmentsoptionallyaccepts aparallelRoutesKey, which allows you to read the active route segment within that slot.ReturnsuseSelectedLayoutSegmentsreturns an array of strings containing the active segments one level down from the layout the hook was called from. Or an empty array if none exist.For example, given the Layouts and URLs below, the returned segments would be:LayoutVisited URLReturned Segmentsapp/layout.js/[]app/layout.js/dashboard['dashboard']app/layout.js/dashboard/settings['dashboard', 'settings']app/dashboard/layout.js/dashboard[]app/dashboard/layout.js/dashboard/settings['settings']Version HistoryVersionChangesv13.0.0useSelectedLayoutSegmentsintroduced.PrevioususeSelectedLayoutSegmentNextuserAgentWas this helpful?supported.Send"
useragent,userAgent,"API ReferenceFunctionsuserAgentuserAgentTheuserAgenthelper extends theWeb Request APIwith additional properties and methods to interact with the user agent object from the request.middleware.tsTypeScriptJavaScriptTypeScriptimport{ NextRequest,NextResponse,userAgent }from'next/server'exportfunctionmiddleware(request:NextRequest) {consturl=request.nextUrlconst{device}=userAgent(request)constviewport=device.type==='mobile'?'mobile':'desktop'url.searchParams.set('viewport',viewport)returnNextResponse.rewrite(url)}isBotA boolean indicating whether the request comes from a known bot.browserAn object containing information about the browser used in the request.name: A string representing the browser's name, orundefinedif not identifiable.version: A string representing the browser's version, orundefined.deviceAn object containing information about the device used in the request.model: A string representing the model of the device, orundefined.type: A string representing the type of the device, such asconsole,mobile,tablet,smarttv,wearable,embedded, orundefined.vendor: A string representing the vendor of the device, orundefined.engineAn object containing information about the browser's engine.name: A string representing the engine's name. Possible values include:Amaya,Blink,EdgeHTML,Flow,Gecko,Goanna,iCab,KHTML,Links,Lynx,NetFront,NetSurf,Presto,Tasman,Trident,w3m,WebKitorundefined.version: A string representing the engine's version, orundefined.osAn object containing information about the operating system.name: A string representing the name of the OS, orundefined.version: A string representing the version of the OS, orundefined.cpuAn object containing information about the CPU architecture.architecture: A string representing the architecture of the CPU. Possible values include:68k,amd64,arm,arm64,armhf,avr,ia32,ia64,irix,irix64,mips,mips64,pa-risc,ppc,sparc,sparc64orundefinedPrevioususeSelectedLayoutSegmentsNextConfigurationWas this helpful?supported.Send"
configuration,Configuration,App RouterAPI ReferenceConfigurationConfigurationnext.config.jsLearn how to configure your application with next.config.js.TypeScriptNext.js provides a TypeScript-first development experience for building your React application.ESLintLearn how to use and configure the ESLint plugin to catch common issues and problems in a Next.js application.PrevioususerAgentNextnext.config.jsWas this helpful?supported.Send
next.config.js,next.config.js,"API ReferenceConfigurationnext.config.jsnext.config.jsNext.js can be configured through anext.config.jsfile in the root of your project directory (for example, bypackage.json) with a default export.next.config.js// @ts-check/**@type{import('next').NextConfig}*/constnextConfig={/* config options here */}module.exports=nextConfigECMAScript Modulesnext.config.jsis a regular Node.js module, not a JSON file. It gets used by the Next.js server and build phases, and it's not included in the browser build.If you needECMAScript modules, you can usenext.config.mjs:next.config.mjs// @ts-check/***@type{import('next').NextConfig}*/constnextConfig={/* config options here */}exportdefaultnextConfigGood to know:next.configwith the.cjs,.cts, or.mtsextensions are currentlynotsupported.Configuration as a FunctionYou can also use a function:next.config.mjs// @ts-checkexportdefault(phase,{ defaultConfig })=>{/***@type{import('next').NextConfig}*/constnextConfig={/* config options here */}returnnextConfig}Async ConfigurationSince Next.js 12.1.0, you can use an async function:next.config.js// @ts-checkmodule.exports=async(phase,{ defaultConfig })=>{/***@type{import('next').NextConfig}*/constnextConfig={/* config options here */}returnnextConfig}Phasephaseis the current context in which the configuration is loaded. You can see theavailable phases. Phases can be imported fromnext/constants:next.config.js// @ts-checkconst{PHASE_DEVELOPMENT_SERVER}=require('next/constants')module.exports=(phase,{ defaultConfig })=>{if(phase===PHASE_DEVELOPMENT_SERVER) {return{/* development only config options here */}}return{/* config options for all phases except development here */}}TypeScriptIf you are using TypeScript in your project, you can usenext.config.tsto use TypeScript in your configuration:next.config.tsimporttype{ NextConfig }from'next'constnextConfig:NextConfig={/* config options here */}exportdefaultnextConfigThe commented lines are the place where you can put the configs allowed bynext.config.js, which aredefined in this file.However, none of the configs are required, and it's not necessary to understand what each config does. Instead, search for the features you need to enable or modify in this section and they will show you what to do.Avoid using new JavaScript features not available in your target Node.js version.next.config.jswill not be parsed by Webpack or Babel.This page documents all the available configuration options:Unit Testing (experimental)Starting in Next.js 15.1, thenext/experimental/testing/serverpackage contains utilities to help unit testnext.config.jsfiles.Theunstable_getResponseFromNextConfigfunction runs theheaders,redirects, andrewritesfunctions fromnext.config.jswith the provided request information and returnsNextResponsewith the results of the routing.The response fromunstable_getResponseFromNextConfigonly considersnext.config.jsfields and does not consider middleware or filesystem routes, so the result in production may be different than the unit test.import{getRedirectUrl,unstable_getResponseFromNextConfig,}from'next/experimental/testing/server'constresponse=awaitunstable_getResponseFromNextConfig({url:'https://nextjs.org/test',nextConfig:{asyncredirects() {return[{ source:'/test',destination:'/test2',permanent:false}]},},})expect(response.status).toEqual(307)expect(getRedirectUrl(response)).toEqual('https://nextjs.org/test2')appDirEnable the App Router to use layouts, streaming, and more.assetPrefixLearn how to use the assetPrefix config option to configure your CDN.authInterruptsLearn how to enable the experimental `authInterrupts` configuration option to use `forbidden` and `unauthorized`.basePathUse `basePath` to deploy a Next.js application under a sub-path of a domain.cacheLifeLearn how to set up cacheLife configurations in Next.js.compressNext.js provides gzip compression to compress rendered content and static files, it only works with the server target. Learn more about it here.crossOriginUse the `crossOrigin` option to add a crossOrigin tag on the `script` tags generated by `next/script`.cssChunkingUse the `cssChunking` option to control how CSS files are chunked in your Next.js application.devIndicatorsConfiguration options for the on-screen indicator that gives context about the current route you're viewing during development.distDirSet a custom build directory to use instead of the default .next directory.dynamicIOLearn how to enable the dynamicIO flag in Next.js.envLearn to add and access environment variables in your Next.js application at build time.eslintNext.js reports ESLint errors and warnings during builds by default. Learn how to opt-out of this behavior here.expireTimeCustomize stale-while-revalidate expire time for ISR enabled pages.exportPathMapCustomize the pages that will be exported as HTML files when using `next export`.generateBuildIdConfigure the build id, which is used to identify the current build in which your application is being served.generateEtagsNext.js will generate etags for every page by default. Learn more about how to disable etag generation here.headersAdd custom HTTP headers to your Next.js app.httpAgentOptionsNext.js will automatically use HTTP Keep-Alive by default. Learn more about how to disable HTTP Keep-Alive here.imagesCustom configuration for the next/image loadercacheHandlerConfigure the Next.js cache used for storing and revalidating data to use any external service like Redis, Memcached, or others.inlineCssEnable inline CSS support.loggingConfigure how data fetches are logged to the console when running Next.js in development mode.mdxRsUse the new Rust compiler to compile MDX files in the App Router.onDemandEntriesConfigure how Next.js will dispose and keep in memory pages created in development.optimizePackageImportsAPI Reference for optimizePackageImports Next.js Config OptionoutputNext.js automatically traces which files are needed by each page to allow for easy deployment of your application. Learn how it works here.pageExtensionsExtend the default page extensions used by Next.js when resolving pages in the Pages Router.poweredByHeaderNext.js will add the `x-powered-by` header by default. Learn to opt-out of it here.pprLearn how to enable Partial Prerendering in Next.js.productionBrowserSourceMapsEnables browser source map generation during the production build.reactCompilerEnable the React Compiler to automatically optimize component rendering.reactMaxHeadersLengthThe maximum length of the headers that are emitted by React and added to the response.reactStrictModeThe complete Next.js runtime is now Strict Mode-compliant, learn how to opt-inredirectsAdd redirects to your Next.js app.rewritesAdd rewrites to your Next.js app.sassOptionsConfigure Sass options.serverActionsConfigure Server Actions behavior in your Next.js application.serverComponentsHmrCacheConfigure whether fetch responses in Server Components are cached across HMR refresh requests.serverExternalPackagesOpt-out specific dependencies from the Server Components bundling and use native Node.js `require`.staleTimesLearn how to override the invalidation time of the Client Router Cache.staticGeneration*Learn how to configure static generation in your Next.js application.trailingSlashConfigure Next.js pages to resolve with or without a trailing slash.transpilePackagesAutomatically transpile and bundle dependencies from local packages (like monorepos) or from external dependencies (`node_modules`).turboConfigure Next.js with Turbopack-specific optionstypedRoutesEnable experimental support for statically typed links.typescriptNext.js reports TypeScript errors by default. Learn to opt-out of this behavior here.urlImportsConfigure Next.js to allow importing modules from external URLs.useCacheLearn how to enable the useCache flag in Next.js.useLightningcssEnable experimental support for Lightning CSS.webpackLearn how to customize the webpack config used by Next.jswebVitalsAttributionLearn how to use the webVitalsAttribution option to pinpoint the source of Web Vitals issues.PreviousConfigurationNextappDirWas this helpful?supported.Send"
appdir,appDir,"Configurationnext.config.jsappDirappDirGood to know: This option isno longerneeded as of Next.js 13.4. The App Router is now stable.The App Router (appdirectory) enables support forlayouts,Server Components,streaming, andcolocated data fetching.Using theappdirectory will automatically enableReact Strict Mode. Learn how toincrementally adoptapp.Previousnext.config.jsNextassetPrefixWas this helpful?supported.Send"
assetprefix,assetPrefix,"Configurationnext.config.jsassetPrefixassetPrefixAttention:Deploying to Vercelautomatically configures a global CDN for your Next.js project.
You do not need to manually setup an Asset Prefix.Good to know: Next.js 9.5+ added support for a customizableBase Path, which is better
suited for hosting your application on a sub-path like/docs.
We do not suggest you use a custom Asset Prefix for this use case.Set up a CDNTo set up aCDN, you can set up an asset prefix and configure your CDN's origin to resolve to the domain that Next.js is hosted on.Opennext.config.mjsand add theassetPrefixconfig based on thephase:next.config.mjs// @ts-checkimport{ PHASE_DEVELOPMENT_SERVER }from'next/constants'exportdefault(phase)=>{constisDev=phase===PHASE_DEVELOPMENT_SERVER/***@type{import('next').NextConfig}*/constnextConfig={assetPrefix:isDev?undefined:'https://cdn.mydomain.com',}returnnextConfig}Next.js will automatically use your asset prefix for the JavaScript and CSS files it loads from the/_next/path (.next/static/folder). For example, with the above configuration, the following request for a JS chunk:/_next/static/chunks/4b9b41aaa062cbbfeff4add70f256968c51ece5d.4d708494b3aed70c04f0.jsWould instead become:https://cdn.mydomain.com/_next/static/chunks/4b9b41aaa062cbbfeff4add70f256968c51ece5d.4d708494b3aed70c04f0.jsThe exact configuration for uploading your files to a given CDN will depend on your CDN of choice. The only folder you need to host on your CDN is the contents of.next/static/, which should be uploaded as_next/static/as the above URL request indicates.Do not upload the rest of your.next/folder, as you should not expose your server code and other configuration to the public.WhileassetPrefixcovers requests to_next/static, it does not influence the following paths:Files in thepublicfolder; if you want to serve those assets over a CDN, you'll have to introduce the prefix yourselfPreviousappDirNextauthInterruptsWas this helpful?supported.Send"
authinterrupts,authInterrupts,"Configurationnext.config.jsauthInterruptsauthInterruptsThis feature is currently available in the canary channel and subject to change. Try it out byupgrading Next.js, and share your feedback onGitHub.TheauthInterruptsconfiguration option allows you to useforbiddenandunauthorizedAPIs in your application. While these functions are experimental, you must enable theauthInterruptsoption in yournext.config.jsfile to use them:next.config.tsTypeScriptJavaScriptTypeScriptimporttype{ NextConfig }from'next'constnextConfig:NextConfig={experimental:{authInterrupts:true,},}exportdefaultnextConfigNext StepsforbiddenAPI Reference for the forbidden function.unauthorizedAPI Reference for the unauthorized function.forbidden.jsAPI reference for the forbidden.js special file.unauthorized.jsAPI reference for the unauthorized.js special file.PreviousassetPrefixNextbasePathWas this helpful?supported.Send"
basepath,basePath,"Configurationnext.config.jsbasePathbasePathTo deploy a Next.js application under a sub-path of a domain you can use thebasePathconfig option.basePathallows you to set a path prefix for the application. For example, to use/docsinstead of''(an empty string, the default), opennext.config.jsand add thebasePathconfig:next.config.jsmodule.exports={basePath:'/docs',}Good to know: This value must be set at build time and cannot be changed without re-building as the value is inlined in the client-side bundles.LinksWhen linking to other pages usingnext/linkandnext/routerthebasePathwill be automatically applied.For example, using/aboutwill automatically become/docs/aboutwhenbasePathis set to/docs.exportdefaultfunctionHomePage() {return(<><Linkhref=""/about"">About Page</Link></>)}Output html:<ahref=""/docs/about"">About Page</a>This makes sure that you don't have to change all links in your application when changing thebasePathvalue.ImagesWhen using thenext/imagecomponent, you will need to add thebasePathin front ofsrc.For example, using/docs/me.pngwill properly serve your image whenbasePathis set to/docs.importImagefrom'next/image'functionHome() {return(<><h1>My Homepage</h1><Imagesrc=""/docs/me.png""alt=""Picture of the author""width={500}height={500}/><p>Welcome to my homepage!</p></>)}exportdefaultHomePreviousauthInterruptsNextcacheLifeWas this helpful?supported.Send"
cachelife,cacheLife,"Configurationnext.config.jscacheLifecacheLifeThis feature is currently available in the canary channel and subject to change. Try it out byupgrading Next.js, and share your feedback onGitHub.ThecacheLifeoption allows you to definecustom cache profileswhen using thecacheLifefunction inside components or functions, and within the scope of theuse cachedirective.UsageTo define a profile, enable thedynamicIOflagand add the cache profile in thecacheLifeobject in thenext.config.jsfile. For example, ablogprofile:next.config.tsTypeScriptJavaScriptTypeScriptimporttype{ NextConfig }from'next'constnextConfig:NextConfig={experimental:{dynamicIO:true,cacheLife:{blog:{stale:3600,// 1 hourrevalidate:900,// 15 minutesexpire:86400,// 1 day},},},}exportdefaultnextConfigYou can now use this customblogconfiguration in your component or function as follows:app/actions.tsTypeScriptJavaScriptTypeScriptimport{ unstable_cacheLifeascacheLife }from'next/cache'exportasyncfunctiongetCachedData() {'use cache'cacheLife('blog')constdata=awaitfetch('/api/data')returndata}ReferenceThe configuration object has key values with the following format:PropertyValueDescriptionRequirementstalenumberDuration the client should cache a value without checking the server.OptionalrevalidatenumberFrequency at which the cache should refresh on the server; stale values may be served while revalidating.OptionalexpirenumberMaximum duration for which a value can remain stale before switching to dynamic.Optional - Must be longer thanrevalidatePreviousbasePathNextcompressWas this helpful?supported.Send"
compress,compress,"Configurationnext.config.jscompresscompressBy default, Next.js usesgzipto compress rendered content and static files when usingnext startor a custom server. This is an optimization for applications that do not have compression configured. If compression isalreadyconfigured in your application via a custom server, Next.js will not add compression.Good to know:When hosting your application onVercel, compression usesbrotlifirst, thengzip.You can check if compression is enabled and which algorithm is used by looking at theAccept-Encoding(browser accepted options) andContent-Encoding(currently used) headers in the response.Disabling compressionTo disablecompression, set thecompressconfig option tofalse:next.config.jsmodule.exports={compress:false,}We do not recommend disabling compression unless you have compression configured on your server, as compression reduces bandwidth usage and improves the performance of your application.Changing the compression algorithmTo change your compression algorithm, you will need to configure your custom server and set thecompressoption tofalsein yournext.config.jsfile.For example, you're usingnginxand want to switch tobrotli, set thecompressoption tofalseto allow nginx to handle compression.Good to know:For Next.js applications on Vercel, compression is handled by the Vercel's Edge Network and not Next.js. See theVercel documentationfor more information.PreviouscacheLifeNextcrossOriginWas this helpful?supported.Send"
crossorigin,crossOrigin,"Configurationnext.config.jscrossOrigincrossOriginUse thecrossOriginoption to add acrossOriginattributein all<script>tags generated by thenext/scriptcomponent, and define how cross-origin requests should be handled.next.config.jsmodule.exports={crossOrigin:'anonymous',}Options'anonymous': AddscrossOrigin=""anonymous""attribute.'use-credentials': AddscrossOrigin=""use-credentials"".PreviouscompressNextcssChunkingWas this helpful?supported.Send"
csschunking,cssChunking,"Configurationnext.config.jscssChunkingcssChunkingThis feature is currently experimental and subject to change, it's not recommended for production. Try it out and share your feedback onGitHub.CSS Chunking is a strategy used to improve the performance of your web application by splitting and re-ordering CSS files into chunks. This allows you to load only the CSS that is needed for a specific route, instead of loading all the application's CSS at once.You can control how CSS files are chunked using theexperimental.cssChunkingoption in yournext.config.jsfile:next.config.tsTypeScriptJavaScriptTypeScriptimporttype{ NextConfig }from'next'constnextConfig={experimental:{cssChunking:true,// default},}satisfiesNextConfigexportdefaultnextConfigOptionstrue(default): Next.js will try to merge CSS files whenever possible, determining explicit and implicit dependencies between files from import order to reduce the number of chunks and therefore the number of requests.false: Next.js will not attempt to merge or re-order your CSS files.'strict': Next.js will load CSS files in the correct order they are imported into your files, which can lead to more chunks and requests.You may consider using'strict'if you run into unexpected CSS behavior. For example, if you importa.cssandb.cssin different files using a differentimportorder (abeforeb, orbbeforea),truewill merge the files in any order and assume there are no dependencies between them. However, ifb.cssdepends ona.css, you may want to use'strict'to prevent the files from being merged, and instead, load them in the order they are imported - which can result in more chunks and requests.For most applications, we recommendtrueas it leads to fewer requests and better performance.PreviouscrossOriginNextdevIndicatorsWas this helpful?supported.Send"
devindicators,devIndicators,"Configurationnext.config.jsdevIndicatorsdevIndicatorsdevIndicatorsallows you to configure the on-screen indicator that gives context about the current route you're viewing during development.TypesdevIndicators:false|{position?:'bottom-right'|'bottom-left'|'top-right'|'top-left',// defaults to 'bottom-left',},SettingdevIndicatorstofalsewill hide the indicator, however Next.js will continue to surface any build or runtime errors that were encountered.TroubleshootingIndicator not marking a route as staticIf you expect a route to be static and the indicator has marked it as dynamic, it's likely the route has opted out of static rendering.You can confirm if a route isstaticordynamicby building your application usingnext build --debug, and checking the output in your terminal. Static (or prerendered) routes will display a○symbol, whereas dynamic routes will display aƒsymbol. For example:Build OutputRoute(app)                              Size     First Load JS┌○/_not-found0B0kB└ƒ/products/[id]0B0kB○(Static)   prerendered as static contentƒ(Dynamic)  server-rendered on demandThere are two reasons a route might opt out of static rendering:The presence ofDynamic APIswhich rely on runtime information.Anuncached data request, like a call to an ORM or database driver.Check your route for any of these conditions, and if you are not able to statically render the route, then consider usingloading.jsor<Suspense />to leveragestreaming.PreviouscssChunkingNextdistDirWas this helpful?supported.Send"
distdir,distDir,"Configurationnext.config.jsdistDirdistDirYou can specify a name to use for a custom build directory to use instead of.next.Opennext.config.jsand add thedistDirconfig:next.config.jsmodule.exports={distDir:'build',}Now if you runnext buildNext.js will usebuildinstead of the default.nextfolder.distDirshould notleave your project directory. For example,../buildis aninvaliddirectory.PreviousdevIndicatorsNextdynamicIOWas this helpful?supported.Send"
dynamicio,dynamicIO,"Configurationnext.config.jsdynamicIOdynamicIOThis feature is currently available in the canary channel and subject to change. Try it out byupgrading Next.js, and share your feedback onGitHub.ThedynamicIOflag is an experimental feature in Next.js that causes data fetching operations in the App Router to be excluded from pre-renders unless they are explicitly cached. This can be useful for optimizing the performance of dynamic data fetching in server components.It is useful if your application requires fresh data fetching during runtime rather than serving from a pre-rendered cache.It is expected to be used in conjunction withuse cacheso that your data fetching happens at runtime by default unless you define specific parts of your application to be cached withuse cacheat the page, function, or component level.UsageTo enable thedynamicIOflag, set it totruein theexperimentalsection of yournext.config.tsfile:next.config.tsimporttype{ NextConfig }from'next'constnextConfig:NextConfig={experimental:{dynamicIO:true,},}exportdefaultnextConfigWhendynamicIOis enabled, you can use the following cache functions and configurations:Theuse cachedirectiveThecacheLifefunctionwithuse cacheThecacheTagfunctionNotesWhiledynamicIOcan optimize performance by ensuring fresh data fetching during runtime, it may also introduce additional latency compared to serving pre-rendered content.PreviousdistDirNextenvWas this helpful?supported.Send"
env,env,"Configurationnext.config.jsenvenvSince the release ofNext.js 9.4we now have a more intuitive and ergonomic experience foradding environment variables. Give it a try!Good to know: environment variables specified in this way willalwaysbe included in the JavaScript bundle, prefixing the environment variable name withNEXT_PUBLIC_only has an effect when specifying themthrough the environment or .env files.To add environment variables to the JavaScript bundle, opennext.config.jsand add theenvconfig:next.config.jsmodule.exports={env:{customKey:'my-value',},}Now you can accessprocess.env.customKeyin your code. For example:functionPage() {return<h1>The value of customKey is: {process.env.customKey}</h1>}exportdefaultPageNext.js will replaceprocess.env.customKeywith'my-value'at build time. Trying to destructureprocess.envvariables won't work due to the nature of webpackDefinePlugin.For example, the following line:return<h1>The value of customKey is: {process.env.customKey}</h1>Will end up being:return<h1>The value of customKey is: {'my-value'}</h1>PreviousdynamicIONexteslintWas this helpful?supported.Send"
eslint,eslint,"Configurationnext.config.jseslinteslintWhen ESLint is detected in your project, Next.js fails yourproduction build(next build) when errors are present.If you'd like Next.js to produce production code even when your application has ESLint errors, you can disable the built-in linting step completely. This is not recommended unless you already have ESLint configured to run in a separate part of your workflow (for example, in CI or a pre-commit hook).Opennext.config.jsand enable theignoreDuringBuildsoption in theeslintconfig:next.config.jsmodule.exports={eslint:{// Warning: This allows production builds to successfully complete even if// your project has ESLint errors.ignoreDuringBuilds:true,},}PreviousenvNextexpireTimeWas this helpful?supported.Send"
expiretime,expireTime,"Configurationnext.config.jsexpireTimeexpireTimeYou can specify a customstale-while-revalidateexpire time for CDNs to consume in theCache-Controlheader for ISR enabled pages.Opennext.config.jsand add theexpireTimeconfig:next.config.jsmodule.exports={// one hour in secondsexpireTime:3600,}Now when sending theCache-Controlheader the expire time will be calculated depending on the specific revalidate period.For example, if you have a revalidate of 15 minutes on a path and the expire time is one hour the generatedCache-Controlheader will bes-maxage=900, stale-while-revalidate=2700so that it can stay stale for 15 minutes less than the configured expire time.PreviouseslintNextexportPathMapWas this helpful?supported.Send"
exportpathmap,exportPathMap,"Configurationnext.config.jsexportPathMapexportPathMapThis is a legacy API and no longer recommended. It's still supported for backward compatibility.This feature is exclusive tonext exportand currentlydeprecatedin favor ofgetStaticPathswithpagesorgenerateStaticParamswithapp.exportPathMapallows you to specify a mapping of request paths to page destinations, to be used during export. Paths defined inexportPathMapwill also be available when usingnext dev.Let's start with an example, to create a customexportPathMapfor an app with the following pages:pages/index.jspages/about.jspages/post.jsOpennext.config.jsand add the followingexportPathMapconfig:next.config.jsmodule.exports={exportPathMap:asyncfunction(defaultPathMap,{ dev,dir,outDir,distDir,buildId }) {return{'/':{ page:'/'},'/about':{ page:'/about'},'/p/hello-nextjs':{ page:'/post',query:{ title:'hello-nextjs'} },'/p/learn-nextjs':{ page:'/post',query:{ title:'learn-nextjs'} },'/p/deploy-nextjs':{ page:'/post',query:{ title:'deploy-nextjs'} },}},}Good to know: thequeryfield inexportPathMapcannot be used withautomatically statically optimized pagesorgetStaticPropspagesas they are rendered to HTML files at build-time and additional query information cannot be provided duringnext export.The pages will then be exported as HTML files, for example,/aboutwill become/about.html.exportPathMapis anasyncfunction that receives 2 arguments: the first one isdefaultPathMap, which is the default map used by Next.js. The second argument is an object with:dev-truewhenexportPathMapis being called in development.falsewhen runningnext export. In developmentexportPathMapis used to define routes.dir- Absolute path to the project directoryoutDir- Absolute path to theout/directory (configurable with-o). Whendevistruethe value ofoutDirwill benull.distDir- Absolute path to the.next/directory (configurable with thedistDirconfig)buildId- The generated build idThe returned object is a map of pages where thekeyis thepathnameand thevalueis an object that accepts the following fields:page:String- the page inside thepagesdirectory to renderquery:Object- thequeryobject passed togetInitialPropswhen prerendering. Defaults to{}The exportedpathnamecan also be a filename (for example,/readme.md), but you may need to set theContent-Typeheader totext/htmlwhen serving its content if it is different than.html.Adding a trailing slashIt is possible to configure Next.js to export pages asindex.htmlfiles and require trailing slashes,/aboutbecomes/about/index.htmland is routable via/about/. This was the default behavior prior to Next.js 9.To switch back and add a trailing slash, opennext.config.jsand enable thetrailingSlashconfig:next.config.jsmodule.exports={trailingSlash:true,}Customizing the output directorynext exportwill useoutas the default output directory, you can customize this using the-oargument, like so:Terminalnextexport-ooutdirWarning: UsingexportPathMapis deprecated and is overridden bygetStaticPathsinsidepages. We don't recommend using them together.PreviousexpireTimeNextgenerateBuildIdWas this helpful?supported.Send"
generatebuildid,generateBuildId,"Configurationnext.config.jsgenerateBuildIdgenerateBuildIdNext.js generates an ID duringnext buildto identify which version of your application is being served. The same build should be used and boot up multiple containers.If you are rebuilding for each stage of your environment, you will need to generate a consistent build ID to use between containers. Use thegenerateBuildIdcommand innext.config.js:next.config.jsmodule.exports={generateBuildId:async()=>{// This could be anything, using the latest git hashreturnprocess.env.GIT_HASH},}PreviousexportPathMapNextgenerateEtagsWas this helpful?supported.Send"
generateetags,generateEtags,"Configurationnext.config.jsgenerateEtagsgenerateEtagsNext.js will generateetagsfor every page by default. You may want to disable etag generation for HTML pages depending on your cache strategy.Opennext.config.jsand disable thegenerateEtagsoption:next.config.jsmodule.exports={generateEtags:false,}PreviousgenerateBuildIdNextheadersWas this helpful?supported.Send"
headers,headers,"Configurationnext.config.jsheadersheadersHeaders allow you to set custom HTTP headers on the response to an incoming request on a given path.To set custom HTTP headers you can use theheaderskey innext.config.js:next.config.jsmodule.exports={asyncheaders() {return[{source:'/about',headers:[{key:'x-custom-header',value:'my custom header value',},{key:'x-another-custom-header',value:'my other custom header value',},],},]},}headersis an async function that expects an array to be returned holding objects withsourceandheadersproperties:sourceis the incoming request path pattern.headersis an array of response header objects, withkeyandvalueproperties.basePath:falseorundefined- if false the basePath won't be included when matching, can be used for external rewrites only.locale:falseorundefined- whether the locale should not be included when matching.hasis an array ofhas objectswith thetype,keyandvalueproperties.missingis an array ofmissing objectswith thetype,keyandvalueproperties.Headers are checked before the filesystem which includes pages and/publicfiles.Header Overriding BehaviorIf two headers match the same path and set the same header key, the last header key will override the first. Using the below headers, the path/hellowill result in the headerx-hellobeingworlddue to the last header value set beingworld.next.config.jsmodule.exports={asyncheaders() {return[{source:'/:path*',headers:[{key:'x-hello',value:'there',},],},{source:'/hello',headers:[{key:'x-hello',value:'world',},],},]},}Path MatchingPath matches are allowed, for example/blog/:slugwill match/blog/hello-world(no nested paths):next.config.jsmodule.exports={asyncheaders() {return[{source:'/blog/:slug',headers:[{key:'x-slug',value:':slug',// Matched parameters can be used in the value},{key:'x-slug-:slug',// Matched parameters can be used in the keyvalue:'my other custom header value',},],},]},}Wildcard Path MatchingTo match a wildcard path you can use*after a parameter, for example/blog/:slug*will match/blog/a/b/c/d/hello-world:next.config.jsmodule.exports={asyncheaders() {return[{source:'/blog/:slug*',headers:[{key:'x-slug',value:':slug*',// Matched parameters can be used in the value},{key:'x-slug-:slug*',// Matched parameters can be used in the keyvalue:'my other custom header value',},],},]},}Regex Path MatchingTo match a regex path you can wrap the regex in parenthesis after a parameter, for example/blog/:slug(\\d{1,})will match/blog/123but not/blog/abc:next.config.jsmodule.exports={asyncheaders() {return[{source:'/blog/:post(\\d{1,})',headers:[{key:'x-post',value:':post',},],},]},}The following characters(,),{,},:,*,+,?are used for regex path matching, so when used in thesourceas non-special values they must be escaped by adding\\before them:next.config.jsmodule.exports={asyncheaders() {return[{// this will match `/english(default)/something` being requestedsource:'/english\\(default\\)/:slug',headers:[{key:'x-header',value:'value',},],},]},}Header, Cookie, and Query MatchingTo only apply a header when header, cookie, or query values also match thehasfield or don't match themissingfield can be used. Both thesourceand allhasitems must match and allmissingitems must not match for the header to be applied.hasandmissingitems can have the following fields:type:String- must be eitherheader,cookie,host, orquery.key:String- the key from the selected type to match against.value:Stringorundefined- the value to check for, if undefined any value will match. A regex like string can be used to capture a specific part of the value, e.g. if the valuefirst-(?<paramName>.*)is used forfirst-secondthensecondwill be usable in the destination with:paramName.next.config.jsmodule.exports={asyncheaders() {return[// if the header `x-add-header` is present,// the `x-another-header` header will be applied{source:'/:path*',has:[{type:'header',key:'x-add-header',},],headers:[{key:'x-another-header',value:'hello',},],},// if the header `x-no-header` is not present,// the `x-another-header` header will be applied{source:'/:path*',missing:[{type:'header',key:'x-no-header',},],headers:[{key:'x-another-header',value:'hello',},],},// if the source, query, and cookie are matched,// the `x-authorized` header will be applied{source:'/specific/:path*',has:[{type:'query',key:'page',// the page value will not be available in the// header key/values since value is provided and// doesn't use a named capture group e.g. (?<page>home)value:'home',},{type:'cookie',key:'authorized',value:'true',},],headers:[{key:'x-authorized',value:':authorized',},],},// if the header `x-authorized` is present and// contains a matching value, the `x-another-header` will be applied{source:'/:path*',has:[{type:'header',key:'x-authorized',value:'(?<authorized>yes|true)',},],headers:[{key:'x-another-header',value:':authorized',},],},// if the host is `example.com`,// this header will be applied{source:'/:path*',has:[{type:'host',value:'example.com',},],headers:[{key:'x-another-header',value:':authorized',},],},]},}Headers with basePath supportWhen leveragingbasePathsupportwith headers eachsourceis automatically prefixed with thebasePathunless you addbasePath: falseto the header:next.config.jsmodule.exports={basePath:'/docs',asyncheaders() {return[{source:'/with-basePath',// becomes /docs/with-basePathheaders:[{key:'x-hello',value:'world',},],},{source:'/without-basePath',// is not modified since basePath: false is setheaders:[{key:'x-hello',value:'world',},],basePath:false,},]},}Headers with i18n supportWhen leveragingi18nsupportwith headers eachsourceis automatically prefixed to handle the configuredlocalesunless you addlocale: falseto the header. Iflocale: falseis used you must prefix thesourcewith a locale for it to be matched correctly.next.config.jsmodule.exports={i18n:{locales:['en','fr','de'],defaultLocale:'en',},asyncheaders() {return[{source:'/with-locale',// automatically handles all localesheaders:[{key:'x-hello',value:'world',},],},{// does not handle locales automatically since locale: false is setsource:'/nl/with-locale-manual',locale:false,headers:[{key:'x-hello',value:'world',},],},{// this matches '/' since `en` is the defaultLocalesource:'/en',locale:false,headers:[{key:'x-hello',value:'world',},],},{// this gets converted to /(en|fr|de)/(.*) so will not match the top-level// `/` or `/fr` routes like /:path* wouldsource:'/(.*)',headers:[{key:'x-hello',value:'world',},],},]},}Cache-ControlNext.js sets theCache-Controlheader ofpublic, max-age=31536000, immutablefor truly immutable assets. It cannot be overridden. These immutable files contain a SHA-hash in the file name, so they can be safely cached indefinitely. For example,Static Image Imports. You cannot setCache-Controlheaders innext.config.jsfor these assets.However, you can setCache-Controlheaders for other responses or data.Learn more aboutcachingwith the App Router.OptionsCORSCross-Origin Resource Sharing (CORS)is a security feature that allows you to control which sites can access your resources. You can set theAccess-Control-Allow-Originheader to allow a specific origin to access yourRoute Handlers.asyncheaders() {return[{source:""/api/:path*"",headers:[{key:""Access-Control-Allow-Origin"",value:""*"",// Set your origin},{key:""Access-Control-Allow-Methods"",value:""GET, POST, PUT, DELETE, OPTIONS"",},{key:""Access-Control-Allow-Headers"",value:""Content-Type, Authorization"",},],},];},X-DNS-Prefetch-ControlThis headercontrols DNS prefetching, allowing browsers to proactively perform domain name resolution on external links, images, CSS, JavaScript, and more. This prefetching is performed in the background, so theDNSis more likely to be resolved by the time the referenced items are needed. This reduces latency when the user clicks a link.{key:'X-DNS-Prefetch-Control',value:'on'}Strict-Transport-SecurityThis headerinforms browsers it should only be accessed using HTTPS, instead of using HTTP. Using the configuration below, all present and future subdomains will use HTTPS for amax-ageof 2 years. This blocks access to pages or subdomains that can only be served over HTTP.If you're deploying toVercel, this header is not necessary as it's automatically added to all deployments unless you declareheadersin yournext.config.js.{key:'Strict-Transport-Security',value:'max-age=63072000; includeSubDomains; preload'}X-Frame-OptionsThis headerindicates whether the site should be allowed to be displayed within aniframe. This can prevent against clickjacking attacks.This header has been superseded by CSP'sframe-ancestorsoption, which has better support in modern browsers (seeContent Security Policyfor configuration details).{key:'X-Frame-Options',value:'SAMEORIGIN'}Permissions-PolicyThis headerallows you to control which features and APIs can be used in the browser. It was previously namedFeature-Policy.{key:'Permissions-Policy',value:'camera=(), microphone=(), geolocation=(), browsing-topics=()'}X-Content-Type-OptionsThis headerprevents the browser from attempting to guess the type of content if theContent-Typeheader is not explicitly set. This can prevent XSS exploits for websites that allow users to upload and share files.For example, a user trying to download an image, but having it treated as a differentContent-Typelike an executable, which could be malicious. This header also applies to downloading browser extensions. The only valid value for this header isnosniff.{key:'X-Content-Type-Options',value:'nosniff'}Referrer-PolicyThis headercontrols how much information the browser includes when navigating from the current website (origin) to another.{key:'Referrer-Policy',value:'origin-when-cross-origin'}Content-Security-PolicyLearn more about adding aContent Security Policyto your application.Version HistoryVersionChangesv13.3.0missingadded.v10.2.0hasadded.v9.5.0Headers added.PreviousgenerateEtagsNexthttpAgentOptionsWas this helpful?supported.Send"
httpagentoptions,httpAgentOptions,"Configurationnext.config.jshttpAgentOptionshttpAgentOptionsIn Node.js versions prior to 18, Next.js automatically polyfillsfetch()withundiciand enablesHTTP Keep-Aliveby default.To disable HTTP Keep-Alive for allfetch()calls on the server-side, opennext.config.jsand add thehttpAgentOptionsconfig:next.config.jsmodule.exports={httpAgentOptions:{keepAlive:false,},}PreviousheadersNextimagesWas this helpful?supported.Send"
images,images,"Configurationnext.config.jsimagesimagesIf you want to use a cloud provider to optimize images instead of using the Next.js built-in Image Optimization API, you can configurenext.config.jswith the following:next.config.jsmodule.exports={images:{loader:'custom',loaderFile:'./my/image/loader.js',},}ThisloaderFilemust point to a file relative to the root of your Next.js application. The file must export a default function that returns a string, for example:my/image/loader.js'use client'exportdefaultfunctionmyImageLoader({ src,width,quality }) {return`https://example.com/${src}?w=${width}&q=${quality||75}`}Alternatively, you can use theloaderpropto pass the function to each instance ofnext/image.Good to know: Customizing the image loader file, which accepts a function, requires usingClient Componentsto serialize the provided function.To learn more about configuring the behavior of the built-inImage Optimization APIand theImage Component, seeImage Configuration Optionsfor available options.Example Loader ConfigurationAkamaiAWS CloudFrontCloudinaryCloudflareContentfulFastlyGumletImageEngineImgixPixelBinSanitySirvSupabaseThumborImagekitNitrogen AIOAkamai// Docs: https://techdocs.akamai.com/ivm/reference/test-images-on-demandexportdefaultfunctionakamaiLoader({ src,width,quality }) {return`https://example.com/${src}?imwidth=${width}`}AWS CloudFront// Docs: https://aws.amazon.com/developer/application-security-performance/articles/image-optimizationexportdefaultfunctioncloudfrontLoader({ src,width,quality }) {consturl=newURL(`https://example.com${src}`)url.searchParams.set('format','auto')url.searchParams.set('width',width.toString())url.searchParams.set('quality',(quality||75).toString())returnurl.href}Cloudinary// Demo: https://res.cloudinary.com/demo/image/upload/w_300,c_limit,q_auto/turtles.jpgexportdefaultfunctioncloudinaryLoader({ src,width,quality }) {constparams=['f_auto','c_limit',`w_${width}`,`q_${quality||'auto'}`]return`https://example.com/${params.join(',')}${src}`}Cloudflare// Docs: https://developers.cloudflare.com/images/transform-imagesexportdefaultfunctioncloudflareLoader({ src,width,quality }) {constparams=[`width=${width}`,`quality=${quality||75}`,'format=auto']return`https://example.com/cdn-cgi/image/${params.join(',')}/${src}`}Contentful// Docs: https://www.contentful.com/developers/docs/references/images-api/exportdefaultfunctioncontentfulLoader({ src,width,quality }) {consturl=newURL(`https://example.com${src}`)url.searchParams.set('fm','webp')url.searchParams.set('w',width.toString())url.searchParams.set('q',(quality||75).toString())returnurl.href}Fastly// Docs: https://developer.fastly.com/reference/io/exportdefaultfunctionfastlyLoader({ src,width,quality }) {consturl=newURL(`https://example.com${src}`)url.searchParams.set('auto','webp')url.searchParams.set('width',width.toString())url.searchParams.set('quality',(quality||75).toString())returnurl.href}Gumlet// Docs: https://docs.gumlet.com/reference/image-transform-sizeexportdefaultfunctiongumletLoader({ src,width,quality }) {consturl=newURL(`https://example.com${src}`)url.searchParams.set('format','auto')url.searchParams.set('w',width.toString())url.searchParams.set('q',(quality||75).toString())returnurl.href}ImageEngine// Docs: https://support.imageengine.io/hc/en-us/articles/360058880672-DirectivesexportdefaultfunctionimageengineLoader({ src,width,quality }) {constcompression=100-(quality||50)constparams=[`w_${width}`,`cmpr_${compression}`)]return`https://example.com${src}?imgeng=/${params.join('/')`}Imgix// Demo: https://static.imgix.net/daisy.png?format=auto&fit=max&w=300exportdefaultfunctionimgixLoader({ src,width,quality }) {consturl=newURL(`https://example.com${src}`)constparams=url.searchParamsparams.set('auto',params.getAll('auto').join(',')||'format')params.set('fit',params.get('fit')||'max')params.set('w',params.get('w')||width.toString())params.set('q',(quality||50).toString())returnurl.href}PixelBin// Doc (Resize): https://www.pixelbin.io/docs/transformations/basic/resize/#width-w// Doc (Optimise): https://www.pixelbin.io/docs/optimizations/quality/#image-quality-when-delivering// Doc (Auto Format Delivery): https://www.pixelbin.io/docs/optimizations/format/#automatic-format-selection-with-f_auto-url-parameterexportdefaultfunctionpixelBinLoader({ src,width,quality }) {constname='<your-cloud-name>'constopt=`t.resize(w:${width})~t.compress(q:${quality||75})`return`https://cdn.pixelbin.io/v2/${name}/${opt}/${src}?f_auto=true`}Sanity// Docs: https://www.sanity.io/docs/image-urlsexportdefaultfunctionsanityLoader({ src,width,quality }) {constprj='zp7mbokg'constdataset='production'consturl=newURL(`https://cdn.sanity.io/images/${prj}/${dataset}${src}`)url.searchParams.set('auto','format')url.searchParams.set('fit','max')url.searchParams.set('w',width.toString())if(quality) {url.searchParams.set('q',quality.toString())}returnurl.href}Sirv// Docs: https://sirv.com/help/articles/dynamic-imaging/exportdefaultfunctionsirvLoader({ src,width,quality }) {consturl=newURL(`https://example.com${src}`)constparams=url.searchParamsparams.set('format',params.getAll('format').join(',')||'optimal')params.set('w',params.get('w')||width.toString())params.set('q',(quality||85).toString())returnurl.href}Supabase// Docs: https://supabase.com/docs/guides/storage/image-transformations#nextjs-loaderexportdefaultfunctionsupabaseLoader({ src,width,quality }) {consturl=newURL(`https://example.com${src}`)url.searchParams.set('width',width.toString())url.searchParams.set('quality',(quality||75).toString())returnurl.href}Thumbor// Docs: https://thumbor.readthedocs.io/en/latest/exportdefaultfunctionthumborLoader({ src,width,quality }) {constparams=[`${width}x0`,`filters:quality(${quality||75})`]return`https://example.com${params.join('/')}${src}`}ImageKit.io// Docs: https://imagekit.io/docs/image-transformationexportdefaultfunctionimageKitLoader({ src,width,quality }) {constparams=[`w-${width}`,`q-${quality||80}`]return`https://ik.imagekit.io/your_imagekit_id/${src}?tr=${params.join(',')}`}Nitrogen AIO// Docs: https://docs.n7.io/aio/intergrations/exportdefaultfunctionaioLoader({ src,width,quality }) {consturl=newURL(src,window.location.href)constparams=url.searchParamsconstaioParams=params.getAll('aio')aioParams.push(`w-${width}`)if(quality) {aioParams.push(`q-${quality.toString()}`)}params.set('aio',aioParams.join(';'))returnurl.href}PrevioushttpAgentOptionsNextcacheHandlerWas this helpful?supported.Send"
cachehandler,cacheHandler,"Configurationnext.config.jscacheHandlerCustom Next.js Cache HandlerCaching and revalidating pages (with Incremental Static Regeneration) use the same shared cache. Whendeploying to Vercel, the ISR cache is automatically persisted to durable storage.When self-hosting, the ISR cache is stored to the filesystem (on disk) on your Next.js server. This works automatically when self-hosting using both the Pages and App Router.You can configure the Next.js cache location if you want to persist cached pages and data to durable storage, or share the cache across multiple containers or instances of your Next.js application.next.config.jsmodule.exports={cacheHandler:require.resolve('./cache-handler.js'),cacheMaxMemorySize:0,// disable default in-memory caching}View an example of acustom cache handlerand learn more about implementation.API ReferenceThe cache handler can implement the following methods:get,set, andrevalidateTag.get()ParameterTypeDescriptionkeystringThe key to the cached value.Returns the cached value ornullif not found.set()ParameterTypeDescriptionkeystringThe key to store the data under.dataData ornullThe data to be cached.ctx{ tags: [] }The cache tags provided.ReturnsPromise<void>.revalidateTag()ParameterTypeDescriptiontagstringorstring[]The cache tags to revalidate.ReturnsPromise<void>. Learn more aboutrevalidating dataor therevalidateTag()function.Good to know:revalidatePathis a convenience layer on top of cache tags. CallingrevalidatePathwill call yourrevalidateTagfunction, which you can then choose if you want to tag cache keys based on the path.Version HistoryVersionChangesv14.1.0Renamed tocacheHandlerand became stable.v13.4.0incrementalCacheHandlerPathsupport forrevalidateTag.v13.4.0incrementalCacheHandlerPathsupport for standalone output.v12.2.0ExperimentalincrementalCacheHandlerPathadded.PreviousimagesNextinlineCssWas this helpful?supported.Send"
inlinecss,inlineCss,"Configurationnext.config.jsinlineCssinlineCssThis feature is currently experimental and subject to change, it's not recommended for production. Try it out and share your feedback onGitHub.UsageExperimental support for inlining CSS in the<head>. When this flag is enabled, all places where we normally generate a<link>tag will instead have a generated<style>tag.next.config.tsTypeScriptJavaScriptTypeScriptimporttype{ NextConfig }from'next'constnextConfig:NextConfig={experimental:{inlineCss:true,},}exportdefaultnextConfigTrade-OffsWhen to Use Inline CSSInlining CSS can be beneficial in several scenarios:First-Time Visitors: Since CSS files are render-blocking resources, inlining eliminates the initial download delay that first-time visitors experience, improving page load performance.Performance Metrics: By removing the additional network requests for CSS files, inlining can significantly improve key metrics like First Contentful Paint (FCP) and Largest Contentful Paint (LCP).Slow Connections: For users on slower networks where each request adds considerable latency, inlining CSS can provide a noticeable performance boost by reducing network roundtrips.Atomic CSS Bundles (e.g., Tailwind): With utility-first frameworks like Tailwind CSS, the size of the styles required for a page is often O(1) relative to the complexity of the design. This makes inlining a compelling choice because the entire set of styles for the current page is lightweight and doesn’t grow with the page size. Inlining Tailwind styles ensures minimal payload and eliminates the need for additional network requests, which can further enhance performance.When Not to Use Inline CSSWhile inlining CSS offers significant benefits for performance, there are scenarios where it may not be the best choice:Large CSS Bundles: If your CSS bundle is too large, inlining it may significantly increase the size of the HTML, resulting in slower Time to First Byte (TTFB) and potentially worse performance for users with slow connections.Dynamic or Page-Specific CSS: For applications with highly dynamic styles or pages that use different sets of CSS, inlining may lead to redundancy and bloat, as the full CSS for all pages may need to be inlined repeatedly.Browser Caching: In cases where visitors frequently return to your site, external CSS files allow browsers to cache styles efficiently, reducing data transfer for subsequent visits. Inlining CSS eliminates this benefit.Evaluate these trade-offs carefully, and consider combining inlining with other strategies, such as critical CSS extraction or a hybrid approach, for the best results tailored to your site's needs.Good to know:This feature is currently experimental and has some known limitations:CSS inlining is applied globally and cannot be configured on a per-page basisStyles are duplicated during initial page load - once within<style>tags for SSR and once in the RSC payloadWhen navigating to statically rendered pages, styles will use<link>tags instead of inline CSS to avoid duplicationThis feature is not available in development mode and only works in production buildsPreviouscacheHandlerNextloggingWas this helpful?supported.Send"
logging,logging,"Configurationnext.config.jsloggingloggingOptionsFetchingYou can configure the logging level and whether the full URL is logged to the console when running Next.js in development mode.Currently,loggingonly applies to data fetching using thefetchAPI. It does not yet apply to other logs inside of Next.js.next.config.jsmodule.exports={logging:{fetches:{fullUrl:true,},},}Anyfetchrequests that are restored from theServer Components HMR cacheare not logged by default. However, this can be enabled by settinglogging.fetches.hmrRefreshestotrue.next.config.jsmodule.exports={logging:{fetches:{hmrRefreshes:true,},},}Incoming RequestsBy default all the incoming requests will be logged in the console during development. You can use theincomingRequestsoption to decide which requests to ignore.
Since this is only logged in development, this option doesn't affect production builds.next.config.jsmodule.exports={logging:{incomingRequests:{ignore:[/\api\/v1\/health/],},},}Or you can disable incoming request logging by settingincomingRequeststofalse.next.config.jsmodule.exports={logging:{incomingRequests:false,},}Disabling LoggingIn addition, you can disable the development logging by settingloggingtofalse.next.config.jsmodule.exports={logging:false,}PreviousinlineCssNextmdxRsWas this helpful?supported.Send"
mdxrs,mdxRs,"Configurationnext.config.jsmdxRsmdxRsFor experimental use with@next/mdx. Compiles MDX files using the new Rust compiler.next.config.jsconstwithMDX=require('@next/mdx')()/**@type{import('next').NextConfig}*/constnextConfig={pageExtensions:['ts','tsx','mdx'],experimental:{mdxRs:true,},}module.exports=withMDX(nextConfig)PreviousloggingNextonDemandEntriesWas this helpful?supported.Send"
ondemandentries,onDemandEntries,"Configurationnext.config.jsonDemandEntriesonDemandEntriesNext.js exposes some options that give you some control over how the server will dispose or keep in memory built pages in development.To change the defaults, opennext.config.jsand add theonDemandEntriesconfig:next.config.jsmodule.exports={onDemandEntries:{// period (in ms) where the server will keep pages in the buffermaxInactiveAge:25*1000,// number of pages that should be kept simultaneously without being disposedpagesBufferLength:2,},}PreviousmdxRsNextoptimizePackageImportsWas this helpful?supported.Send"
optimizepackageimports,optimizePackageImports,"Configurationnext.config.jsoptimizePackageImportsoptimizePackageImportsSome packages can export hundreds or thousands of modules, which can cause performance issues in development and production.Adding a package toexperimental.optimizePackageImportswill only load the modules you are actually using, while still giving you the convenience of writing import statements with many named exports.next.config.jsmodule.exports={experimental:{optimizePackageImports:['package-name'],},}The following libraries are optimized by default:lucide-reactdate-fnslodash-esramdaantdreact-bootstrapahooks@ant-design/icons@headlessui/react@headlessui-float/react@heroicons/react/20/solid@heroicons/react/24/solid@heroicons/react/24/outline@visx/visx@tremor/reactrxjs@mui/material@mui/icons-materialrechartsreact-use@material-ui/core@material-ui/icons@tabler/icons-reactmui-corereact-icons/*PreviousonDemandEntriesNextoutputWas this helpful?supported.Send"
output,output,"Configurationnext.config.jsoutputoutputDuring a build, Next.js will automatically trace each page and its dependencies to determine all of the files that are needed for deploying a production version of your application.This feature helps reduce the size of deployments drastically. Previously, when deploying with Docker you would need to have all files from your package'sdependenciesinstalled to runnext start. Starting with Next.js 12, you can leverage Output File Tracing in the.next/directory to only include the necessary files.Furthermore, this removes the need for the deprecatedserverlesstarget which can cause various issues and also creates unnecessary duplication.How it WorksDuringnext build, Next.js will use@vercel/nftto statically analyzeimport,require, andfsusage to determine all files that a page might load.Next.js' production server is also traced for its needed files and output at.next/next-server.js.nft.jsonwhich can be leveraged in production.To leverage the.nft.jsonfiles emitted to the.nextoutput directory, you can read the list of files in each trace that are relative to the.nft.jsonfile and then copy them to your deployment location.Automatically Copying Traced FilesNext.js can automatically create astandalonefolder that copies only the necessary files for a production deployment including select files innode_modules.To leverage this automatic copying you can enable it in yournext.config.js:next.config.jsmodule.exports={output:'standalone',}This will create a folder at.next/standalonewhich can then be deployed on its own without installingnode_modules.Additionally, a minimalserver.jsfile is also output which can be used instead ofnext start. This minimal server does not copy thepublicor.next/staticfolders by default as these should ideally be handled by a CDN instead, although these folders can be copied to thestandalone/publicandstandalone/.next/staticfolders manually, after whichserver.jsfile will serve these automatically.To copy these manually, you can use thecpcommand-line tool after younext build:Terminalcp-rpublic.next/standalone/&&cp-r.next/static.next/standalone/.next/To start your minimalserver.jsfile locally, run the following command:Terminalnode.next/standalone/server.jsGood to know:If your project needs to listen to a specific port or hostname, you can definePORTorHOSTNAMEenvironment variables before runningserver.js. For example, runPORT=8080 HOSTNAME=0.0.0.0 node server.jsto start the server onhttp://0.0.0.0:8080.CaveatsWhile tracing in monorepo setups, the project directory is used for tracing by default. Fornext build packages/web-app,packages/web-appwould be the tracing root and any files outside of that folder will not be included. To include files outside of this folder you can setoutputFileTracingRootin yournext.config.js.packages/web-app/next.config.jsmodule.exports={// this includes files from the monorepo base two directories upoutputFileTracingRoot:path.join(__dirname,'../../'),}There are some cases in which Next.js might fail to include required files, or might incorrectly include unused files. In those cases, you can leverageoutputFileTracingExcludesandoutputFileTracingIncludesrespectively innext.config.js. Each config accepts an object withminimatch globsfor the key to match specific pages and a value of an array with globs relative to the project's root to either include or exclude in the trace.next.config.jsmodule.exports={outputFileTracingExcludes:{'/api/hello':['./un-necessary-folder/**/*'],},outputFileTracingIncludes:{'/api/another':['./necessary-folder/**/*'],'/api/login/\\[\\[\\.\\.\\.slug\\]\\]':['./node_modules/aws-crt/dist/bin/**/*',],},}Note:The key ofoutputFileTracingIncludes/outputFileTracingExcludesis aglob, so special characters need to be escaped.Currently, Next.js does not do anything with the emitted.nft.jsonfiles. The files must be read by your deployment platform, for exampleVercel, to create a minimal deployment. In a future release, a new command is planned to utilize these.nft.jsonfiles.ExperimentalturbotraceTracing dependencies can be slow because it requires very complex computations and analysis. We createdturbotracein Rust as a faster and smarter alternative to the JavaScript implementation.To enable it, you can add the following configuration to yournext.config.js:next.config.jsmodule.exports={experimental:{turbotrace:{// control the log level of the turbotrace, default is `error`logLevel?:|'bug'|'fatal'|'error'|'warning'|'hint'|'note'|'suggestions'|'info',// control if the log of turbotrace should contain the details of the analysis, default is `false`logDetail?:boolean// show all log messages without limit// turbotrace only show 1 log message for each categories by defaultlogAll?:boolean// control the context directory of the turbotrace// files outside of the context directory will not be traced// set the `outputFileTracingRoot` has the same effect// if the `outputFileTracingRoot` and this option are both set, the `experimental.turbotrace.contextDirectory` will be usedcontextDirectory?:string// if there is `process.cwd()` expression in your code, you can set this option to tell `turbotrace` the value of `process.cwd()` while tracing.// for example the require(process.cwd() + '/package.json') will be traced as require('/path/to/cwd/package.json')processCwd?:string// control the maximum memory usage of the `turbotrace`, in `MB`, default is `6000`.memoryLimit?:number},},}PreviousoptimizePackageImportsNextpageExtensionsWas this helpful?supported.Send"
pageextensions,pageExtensions,"Configurationnext.config.jspageExtensionspageExtensionsBy default, Next.js accepts files with the following extensions:.tsx,.ts,.jsx,.js. This can be modified to allow other extensions like markdown (.md,.mdx).next.config.jsconstwithMDX=require('@next/mdx')()/**@type{import('next').NextConfig}*/constnextConfig={pageExtensions:['js','jsx','ts','tsx','md','mdx'],}module.exports=withMDX(nextConfig)PreviousoutputNextpoweredByHeaderWas this helpful?supported.Send"
poweredbyheader,poweredByHeader,"Configurationnext.config.jspoweredByHeaderpoweredByHeaderBy default Next.js will add thex-powered-byheader. To opt-out of it, opennext.config.jsand disable thepoweredByHeaderconfig:next.config.jsmodule.exports={poweredByHeader:false,}PreviouspageExtensionsNextpprWas this helpful?supported.Send"
ppr,ppr,"Configurationnext.config.jspprpprThis feature is currently experimental and subject to change, it's not recommended for production. Try it out and share your feedback onGitHub.Partial Prerendering (PPR) enables you to combine static and dynamic components together in the same route. Learn more aboutPPR.Using Partial PrerenderingIncremental Adoption (Version 15)In Next.js 15, you can incrementally adopt Partial Prerendering inlayoutsandpagesby setting thepproption innext.config.jstoincremental, and exporting theexperimental_pprroute config optionat the top of the file:next.config.tsTypeScriptJavaScriptTypeScriptimporttype{ NextConfig }from'next'constnextConfig:NextConfig={experimental:{ppr:'incremental',},}exportdefaultnextConfigapp/page.tsxTypeScriptJavaScriptTypeScriptimport{ Suspense }from""react""import{ StaticComponent,DynamicComponent,Fallback }from""@/app/ui""exportconstexperimental_ppr=trueexportdefaultfunctionPage() {return{<><StaticComponent /><Suspense fallback={<Fallback />}><DynamicComponent /></Suspense></>};}Good to know:Routes that don't haveexperimental_pprwill default tofalseand will not be prerendered using PPR. You need to explicitly opt-in to PPR for each route.experimental_pprwill apply to all children of the route segment, including nested layouts and pages. You don't have to add it to every file, only the top segment of a route.To disable PPR for children segments, you can setexperimental_pprtofalsein the child segment.VersionChangesv15.0.0experimentalincrementalvalue introducedv14.0.0experimentalpprintroducedLearn more about Partial PrerenderingPartial PrerenderingLearn how to combine the benefits of static and dynamic rendering with Partial Prerendering.PreviouspoweredByHeaderNextproductionBrowserSourceMapsWas this helpful?supported.Send"
productionbrowsersourcemaps,productionBrowserSourceMaps,"Configurationnext.config.jsproductionBrowserSourceMapsproductionBrowserSourceMapsSource Maps are enabled by default during development. During production builds, they are disabled to prevent you leaking your source on the client, unless you specifically opt-in with the configuration flag.Next.js provides a configuration flag you can use to enable browser source map generation during the production build:next.config.jsmodule.exports={productionBrowserSourceMaps:true,}When theproductionBrowserSourceMapsoption is enabled, the source maps will be output in the same directory as the JavaScript files. Next.js will automatically serve these files when requested.Adding source maps can increasenext buildtimeIncreases memory usage duringnext buildPreviouspprNextreactCompilerWas this helpful?supported.Send"
reactcompiler,reactCompiler,"Configurationnext.config.jsreactCompilerreactCompilerThis feature is currently experimental and subject to change, it's not recommended for production. Try it out and share your feedback onGitHub.Next.js 15 introduced support for theReact Compiler. The compiler improves performance by automatically optimizing component rendering. This reduces the amount of manual memoization developers have to do through APIs such asuseMemoanduseCallback.To use it, upgrade to Next.js 15, install thebabel-plugin-react-compiler:Terminalnpminstallbabel-plugin-react-compilerThen, addexperimental.reactCompileroption innext.config.js:next.config.tsTypeScriptJavaScriptTypeScriptimporttype{ NextConfig }from'next'constnextConfig:NextConfig={experimental:{reactCompiler:true,},}exportdefaultnextConfigNote:The React Compiler is currently only possible to use in Next.js through a Babel plugin. This will opt-out of Next.js's defaultRust-based compiler, which could result in slower build times. We are working on support for the React Compiler as our default compiler.AnnotationsYou can configure the compiler to run in ""opt-in"" mode as follows:next.config.tsTypeScriptJavaScriptTypeScriptimporttype{ NextConfig }from'next'constnextConfig:NextConfig={experimental:{reactCompiler:{compilationMode:'annotation',},},}exportdefaultnextConfigThen, you can annotate specific components or hooks with the""use memo""directive from React to opt-in:app/page.tsxTypeScriptJavaScriptTypeScriptexportdefaultfunctionPage() {'use memo'// ...}Note:You can also use the""use no memo""directive from React for the opposite effect, to opt-out a component or hook.PreviousproductionBrowserSourceMapsNextreactMaxHeadersLengthWas this helpful?supported.Send"
reactmaxheaderslength,reactMaxHeadersLength,"Configurationnext.config.jsreactMaxHeadersLengthreactMaxHeadersLengthDuring static rendering, React can emit headers that can be added to the response. These can be used to improve performance by allowing the browser to preload resources like fonts, scripts, and stylesheets. The default value is6000, but you can override this value by configuring thereactMaxHeadersLengthoption innext.config.js:next.config.jsmodule.exports={reactMaxHeadersLength:1000,}Good to know: This option is only available in App Router.Depending on the type of proxy between the browser and the server, the headers can be truncated. For example, if you are using a reverse proxy that doesn't support long headers, you should set a lower value to ensure that the headers are not truncated.PreviousreactCompilerNextreactStrictModeWas this helpful?supported.Send"
reactstrictmode,reactStrictMode,"Configurationnext.config.jsreactStrictModereactStrictModeGood to know: Since Next.js 13.5.1, Strict Mode istrueby default withapprouter, so the above configuration is only necessary forpages. You can still disable Strict Mode by settingreactStrictMode: false.Suggested: We strongly suggest you enable Strict Mode in your Next.js application to better prepare your application for the future of React.React'sStrict Modeis a development mode only feature for highlighting potential problems in an application. It helps to identify unsafe lifecycles, legacy API usage, and a number of other features.The Next.js runtime is Strict Mode-compliant. To opt-in to Strict Mode, configure the following option in yournext.config.js:next.config.jsmodule.exports={reactStrictMode:true,}If you or your team are not ready to use Strict Mode in your entire application, that's OK! You can incrementally migrate on a page-by-page basis using<React.StrictMode>.PreviousreactMaxHeadersLengthNextredirectsWas this helpful?supported.Send"
redirects,redirects,"Configurationnext.config.jsredirectsredirectsRedirects allow you to redirect an incoming request path to a different destination path.To use redirects you can use theredirectskey innext.config.js:next.config.jsmodule.exports={asyncredirects() {return[{source:'/about',destination:'/',permanent:true,},]},}redirectsis an async function that expects an array to be returned holding objects withsource,destination, andpermanentproperties:sourceis the incoming request path pattern.destinationis the path you want to route to.permanenttrueorfalse- iftruewill use the 308 status code which instructs clients/search engines to cache the redirect forever, iffalsewill use the 307 status code which is temporary and is not cached.Why does Next.js use 307 and 308?Traditionally a 302 was used for a temporary redirect, and a 301 for a permanent redirect, but many browsers changed the request method of the redirect toGET, regardless of the original method. For example, if the browser made a request toPOST /v1/userswhich returned status code302with location/v2/users, the subsequent request might beGET /v2/usersinstead of the expectedPOST /v2/users. Next.js uses the 307 temporary redirect, and 308 permanent redirect status codes to explicitly preserve the request method used.basePath:falseorundefined- if false thebasePathwon't be included when matching, can be used for external redirects only.locale:falseorundefined- whether the locale should not be included when matching.hasis an array ofhas objectswith thetype,keyandvalueproperties.missingis an array ofmissing objectswith thetype,keyandvalueproperties.Redirects are checked before the filesystem which includes pages and/publicfiles.When using the Pages Router, redirects are not applied to client-side routing (Link,router.push) unlessMiddlewareis present and matches the path.When a redirect is applied, any query values provided in the request will be passed through to the redirect destination. For example, see the following redirect configuration:{source:'/old-blog/:path*',destination:'/blog/:path*',permanent:false}Good to know: Remember to include the forward slash/before the colon:in path parameters of thesourceanddestinationpaths, otherwise the path will be treated as a literal string and you run the risk of causing infinite redirects.When/old-blog/post-1?hello=worldis requested, the client will be redirected to/blog/post-1?hello=world.Path MatchingPath matches are allowed, for example/old-blog/:slugwill match/old-blog/hello-world(no nested paths):next.config.jsmodule.exports={asyncredirects() {return[{source:'/old-blog/:slug',destination:'/news/:slug',// Matched parameters can be used in the destinationpermanent:true,},]},}Wildcard Path MatchingTo match a wildcard path you can use*after a parameter, for example/blog/:slug*will match/blog/a/b/c/d/hello-world:next.config.jsmodule.exports={asyncredirects() {return[{source:'/blog/:slug*',destination:'/news/:slug*',// Matched parameters can be used in the destinationpermanent:true,},]},}Regex Path MatchingTo match a regex path you can wrap the regex in parentheses after a parameter, for example/post/:slug(\\d{1,})will match/post/123but not/post/abc:next.config.jsmodule.exports={asyncredirects() {return[{source:'/post/:slug(\\d{1,})',destination:'/news/:slug',// Matched parameters can be used in the destinationpermanent:false,},]},}The following characters(,),{,},:,*,+,?are used for regex path matching, so when used in thesourceas non-special values they must be escaped by adding\\before them:next.config.jsmodule.exports={asyncredirects() {return[{// this will match `/english(default)/something` being requestedsource:'/english\\(default\\)/:slug',destination:'/en-us/:slug',permanent:false,},]},}Header, Cookie, and Query MatchingTo only match a redirect when header, cookie, or query values also match thehasfield or don't match themissingfield can be used. Both thesourceand allhasitems must match and allmissingitems must not match for the redirect to be applied.hasandmissingitems can have the following fields:type:String- must be eitherheader,cookie,host, orquery.key:String- the key from the selected type to match against.value:Stringorundefined- the value to check for, if undefined any value will match. A regex like string can be used to capture a specific part of the value, e.g. if the valuefirst-(?<paramName>.*)is used forfirst-secondthensecondwill be usable in the destination with:paramName.next.config.jsmodule.exports={asyncredirects() {return[// if the header `x-redirect-me` is present,// this redirect will be applied{source:'/:path((?!another-page$).*)',has:[{type:'header',key:'x-redirect-me',},],permanent:false,destination:'/another-page',},// if the header `x-dont-redirect` is present,// this redirect will NOT be applied{source:'/:path((?!another-page$).*)',missing:[{type:'header',key:'x-do-not-redirect',},],permanent:false,destination:'/another-page',},// if the source, query, and cookie are matched,// this redirect will be applied{source:'/specific/:path*',has:[{type:'query',key:'page',// the page value will not be available in the// destination since value is provided and doesn't// use a named capture group e.g. (?<page>home)value:'home',},{type:'cookie',key:'authorized',value:'true',},],permanent:false,destination:'/another/:path*',},// if the header `x-authorized` is present and// contains a matching value, this redirect will be applied{source:'/',has:[{type:'header',key:'x-authorized',value:'(?<authorized>yes|true)',},],permanent:false,destination:'/home?authorized=:authorized',},// if the host is `example.com`,// this redirect will be applied{source:'/:path((?!another-page$).*)',has:[{type:'host',value:'example.com',},],permanent:false,destination:'/another-page',},]},}Redirects with basePath supportWhen leveragingbasePathsupportwith redirects eachsourceanddestinationis automatically prefixed with thebasePathunless you addbasePath: falseto the redirect:next.config.jsmodule.exports={basePath:'/docs',asyncredirects() {return[{source:'/with-basePath',// automatically becomes /docs/with-basePathdestination:'/another',// automatically becomes /docs/anotherpermanent:false,},{// does not add /docs since basePath: false is setsource:'/without-basePath',destination:'https://example.com',basePath:false,permanent:false,},]},}Redirects with i18n supportWhen leveragingi18nsupportwith redirects eachsourceanddestinationis automatically prefixed to handle the configuredlocalesunless you addlocale: falseto the redirect. Iflocale: falseis used you must prefix thesourceanddestinationwith a locale for it to be matched correctly.next.config.jsmodule.exports={i18n:{locales:['en','fr','de'],defaultLocale:'en',},asyncredirects() {return[{source:'/with-locale',// automatically handles all localesdestination:'/another',// automatically passes the locale onpermanent:false,},{// does not handle locales automatically since locale: false is setsource:'/nl/with-locale-manual',destination:'/nl/another',locale:false,permanent:false,},{// this matches '/' since `en` is the defaultLocalesource:'/en',destination:'/en/another',locale:false,permanent:false,},// it's possible to match all locales even when locale: false is set{source:'/:locale/page',destination:'/en/newpage',permanent:false,locale:false,},{// this gets converted to /(en|fr|de)/(.*) so will not match the top-level// `/` or `/fr` routes like /:path* wouldsource:'/(.*)',destination:'/another',permanent:false,},]},}In some rare cases, you might need to assign a custom status code for older HTTP Clients to properly redirect. In these cases, you can use thestatusCodeproperty instead of thepermanentproperty, but not both. To to ensure IE11 compatibility, aRefreshheader is automatically added for the 308 status code.Other RedirectsInsideAPI RoutesandRoute Handlers, you can redirect based on the incoming request.InsidegetStaticPropsandgetServerSideProps, you can redirect specific pages at request-time.Version HistoryVersionChangesv13.3.0missingadded.v10.2.0hasadded.v9.5.0redirectsadded.PreviousreactStrictModeNextrewritesWas this helpful?supported.Send"
rewrites,rewrites,"Configurationnext.config.jsrewritesrewritesRewrites allow you to map an incoming request path to a different destination path.Rewrites act as a URL proxy and mask the destination path, making it appear the user hasn't changed their location on the site. In contrast,redirectswill reroute to a new page and show the URL changes.To use rewrites you can use therewriteskey innext.config.js:next.config.jsmodule.exports={asyncrewrites() {return[{source:'/about',destination:'/',},]},}Rewrites are applied to client-side routing, a<Link href=""/about"">will have the rewrite applied in the above example.rewritesis an async function that expects to return either an array or an object of arrays (see below) holding objects withsourceanddestinationproperties:source:String- is the incoming request path pattern.destination:Stringis the path you want to route to.basePath:falseorundefined- if false the basePath won't be included when matching, can be used for external rewrites only.locale:falseorundefined- whether the locale should not be included when matching.hasis an array ofhas objectswith thetype,keyandvalueproperties.missingis an array ofmissing objectswith thetype,keyandvalueproperties.When therewritesfunction returns an array, rewrites are applied after checking the filesystem (pages and/publicfiles) and before dynamic routes. When therewritesfunction returns an object of arrays with a specific shape, this behavior can be changed and more finely controlled, as ofv10.1of Next.js:next.config.jsmodule.exports={asyncrewrites() {return{beforeFiles:[// These rewrites are checked after headers/redirects// and before all files including _next/public files which// allows overriding page files{source:'/some-page',destination:'/somewhere-else',has:[{ type:'query',key:'overrideMe'}],},],afterFiles:[// These rewrites are checked after pages/public files// are checked but before dynamic routes{source:'/non-existent',destination:'/somewhere-else',},],fallback:[// These rewrites are checked after both pages/public files// and dynamic routes are checked{source:'/:path*',destination:`https://my-old-site.com/:path*`,},],}},}Good to know: rewrites inbeforeFilesdo not check the filesystem/dynamic routes immediately after matching a source, they continue until allbeforeFileshave been checked.The order Next.js routes are checked is:headersare checked/appliedredirectsare checked/appliedbeforeFilesrewrites are checked/appliedstatic files from thepublic directory,_next/staticfiles, and non-dynamic pages are checked/servedafterFilesrewrites are checked/applied, if one of these rewrites is matched we check dynamic routes/static files after each matchfallbackrewrites are checked/applied, these are applied before rendering the 404 page and after dynamic routes/all static assets have been checked. If you usefallback: true/'blocking'ingetStaticPaths, the fallbackrewritesdefined in yournext.config.jswillnotbe run.Rewrite parametersWhen using parameters in a rewrite the parameters will be passed in the query by default when none of the parameters are used in thedestination.next.config.jsmodule.exports={asyncrewrites() {return[{source:'/old-about/:path*',destination:'/about',// The :path parameter isn't used here so will be automatically passed in the query},]},}If a parameter is used in the destination none of the parameters will be automatically passed in the query.next.config.jsmodule.exports={asyncrewrites() {return[{source:'/docs/:path*',destination:'/:path*',// The :path parameter is used here so will not be automatically passed in the query},]},}You can still pass the parameters manually in the query if one is already used in the destination by specifying the query in thedestination.next.config.jsmodule.exports={asyncrewrites() {return[{source:'/:first/:second',destination:'/:first?second=:second',// Since the :first parameter is used in the destination the :second parameter// will not automatically be added in the query although we can manually add it// as shown above},]},}Good to know: Static pages fromAutomatic Static Optimizationorprerenderingparams from rewrites will be parsed on the client after hydration and provided in the query.Path MatchingPath matches are allowed, for example/blog/:slugwill match/blog/hello-world(no nested paths):next.config.jsmodule.exports={asyncrewrites() {return[{source:'/blog/:slug',destination:'/news/:slug',// Matched parameters can be used in the destination},]},}Wildcard Path MatchingTo match a wildcard path you can use*after a parameter, for example/blog/:slug*will match/blog/a/b/c/d/hello-world:next.config.jsmodule.exports={asyncrewrites() {return[{source:'/blog/:slug*',destination:'/news/:slug*',// Matched parameters can be used in the destination},]},}Regex Path MatchingTo match a regex path you can wrap the regex in parenthesis after a parameter, for example/blog/:slug(\\d{1,})will match/blog/123but not/blog/abc:next.config.jsmodule.exports={asyncrewrites() {return[{source:'/old-blog/:post(\\d{1,})',destination:'/blog/:post',// Matched parameters can be used in the destination},]},}The following characters(,),{,},[,],|,\,^,.,:,*,+,-,?,$are used for regex path matching, so when used in thesourceas non-special values they must be escaped by adding\\before them:next.config.jsmodule.exports={asyncrewrites() {return[{// this will match `/english(default)/something` being requestedsource:'/english\\(default\\)/:slug',destination:'/en-us/:slug',},]},}Header, Cookie, and Query MatchingTo only match a rewrite when header, cookie, or query values also match thehasfield or don't match themissingfield can be used. Both thesourceand allhasitems must match and allmissingitems must not match for the rewrite to be applied.hasandmissingitems can have the following fields:type:String- must be eitherheader,cookie,host, orquery.key:String- the key from the selected type to match against.value:Stringorundefined- the value to check for, if undefined any value will match. A regex like string can be used to capture a specific part of the value, e.g. if the valuefirst-(?<paramName>.*)is used forfirst-secondthensecondwill be usable in the destination with:paramName.next.config.jsmodule.exports={asyncrewrites() {return[// if the header `x-rewrite-me` is present,// this rewrite will be applied{source:'/:path*',has:[{type:'header',key:'x-rewrite-me',},],destination:'/another-page',},// if the header `x-rewrite-me` is not present,// this rewrite will be applied{source:'/:path*',missing:[{type:'header',key:'x-rewrite-me',},],destination:'/another-page',},// if the source, query, and cookie are matched,// this rewrite will be applied{source:'/specific/:path*',has:[{type:'query',key:'page',// the page value will not be available in the// destination since value is provided and doesn't// use a named capture group e.g. (?<page>home)value:'home',},{type:'cookie',key:'authorized',value:'true',},],destination:'/:path*/home',},// if the header `x-authorized` is present and// contains a matching value, this rewrite will be applied{source:'/:path*',has:[{type:'header',key:'x-authorized',value:'(?<authorized>yes|true)',},],destination:'/home?authorized=:authorized',},// if the host is `example.com`,// this rewrite will be applied{source:'/:path*',has:[{type:'host',value:'example.com',},],destination:'/another-page',},]},}Rewriting to an external URLExamplesIncremental adoption of Next.jsUsing Multiple ZonesRewrites allow you to rewrite to an external URL. This is especially useful for incrementally adopting Next.js. The following is an example rewrite for redirecting the/blogroute of your main app to an external site.next.config.jsmodule.exports={asyncrewrites() {return[{source:'/blog',destination:'https://example.com/blog',},{source:'/blog/:slug',destination:'https://example.com/blog/:slug',// Matched parameters can be used in the destination},]},}If you're usingtrailingSlash: true, you also need to insert a trailing slash in thesourceparameter. If the destination server is also expecting a trailing slash it should be included in thedestinationparameter as well.next.config.jsmodule.exports={trailingSlash:true,asyncrewrites() {return[{source:'/blog/',destination:'https://example.com/blog/',},{source:'/blog/:path*/',destination:'https://example.com/blog/:path*/',},]},}Incremental adoption of Next.jsYou can also have Next.js fall back to proxying to an existing website after checking all Next.js routes.This way you don't have to change the rewrites configuration when migrating more pages to Next.jsnext.config.jsmodule.exports={asyncrewrites() {return{fallback:[{source:'/:path*',destination:`https://custom-routes-proxying-endpoint.vercel.app/:path*`,},],}},}Rewrites with basePath supportWhen leveragingbasePathsupportwith rewrites eachsourceanddestinationis automatically prefixed with thebasePathunless you addbasePath: falseto the rewrite:next.config.jsmodule.exports={basePath:'/docs',asyncrewrites() {return[{source:'/with-basePath',// automatically becomes /docs/with-basePathdestination:'/another',// automatically becomes /docs/another},{// does not add /docs to /without-basePath since basePath: false is set// Note: this can not be used for internal rewrites e.g. `destination: '/another'`source:'/without-basePath',destination:'https://example.com',basePath:false,},]},}Rewrites with i18n supportWhen leveragingi18nsupportwith rewrites eachsourceanddestinationis automatically prefixed to handle the configuredlocalesunless you addlocale: falseto the rewrite. Iflocale: falseis used you must prefix thesourceanddestinationwith a locale for it to be matched correctly.next.config.jsmodule.exports={i18n:{locales:['en','fr','de'],defaultLocale:'en',},asyncrewrites() {return[{source:'/with-locale',// automatically handles all localesdestination:'/another',// automatically passes the locale on},{// does not handle locales automatically since locale: false is setsource:'/nl/with-locale-manual',destination:'/nl/another',locale:false,},{// this matches '/' since `en` is the defaultLocalesource:'/en',destination:'/en/another',locale:false,},{// it's possible to match all locales even when locale: false is setsource:'/:locale/api-alias/:path*',destination:'/api/:path*',locale:false,},{// this gets converted to /(en|fr|de)/(.*) so will not match the top-level// `/` or `/fr` routes like /:path* wouldsource:'/(.*)',destination:'/another',},]},}Version HistoryVersionChangesv13.3.0missingadded.v10.2.0hasadded.v9.5.0Headers added.PreviousredirectsNextsassOptionsWas this helpful?supported.Send"
sassoptions,sassOptions,"Configurationnext.config.jssassOptionssassOptionssassOptionsallow you to configure the Sass compiler.next.config.tsTypeScriptJavaScriptTypeScriptimporttype{ NextConfig }from'next'constsassOptions={additionalData:`$var: red;`,}constnextConfig:NextConfig={sassOptions:{...sassOptions,implementation:'sass-embedded',},}exportdefaultnextConfigGood to know:sassOptionsare not typed outside ofimplementationbecause Next.js does not maintain the other possible properties.PreviousrewritesNextserverActionsWas this helpful?supported.Send"
serveractions,serverActions,"Configurationnext.config.jsserverActionsserverActionsOptions for configuring Server Actions behavior in your Next.js application.allowedOriginsA list of extra safe origin domains from which Server Actions can be invoked. Next.js compares the origin of a Server Action request with the host domain, ensuring they match to prevent CSRF attacks. If not provided, only the same origin is allowed.next.config.js/**@type{import('next').NextConfig}*/module.exports={experimental:{serverActions:{allowedOrigins:['my-proxy.com','*.my-proxy.com'],},},}bodySizeLimitBy default, the maximum size of the request body sent to a Server Action is 1MB, to prevent the consumption of excessive server resources in parsing large amounts of data, as well as potential DDoS attacks.However, you can configure this limit using theserverActions.bodySizeLimitoption. It can take the number of bytes or any string format supported by bytes, for example1000,'500kb'or'3mb'.next.config.js/**@type{import('next').NextConfig}*/module.exports={experimental:{serverActions:{bodySizeLimit:'2mb',},},}Enabling Server Actions (v13)Server Actions became a stable feature in Next.js 14, and are enabled by default. However, if you are using an earlier version of Next.js, you can enable them by settingexperimental.serverActionstotrue.next.config.js/**@type{import('next').NextConfig}*/constconfig={experimental:{serverActions:true,},}module.exports=configPrevioussassOptionsNextserverComponentsHmrCacheWas this helpful?supported.Send"
servercomponentshmrcache,serverComponentsHmrCache,"Configurationnext.config.jsserverComponentsHmrCacheserverComponentsHmrCacheThis feature is currently experimental and subject to change, it's not recommended for production. Try it out and share your feedback onGitHub.The experimentalserverComponentsHmrCacheoption allows you to cachefetchresponses in Server Components across Hot Module Replacement (HMR) refreshes in local development. This results in faster responses and reduced costs for billed API calls.By default, the HMR cache applies to allfetchrequests, including those with thecache: 'no-store'option. This means uncached requests will not show fresh data between HMR refreshes. However, the cache will be cleared on navigation or full-page reloads.You can disable the HMR cache by settingserverComponentsHmrCachetofalsein yournext.config.jsfile:next.config.tsTypeScriptJavaScriptTypeScriptimporttype{ NextConfig }from'next'constnextConfig:NextConfig={experimental:{serverComponentsHmrCache:false,// defaults to true},}exportdefaultnextConfigGood to know:For better observability, we recommend using thelogging.fetchesoption which logs fetch cache hits and misses in the console during development.PreviousserverActionsNextserverExternalPackagesWas this helpful?supported.Send"
serverexternalpackages,serverExternalPackages,"Configurationnext.config.jsserverExternalPackagesserverExternalPackagesDependencies used insideServer ComponentsandRoute Handlerswill automatically be bundled by Next.js.If a dependency is using Node.js specific features, you can choose to opt-out specific dependencies from the Server Components bundling and use native Node.jsrequire.next.config.js/**@type{import('next').NextConfig}*/constnextConfig={serverExternalPackages:['@acme/ui'],}module.exports=nextConfigNext.js includes ashort list of popular packagesthat currently are working on compatibility and automatically opt-ed out:@appsignal/nodejs@aws-sdk/client-s3@aws-sdk/s3-presigned-post@blockfrost/blockfrost-js@highlight-run/node@jpg-store/lucid-cardano@libsql/client@mikro-orm/core@mikro-orm/knex@node-rs/argon2@node-rs/bcrypt@prisma/client@react-pdf/renderer@sentry/profiling-node@sparticuz/chromium@swc/coreargon2autoprefixeraws-crtbcryptbetter-sqlite3canvascpu-featurescypressdd-traceeslintexpressfirebase-adminimport-in-the-middleisolated-vmjestjsdomkeyvlibsqlmdx-bundlermongodbmongoosenewrelicnext-mdx-remotenext-seonode-cronnode-ptynode-web-audio-apioslopgplaywrightplaywright-corepostcssprettierprismapuppeteer-corepuppeteerrequire-in-the-middlerimrafsharpshikisqlite3ts-nodets-morphtypescriptvscode-onigurumawebpackwebsocketzeromqVersionChangesv15.0.0Moved from experimental to stable. Renamed fromserverComponentsExternalPackagestoserverExternalPackagesPreviousserverComponentsHmrCacheNextstaleTimesWas this helpful?supported.Send"
staletimes,staleTimes,"Configurationnext.config.jsstaleTimesstaleTimesThis feature is currently experimental and subject to change, it's not recommended for production. Try it out and share your feedback onGitHub.staleTimesis an experimental feature that enables caching of page segments in theclient-side router cache.You can enable this experimental feature and provide custom revalidation times by setting the experimentalstaleTimesflag:next.config.js/**@type{import('next').NextConfig}*/constnextConfig={experimental:{staleTimes:{dynamic:30,static:180,},},}module.exports=nextConfigThestaticanddynamicproperties correspond with the time period (in seconds) based on different types oflink prefetching.Thedynamicproperty is used when the page is neither statically generated nor fully prefetched (e.g. withprefetch={true}).Default: 0 seconds (not cached)Thestaticproperty is used for statically generated pages, or when theprefetchprop onLinkis set totrue, or when callingrouter.prefetch.Default: 5 minutesGood to know:Loading boundariesare considered reusable for thestaticperiod defined in this configuration.This doesn't affectpartial rendering,meaning shared layouts won't automatically be refetched on every navigation, only the page segment that changes.This doesn't changeback/forward cachingbehavior to prevent layout shift and to prevent losing the browser scroll position.You can learn more about the Client Router Cachehere.Version HistoryVersionChangesv15.0.0ThedynamicstaleTimesdefault changed from 30s to 0s.v14.2.0ExperimentalstaleTimesintroduced.PreviousserverExternalPackagesNextstaticGeneration*Was this helpful?supported.Send"
staticgeneration*,staticGeneration*,"Configurationnext.config.jsstaticGeneration*staticGeneration*This feature is currently experimental and subject to change, it's not recommended for production. Try it out and share your feedback onGitHub.ThestaticGeneration*options allow you to configure the Static Generation process for advanced use cases.next.config.tsTypeScriptJavaScriptTypeScriptimporttype{ NextConfig }from'next'constnextConfig:NextConfig={experimental:{staticGenerationRetryCount:1,staticGenerationMaxConcurrency:8,staticGenerationMinPagesPerWorker:25,},}exportdefaultnextConfigConfig OptionsThe following options are available:staticGenerationRetryCount: The number of times to retry a failed page generation before failing the build.staticGenerationMaxConcurrency: The maximum number of pages to be processed per worker.staticGenerationMinPagesPerWorker: The minimum number of pages to be processed before starting a new worker.PreviousstaleTimesNexttrailingSlashWas this helpful?supported.Send"
trailingslash,trailingSlash,"Configurationnext.config.jstrailingSlashtrailingSlashBy default Next.js will redirect URLs with trailing slashes to their counterpart without a trailing slash. For example/about/will redirect to/about. You can configure this behavior to act the opposite way, where URLs without trailing slashes are redirected to their counterparts with trailing slashes.Opennext.config.jsand add thetrailingSlashconfig:next.config.jsmodule.exports={trailingSlash:true,}With this option set, URLs like/aboutwill redirect to/about/.When usingtrailingSlash: true, certain URLs are exceptions and will not have a trailing slash appended:Static file URLs, such as files with extensions.Any paths under.well-known/.For example, the following URLs will remain unchanged:/file.txt,images/photos/picture.png, and.well-known/subfolder/config.json.When used withoutput: ""export""configuration, the/aboutpage will output/about/index.html(instead of the default/about.html).Version HistoryVersionChangesv9.5.0trailingSlashadded.PreviousstaticGeneration*NexttranspilePackagesWas this helpful?supported.Send"
transpilepackages,transpilePackages,"Configurationnext.config.jstranspilePackagestranspilePackagesNext.js can automatically transpile and bundle dependencies from local packages (like monorepos) or from external dependencies (node_modules). This replaces thenext-transpile-modulespackage.next.config.js/**@type{import('next').NextConfig}*/constnextConfig={transpilePackages:['package-name'],}module.exports=nextConfigVersion HistoryVersionChangesv13.0.0transpilePackagesadded.PrevioustrailingSlashNextturboWas this helpful?supported.Send"
turbo,turbo,"Configurationnext.config.jsturboturboThis feature is currently experimental and subject to change, it's not recommended for production. Try it out and share your feedback onGitHub.Theturbooption lets you customizeTurbopackto transform different files and change how modules are resolved.next.config.tsTypeScriptJavaScriptTypeScriptimporttype{ NextConfig }from'next'constnextConfig:NextConfig={experimental:{turbo:{// ...},},}exportdefaultnextConfigGood to know:Turbopack for Next.js does not require loaders nor loader configuration for built-in functionality. Turbopack has built-in support for CSS and compiling modern JavaScript, so there's no need forcss-loader,postcss-loader, orbabel-loaderif you're using@babel/preset-env.ReferenceOptionsThe following options are available for theturboconfiguration:OptionDescriptionrulesList of supported webpack loaders to apply when running with Turbopack.resolveAliasMap aliased imports to modules to load in their place.resolveExtensionsList of extensions to resolve when importing files.moduleIdStrategyAssign module IDstreeShakingEnable tree shaking for the turbopack dev server and build.memoryLimitA target memory limit for turbo, in bytes.Supported loadersThe following loaders have been tested to work with Turbopack's webpack loader implementation:babel-loader@svgr/webpacksvg-inline-loaderyaml-loaderstring-replace-loaderraw-loadersass-loaderExamplesConfiguring webpack loadersIf you need loader support beyond what's built in, many webpack loaders already work with Turbopack. There are currently some limitations:Only a core subset of the webpack loader API is implemented. Currently, there is enough coverage for some popular loaders, and we'll expand our API support in the future.Only loaders that return JavaScript code are supported. Loaders that transform files like stylesheets or images are not currently supported.Options passed to webpack loaders must be plain JavaScript primitives, objects, and arrays. For example, it's not possible to passrequire()plugin modules as option values.To configure loaders, add the names of the loaders you've installed and any options innext.config.js, mapping file extensions to a list of loaders:next.config.jsmodule.exports={experimental:{turbo:{rules:{'*.svg':{loaders:['@svgr/webpack'],as:'*.js',},},},},}Good to know: Prior to Next.js version 13.4.4,turbo.ruleswas namedturbo.loadersand only accepted file extensions like.mdxinstead of*.mdx.Resolving aliasesTurbopack can be configured to modify module resolution through aliases, similar to webpack'sresolve.aliasconfiguration.To configure resolve aliases, map imported patterns to their new destination innext.config.js:next.config.jsmodule.exports={experimental:{turbo:{resolveAlias:{underscore:'lodash',mocha:{ browser:'mocha/browser-entry.js'},},},},}This aliases imports of theunderscorepackage to thelodashpackage. In other words,import underscore from 'underscore'will load thelodashmodule instead ofunderscore.Turbopack also supports conditional aliasing through this field, similar to Node.js'conditional exports. At the moment only thebrowsercondition is supported. In the case above, imports of themochamodule will be aliased tomocha/browser-entry.jswhen Turbopack targets browser environments.Resolving custom extensionsTurbopack can be configured to resolve modules with custom extensions, similar to webpack'sresolve.extensionsconfiguration.To configure resolve extensions, use theresolveExtensionsfield innext.config.js:next.config.jsmodule.exports={experimental:{turbo:{resolveExtensions:['.mdx','.tsx','.ts','.jsx','.js','.mjs','.json',],},},}This overwrites the original resolve extensions with the provided list. Make sure to include the default extensions.For more information and guidance for how to migrate your app to Turbopack from webpack, seeTurbopack's documentation on webpack compatibility.Assigning module IDsTurbopack currently supports two strategies for assigning module IDs:'named'assigns readable module IDs based on the module's path and functionality.'deterministic'assigns small hashed numeric module IDs, which are mostly consistent between builds and therefore help with long-term caching.If not set, Turbopack will use'named'for development builds and'deterministic'for production builds.To configure the module IDs strategy, use themoduleIdStrategyfield innext.config.js:next.config.jsmodule.exports={experimental:{turbo:{moduleIdStrategy:'deterministic',},},}Version HistoryVersionChanges13.0.0experimental.turbointroduced.PrevioustranspilePackagesNexttypedRoutesWas this helpful?supported.Send"
typedroutes,typedRoutes,"Configurationnext.config.jstypedRoutestypedRoutesThis feature is currently experimental and subject to change, it's not recommended for production. Try it out and share your feedback onGitHub.Experimental support forstatically typed links. This feature requires using the App Router as well as TypeScript in your project.next.config.js/**@type{import('next').NextConfig}*/constnextConfig={experimental:{typedRoutes:true,},}module.exports=nextConfigPreviousturboNexttypescriptWas this helpful?supported.Send"
typescript,typescript,"Configurationnext.config.jstypescripttypescriptNext.js fails yourproduction build(next build) when TypeScript errors are present in your project.If you'd like Next.js to dangerously produce production code even when your application has errors, you can disable the built-in type checking step.If disabled, be sure you are running type checks as part of your build or deploy process, otherwise this can be very dangerous.Opennext.config.jsand enable theignoreBuildErrorsoption in thetypescriptconfig:next.config.jsmodule.exports={typescript:{// !! WARN !!// Dangerously allow production builds to successfully complete even if// your project has type errors.// !! WARN !!ignoreBuildErrors:true,},}PrevioustypedRoutesNexturlImportsWas this helpful?supported.Send"
urlimports,urlImports,"Configurationnext.config.jsurlImportsurlImportsThis feature is currently experimental and subject to change, it's not recommended for production. Try it out and share your feedback onGitHub.URL imports are an experimental feature that allows you to import modules directly from external servers (instead of from the local disk).Warning: Only use domains that you trust to download and execute on your machine. Please exercise discretion, and caution until the feature is flagged as stable.To opt-in, add the allowed URL prefixes insidenext.config.js:next.config.jsmodule.exports={experimental:{urlImports:['https://example.com/assets/','https://cdn.skypack.dev'],},}Then, you can import modules directly from URLs:import{ a,b,c }from'https://example.com/assets/some/module.js'URL Imports can be used everywhere normal package imports can be used.Security ModelThis feature is being designed withsecurity as the top priority. To start, we added an experimental flag forcing you to explicitly allow the domains you accept URL imports from. We're working to take this further by limiting URL imports to execute in the browser sandbox using theEdge Runtime.LockfileWhen using URL imports, Next.js will create anext.lockdirectory containing a lockfile and fetched assets.
This directorymust be committed to Git, not ignored by.gitignore.When runningnext dev, Next.js will download and add all newly discovered URL Imports to your lockfile.When runningnext build, Next.js will use only the lockfile to build the application for production.Typically, no network requests are needed and any outdated lockfile will cause the build to fail.
One exception is resources that respond withCache-Control: no-cache.
These resources will have ano-cacheentry in the lockfile and will always be fetched from the network on each build.ExamplesSkypackimportconfettifrom'https://cdn.skypack.dev/canvas-confetti'import{ useEffect }from'react'exportdefault()=>{useEffect(()=>{confetti()})return<p>Hello</p>}Static Image ImportsimportImagefrom'next/image'importlogofrom'https://example.com/assets/logo.png'exportdefault()=>(<div><Imagesrc={logo}placeholder=""blur""/></div>)URLs in CSS.className{background:url('https://example.com/assets/hero.jpg');}Asset Importsconstlogo=newURL('https://example.com/assets/file.txt',import.meta.url)console.log(logo.pathname)// prints ""/_next/static/media/file.a9727b5d.txt""PrevioustypescriptNextuseCacheWas this helpful?supported.Send"
usecache,useCache,"Configurationnext.config.jsuseCacheuseCacheThis feature is currently available in the canary channel and subject to change. Try it out byupgrading Next.js, and share your feedback onGitHub.TheuseCacheflag is an experimental feature in Next.js that enables theuse cachedirectiveto be used independently ofdynamicIO. When enabled, you can useuse cachein your application even ifdynamicIOis turned off.UsageTo enable theuseCacheflag, set it totruein theexperimentalsection of yournext.config.tsfile:next.config.tsimporttype{ NextConfig }from'next'constnextConfig:NextConfig={experimental:{useCache:true,},}exportdefaultnextConfigWhenuseCacheis enabled, you can use the following cache functions and configurations:Theuse cachedirectiveThecacheLifefunctionwithuse cacheThecacheTagfunctionPreviousurlImportsNextuseLightningcssWas this helpful?supported.Send"
uselightningcss,useLightningcss,"Configurationnext.config.jsuseLightningcssuseLightningcssThis feature is currently experimental and subject to change, it's not recommended for production. Try it out and share your feedback onGitHub.Experimental support for usingLightning CSS, a fast CSS bundler and minifier, written in Rust.next.config.tsTypeScriptJavaScriptTypeScriptimporttype{ NextConfig }from'next'constnextConfig:NextConfig={experimental:{useLightningcss:true,},}exportdefaultnextConfigPrevioususeCacheNextwebpackWas this helpful?supported.Send"
webpack,webpack,"Configurationnext.config.jswebpackCustom Webpack ConfigGood to know: changes to webpack config are not covered by semver so proceed at your own riskBefore continuing to add custom webpack configuration to your application make sure Next.js doesn't already support your use-case:CSS importsCSS modulesSass/SCSS importsSass/SCSS modulesSome commonly asked for features are available as plugins:@next/mdx@next/bundle-analyzerIn order to extend our usage ofwebpack, you can define a function that extends its config insidenext.config.js, like so:next.config.jsmodule.exports={webpack:(config,{ buildId,dev,isServer,defaultLoaders,nextRuntime,webpack })=>{// Important: return the modified configreturnconfig},}Thewebpackfunction is executed three times, twice for the server (nodejs / edge runtime) and once for the client. This allows you to distinguish between client and server configuration using theisServerproperty.The second argument to thewebpackfunction is an object with the following properties:buildId:String- The build id, used as a unique identifier between builds.dev:Boolean- Indicates if the compilation will be done in development.isServer:Boolean- It'struefor server-side compilation, andfalsefor client-side compilation.nextRuntime:String | undefined- The target runtime for server-side compilation; either""edge""or""nodejs"", it'sundefinedfor client-side compilation.defaultLoaders:Object- Default loaders used internally by Next.js:babel:Object- Defaultbabel-loaderconfiguration.Example usage ofdefaultLoaders.babel:// Example config for adding a loader that depends on babel-loader// This source was taken from the @next/mdx plugin source:// https://github.com/vercel/next.js/tree/canary/packages/next-mdxmodule.exports={webpack:(config,options)=>{config.module.rules.push({test:/\.mdx/,use:[options.defaultLoaders.babel,{loader:'@mdx-js/loader',options:pluginOptions.options,},],})returnconfig},}nextRuntimeNotice thatisServeristruewhennextRuntimeis""edge""or""nodejs"",nextRuntime""edge""is currently for middleware and Server Components in edge runtime only.PrevioususeLightningcssNextwebVitalsAttributionWas this helpful?supported.Send"
webvitalsattribution,webVitalsAttribution,"Configurationnext.config.jswebVitalsAttributionwebVitalsAttributionThis feature is currently experimental and subject to change, it's not recommended for production. Try it out and share your feedback onGitHub.When debugging issues related to Web Vitals, it is often helpful if we can pinpoint the source of the problem.
For example, in the case of Cumulative Layout Shift (CLS), we might want to know the first element that shifted when the single largest layout shift occurred.
Or, in the case of Largest Contentful Paint (LCP), we might want to identify the element corresponding to the LCP for the page.
If the LCP element is an image, knowing the URL of the image resource can help us locate the asset we need to optimize.Pinpointing the biggest contributor to the Web Vitals score, akaattribution,
allows us to obtain more in-depth information like entries forPerformanceEventTiming,PerformanceNavigationTimingandPerformanceResourceTiming.Attribution is disabled by default in Next.js but can be enabledper metricby specifying the following innext.config.js.next.config.jsmodule.exports={experimental:{webVitalsAttribution:['CLS','LCP'],},}Valid attribution values are allweb-vitalsmetrics specified in theNextWebVitalsMetrictype.PreviouswebpackNextTypeScriptWas this helpful?supported.Send"
typescript,TypeScript,"API ReferenceConfigurationTypeScriptTypeScriptNext.js comes with built-in TypeScript, automatically installing the necessary packages and configuring the proper settings when you create a new project withcreate-next-app.To add TypeScript to an existing project, rename a file to.ts/.tsx. Runnext devandnext buildto automatically install the necessary dependencies and add atsconfig.jsonfile with the recommended config options.Good to know: If you already have ajsconfig.jsonfile, copy thepathscompiler option from the oldjsconfig.jsoninto the newtsconfig.jsonfile, and delete the oldjsconfig.jsonfile.IDE PluginNext.js includes a custom TypeScript plugin and type checker, which VSCode and other code editors can use for advanced type-checking and auto-completion.You can enable the plugin in VS Code by:Opening the command palette (Ctrl/⌘+Shift+P)Searching for ""TypeScript: Select TypeScript Version""Selecting ""Use Workspace Version""Now, when editing files, the custom plugin will be enabled. When runningnext build, the custom type checker will be used.The TypeScript plugin can help with:Warning if the invalid values forsegment config optionsare passed.Showing available options and in-context documentation.Ensuring theuse clientdirective is used correctly.Ensuring client hooks (likeuseState) are only used in Client Components.🎥 Watch:Learn about the built-in TypeScript plugin →YouTube (3 minutes)End-to-End Type SafetyThe Next.js App Router hasenhanced type safety. This includes:No serialization of data between fetching function and page: You canfetchdirectly in components, layouts, and pages on the server. This datadoes notneed to be serialized (converted to a string) to be passed to the client side for consumption in React. Instead, sinceappuses Server Components by default, we can use values likeDate,Map,Set, and more without any extra steps. Previously, you needed to manually type the boundary between server and client with Next.js-specific types.Streamlined data flow between components: With the removal of_appin favor of root layouts, it is now easier to visualize the data flow between components and pages. Previously, data flowing between individualpagesand_appwere difficult to type and could introduce confusing bugs. Withcolocated data fetchingin the App Router, this is no longer an issue.Data Fetching in Next.jsnow provides as close to end-to-end type safety as possible without being prescriptive about your database or content provider selection.We're able to type the response data as you would expect with normal TypeScript. For example:app/page.tsxTypeScriptJavaScriptTypeScriptasyncfunctiongetData() {constres=awaitfetch('https://api.example.com/...')// The return value is *not* serialized// You can return Date, Map, Set, etc.returnres.json()}exportdefaultasyncfunctionPage() {constname=awaitgetData()return'...'}Forcompleteend-to-end type safety, this also requires your database or content provider to support TypeScript. This could be through using anORMor type-safe query builder.ExamplesType checkingnext.config.tsYou can use TypeScript and import types in your Next.js configuration by usingnext.config.ts.next.config.tsimporttype{ NextConfig }from'next'constnextConfig:NextConfig={/* config options here */}exportdefaultnextConfigGood to know: Module resolution innext.config.tsis currently limited toCommonJS. This may cause incompatibilities with ESM only packages being loaded innext.config.ts.When using thenext.config.jsfile, you can add some type checking in your IDE using JSDoc as below:next.config.js// @ts-check/**@type{import('next').NextConfig}*/constnextConfig={/* config options here */}module.exports=nextConfigStatically Typed LinksNext.js can statically type links to prevent typos and other errors when usingnext/link, improving type safety when navigating between pages.To opt-into this feature,experimental.typedRoutesneed to be enabled and the project needs to be using TypeScript.next.config.tsimporttype{ NextConfig }from'next'constnextConfig:NextConfig={experimental:{typedRoutes:true,},}exportdefaultnextConfigNext.js will generate a link definition in.next/typesthat contains information about all existing routes in your application, which TypeScript can then use to provide feedback in your editor about invalid links.Currently, experimental support includes any string literal, including dynamic segments. For non-literal strings, you currently need to manually cast thehrefwithas Route:importtype{ Route }from'next';importLinkfrom'next/link'// No TypeScript errors if href is a valid route<Linkhref=""/about""/><Linkhref=""/blog/nextjs""/><Linkhref={`/blog/${slug}`} /><Linkhref={('/blog'+slug)asRoute} />// TypeScript errors if href is not a valid route<Linkhref=""/aboot""/>To accepthrefin a custom component wrappingnext/link, use a generic:importtype{ Route }from'next'importLinkfrom'next/link'functionCard<Textendsstring>({ href }:{ href:Route<T>|URL}) {return(<Linkhref={href}><div>My Card</div></Link>)}How does it work?When runningnext devornext build, Next.js generates a hidden.d.tsfile inside.nextthat contains information about all existing routes in your application (all valid routes as thehreftype ofLink). This.d.tsfile is included intsconfig.jsonand the TypeScript compiler will check that.d.tsand provide feedback in your editor about invalid links.With Async Server ComponentsTo use anasyncServer Component with TypeScript, ensure you are using TypeScript5.1.3or higher and@types/react18.2.8or higher.If you are using an older version of TypeScript, you may see a'Promise<Element>' is not a valid JSX elementtype error. Updating to the latest version of TypeScript and@types/reactshould resolve this issue.Incremental type checkingSincev10.2.1Next.js supportsincremental type checkingwhen enabled in yourtsconfig.json, this can help speed up type checking in larger applications.Disabling TypeScript errors in productionNext.js fails yourproduction build(next build) when TypeScript errors are present in your project.If you'd like Next.js to dangerously produce production code even when your application has errors, you can disable the built-in type checking step.If disabled, be sure you are running type checks as part of your build or deploy process, otherwise this can be very dangerous.Opennext.config.tsand enable theignoreBuildErrorsoption in thetypescriptconfig:next.config.tsimporttype{ NextConfig }from'next'constnextConfig:NextConfig={typescript:{// !! WARN !!// Dangerously allow production builds to successfully complete even if// your project has type errors.// !! WARN !!ignoreBuildErrors:true,},}exportdefaultnextConfigGood to know: You can runtsc --noEmitto check for TypeScript errors yourself before building. This is useful for CI/CD pipelines where you'd like to check for TypeScript errors before deploying.Custom type declarationsWhen you need to declare custom types, you might be tempted to modifynext-env.d.ts. However, this file is automatically generated, so any changes you make will be overwritten. Instead, you should create a new file, let's call itnew-types.d.ts, and reference it in yourtsconfig.json:tsconfig.json{""compilerOptions"":{""skipLibCheck"":true//...truncated...},""include"":[""new-types.d.ts"",""next-env.d.ts"","".next/types/**/*.ts"",""**/*.ts"",""**/*.tsx""],""exclude"":[""node_modules""]}Version ChangesVersionChangesv15.0.0next.config.tssupport added for TypeScript projects.v13.2.0Statically typed links are available in beta.v12.0.0SWCis now used by default to compile TypeScript and TSX for faster builds.v10.2.1Incremental type checkingsupport added when enabled in yourtsconfig.json.PreviouswebVitalsAttributionNextESLintWas this helpful?supported.Send"
eslint,ESLint,"API ReferenceConfigurationESLintESLint PluginNext.js provides an ESLint plugin,eslint-plugin-next, already bundled within the base configuration that makes it possible to catch common issues and problems in a Next.js application.ReferenceRecommended rule-sets from the following ESLint plugins are all used withineslint-config-next:eslint-plugin-reacteslint-plugin-react-hookseslint-plugin-nextThis will take precedence over the configuration fromnext.config.js.RulesThe full set of rules is as follows:Enabled in recommended configRuleDescription@next/next/google-font-displayEnforce font-display behavior with Google Fonts.@next/next/google-font-preconnectEnsurepreconnectis used with Google Fonts.@next/next/inline-script-idEnforceidattribute onnext/scriptcomponents with inline content.@next/next/next-script-for-gaPrefernext/scriptcomponent when using the inline script for Google Analytics.@next/next/no-assign-module-variablePrevent assignment to themodulevariable.@next/next/no-async-client-componentPrevent client components from being async functions.@next/next/no-before-interactive-script-outside-documentPrevent usage ofnext/script'sbeforeInteractivestrategy outside ofpages/_document.js.@next/next/no-css-tagsPrevent manual stylesheet tags.@next/next/no-document-import-in-pagePrevent importingnext/documentoutside ofpages/_document.js.@next/next/no-duplicate-headPrevent duplicate usage of<Head>inpages/_document.js.@next/next/no-head-elementPrevent usage of<head>element.@next/next/no-head-import-in-documentPrevent usage ofnext/headinpages/_document.js.@next/next/no-html-link-for-pagesPrevent usage of<a>elements to navigate to internal Next.js pages.@next/next/no-img-elementPrevent usage of<img>element due to slower LCP and higher bandwidth.@next/next/no-page-custom-fontPrevent page-only custom fonts.@next/next/no-script-component-in-headPrevent usage ofnext/scriptinnext/headcomponent.@next/next/no-styled-jsx-in-documentPrevent usage ofstyled-jsxinpages/_document.js.@next/next/no-sync-scriptsPrevent synchronous scripts.@next/next/no-title-in-document-headPrevent usage of<title>withHeadcomponent fromnext/document.@next/next/no-typosPrevent common typos inNext.js's data fetching functions@next/next/no-unwanted-polyfillioPrevent duplicate polyfills from Polyfill.io.We recommend using an appropriateintegrationto view warnings and errors directly in your code editor during development.ExamplesLinting custom directories and filesBy default, Next.js will run ESLint for all files in thepages/,app/,components/,lib/, andsrc/directories. However, you can specify which directories using thedirsoption in theeslintconfig innext.config.jsfor production builds:next.config.jsmodule.exports={eslint:{dirs:['pages','utils'],// Only run ESLint on the 'pages' and 'utils' directories during production builds (next build)},}Similarly, the--dirand--fileflags can be used fornext lintto lint specific directories and files:Terminalnextlint--dirpages--dirutils--filebar.jsSpecifying a root directory within a monorepoIf you're usingeslint-plugin-nextin a project where Next.js isn't installed in your root directory (such as a monorepo), you can telleslint-plugin-nextwhere to find your Next.js application using thesettingsproperty in your.eslintrc:eslint.config.mjsimport { FlatCompat } from '@eslint/eslintrc'const compat = new FlatCompat({// import.meta.dirname is available after Node.js v20.11.0baseDirectory: import.meta.dirname,})const eslintConfig = [...compat.config({extends: ['next'],settings: {next: {rootDir: 'packages/my-app/',},},}),]export default eslintConfigrootDircan be a path (relative or absolute), a glob (i.e.""packages/*/""), or an array of paths and/or globs.Disabling the cacheTo improve performance, information of files processed by ESLint are cached by default. This is stored in.next/cacheor in your definedbuild directory. If you include any ESLint rules that depend on more than the contents of a single source file and need to disable the cache, use the--no-cacheflag withnext lint.Terminalnextlint--no-cacheDisabling rulesIf you would like to modify or disable any rules provided by the supported plugins (react,react-hooks,next), you can directly change them using therulesproperty in your.eslintrc:eslint.config.mjsimport { FlatCompat } from '@eslint/eslintrc'const compat = new FlatCompat({// import.meta.dirname is available after Node.js v20.11.0baseDirectory: import.meta.dirname,})const eslintConfig = [...compat.config({extends: ['next'],rules: {'react/no-unescaped-entities': 'off','@next/next/no-page-custom-font': 'off',},}),]export default eslintConfigWith Core Web VitalsThenext/core-web-vitalsrule set is enabled whennext lintis run for the first time and thestrictoption is selected.eslint.config.mjsimport { FlatCompat } from '@eslint/eslintrc'const compat = new FlatCompat({// import.meta.dirname is available after Node.js v20.11.0baseDirectory: import.meta.dirname,})const eslintConfig = [...compat.config({extends: ['next/core-web-vitals'],}),]export default eslintConfignext/core-web-vitalsupdateseslint-plugin-nextto error on a number of rules that are warnings by default if they affectCore Web Vitals.Thenext/core-web-vitalsentry point is automatically included for new applications built withCreate Next App.With TypeScriptIn addition to the Next.js ESLint rules,create-next-app --typescriptwill also add TypeScript-specific lint rules withnext/typescriptto your config:eslint.config.mjsimport { FlatCompat } from '@eslint/eslintrc'const compat = new FlatCompat({// import.meta.dirname is available after Node.js v20.11.0baseDirectory: import.meta.dirname,})const eslintConfig = [...compat.config({extends: ['next/core-web-vitals', 'next/typescript'],}),]export default eslintConfigThose rules are based onplugin:@typescript-eslint/recommended.
Seetypescript-eslint > Configsfor more details.With PrettierESLint also contains code formatting rules, which can conflict with your existingPrettiersetup. We recommend includingeslint-config-prettierin your ESLint config to make ESLint and Prettier work together.First, install the dependency:Terminalnpminstall--save-deveslint-config-prettieryarnadd--deveslint-config-prettierpnpmadd--save-deveslint-config-prettierbunadd--deveslint-config-prettierThen, addprettierto your existing ESLint config:eslint.config.mjsimport { FlatCompat } from '@eslint/eslintrc'const compat = new FlatCompat({// import.meta.dirname is available after Node.js v20.11.0baseDirectory: import.meta.dirname,})const eslintConfig = [...compat.config({extends: ['next', 'prettier'],}),]export default eslintConfigRunning lint on staged filesIf you would like to usenext lintwithlint-stagedto run the linter on staged git files, you'll have to add the following to the.lintstagedrc.jsfile in the root of your project in order to specify usage of the--fileflag..lintstagedrc.jsconstpath=require('path')constbuildEslintCommand=(filenames)=>`next lint --fix --file${filenames.map((f)=>path.relative(process.cwd(),f)).join(' --file ')}`module.exports={'*.{js,jsx,ts,tsx}':[buildEslintCommand],}Disabling linting during production buildsIf you do not want ESLint to run duringnext build, you can set theeslint.ignoreDuringBuildsoption innext.config.jstotrue:next.config.tsTypeScriptJavaScriptTypeScriptimporttype{ NextConfig }from'next'constnextConfig:NextConfig={eslint:{// Warning: This allows production builds to successfully complete even if// your project has ESLint errors.ignoreDuringBuilds:true,},}exportdefaultnextConfigMigrating existing configIf you already have ESLint configured in your application, we recommend extending from this plugin directly instead of includingeslint-config-nextunless a few conditions are met.Recommended plugin rulesetIf the following conditions are true:You have one or more of the following plugins already installed (either separately or through a different config such asairbnborreact-app):reactreact-hooksjsx-a11yimportYou've defined specificparserOptionsthat are different from how Babel is configured within Next.js (this is not recommended unless you havecustomized your Babel configuration)You haveeslint-plugin-importinstalled with Node.js and/or TypeScriptresolversdefined to handle importsThen we recommend either removing these settings if you prefer how these properties have been configured withineslint-config-nextor extending directly from the Next.js ESLint plugin instead:module.exports={extends:[//...'plugin:@next/next/recommended',],}The plugin can be installed normally in your project without needing to runnext lint:Terminalnpminstall--save-dev@next/eslint-plugin-nextyarnadd--dev@next/eslint-plugin-nextpnpmadd--save-dev@next/eslint-plugin-nextbunadd--dev@next/eslint-plugin-nextThis eliminates the risk of collisions or errors that can occur due to importing the same plugin or parser across multiple configurations.Additional configurationsIf you already use a separate ESLint configuration and want to includeeslint-config-next, ensure that it is extended last after other configurations. For example:eslint.config.mjsimport js from '@eslint/js'import { FlatCompat } from '@eslint/eslintrc'const compat = new FlatCompat({// import.meta.dirname is available after Node.js v20.11.0baseDirectory: import.meta.dirname,recommendedConfig: js.configs.recommended,})const eslintConfig = [...compat.config({extends: ['eslint:recommended', 'next'],}),]export default eslintConfigThenextconfiguration already handles setting default values for theparser,pluginsandsettingsproperties. There is no need to manually re-declare any of these properties unless you need a different configuration for your use case.If you include any other shareable configurations,you will need to make sure that these properties are not overwritten or modified. Otherwise, we recommend removing any configurations that share behavior with thenextconfiguration or extending directly from the Next.js ESLint plugin as mentioned above.PreviousTypeScriptNextCLIWas this helpful?supported.Send"
cli,CLI,"App RouterAPI ReferenceCLICLINext.js comes withtwoCommand Line Interface (CLI) tools:create-next-app: Quickly create a new Next.js application using the default template or anexamplefrom a public GitHub repository.next: Run the Next.js development server, build your application, and more.create-next-appCreate Next.js apps using one command with the create-next-app CLI.next CLILearn how to run and build your application with the Next.js CLI.PreviousESLintNextcreate-next-appWas this helpful?supported.Send"
create-next-app,create-next-app,"API ReferenceCLIcreate-next-appcreate-next-appThecreate-next-appCLI allow you to create a new Next.js application using the default template or anexamplefrom a public GitHub repository. It is the easiest way to get started with Next.js.Basic usage:Terminalnpxcreate-next-app@latest[project-name] [options]ReferenceThe following options are available:OptionsDescription-hor--helpShow all available options-vor--versionOutput the version number--no-*Negate default options. E.g.--no-eslint--tsor--typescriptInitialize as a TypeScript project (default)--jsor--javascriptInitialize as a JavaScript project--tailwindInitialize with Tailwind CSS config (default)--eslintInitialize with ESLint config--appInitialize as an App Router project--apiInitialize a project with only route handlers--src-dirInitialize inside asrc/directory--turbopackEnable Turbopack by default for development--import-alias <alias-to-configure>Specify import alias to use (default ""@/*"")--emptyInitialize an empty project--use-npmExplicitly tell the CLI to bootstrap the application using npm--use-pnpmExplicitly tell the CLI to bootstrap the application using pnpm--use-yarnExplicitly tell the CLI to bootstrap the application using Yarn--use-bunExplicitly tell the CLI to bootstrap the application using Bun-eor--example [name] [github-url]An example to bootstrap the app with--example-path <path-to-example>Specify the path to the example separately--reset-preferencesExplicitly tell the CLI to reset any stored preferences--skip-installExplicitly tell the CLI to skip installing packages--yesUse previous preferences or defaults for all optionsExamplesWith the default templateTo create a new app using the default template, run the following command in your terminal:Terminalnpxcreate-next-app@latestYou will then be asked the following prompts:TerminalWhat is your project named?  my-appWould you like to use TypeScript?  No / YesWould you like to use ESLint?  No / YesWould you like to use Tailwind CSS?  No / YesWould you like your code inside a `src/` directory?  No / YesWould you like to use App Router? (recommended)  No / YesWould you like to use Turbopack for `next dev`?  No / YesWould you like to customize the import alias (`@/*` by default)?  No / YesOnce you've answered the prompts, a new project will be created with your chosen configuration.With an official Next.js exampleTo create a new app using an official Next.js example, use the--exampleflag. For example:Terminalnpxcreate-next-app@latest--example[example-name] [your-project-name]You can view a list of all available examples along with setup instructions in theNext.js repository.With any public GitHub exampleTo create a new app using any public GitHub example, use the--exampleoption with the GitHub repo's URL. For example:Terminalnpxcreate-next-app@latest--example""https://github.com/.../""[your-project-name]PreviousCLINextnext CLIWas this helpful?supported.Send"
next cli,next CLI,"API ReferenceCLInext CLInext CLIThe Next.js CLI allows you to develop, build, start your application, and more.Basic usage:Terminalnpxnext[command] [options]ReferenceThe following options are available:OptionsDescription-hor--helpShows all available options-vor--versionOutputs the Next.js version numberCommandsThe following commands are available:CommandDescriptiondevStarts Next.js in development mode with Hot Module Reloading, error reporting, and more.buildCreates an optimized production build of your application. Displaying information about each route.startStarts Next.js in production mode. The application should be compiled withnext buildfirst.infoPrints relevant details about the current system which can be used to report Next.js bugs.lintRuns ESLint for all files in the/src,/app,/pages,/components, and/libdirectories. It also provides a guided setup to install any required dependencies if ESLint it is not already configured in your application.telemetryAllows you to enable or disable Next.js' completely anonymous telemetry collection.Good to know: Runningnextwithout a command is an alias fornext dev.next devoptionsnext devstarts the application in development mode with Hot Module Reloading (HMR), error reporting, and more. The following options are available when runningnext dev:OptionDescription-h, --helpShow all available options.[directory]A directory in which to build the application. If not provided, current directory is used.--turbopackStarts development mode usingTurbopack.-por--port <port>Specify a port number on which to start the application. Default: 3000, env: PORT-Hor--hostname <hostname>Specify a hostname on which to start the application. Useful for making the application available for other devices on the network. Default: 0.0.0.0--experimental-httpsStarts the server with HTTPS and generates a self-signed certificate.--experimental-https-key <path>Path to a HTTPS key file.--experimental-https-cert <path>Path to a HTTPS certificate file.--experimental-https-ca <path>Path to a HTTPS certificate authority file.--experimental-upload-trace <traceUrl>Reports a subset of the debugging trace to a remote HTTP URL.next buildoptionsnext buildcreates an optimized production build of your application. The output displays information about each route. For example:TerminalRoute(app)                              Size     First Load JS┌○/_not-found0B0kB└ƒ/products/[id]0B0kB○(Static)   prerendered as static contentƒ(Dynamic)  server-rendered on demandSize: The size of assets downloaded when navigating to the page client-side. The size for each route only includes its dependencies.First Load JS: The size of assets downloaded when visiting the page from the server. The amount of JS shared by all is shown as a separate metric.Both of these values arecompressed with gzip. The first load is indicated by green, yellow, or red. Aim for green for performant applications.The following options are available for thenext buildcommand:OptionDescription-h, --helpShow all available options.[directory]A directory on which to build the application. If not provided, the current directory will be used.-dor--debugEnables a more verbose build output. With this flag enabled additional build output like rewrites, redirects, and headers will be shown.--profileEnables productionprofiling for React.--no-lintDisables linting.--no-manglingDisablesmangling. This may affect performance and should only be used for debugging purposes.--experimental-app-onlyBuilds only App Router routes.--experimental-build-mode [mode]Uses an experimental build mode. (choices: ""compile"", ""generate"", default: ""default"")next startoptionsnext startstarts the application in production mode. The application should be compiled withnext buildfirst.The following options are available for thenext startcommand:OptionDescription-hor--helpShow all available options.[directory]A directory on which to start the application. If no directory is provided, the current directory will be used.-por--port <port>Specify a port number on which to start the application. (default: 3000, env: PORT)-Hor--hostname <hostname>Specify a hostname on which to start the application (default: 0.0.0.0).--keepAliveTimeout <keepAliveTimeout>Specify the maximum amount of milliseconds to wait before closing the inactive connections.next infooptionsnext infoprints relevant details about the current system which can be used to report Next.js bugs when opening aGitHub issue. This information includes Operating System platform/arch/version, Binaries (Node.js, npm, Yarn, pnpm), package versions (next,react,react-dom), and more.The output should look like this:TerminalOperatingSystem:Platform:darwinArch:arm64Version:DarwinKernelVersion23.6.0Availablememory(MB): 65536AvailableCPUcores:10Binaries:Node:20.12.0npm:10.5.0Yarn:1.22.19pnpm:9.6.0RelevantPackages:next:15.0.0-canary.115//Latestavailableversionisdetected(15.0.0-canary.115).eslint-config-next:14.2.5react:19.0.0-rcreact-dom:19.0.0typescript:5.5.4Next.jsConfig:output:N/AThe following options are available for thenext infocommand:OptionDescription-hor--helpShow all available options--verboseCollects additional information for debugging.next lintoptionsnext lintruns ESLint for all files in thepages/,app/,components/,lib/, andsrc/directories. It also provides a guided setup to install any required dependencies if ESLint is not already configured in your application.The following options are available for thenext lintcommand:OptionDescription[directory]A base directory on which to lint the application. If not provided, the current directory will be used.-d, --dir, <dirs...>Include directory, or directories, to run ESLint.--file, <files...>Include file, or files, to run ESLint.--ext, [exts...]Specify JavaScript file extensions. (default: ["".js"", "".mjs"", "".cjs"", "".jsx"", "".ts"", "".mts"", "".cts"", "".tsx""])-c, --config, <config>Uses this configuration file, overriding all other configuration options.--resolve-plugins-relative-to, <rprt>Specify a directory where plugins should be resolved from.--strictCreates a.eslintrc.jsonfile using the Next.js strict configuration.--rulesdir, <rulesdir...>Uses additional rules from this directory(s).--fixAutomatically fix linting issues.--fix-type <fixType>Specify the types of fixes to apply (e.g., problem, suggestion, layout).--ignore-path <path>Specify a file to ignore.--no-ignore <path>Disables the--ignore-pathoption.--quietReports errors only.--max-warnings [maxWarnings]Specify the number of warnings before triggering a non-zero exit code. (default: -1)-o, --output-file, <outputFile>Specify a file to write report to.-f, --format, <format>Uses a specific output format.--no-inline-configPrevents comments from changing config or rules.--report-unused-disable-directives-severity <level>Specify severity level for unused eslint-disable directives. (choices: ""error"", ""off"", ""warn"")--no-cacheDisables caching.--cache-location, <cacheLocation>Specify a location for cache.--cache-strategy, [cacheStrategy]Specify a strategy to use for detecting changed files in the cache. (default: ""metadata"")--error-on-unmatched-patternReports errors when any file patterns are unmatched.-h, --helpDisplays this message.next telemetryoptionsNext.js collectscompletely anonymoustelemetry data about general usage. Participation in this anonymous program is optional, and you can opt-out if you prefer not to share information.The following options are available for thenext telemetrycommand:OptionDescription-h, --helpShow all available options.--enableEnables Next.js' telemetry collection.--disableDisables Next.js' telemetry collection.Learn more aboutTelemetry.ExamplesChanging the default portBy default, Next.js useshttp://localhost:3000during development and withnext start. The default port can be changed with the-poption, like so:Terminalnextdev-p4000Or using thePORTenvironment variable:TerminalPORT=4000nextdevGood to know:PORTcannot be set in.envas booting up the HTTP server happens before any other code is initialized.Using HTTPS during developmentFor certain use cases like webhooks or authentication, you can useHTTPSto have a secure environment onlocalhost. Next.js can generate a self-signed certificate withnext devusing the--experimental-httpsflag:Terminalnextdev--experimental-httpsWith the generated certificate, the Next.js development server will exist athttps://localhost:3000. The default port3000is used unless a port is specified with-p,--port, orPORT.You can also provide a custom certificate and key with--experimental-https-keyand--experimental-https-cert. Optionally, you can provide a custom CA certificate with--experimental-https-caas well.Terminalnextdev--experimental-https--experimental-https-key./certificates/localhost-key.pem--experimental-https-cert./certificates/localhost.pemnext dev --experimental-httpsis only intended for development and creates a locally trusted certificate withmkcert. In production, use properly issued certificates from trusted authorities.Good to know: When deploying to Vercel, HTTPS isautomatically configuredfor your Next.js application.Configuring a timeout for downstream proxiesWhen deploying Next.js behind a downstream proxy (e.g. a load-balancer like AWS ELB/ALB), it's important to configure Next's underlying HTTP server withkeep-alive timeoutsthat arelargerthan the downstream proxy's timeouts. Otherwise, once a keep-alive timeout is reached for a given TCP connection, Node.js will immediately terminate that connection without notifying the downstream proxy. This results in a proxy error whenever it attempts to reuse a connection that Node.js has already terminated.To configure the timeout values for the production Next.js server, pass--keepAliveTimeout(in milliseconds) tonext start, like so:Terminalnextstart--keepAliveTimeout70000Passing Node.js argumentsYou can pass anynode argumentstonextcommands. For example:TerminalNODE_OPTIONS='--throw-deprecation'nextNODE_OPTIONS='-r esm'nextNODE_OPTIONS='--inspect'nextPreviouscreate-next-appNextEdge RuntimeWas this helpful?supported.Send"
edge runtime,Edge Runtime,"App RouterAPI ReferenceEdge RuntimeEdge RuntimeThe Next.js Edge Runtime is used for Middleware and supports the following APIs:Network APIsAPIDescriptionBlobRepresents a blobfetchFetches a resourceFetchEventRepresents a fetch eventFileRepresents a fileFormDataRepresents form dataHeadersRepresents HTTP headersRequestRepresents an HTTP requestResponseRepresents an HTTP responseURLSearchParamsRepresents URL search parametersWebSocketRepresents a websocket connectionEncoding APIsAPIDescriptionatobDecodes a base-64 encoded stringbtoaEncodes a string in base-64TextDecoderDecodes a Uint8Array into a stringTextDecoderStreamChainable decoder for streamsTextEncoderEncodes a string into a Uint8ArrayTextEncoderStreamChainable encoder for streamsStream APIsAPIDescriptionReadableStreamRepresents a readable streamReadableStreamBYOBReaderRepresents a reader of a ReadableStreamReadableStreamDefaultReaderRepresents a reader of a ReadableStreamTransformStreamRepresents a transform streamWritableStreamRepresents a writable streamWritableStreamDefaultWriterRepresents a writer of a WritableStreamCrypto APIsAPIDescriptioncryptoProvides access to the cryptographic functionality of the platformCryptoKeyRepresents a cryptographic keySubtleCryptoProvides access to common cryptographic primitives, like hashing, signing, encryption or decryptionWeb Standard APIsAPIDescriptionAbortControllerAllows you to abort one or more DOM requests as and when desiredArrayRepresents an array of valuesArrayBufferRepresents a generic, fixed-length raw binary data bufferAtomicsProvides atomic operations as static methodsBigIntRepresents a whole number with arbitrary precisionBigInt64ArrayRepresents a typed array of 64-bit signed integersBigUint64ArrayRepresents a typed array of 64-bit unsigned integersBooleanRepresents a logical entity and can have two values:trueandfalseclearIntervalCancels a timed, repeating action which was previously established by a call tosetInterval()clearTimeoutCancels a timed, repeating action which was previously established by a call tosetTimeout()consoleProvides access to the browser's debugging consoleDataViewRepresents a generic view of anArrayBufferDateRepresents a single moment in time in a platform-independent formatdecodeURIDecodes a Uniform Resource Identifier (URI) previously created byencodeURIor by a similar routinedecodeURIComponentDecodes a Uniform Resource Identifier (URI) component previously created byencodeURIComponentor by a similar routineDOMExceptionRepresents an error that occurs in the DOMencodeURIEncodes a Uniform Resource Identifier (URI) by replacing each instance of certain characters by one, two, three, or four escape sequences representing the UTF-8 encoding of the characterencodeURIComponentEncodes a Uniform Resource Identifier (URI) component by replacing each instance of certain characters by one, two, three, or four escape sequences representing the UTF-8 encoding of the characterErrorRepresents an error when trying to execute a statement or accessing a propertyEvalErrorRepresents an error that occurs regarding the global functioneval()Float32ArrayRepresents a typed array of 32-bit floating point numbersFloat64ArrayRepresents a typed array of 64-bit floating point numbersFunctionRepresents a functionInfinityRepresents the mathematical Infinity valueInt8ArrayRepresents a typed array of 8-bit signed integersInt16ArrayRepresents a typed array of 16-bit signed integersInt32ArrayRepresents a typed array of 32-bit signed integersIntlProvides access to internationalization and localization functionalityisFiniteDetermines whether a value is a finite numberisNaNDetermines whether a value isNaNor notJSONProvides functionality to convert JavaScript values to and from the JSON formatMapRepresents a collection of values, where each value may occur only onceMathProvides access to mathematical functions and constantsNumberRepresents a numeric valueObjectRepresents the object that is the base of all JavaScript objectsparseFloatParses a string argument and returns a floating point numberparseIntParses a string argument and returns an integer of the specified radixPromiseRepresents the eventual completion (or failure) of an asynchronous operation, and its resulting valueProxyRepresents an object that is used to define custom behavior for fundamental operations (e.g. property lookup, assignment, enumeration, function invocation, etc)queueMicrotaskQueues a microtask to be executedRangeErrorRepresents an error when a value is not in the set or range of allowed valuesReferenceErrorRepresents an error when a non-existent variable is referencedReflectProvides methods for interceptable JavaScript operationsRegExpRepresents a regular expression, allowing you to match combinations of charactersSetRepresents a collection of values, where each value may occur only oncesetIntervalRepeatedly calls a function, with a fixed time delay between each callsetTimeoutCalls a function or evaluates an expression after a specified number of millisecondsSharedArrayBufferRepresents a generic, fixed-length raw binary data bufferStringRepresents a sequence of charactersstructuredCloneCreates a deep copy of a valueSymbolRepresents a unique and immutable data type that is used as the key of an object propertySyntaxErrorRepresents an error when trying to interpret syntactically invalid codeTypeErrorRepresents an error when a value is not of the expected typeUint8ArrayRepresents a typed array of 8-bit unsigned integersUint8ClampedArrayRepresents a typed array of 8-bit unsigned integers clamped to 0-255Uint32ArrayRepresents a typed array of 32-bit unsigned integersURIErrorRepresents an error when a global URI handling function was used in a wrong wayURLRepresents an object providing static methods used for creating object URLsURLPatternRepresents a URL patternURLSearchParamsRepresents a collection of key/value pairsWeakMapRepresents a collection of key/value pairs in which the keys are weakly referencedWeakSetRepresents a collection of objects in which each object may occur only onceWebAssemblyProvides access to WebAssemblyNext.js Specific PolyfillsAsyncLocalStorageEnvironment VariablesYou can useprocess.envto accessEnvironment Variablesfor bothnext devandnext build.Unsupported APIsThe Edge Runtime has some restrictions including:Native Node.js APIsare not supported. For example, you can't read or write to the filesystem.node_modulescanbe used, as long as they implement ES Modules and do not use native Node.js APIs.Callingrequiredirectly isnot allowed. Use ES Modules instead.The following JavaScript language features are disabled, andwill not work:APIDescriptionevalEvaluates JavaScript code represented as a stringnew Function(evalString)Creates a new function with the code provided as an argumentWebAssembly.compileCompiles a WebAssembly module from a buffer sourceWebAssembly.instantiateCompiles and instantiates a WebAssembly module from a buffer sourceIn rare cases, your code could contain (or import) some dynamic code evaluation statements whichcan not be reached at runtimeand which can not be removed by treeshaking.
You can relax the check to allow specific files with your Middleware configuration:middleware.tsexportconstconfig={unstable_allowDynamic:[// allows a single file'/lib/utilities.js',// use a glob to allow anything in the function-bind 3rd party module'**/node_modules/function-bind/**',],}unstable_allowDynamicis aglob, or an array of globs, ignoring dynamic code evaluation for specific files. The globs are relative to your application root folder.Be warned that if these statements are executed on the Edge,they will throw and cause a runtime error.Previousnext CLINextTurbopackWas this helpful?supported.Send"
turbopack,Turbopack,"App RouterAPI ReferenceTurbopackTurbopackTurbopackis an incremental bundler optimized for JavaScript and TypeScript, written in Rust, and built into Next.js. Turbopack can be used in Next.js in both thepagesandappdirectories for faster local development.To enable Turbopack, use the--turbopackflag when running the Next.js development server.package.json{""scripts"":{""dev"":""next dev --turbopack"",""build"":""next build"",""start"":""next start"",""lint"":""next lint""}}ReferenceSupported featuresTurbopack in Next.js requires zero-configuration for most users and can be extended for more advanced use cases. To learn more about the currently supported features for Turbopack, view theAPI Reference.Unsupported featuresTurbopack currently only supportsnext devand does not supportnext build. We are currently working on support for builds as we move closer towards stability.These features are currently not supported:Turbopack leveragesLightning CSSwhich doesn't support some low usage CSS Modules features:localand:globalas standalone pseudo classes. Only the function variant is supported, for example::global(a).The @value rule which has been superseded by CSS variables.:importand:exportICSS rules.Invalid CSS comment syntaxsuch as//CSS comments should be written as/* comment */per the specification.Preprocessors such as Sass do support this alternative syntax for comments.webpack()configuration innext.config.jsTurbopack replaces Webpack, this means that webpack configuration is not supported.To configure Turbopack,see the documentation.A subset ofWebpack loadersare supported in Turbopack.Babel (.babelrc)Turbopack leverages theSWCcompiler for all transpilation and optimizations. This means that Babel is not included by default.If you have a.babelrcfile, you might no longer need it because Next.js includes common Babel plugins as SWC transforms that can be enabled. You can read more about this in thecompiler documentation.If you still need to use Babel after verifying your particular use case is not covered, you can leverage Turbopack'ssupport for custom webpack loadersto includebabel-loader.Creating a root layout automatically in App Router.This behavior is currently not supported since it changes input files, instead, an error will be shown for you to manually add a root layout in the desired location.@next/font(legacy font support).@next/fontis deprecated in favor ofnext/font.next/fontis fully supported with Turbopack.Relay transformsWe are planning to implement this in the future.Blocking.cssimports inpages/_document.tsxCurrently with webpack Next.js blocks importing.cssfiles inpages/_document.tsxWe are planning to implement this warning in the future.experimental.typedRoutesWe are planning to implement this in the future.experimental.nextScriptWorkersWe are planning to implement this in the future.experimental.sri.algorithmWe are planning to implement this in the future.experimental.fallbackNodePolyfillsWe are planning to implement this in the future.experimental.esmExternalsWe are currently not planning to support the legacy esmExternals configuration in Next.js with Turbopack.AMP.We are currently not planning to support AMP in Next.js with Turbopack.Yarn PnPWe are currently not planning to support Yarn PnP in Next.js with Turbopack.experimental.urlImportsWe are currently not planning to supportexperimental.urlImportsin Next.js with Turbopack.:importand:exportICSS rulesWe are currently not planning to support:importand:exportICSS rules in Next.js with Turbopack asLightning CSSthe CSS parser Turbopack uses does not support these rules.unstable_allowDynamicconfiguration in edge runtimeExamplesGenerating Trace FilesTrace files allow the Next.js team to investigate and improve performance metrics and memory usage. To generate a trace file, appendNEXT_TURBOPACK_TRACING=1to thenext dev --turbopackcommand, this will generate a.next/trace-turbopackfile.When reporting issues related to Turbopack performance and memory usage, please include the trace file in yourGitHubissue.PreviousEdge RuntimeNextPages RouterWas this helpful?supported.Send"
getting started,Getting Started,"IntroductionPages RouterGetting StartedGetting Started - Pages RouterInstallationHow to create a new Next.js application with `create-next-app`. Set up TypeScript, ESLint,and configure your `next.config.js` file.Project StructureLearn about the folder and file conventions in a Next.js project, and how to organize your project.PreviousPages RouterNextInstallationWas this helpful?supported.Send"
installation,Installation,"Pages RouterGetting StartedInstallationCreate a new Next.js applicationSystem requirementsNode.js 18.18or later.macOS, Windows (including WSL), and Linux are supported.Automatic installationWe recommend starting a new Next.js app usingcreate-next-app, which sets up everything automatically for you. To create a project, run:Terminalnpxcreate-next-app@latestOn installation, you'll see the following prompts:TerminalWhat is your project named? my-appWould you like to use TypeScript? No / YesWould you like to use ESLint? No / YesWould you like to use Tailwind CSS? No / YesWould you like your code inside a `src/` directory? No / YesWould you like to use App Router? (recommended) No / YesWould you like to use Turbopack for `next dev`?  No / YesWould you like to customize the import alias (`@/*` by default)? No / YesWhat import alias would you like configured? @/*After the prompts,create-next-appwill create a folder with your project name and install the required dependencies.Manual installationTo manually create a new Next.js app, install the required packages:Terminalnpminstallnext@latestreact@latestreact-dom@latestOpen yourpackage.jsonfile and add the followingscripts:package.json{""scripts"":{""dev"":""next dev"",""build"":""next build"",""start"":""next start"",""lint"":""next lint""}}These scripts refer to the different stages of developing an application:dev: runsnext devto start Next.js in development mode.build: runsnext buildto build the application for production usage.start: runsnext startto start a Next.js production server.lint: runsnext lintto set up Next.js' built-in ESLint configuration.Create thepagesdirectoryNext.js uses file-system routing, which means the routes in your application are determined by how you structure your files.Create apagesdirectory at the root of your project. Then, add anindex.tsxfile inside yourpagesfolder. This will be your home page (/):pages/index.tsxTypeScriptJavaScriptTypeScriptexportdefaultfunctionPage() {return<h1>Hello, Next.js!</h1>}Next, add an_app.tsxfile insidepages/to define the global layout. Learn more about thecustom App file.pages/_app.tsxTypeScriptJavaScriptTypeScriptimporttype{ AppProps }from'next/app'exportdefaultfunctionApp({ Component,pageProps }:AppProps) {return<Component{...pageProps} />}Finally, add a_document.tsxfile insidepages/to control the initial response from the server. Learn more about thecustom Document file.pages/_document.tsxTypeScriptJavaScriptTypeScriptimport{ Html,Head,Main,NextScript }from'next/document'exportdefaultfunctionDocument() {return(<Html><Head/><body><Main/><NextScript/></body></Html>)}Create thepublicfolder (optional)You can optionally create apublicfolderat the root of your project to store static assets such as images, fonts, etc. Files insidepubliccan then be referenced by your code starting from the base URL (/).Run the development serverRunnpm run devto start the development server.Visithttp://localhost:3000to view your application.Edit thepages/index.tsxfile and save it to see the updated result in your browser.Set up TypeScriptMinimum TypeScript version:v4.5.2Next.js comes with built-in TypeScript support. To add TypeScript to your project, rename a file to.ts/.tsx. Runnext dev, Next.js will automatically install the necessary dependencies and add atsconfig.jsonfile with the recommended config options.See theTypeScript configurationpage for more information on how to use TypeScript in your project.Set up ESLintNext.js comes with built-in ESLint, automatically installing the necessary packages and configuring the proper settings when you create a new project withcreate-next-app.To add ESLint to an existing project, addnext lintas a script topackage.json:package.json{""scripts"":{""lint"":""next lint""}}Then, runnpm run lintand you will be guided through the installation and configuration process.TerminalnpmrunlintYou'll see a prompt like this:? How would you like to configure ESLint?❯ Strict (recommended)BaseCancelStrict: Includes Next.js' base ESLint configuration along with a stricter Core Web Vitals rule-set. This is the recommended configuration for developers setting up ESLint for the first time.Base: Includes Next.js' base ESLint configuration.Cancel: Does not include any ESLint configuration. Only select this option if you plan on setting up your own custom ESLint configuration.If either of the two configuration options are selected, Next.js will automatically installeslintandeslint-config-nextas dependencies in your application and create an.eslintrc.jsonfile in the root of your project that includes your selected configuration.You can now runnext lintevery time you want to run ESLint to catch errors. Once ESLint has been set up, it will also automatically run during every build (next build). Errors will fail the build, while warnings will not.See theESLint Pluginpage for more information on how to configure ESLint in your project.Set up Absolute Imports and Module Path AliasesNext.js has in-built support for the""paths""and""baseUrl""options oftsconfig.jsonandjsconfig.jsonfiles. These options allow you to alias project directories to absolute paths, making it easier to import modules. For example:// Beforeimport{ Button }from'../../../components/button'// Afterimport{ Button }from'@/components/button'To configure absolute imports, add thebaseUrlconfiguration option to yourtsconfig.jsonorjsconfig.jsonfile. For example:tsconfig.json or jsconfig.json{""compilerOptions"":{""baseUrl"":""src/""}}In addition to configuring thebaseUrlpath, you can use the""paths""option to""alias""module paths.For example, the following configuration maps@/components/*tocomponents/*:tsconfig.json or jsconfig.json{""compilerOptions"":{""baseUrl"":""src/"",""paths"":{""@/styles/*"":[""styles/*""],""@/components/*"":[""components/*""]}}}Each of the""paths""are relative to thebaseUrllocation. For example:src/app/page.tsxTypeScriptJavaScriptTypeScriptimportButtonfrom'@/components/button'import'@/styles/styles.css'exportdefaultfunctionHomePage() {return(<div><h1>Hello World</h1><Button/></div>)}PreviousGetting StartedNextProject StructureWas this helpful?supported.Send"
project structure,Project Structure,"Pages RouterGetting StartedProject StructureProject Structure and OrganizationThis page provides an overview of the folder and file conventions in Next.js, as well as tips for organizing your project.Folder and file conventionsTop-level foldersTop-level folders are used to organize your application's code and static assets.appApp RouterpagesPages RouterpublicStatic assets to be servedsrcOptional application source folderTop-level filesTop-level files are used to configure your application, manage dependencies, run middleware, integrate monitoring tools, and define environment variables.Next.jsnext.config.jsConfiguration file for Next.jspackage.jsonProject dependencies and scriptsinstrumentation.tsOpenTelemetry and Instrumentation filemiddleware.tsNext.js request middleware.envEnvironment variables.env.localLocal environment variables.env.productionProduction environment variables.env.developmentDevelopment environment variables.eslintrc.jsonConfiguration file for ESLint.gitignoreGit files and folders to ignorenext-env.d.tsTypeScript declaration file for Next.jstsconfig.jsonConfiguration file for TypeScriptjsconfig.jsonConfiguration file for JavaScriptFiles conventions_app.js.jsx.tsxCustom App_document.js.jsx.tsxCustom Document_error.js.jsx.tsxCustom Error Page404.js.jsx.tsx404 Error Page500.js.jsx.tsx500 Error PageRoutesFolder conventionindex.js.jsx.tsxHome pagefolder/index.js.jsx.tsxNested pageFile conventionindex.js.jsx.tsxHome pagefile.js.jsx.tsxNested pageDynamic routesFolder convention[folder]/index.js.jsx.tsxDynamic route segment[...folder]/index.js.jsx.tsxCatch-all route segment[[...folder]]/index.js.jsx.tsxOptional catch-all route segmentFile convention[file].js.jsx.tsxDynamic route segment[...file].js.jsx.tsxCatch-all route segment[[...file]].js.jsx.tsxOptional catch-all route segmentPreviousInstallationNextBuilding Your ApplicationWas this helpful?supported.Send"
building your application,Building Your Application,"IntroductionPages RouterBuilding Your ApplicationBuilding Your ApplicationNext.js provides the building blocks to create flexible, full-stack web applications. The guides inBuilding Your Applicationexplain how to use these features and how to customize your application's behavior.The sections and pages are organized sequentially, from basic to advanced, so you can follow them step-by-step when building your Next.js application. However, you can read them in any order or skip to the pages that apply to your use case.If you're new to Next.js, we recommend starting with theRouting,Rendering,Data FetchingandStylingsections, as they introduce the fundamental Next.js and web concepts to help you get started. Then, you can dive deeper into the other sections such asOptimizingandConfiguring. Finally, once you're ready, checkout theDeployingandUpgradingsections.RoutingLearn the fundamentals of routing for front-end applications with the Pages Router.RenderingLearn the fundamentals of rendering in React and Next.js.Data FetchingNext.js allows you to fetch data in multiple ways, with pre-rendering, server-side rendering or static-site generation, and incremental static regeneration. Learn how to manage your application data in Next.js.StylingLearn the different ways you can style your Next.js application.OptimizingOptimize your Next.js application for best performance and user experience.ConfiguringLearn how to configure your Next.js application.TestingLearn how to set up Next.js with three commonly used testing tools — Cypress, Playwright, Vitest, and Jest.AuthenticationLearn how to implement authentication in Next.js, covering best practices, securing routes, authorization techniques, and session management.DeployingLearn how to deploy your Next.js app to production, either managed or self-hosted.UpgradingLearn how to upgrade to the latest versions of Next.js.PreviousProject StructureNextRoutingWas this helpful?supported.Send"
routing,Routing,"Pages RouterBuilding Your ApplicationRoutingRoutingThe Pages Router has a file-system based router built on concepts of pages. When a file is added to thepagesdirectory it's automatically available as a route. Learn more about routing in the Pages Router:Pages and LayoutsCreate your first page and shared layout with the Pages Router.Dynamic RoutesDynamic Routes are pages that allow you to add custom params to your URLs. Start creating Dynamic Routes and learn more here.Linking and NavigatingLearn how navigation works in Next.js, and how to use the Link Component and `useRouter` hook.RedirectingLearn the different ways to handle redirects in Next.js.Custom AppControl page initialization and add a layout that persists for all pages by overriding the default App component used by Next.js.Custom DocumentExtend the default document markup added by Next.js.API RoutesNext.js supports API Routes, which allow you to build your API without leaving your Next.js app. Learn how it works here.Custom ErrorsOverride and extend the built-in Error page to handle custom errors.InternationalizationNext.js has built-in support for internationalized routing and language detection. Learn more here.MiddlewareLearn how to use Middleware to run code before a request is completed.PreviousBuilding Your ApplicationNextPages and LayoutsWas this helpful?supported.Send"
pages and layouts,Pages and Layouts,"Building Your ApplicationRoutingPages and LayoutsPages and LayoutsThe Pages Router has a file-system based router built on the concept of pages.When a file is added to thepagesdirectory, it's automatically available as a route.In Next.js, apageis aReact Componentexported from a.js,.jsx,.ts, or.tsxfile in thepagesdirectory. Each page is associated with a route based on its file name.Example: If you createpages/about.jsthat exports a React component like below, it will be accessible at/about.exportdefaultfunctionAbout() {return<div>About</div>}Index routesThe router will automatically route files namedindexto the root of the directory.pages/index.js→/pages/blog/index.js→/blogNested routesThe router supports nested files. If you create a nested folder structure, files will automatically be routed in the same way still.pages/blog/first-post.js→/blog/first-postpages/dashboard/settings/username.js→/dashboard/settings/usernamePages with Dynamic RoutesNext.js supports pages with dynamic routes. For example, if you create a file calledpages/posts/[id].js, then it will be accessible atposts/1,posts/2, etc.To learn more about dynamic routing, check theDynamic Routing documentation.Layout PatternThe React model allows us to deconstruct apageinto a series of components. Many of these components are often reused between pages. For example, you might have the same navigation bar and footer on every page.components/layout.jsimportNavbarfrom'./navbar'importFooterfrom'./footer'exportdefaultfunctionLayout({ children }) {return(<><Navbar/><main>{children}</main><Footer/></>)}ExamplesSingle Shared Layout with Custom AppIf you only have one layout for your entire application, you can create aCustom Appand wrap your application with the layout. Since the<Layout />component is re-used when changing pages, its component state will be preserved (e.g. input values).pages/_app.jsimportLayoutfrom'../components/layout'exportdefaultfunctionMyApp({ Component,pageProps }) {return(<Layout><Component{...pageProps} /></Layout>)}Per-Page LayoutsIf you need multiple layouts, you can add a propertygetLayoutto your page, allowing you to return a React component for the layout. This allows you to define the layout on aper-page basis. Since we're returning a function, we can have complex nested layouts if desired.pages/index.jsimportLayoutfrom'../components/layout'importNestedLayoutfrom'../components/nested-layout'exportdefaultfunctionPage() {return(/** Your content */)}Page.getLayout=functiongetLayout(page) {return(<Layout><NestedLayout>{page}</NestedLayout></Layout>)}pages/_app.jsexportdefaultfunctionMyApp({ Component,pageProps }) {// Use the layout defined at the page level, if availableconstgetLayout=Component.getLayout??((page)=>page)returngetLayout(<Component{...pageProps} />)}When navigating between pages, we want topersistpage state (input values, scroll position, etc.) for a Single-Page Application (SPA) experience.This layout pattern enables state persistence because the React component tree is maintained between page transitions. With the component tree, React can understand which elements have changed to preserve state.Good to know: This process is calledreconciliation, which is how React understands which elements have changed.With TypeScriptWhen using TypeScript, you must first create a new type for your pages which includes agetLayoutfunction. Then, you must create a new type for yourAppPropswhich overrides theComponentproperty to use the previously created type.pages/index.tsxTypeScriptJavaScriptTypeScriptimporttype{ ReactElement }from'react'importLayoutfrom'../components/layout'importNestedLayoutfrom'../components/nested-layout'importtype{ NextPageWithLayout }from'./_app'constPage:NextPageWithLayout=()=>{return<p>hello world</p>}Page.getLayout=functiongetLayout(page:ReactElement) {return(<Layout><NestedLayout>{page}</NestedLayout></Layout>)}exportdefaultPagepages/_app.tsxTypeScriptJavaScriptTypeScriptimporttype{ ReactElement,ReactNode }from'react'importtype{ NextPage }from'next'importtype{ AppProps }from'next/app'exporttypeNextPageWithLayout<P={},IP=P>=NextPage<P,IP>&{getLayout?:(page:ReactElement)=>ReactNode}typeAppPropsWithLayout=AppProps&{Component:NextPageWithLayout}exportdefaultfunctionMyApp({ Component,pageProps }:AppPropsWithLayout) {// Use the layout defined at the page level, if availableconstgetLayout=Component.getLayout??((page)=>page)returngetLayout(<Component{...pageProps} />)}Data FetchingInside your layout, you can fetch data on the client-side usinguseEffector a library likeSWR. Because this file is not aPage, you cannot usegetStaticPropsorgetServerSidePropscurrently.components/layout.jsimportuseSWRfrom'swr'importNavbarfrom'./navbar'importFooterfrom'./footer'exportdefaultfunctionLayout({ children }) {const{data,error}=useSWR('/api/navigation',fetcher)if(error)return<div>Failed to load</div>if(!data)return<div>Loading...</div>return(<><Navbarlinks={data.links} /><main>{children}</main><Footer/></>)}PreviousRoutingNextDynamic RoutesWas this helpful?supported.Send"
dynamic routes,Dynamic Routes,"Building Your ApplicationRoutingDynamic RoutesDynamic RoutesWhen you don't know the exact segment names ahead of time and want to create routes from dynamic data, you can use Dynamic Segments that are filled in at request time orprerenderedat build time.ConventionA Dynamic Segment can be created by wrapping a file or folder name in square brackets:[segmentName]. For example,[id]or[slug].Dynamic Segments can be accessed fromuseRouter.ExampleFor example, a blog could include the following routepages/blog/[slug].jswhere[slug]is the Dynamic Segment for blog posts.import{ useRouter }from'next/router'exportdefaultfunctionPage() {constrouter=useRouter()return<p>Post: {router.query.slug}</p>}RouteExample URLparamspages/blog/[slug].js/blog/a{ slug: 'a' }pages/blog/[slug].js/blog/b{ slug: 'b' }pages/blog/[slug].js/blog/c{ slug: 'c' }Catch-all SegmentsDynamic Segments can be extended tocatch-allsubsequent segments by adding an ellipsis inside the brackets[...segmentName].For example,pages/shop/[...slug].jswill match/shop/clothes, but also/shop/clothes/tops,/shop/clothes/tops/t-shirts, and so on.RouteExample URLparamspages/shop/[...slug].js/shop/a{ slug: ['a'] }pages/shop/[...slug].js/shop/a/b{ slug: ['a', 'b'] }pages/shop/[...slug].js/shop/a/b/c{ slug: ['a', 'b', 'c'] }Optional Catch-all SegmentsCatch-all Segments can be madeoptionalby including the parameter in double square brackets:[[...segmentName]].For example,pages/shop/[[...slug]].jswillalsomatch/shop, in addition to/shop/clothes,/shop/clothes/tops,/shop/clothes/tops/t-shirts.The difference betweencatch-allandoptional catch-allsegments is that with optional, the route without the parameter is also matched (/shopin the example above).RouteExample URLparamspages/shop/[[...slug]].js/shop{ slug: undefined }pages/shop/[[...slug]].js/shop/a{ slug: ['a'] }pages/shop/[[...slug]].js/shop/a/b{ slug: ['a', 'b'] }pages/shop/[[...slug]].js/shop/a/b/c{ slug: ['a', 'b', 'c'] }Next StepsFor more information on what to do next, we recommend the following sectionsLinking and NavigatingLearn how navigation works in Next.js, and how to use the Link Component and `useRouter` hook.useRouterLearn more about the API of the Next.js Router, and access the router instance in your page with the useRouter hook.PreviousPages and LayoutsNextLinking and NavigatingWas this helpful?supported.Send"
linking and navigating,Linking and Navigating,"Building Your ApplicationRoutingLinking and NavigatingLinking and NavigatingThe Next.js router allows you to do client-side route transitions between pages, similar to a single-page application.A React component calledLinkis provided to do this client-side route transition.importLinkfrom'next/link'functionHome() {return(<ul><li><Linkhref=""/"">Home</Link></li><li><Linkhref=""/about"">About Us</Link></li><li><Linkhref=""/blog/hello-world"">Blog Post</Link></li></ul>)}exportdefaultHomeThe example above uses multiple links. Each one maps a path (href) to a known page:/→pages/index.js/about→pages/about.js/blog/hello-world→pages/blog/[slug].jsAny<Link />in the viewport (initially or through scroll) will be prefetched by default (including the corresponding data) for pages usingStatic Generation. The corresponding data forserver-renderedroutes is fetchedonly whenthe<Link />is clicked.Linking to dynamic pathsYou can also use interpolation to create the path, which comes in handy fordynamic route segments. For example, to show a list of posts which have been passed to the component as a prop:importLinkfrom'next/link'functionPosts({ posts }) {return(<ul>{posts.map((post)=>(<likey={post.id}><Linkhref={`/blog/${encodeURIComponent(post.slug)}`}>{post.title}</Link></li>))}</ul>)}exportdefaultPostsencodeURIComponentis used in the example to keep the path utf-8 compatible.Alternatively, using a URL Object:importLinkfrom'next/link'functionPosts({ posts }) {return(<ul>{posts.map((post)=>(<likey={post.id}><Linkhref={{pathname:'/blog/[slug]',query:{ slug:post.slug },}}>{post.title}</Link></li>))}</ul>)}exportdefaultPostsNow, instead of using interpolation to create the path, we use a URL object inhrefwhere:pathnameis the name of the page in thepagesdirectory./blog/[slug]in this case.queryis an object with the dynamic segment.slugin this case.Injecting the routerExamplesDynamic RoutingTo access therouterobjectin a React component you can useuseRouterorwithRouter.In general we recommend usinguseRouter.Imperative Routingnext/linkshould be able to cover most of your routing needs, but you can also do client-side navigations without it, take a look at thedocumentation fornext/router.The following example shows how to do basic page navigations withuseRouter:import{ useRouter }from'next/router'exportdefaultfunctionReadMore() {constrouter=useRouter()return(<buttononClick={()=>router.push('/about')}>Click here to read more</button>)}Shallow RoutingExamplesShallow RoutingShallow routing allows you to change the URL without running data fetching methods again, that includesgetServerSideProps,getStaticProps, andgetInitialProps.You'll receive the updatedpathnameand thequeryvia therouterobject(added byuseRouterorwithRouter), without losing state.To enable shallow routing, set theshallowoption totrue. Consider the following example:import{ useEffect }from'react'import{ useRouter }from'next/router'// Current URL is '/'functionPage() {constrouter=useRouter()useEffect(()=>{// Always do navigations after the first renderrouter.push('/?counter=10',undefined,{ shallow:true})},[])useEffect(()=>{// The counter changed!},[router.query.counter])}exportdefaultPageThe URL will get updated to/?counter=10and the page won't get replaced, only the state of the route is changed.You can also watch for URL changes viacomponentDidUpdateas shown below:componentDidUpdate(prevProps) {const{pathname,query}=this.props.router// verify props have changed to avoid an infinite loopif(query.counter!==prevProps.router.query.counter) {// fetch data based on the new query}}CaveatsShallow routingonlyworks for URL changes in the current page. For example, let's assume we have another page calledpages/about.js, and you run this:router.push('/?counter=10','/about?counter=10',{ shallow:true})Since that's a new page, it'll unload the current page, load the new one and wait for data fetching even though we asked to do shallow routing.When shallow routing is used with middleware it will not ensure the new page matches the current page like previously done without middleware. This is due to middleware being able to rewrite dynamically and can't be verified client-side without a data fetch which is skipped with shallow, so a shallow route change must always be treated as shallow.PreviousDynamic RoutesNextRedirectingWas this helpful?supported.Send"
redirecting,Redirecting,"Building Your ApplicationRoutingRedirectingRedirectingThere are a few ways you can handle redirects in Next.js. This page will go through each available option, use cases, and how to manage large numbers of redirects.APIPurposeWhereStatus CodeuseRouterPerform a client-side navigationComponentsN/Aredirectsinnext.config.jsRedirect an incoming request based on a pathnext.config.jsfile307 (Temporary) or 308 (Permanent)NextResponse.redirectRedirect an incoming request based on a conditionMiddlewareAnyuseRouter()hookIf you need to redirect inside a component, you can use thepushmethod from theuseRouterhook. For example:app/page.tsxTypeScriptJavaScriptTypeScriptimport{ useRouter }from'next/router'exportdefaultfunctionPage() {constrouter=useRouter()return(<buttontype=""button""onClick={()=>router.push('/dashboard')}>Dashboard</button>)}Good to know:If you don't need to programmatically navigate a user, you should use a<Link>component.See theuseRouterAPI referencefor more information.redirectsinnext.config.jsTheredirectsoption in thenext.config.jsfile allows you to redirect an incoming request path to a different destination path. This is useful when you change the URL structure of pages or have a list of redirects that are known ahead of time.redirectssupportspath,header, cookie, and query matching, giving you the flexibility to redirect users based on an incoming request.To useredirects, add the option to yournext.config.jsfile:next.config.tsTypeScriptJavaScriptTypeScriptimporttype{ NextConfig }from'next'constnextConfig:NextConfig={asyncredirects() {return[// Basic redirect{source:'/about',destination:'/',permanent:true,},// Wildcard path matching{source:'/blog/:slug',destination:'/news/:slug',permanent:true,},]},}exportdefaultnextConfigSee theredirectsAPI referencefor more information.Good to know:redirectscan return a 307 (Temporary Redirect) or 308 (Permanent Redirect) status code with thepermanentoption.redirectsmay have a limit on platforms. For example, on Vercel, there's a limit of 1,024 redirects. To manage a large number of redirects (1000+), consider creating a custom solution usingMiddleware. Seemanaging redirects at scalefor more.redirectsrunsbeforeMiddleware.NextResponse.redirectin MiddlewareMiddleware allows you to run code before a request is completed. Then, based on the incoming request, redirect to a different URL usingNextResponse.redirect. This is useful if you want to redirect users based on a condition (e.g. authentication, session management, etc) or havea large number of redirects.For example, to redirect the user to a/loginpage if they are not authenticated:middleware.tsTypeScriptJavaScriptTypeScriptimport{ NextResponse,NextRequest }from'next/server'import{ authenticate }from'auth-provider'exportfunctionmiddleware(request:NextRequest) {constisAuthenticated=authenticate(request)// If the user is authenticated, continue as normalif(isAuthenticated) {returnNextResponse.next()}// Redirect to login page if not authenticatedreturnNextResponse.redirect(newURL('/login',request.url))}exportconstconfig={matcher:'/dashboard/:path*',}Good to know:Middleware runsafterredirectsinnext.config.jsandbeforerendering.See theMiddlewaredocumentation for more information.Managing redirects at scale (advanced)To manage a large number of redirects (1000+), you may consider creating a custom solution using Middleware. This allows you to handle redirects programmatically without having to redeploy your application.To do this, you'll need to consider:Creating and storing a redirect map.Optimizing data lookup performance.Next.js Example: See ourMiddleware with Bloom filterexample for an implementation of the recommendations below.1. Creating and storing a redirect mapA redirect map is a list of redirects that you can store in a database (usually a key-value store) or JSON file.Consider the following data structure:{""/old"":{""destination"":""/new"",""permanent"":true},""/blog/post-old"":{""destination"":""/blog/post-new"",""permanent"":true}}InMiddleware, you can read from a database such as Vercel'sEdge ConfigorRedis, and redirect the user based on the incoming request:middleware.tsTypeScriptJavaScriptTypeScriptimport{ NextResponse,NextRequest }from'next/server'import{ get }from'@vercel/edge-config'typeRedirectEntry={destination:stringpermanent:boolean}exportasyncfunctionmiddleware(request:NextRequest) {constpathname=request.nextUrl.pathnameconstredirectData=awaitget(pathname)if(redirectData&&typeofredirectData==='string') {constredirectEntry:RedirectEntry=JSON.parse(redirectData)conststatusCode=redirectEntry.permanent?308:307returnNextResponse.redirect(redirectEntry.destination,statusCode)}// No redirect found, continue without redirectingreturnNextResponse.next()}2. Optimizing data lookup performanceReading a large dataset for every incoming request can be slow and expensive. There are two ways you can optimize data lookup performance:Use a database that is optimized for fast reads, such asVercel Edge ConfigorRedis.Use a data lookup strategy such as aBloom filterto efficiently check if a redirect existsbeforereading the larger redirects file or database.Considering the previous example, you can import a generated bloom filter file into Middleware, then, check if the incoming request pathname exists in the bloom filter.If it does, forward the request to aAPI Routeswhich will check the actual file and redirect the user to the appropriate URL. This avoids importing a large redirects file into Middleware, which can slow down every incoming request.middleware.tsTypeScriptJavaScriptTypeScriptimport{ NextResponse,NextRequest }from'next/server'import{ ScalableBloomFilter }from'bloom-filters'importGeneratedBloomFilterfrom'./redirects/bloom-filter.json'typeRedirectEntry={destination:stringpermanent:boolean}// Initialize bloom filter from a generated JSON fileconstbloomFilter=ScalableBloomFilter.fromJSON(GeneratedBloomFilterasany)exportasyncfunctionmiddleware(request:NextRequest) {// Get the path for the incoming requestconstpathname=request.nextUrl.pathname// Check if the path is in the bloom filterif(bloomFilter.has(pathname)) {// Forward the pathname to the Route Handlerconstapi=newURL(`/api/redirects?pathname=${encodeURIComponent(request.nextUrl.pathname)}`,request.nextUrl.origin)try{// Fetch redirect data from the Route HandlerconstredirectData=awaitfetch(api)if(redirectData.ok) {constredirectEntry:RedirectEntry|undefined=awaitredirectData.json()if(redirectEntry) {// Determine the status codeconststatusCode=redirectEntry.permanent?308:307// Redirect to the destinationreturnNextResponse.redirect(redirectEntry.destination,statusCode)}}}catch(error) {console.error(error)}}// No redirect found, continue the request without redirectingreturnNextResponse.next()}Then, in the API Route:pages/api/redirects.tsTypeScriptJavaScriptTypeScriptimporttype{ NextApiRequest,NextApiResponse }from'next'importredirectsfrom'@/app/redirects/redirects.json'typeRedirectEntry={destination:stringpermanent:boolean}exportdefaultfunctionhandler(req:NextApiRequest,res:NextApiResponse) {constpathname=req.query.pathnameif(!pathname) {returnres.status(400).json({ message:'Bad Request'})}// Get the redirect entry from the redirects.json fileconstredirect=(redirectsasRecord<string,RedirectEntry>)[pathname]// Account for bloom filter false positivesif(!redirect) {returnres.status(400).json({ message:'No redirect'})}// Return the redirect entryreturnres.json(redirect)}Good to know:To generate a bloom filter, you can use a library likebloom-filters.You should validate requests made to your Route Handler to prevent malicious requests.PreviousLinking and NavigatingNextCustom AppWas this helpful?supported.Send"
custom app,Custom App,"Building Your ApplicationRoutingCustom AppCustom AppNext.js uses theAppcomponent to initialize pages. You can override it and control the page initialization and:Create a shared layout between page changesInject additional data into pagesAdd global CSSUsageTo override the defaultApp, create the filepages/_appas shown below:pages/_app.tsxTypeScriptJavaScriptTypeScriptimporttype{ AppProps }from'next/app'exportdefaultfunctionMyApp({ Component,pageProps }:AppProps) {return<Component{...pageProps} />}TheComponentprop is the activepage, so whenever you navigate between routes,Componentwill change to the newpage. Therefore, any props you send toComponentwill be received by thepage.pagePropsis an object with the initial props that were preloaded for your page by one of ourdata fetching methods, otherwise it's an empty object.Good to know:If your app is running and you added a customApp, you'll need to restart the development server. Only required ifpages/_app.jsdidn't exist before.Appdoes not support Next.jsData Fetching methodslikegetStaticPropsorgetServerSideProps.getInitialPropswithAppUsinggetInitialPropsinAppwill disableAutomatic Static Optimizationfor pages withoutgetStaticProps.We do not recommend using this pattern.Instead, considerincrementally adoptingthe App Router, which allows you to more easily fetch data forpages and layouts.pages/_app.tsxTypeScriptJavaScriptTypeScriptimportApp,{ AppContext,AppInitialProps,AppProps }from'next/app'typeAppOwnProps={ example:string}exportdefaultfunctionMyApp({Component,pageProps,example,}:AppProps&AppOwnProps) {return(<><p>Data: {example}</p><Component{...pageProps} /></>)}MyApp.getInitialProps=async(context:AppContext):Promise<AppOwnProps&AppInitialProps>=>{constctx=awaitApp.getInitialProps(context)return{...ctx,example:'data'}}PreviousRedirectingNextCustom DocumentWas this helpful?supported.Send"
custom document,Custom Document,"Building Your ApplicationRoutingCustom DocumentCustom DocumentA customDocumentcan update the<html>and<body>tags used to render aPage.To override the defaultDocument, create the filepages/_documentas shown below:pages/_document.tsxTypeScriptJavaScriptTypeScriptimport{ Html,Head,Main,NextScript }from'next/document'exportdefaultfunctionDocument() {return(<Htmllang=""en""><Head/><body><Main/><NextScript/></body></Html>)}Good to know:_documentis only rendered on the server, so event handlers likeonClickcannot be used in this file.<Html>,<Head />,<Main />and<NextScript />are required for the page to be properly rendered.CaveatsThe<Head />component used in_documentis not the same asnext/head. The<Head />component used here should only be used for any<head>code that is common for all pages. For all other cases, such as<title>tags, we recommend usingnext/headin your pages or components.React components outside of<Main />will not be initialized by the browser. Donotadd application logic here or custom CSS (likestyled-jsx). If you need shared components in all your pages (like a menu or a toolbar), readLayoutsinstead.Documentcurrently does not support Next.jsData Fetching methodslikegetStaticPropsorgetServerSideProps.CustomizingrenderPageCustomizingrenderPageis advanced and only needed for libraries like CSS-in-JS to support server-side rendering. This is not needed for built-instyled-jsxsupport.We do not recommend using this pattern.Instead, considerincrementally adoptingthe App Router, which allows you to more easily fetch data forpages and layouts.pages/_document.tsxTypeScriptJavaScriptTypeScriptimportDocument,{Html,Head,Main,NextScript,DocumentContext,DocumentInitialProps,}from'next/document'classMyDocumentextendsDocument{staticasyncgetInitialProps(ctx:DocumentContext):Promise<DocumentInitialProps> {constoriginalRenderPage=ctx.renderPage// Run the React rendering logic synchronouslyctx.renderPage=()=>originalRenderPage({// Useful for wrapping the whole react treeenhanceApp:(App)=>App,// Useful for wrapping in a per-page basisenhanceComponent:(Component)=>Component,})// Run the parent `getInitialProps`, it now includes the custom `renderPage`constinitialProps=awaitDocument.getInitialProps(ctx)returninitialProps}render() {return(<Htmllang=""en""><Head/><body><Main/><NextScript/></body></Html>)}}exportdefaultMyDocumentGood to know:getInitialPropsin_documentis not called during client-side transitions.Thectxobject for_documentis equivalent to the one received ingetInitialProps, with the addition ofrenderPage.PreviousCustom AppNextAPI RoutesWas this helpful?supported.Send"
api routes,API Routes,"Building Your ApplicationRoutingAPI RoutesAPI RoutesExamplesAPI Routes Request HelpersAPI Routes with GraphQLAPI Routes with RESTAPI Routes with CORSGood to know: If you are using the App Router, you can useServer ComponentsorRoute Handlersinstead of API Routes.API routes provide a solution to build apublic APIwith Next.js.Any file inside the folderpages/apiis mapped to/api/*and will be treated as an API endpoint instead of apage. They are server-side only bundles and won't increase your client-side bundle size.For example, the following API route returns a JSON response with a status code of200:pages/api/hello.tsTypeScriptJavaScriptTypeScriptimporttype{ NextApiRequest,NextApiResponse }from'next'typeResponseData={message:string}exportdefaultfunctionhandler(req:NextApiRequest,res:NextApiResponse<ResponseData>) {res.status(200).json({ message:'Hello from Next.js!'})}Good to know:API Routesdo not specify CORS headers, meaning they aresame-origin onlyby default. You can customize such behavior by wrapping the request handler with theCORS request helpers.API Routes can't be used withstatic exports. However,Route Handlersin the App Router can.API Routes will be affected bypageExtensionsconfigurationinnext.config.js.Parametersexportdefaultfunctionhandler(req:NextApiRequest,res:NextApiResponse) {// ...}req: An instance ofhttp.IncomingMessageres: An instance ofhttp.ServerResponseHTTP MethodsTo handle different HTTP methods in an API route, you can usereq.methodin your request handler, like so:pages/api/hello.tsTypeScriptJavaScriptTypeScriptimporttype{ NextApiRequest,NextApiResponse }from'next'exportdefaultfunctionhandler(req:NextApiRequest,res:NextApiResponse) {if(req.method==='POST') {// Process a POST request}else{// Handle any other HTTP method}}Request HelpersAPI Routes provide built-in request helpers which parse the incoming request (req):req.cookies- An object containing the cookies sent by the request. Defaults to{}req.query- An object containing thequery string. Defaults to{}req.body- An object containing the body parsed bycontent-type, ornullif no body was sentCustom configEvery API Route can export aconfigobject to change the default configuration, which is the following:exportconstconfig={api:{bodyParser:{sizeLimit:'1mb',},},// Specifies the maximum allowed duration for this function to execute (in seconds)maxDuration:5,}bodyParseris automatically enabled. If you want to consume the body as aStreamor withraw-body, you can set this tofalse.One use case for disabling the automaticbodyParsingis to allow you to verify the raw body of awebhookrequest, for examplefrom GitHub.exportconstconfig={api:{bodyParser:false,},}bodyParser.sizeLimitis the maximum size allowed for the parsed body, in any format supported bybytes, like so:exportconstconfig={api:{bodyParser:{sizeLimit:'500kb',},},}externalResolveris an explicit flag that tells the server that this route is being handled by an external resolver likeexpressorconnect. Enabling this option disables warnings for unresolved requests.exportconstconfig={api:{externalResolver:true,},}responseLimitis automatically enabled, warning when an API Routes' response body is over 4MB.If you are not using Next.js in a serverless environment, and understand the performance implications of not using a CDN or dedicated media host, you can set this limit tofalse.exportconstconfig={api:{responseLimit:false,},}responseLimitcan also take the number of bytes or any string format supported bybytes, for example1000,'500kb'or'3mb'.
This value will be the maximum response size before a warning is displayed. Default is 4MB. (see above)exportconstconfig={api:{responseLimit:'8mb',},}Response HelpersTheServer Response object, (often abbreviated asres) includes a set of Express.js-like helper methods to improve the developer experience and increase the speed of creating new API endpoints.The included helpers are:res.status(code)- A function to set the status code.codemust be a validHTTP status coderes.json(body)- Sends a JSON response.bodymust be aserializable objectres.send(body)- Sends the HTTP response.bodycan be astring, anobjector aBufferres.redirect([status,] path)- Redirects to a specified path or URL.statusmust be a validHTTP status code. If not specified,statusdefaults to ""307"" ""Temporary redirect"".res.revalidate(urlPath)-Revalidate a page on demandusinggetStaticProps.urlPathmust be astring.Setting the status code of a responseWhen sending a response back to the client, you can set the status code of the response.The following example sets the status code of the response to200(OK) and returns amessageproperty with the value ofHello from Next.js!as a JSON response:pages/api/hello.tsTypeScriptJavaScriptTypeScriptimporttype{ NextApiRequest,NextApiResponse }from'next'typeResponseData={message:string}exportdefaultfunctionhandler(req:NextApiRequest,res:NextApiResponse<ResponseData>) {res.status(200).json({ message:'Hello from Next.js!'})}Sending a JSON responseWhen sending a response back to the client you can send a JSON response, this must be aserializable object.
In a real world application you might want to let the client know the status of the request depending on the result of the requested endpoint.The following example sends a JSON response with the status code200(OK) and the result of the async operation. It's contained in a try catch block to handle any errors that may occur, with the appropriate status code and error message caught and sent back to the client:pages/api/hello.tsTypeScriptJavaScriptTypeScriptimporttype{ NextApiRequest,NextApiResponse }from'next'exportdefaultasyncfunctionhandler(req:NextApiRequest,res:NextApiResponse) {try{constresult=awaitsomeAsyncOperation()res.status(200).json({ result })}catch(err) {res.status(500).json({ error:'failed to load data'})}}Sending a HTTP responseSending an HTTP response works the same way as when sending a JSON response. The only difference is that the response body can be astring, anobjector aBuffer.The following example sends a HTTP response with the status code200(OK) and the result of the async operation.pages/api/hello.tsTypeScriptJavaScriptTypeScriptimporttype{ NextApiRequest,NextApiResponse }from'next'exportdefaultasyncfunctionhandler(req:NextApiRequest,res:NextApiResponse) {try{constresult=awaitsomeAsyncOperation()res.status(200).send({ result })}catch(err) {res.status(500).send({ error:'failed to fetch data'})}}Redirects to a specified path or URLTaking a form as an example, you may want to redirect your client to a specified path or URL once they have submitted the form.The following example redirects the client to the/path if the form is successfully submitted:pages/api/hello.tsTypeScriptJavaScriptTypeScriptimporttype{ NextApiRequest,NextApiResponse }from'next'exportdefaultasyncfunctionhandler(req:NextApiRequest,res:NextApiResponse) {const{name,message}=req.bodytry{awaithandleFormInputAsync({ name,message })res.redirect(307,'/')}catch(err) {res.status(500).send({ error:'Failed to fetch data'})}}Adding TypeScript typesYou can make your API Routes more type-safe by importing theNextApiRequestandNextApiResponsetypes fromnext, in addition to those, you can also type your response data:importtype{ NextApiRequest,NextApiResponse }from'next'typeResponseData={message:string}exportdefaultfunctionhandler(req:NextApiRequest,res:NextApiResponse<ResponseData>) {res.status(200).json({ message:'Hello from Next.js!'})}Good to know: The body ofNextApiRequestisanybecause the client may include any payload. You should validate the type/shape of the body at runtime before using it.Dynamic API RoutesAPI Routes supportdynamic routes, and follow the same file naming rules used forpages/.pages/api/post/[pid].tsTypeScriptJavaScriptTypeScriptimporttype{ NextApiRequest,NextApiResponse }from'next'exportdefaultfunctionhandler(req:NextApiRequest,res:NextApiResponse) {const{pid}=req.queryres.end(`Post:${pid}`)}Now, a request to/api/post/abcwill respond with the text:Post: abc.Catch all API routesAPI Routes can be extended to catch all paths by adding three dots (...) inside the brackets. For example:pages/api/post/[...slug].jsmatches/api/post/a, but also/api/post/a/b,/api/post/a/b/cand so on.Good to know: You can use names other thanslug, such as:[...param]Matched parameters will be sent as a query parameter (slugin the example) to the page, and it will always be an array, so, the path/api/post/awill have the followingqueryobject:{""slug"":[""a""] }And in the case of/api/post/a/b, and any other matching path, new parameters will be added to the array, like so:{""slug"":[""a"",""b""] }For example:pages/api/post/[...slug].tsTypeScriptJavaScriptTypeScriptimporttype{ NextApiRequest,NextApiResponse }from'next'exportdefaultfunctionhandler(req:NextApiRequest,res:NextApiResponse) {const{slug}=req.queryres.end(`Post:${slug.join(', ')}`)}Now, a request to/api/post/a/b/cwill respond with the text:Post: a, b, c.Optional catch all API routesCatch all routes can be made optional by including the parameter in double brackets ([[...slug]]).For example,pages/api/post/[[...slug]].jswill match/api/post,/api/post/a,/api/post/a/b, and so on.The main difference between catch all and optional catch all routes is that with optional, the route without the parameter is also matched (/api/postin the example above).Thequeryobjects are as follows:{ }// GET `/api/post` (empty object){""slug"":[""a""] }// `GET /api/post/a` (single-element array){""slug"":[""a"",""b""] }// `GET /api/post/a/b` (multi-element array)CaveatsPredefined API routes take precedence over dynamic API routes, and dynamic API routes over catch all API routes. Take a look at the following examples:pages/api/post/create.js- Will match/api/post/createpages/api/post/[pid].js- Will match/api/post/1,/api/post/abc, etc. But not/api/post/createpages/api/post/[...slug].js- Will match/api/post/1/2,/api/post/a/b/c, etc. But not/api/post/create,/api/post/abcEdge API RoutesIf you would like to use API Routes with the Edge Runtime, we recommend incrementally adopting the App Router and usingRoute Handlersinstead.The Route Handlers function signature is isomorphic, meaning you can use the same function for both Edge and Node.js runtimes.PreviousCustom DocumentNextCustom ErrorsWas this helpful?supported.Send"
custom errors,Custom Errors,"Building Your ApplicationRoutingCustom ErrorsCustom Errors404 PageA 404 page may be accessed very often. Server-rendering an error page for every visit increases the load of the Next.js server. This can result in increased costs and slow experiences.To avoid the above pitfalls, Next.js provides a static 404 page by default without having to add any additional files.Customizing The 404 PageTo create a custom 404 page you can create apages/404.jsfile. This file is statically generated at build time.pages/404.jsexportdefaultfunctionCustom404() {return<h1>404 - Page Not Found</h1>}Good to know: You can usegetStaticPropsinside this page if you need to fetch data at build time.500 PageServer-rendering an error page for every visit adds complexity to responding to errors. To help users get responses to errors as fast as possible, Next.js provides a static 500 page by default without having to add any additional files.Customizing The 500 PageTo customize the 500 page you can create apages/500.jsfile. This file is statically generated at build time.pages/500.jsexportdefaultfunctionCustom500() {return<h1>500 - Server-side error occurred</h1>}Good to know: You can usegetStaticPropsinside this page if you need to fetch data at build time.More Advanced Error Page Customizing500 errors are handled both client-side and server-side by theErrorcomponent. If you wish to override it, define the filepages/_error.jsand add the following code:functionError({ statusCode }) {return(<p>{statusCode?`An error${statusCode}occurred on server`:'An error occurred on client'}</p>)}Error.getInitialProps=({ res,err })=>{conststatusCode=res?res.statusCode:err?err.statusCode:404return{ statusCode }}exportdefaultErrorpages/_error.jsis only used in production. In development you’ll get an error with the call stack to know where the error originated from.Reusing the built-in error pageIf you want to render the built-in error page you can by importing theErrorcomponent:importErrorfrom'next/error'exportasyncfunctiongetServerSideProps() {constres=awaitfetch('https://api.github.com/repos/vercel/next.js')consterrorCode=res.ok?false:res.statusconstjson=awaitres.json()return{props:{ errorCode,stars:json.stargazers_count },}}exportdefaultfunctionPage({ errorCode,stars }) {if(errorCode) {return<ErrorstatusCode={errorCode} />}return<div>Next stars: {stars}</div>}TheErrorcomponent also takestitleas a property if you want to pass in a text message along with astatusCode.If you have a customErrorcomponent be sure to import that one instead.next/errorexports the default component used by Next.js.CaveatsErrordoes not currently support Next.jsData Fetching methodslikegetStaticPropsorgetServerSideProps._error, like_app, is a reserved pathname._erroris used to define the customized layouts and behaviors of the error pages./_errorwill render 404 when accessed directly viaroutingor rendering in acustom server.PreviousAPI RoutesNextInternationalizationWas this helpful?supported.Send"
internationalization,Internationalization,"Building Your ApplicationRoutingInternationalizationInternationalization (i18n) RoutingExamplesi18n routingNext.js has built-in support for internationalized (i18n) routing sincev10.0.0. You can provide a list of locales, the default locale, and domain-specific locales and Next.js will automatically handle the routing.The i18n routing support is currently meant to complement existing i18n library solutions likereact-intl,react-i18next,lingui,rosetta,next-intl,next-translate,next-multilingual,tolgee,paraglide-next,next-intlayerand others by streamlining the routes and locale parsing.Getting startedTo get started, add thei18nconfig to yournext.config.jsfile.Locales areUTS Locale Identifiers, a standardized format for defining locales.Generally a Locale Identifier is made up of a language, region, and script separated by a dash:language-region-script. The region and script are optional. An example:en-US- English as spoken in the United Statesnl-NL- Dutch as spoken in the Netherlandsnl- Dutch, no specific regionIf user locale isnl-BEand it is not listed in your configuration, they will be redirected tonlif available, or to the default locale otherwise.
If you don't plan to support all regions of a country, it is therefore a good practice to include country locales that will act as fallbacks.next.config.jsmodule.exports={i18n:{// These are all the locales you want to support in// your applicationlocales:['en-US','fr','nl-NL'],// This is the default locale you want to be used when visiting// a non-locale prefixed path e.g. `/hello`defaultLocale:'en-US',// This is a list of locale domains and the default locale they// should handle (these are only required when setting up domain routing)// Note: subdomains must be included in the domain value to be matched e.g. ""fr.example.com"".domains:[{domain:'example.com',defaultLocale:'en-US',},{domain:'example.nl',defaultLocale:'nl-NL',},{domain:'example.fr',defaultLocale:'fr',// an optional http field can also be used to test// locale domains locally with http instead of httpshttp:true,},],},}Locale StrategiesThere are two locale handling strategies: Sub-path Routing and Domain Routing.Sub-path RoutingSub-path Routing puts the locale in the url path.next.config.jsmodule.exports={i18n:{locales:['en-US','fr','nl-NL'],defaultLocale:'en-US',},}With the above configurationen-US,fr, andnl-NLwill be available to be routed to, anden-USis the default locale. If you have apages/blog.jsthe following urls would be available:/blog/fr/blog/nl-nl/blogThe default locale does not have a prefix.Domain RoutingBy using domain routing you can configure locales to be served from different domains:next.config.jsmodule.exports={i18n:{locales:['en-US','fr','nl-NL','nl-BE'],defaultLocale:'en-US',domains:[{// Note: subdomains must be included in the domain value to be matched// e.g. www.example.com should be used if that is the expected hostnamedomain:'example.com',defaultLocale:'en-US',},{domain:'example.fr',defaultLocale:'fr',},{domain:'example.nl',defaultLocale:'nl-NL',// specify other locales that should be redirected// to this domainlocales:['nl-BE'],},],},}For example if you havepages/blog.jsthe following urls will be available:example.com/blogwww.example.com/blogexample.fr/blogexample.nl/blogexample.nl/nl-BE/blogAutomatic Locale DetectionWhen a user visits the application root (generally/), Next.js will try to automatically detect which locale the user prefers based on theAccept-Languageheader and the current domain.If a locale other than the default locale is detected, the user will be redirected to either:When using Sub-path Routing:The locale prefixed pathWhen using Domain Routing:The domain with that locale specified as the defaultWhen using Domain Routing, if a user with theAccept-Languageheaderfr;q=0.9visitsexample.com, they will be redirected toexample.frsince that domain handles thefrlocale by default.When using Sub-path Routing, the user would be redirected to/fr.Prefixing the Default LocaleWith Next.js 12 andMiddleware, we can add a prefix to the default locale with aworkaround.For example, here's anext.config.jsfile with support for a few languages. Note the""default""locale has been added intentionally.next.config.jsmodule.exports={i18n:{locales:['default','en','de','fr'],defaultLocale:'default',localeDetection:false,},trailingSlash:true,}Next, we can useMiddlewareto add custom routing rules:middleware.tsimport{ NextRequest,NextResponse }from'next/server'constPUBLIC_FILE=/\.(.*)$/exportasyncfunctionmiddleware(req:NextRequest) {if(req.nextUrl.pathname.startsWith('/_next')||req.nextUrl.pathname.includes('/api/')||PUBLIC_FILE.test(req.nextUrl.pathname)) {return}if(req.nextUrl.locale==='default') {constlocale=req.cookies.get('NEXT_LOCALE')?.value||'en'returnNextResponse.redirect(newURL(`/${locale}${req.nextUrl.pathname}${req.nextUrl.search}`,req.url))}}ThisMiddlewareskips adding the default prefix toAPI Routesandpublicfiles like fonts or images. If a request is made to the default locale, we redirect to our prefix/en.Disabling Automatic Locale DetectionThe automatic locale detection can be disabled with:next.config.jsmodule.exports={i18n:{localeDetection:false,},}WhenlocaleDetectionis set tofalseNext.js will no longer automatically redirect based on the user's preferred locale and will only provide locale information detected from either the locale based domain or locale path as described above.Accessing the locale informationYou can access the locale information via the Next.js router. For example, using theuseRouter()hook the following properties are available:localecontains the currently active locale.localescontains all configured locales.defaultLocalecontains the configured default locale.Whenpre-renderingpages withgetStaticPropsorgetServerSideProps, the locale information is provided inthe contextprovided to the function.When leveraginggetStaticPaths, the configured locales are provided in the context parameter of the function underlocalesand the configured defaultLocale underdefaultLocale.Transition between localesYou can usenext/linkornext/routerto transition between locales.Fornext/link, alocaleprop can be provided to transition to a different locale from the currently active one. If nolocaleprop is provided, the currently activelocaleis used during client-transitions. For example:importLinkfrom'next/link'exportdefaultfunctionIndexPage(props) {return(<Linkhref=""/another""locale=""fr"">To /fr/another</Link>)}When using thenext/routermethods directly, you can specify thelocalethat should be used via the transition options. For example:import{ useRouter }from'next/router'exportdefaultfunctionIndexPage(props) {constrouter=useRouter()return(<divonClick={()=>{router.push('/another','/another',{ locale:'fr'})}}>to /fr/another</div>)}Note that to handle switching only thelocalewhile preserving all routing information such asdynamic routequery values or hidden href query values, you can provide thehrefparameter as an object:import{ useRouter }from'next/router'constrouter=useRouter()const{pathname,asPath,query}=router// change just the locale and maintain all other route information including href's queryrouter.push({ pathname,query },asPath,{ locale:nextLocale })Seeherefor more information on the object structure forrouter.push.If you have ahrefthat already includes the locale you can opt-out of automatically handling the locale prefixing:importLinkfrom'next/link'exportdefaultfunctionIndexPage(props) {return(<Linkhref=""/fr/another""locale={false}>To /fr/another</Link>)}Leveraging theNEXT_LOCALEcookieNext.js allows setting aNEXT_LOCALE=the-localecookie, which takes priority over the accept-language header. This cookie can be set using a language switcher and then when a user comes back to the site it will leverage the locale specified in the cookie when redirecting from/to the correct locale location.For example, if a user prefers the localefrin their accept-language header but aNEXT_LOCALE=encookie is set theenlocale when visiting/the user will be redirected to theenlocale location until the cookie is removed or expired.Search Engine OptimizationSince Next.js knows what language the user is visiting it will automatically add thelangattribute to the<html>tag.Next.js doesn't know about variants of a page so it's up to you to add thehreflangmeta tags usingnext/head. You can learn more abouthreflangin theGoogle Webmasters documentation.How does this work with Static Generation?Note that Internationalized Routing does not integrate withoutput: 'export'as it does not leverage the Next.js routing layer. Hybrid Next.js applications that do not useoutput: 'export'are fully supported.Dynamic Routes andgetStaticPropsPagesFor pages usinggetStaticPropswithDynamic Routes, all locale variants of the page desired to be prerendered need to be returned fromgetStaticPaths. Along with theparamsobject returned forpaths, you can also return alocalefield specifying which locale you want to render. For example:pages/blog/[slug].jsexportconstgetStaticPaths=({ locales })=>{return{paths:[// if no `locale` is provided only the defaultLocale will be generated{ params:{ slug:'post-1'},locale:'en-US'},{ params:{ slug:'post-1'},locale:'fr'},],fallback:true,}}ForAutomatically Statically Optimizedand non-dynamicgetStaticPropspages,a version of the page will be generated for each locale. This is important to consider because it can increase build times depending on how many locales are configured insidegetStaticProps.For example, if you have 50 locales configured with 10 non-dynamic pages usinggetStaticProps, this meansgetStaticPropswill be called 500 times. 50 versions of the 10 pages will be generated during each build.To decrease the build time of dynamic pages withgetStaticProps, use afallbackmode. This allows you to return only the most popular paths and locales fromgetStaticPathsfor prerendering during the build. Then, Next.js will build the remaining pages at runtime as they are requested.Automatically Statically Optimized PagesFor pages that areautomatically statically optimized, a version of the page will be generated for each locale.Non-dynamic getStaticProps PagesFor non-dynamicgetStaticPropspages, a version is generated for each locale like above.getStaticPropsis called with eachlocalethat is being rendered. If you would like to opt-out of a certain locale from being pre-rendered, you can returnnotFound: truefromgetStaticPropsand this variant of the page will not be generated.exportasyncfunctiongetStaticProps({ locale }) {// Call an external API endpoint to get posts.// You can use any data fetching libraryconstres=awaitfetch(`https://.../posts?locale=${locale}`)constposts=awaitres.json()if(posts.length===0) {return{notFound:true,}}// By returning { props: posts }, the Blog component// will receive `posts` as a prop at build timereturn{props:{posts,},}}Limits for the i18n configlocales: 100 total localesdomains: 100 total locale domain itemsGood to know: These limits have been added initially to prevent potentialperformance issues at build time. You can workaround these limits with custom routing usingMiddlewarein Next.js 12.PreviousCustom ErrorsNextMiddlewareWas this helpful?supported.Send"
middleware,Middleware,"Building Your ApplicationRoutingMiddlewareMiddlewareMiddleware allows you to run code before a request is completed. Then, based on the incoming request, you can modify the response by rewriting, redirecting, modifying the request or response headers, or responding directly.Middleware runs before cached content and routes are matched. SeeMatching Pathsfor more details.Use CasesIntegrating Middleware into your application can lead to significant improvements in performance, security, and user experience. Some common scenarios where Middleware is particularly effective include:Authentication and Authorization: Ensure user identity and check session cookies before granting access to specific pages or API routes.Server-Side Redirects: Redirect users at the server level based on certain conditions (e.g., locale, user role).Path Rewriting: Support A/B testing, feature rollouts, or legacy paths by dynamically rewriting paths to API routes or pages based on request properties.Bot Detection: Protect your resources by detecting and blocking bot traffic.Logging and Analytics: Capture and analyze request data for insights before processing by the page or API.Feature Flagging: Enable or disable features dynamically for seamless feature rollouts or testing.Recognizing situations where middleware may not be the optimal approach is just as crucial. Here are some scenarios to be mindful of:Complex Data Fetching and Manipulation: Middleware is not designed for direct data fetching or manipulation, this should be done within Route Handlers or server-side utilities instead.Heavy Computational Tasks: Middleware should be lightweight and respond quickly or it can cause delays in page load. Heavy computational tasks or long-running processes should be done within dedicated Route Handlers.Extensive Session Management: While Middleware can manage basic session tasks, extensive session management should be managed by dedicated authentication services or within Route Handlers.Direct Database Operations: Performing direct database operations within Middleware is not recommended. Database interactions should be done within Route Handlers or server-side utilities.ConventionUse the filemiddleware.ts(or.js) in the root of your project to define Middleware. For example, at the same level aspagesorapp, or insidesrcif applicable.Note: While only onemiddleware.tsfile is supported per project, you can still organize your middleware logic modularly. Break out middleware functionalities into separate.tsor.jsfiles and import them into your mainmiddleware.tsfile. This allows for cleaner management of route-specific middleware, aggregated in themiddleware.tsfor centralized control. By enforcing a single middleware file, it simplifies configuration, prevents potential conflicts, and optimizes performance by avoiding multiple middleware layers.Examplemiddleware.tsTypeScriptJavaScriptTypeScriptimport{ NextResponse }from'next/server'importtype{ NextRequest }from'next/server'// This function can be marked `async` if using `await` insideexportfunctionmiddleware(request:NextRequest) {returnNextResponse.redirect(newURL('/home',request.url))}// See ""Matching Paths"" below to learn moreexportconstconfig={matcher:'/about/:path*',}Matching PathsMiddleware will be invoked forevery route in your project. Given this, it's crucial to use matchers to precisely target or exclude specific routes. The following is the execution order:headersfromnext.config.jsredirectsfromnext.config.jsMiddleware (rewrites,redirects, etc.)beforeFiles(rewrites) fromnext.config.jsFilesystem routes (public/,_next/static/,pages/,app/, etc.)afterFiles(rewrites) fromnext.config.jsDynamic Routes (/blog/[slug])fallback(rewrites) fromnext.config.jsThere are two ways to define which paths Middleware will run on:Custom matcher configConditional statementsMatchermatcherallows you to filter Middleware to run on specific paths.middleware.jsexportconstconfig={matcher:'/about/:path*',}You can match a single path or multiple paths with an array syntax:middleware.jsexportconstconfig={matcher:['/about/:path*','/dashboard/:path*'],}Thematcherconfig allows full regex so matching like negative lookaheads or character matching is supported. An example of a negative lookahead to match all except specific paths can be seen here:middleware.jsexportconstconfig={matcher:[/** Match all request paths except for the ones starting with:* - api (API routes)* - _next/static (static files)* - _next/image (image optimization files)* - favicon.ico, sitemap.xml, robots.txt (metadata files)*/'/((?!api|_next/static|_next/image|favicon.ico|sitemap.xml|robots.txt).*)',],}You can also bypass Middleware for certain requests by using themissingorhasarrays, or a combination of both:middleware.jsexportconstconfig={matcher:[/** Match all request paths except for the ones starting with:* - api (API routes)* - _next/static (static files)* - _next/image (image optimization files)* - favicon.ico, sitemap.xml, robots.txt (metadata files)*/{source:'/((?!api|_next/static|_next/image|favicon.ico|sitemap.xml|robots.txt).*)',missing:[{ type:'header',key:'next-router-prefetch'},{ type:'header',key:'purpose',value:'prefetch'},],},{source:'/((?!api|_next/static|_next/image|favicon.ico|sitemap.xml|robots.txt).*)',has:[{ type:'header',key:'next-router-prefetch'},{ type:'header',key:'purpose',value:'prefetch'},],},{source:'/((?!api|_next/static|_next/image|favicon.ico|sitemap.xml|robots.txt).*)',has:[{ type:'header',key:'x-present'}],missing:[{ type:'header',key:'x-missing',value:'prefetch'}],},],}Good to know: Thematchervalues need to be constants so they can be statically analyzed at build-time. Dynamic values such as variables will be ignored.Configured matchers:MUST start with/Can include named parameters:/about/:pathmatches/about/aand/about/bbut not/about/a/cCan have modifiers on named parameters (starting with:):/about/:path*matches/about/a/b/cbecause*iszero or more.?iszero or oneand+one or moreCan use regular expression enclosed in parenthesis:/about/(.*)is the same as/about/:path*Read more details onpath-to-regexpdocumentation.Good to know: For backward compatibility, Next.js always considers/publicas/public/index. Therefore, a matcher of/public/:pathwill match.Conditional Statementsmiddleware.tsTypeScriptJavaScriptTypeScriptimport{ NextResponse }from'next/server'importtype{ NextRequest }from'next/server'exportfunctionmiddleware(request:NextRequest) {if(request.nextUrl.pathname.startsWith('/about')) {returnNextResponse.rewrite(newURL('/about-2',request.url))}if(request.nextUrl.pathname.startsWith('/dashboard')) {returnNextResponse.rewrite(newURL('/dashboard/user',request.url))}}NextResponseTheNextResponseAPI allows you to:redirectthe incoming request to a different URLrewritethe response by displaying a given URLSet request headers for API Routes,getServerSideProps, andrewritedestinationsSet response cookiesSet response headersTo produce a response from Middleware, you can:rewriteto a route (PageorEdge API Route) that produces a responsereturn aNextResponsedirectly. SeeProducing a ResponseUsing CookiesCookies are regular headers. On aRequest, they are stored in theCookieheader. On aResponsethey are in theSet-Cookieheader. Next.js provides a convenient way to access and manipulate these cookies through thecookiesextension onNextRequestandNextResponse.For incoming requests,cookiescomes with the following methods:get,getAll,set, anddeletecookies. You can check for the existence of a cookie withhasor remove all cookies withclear.For outgoing responses,cookieshave the following methodsget,getAll,set, anddelete.middleware.tsTypeScriptJavaScriptTypeScriptimport{ NextResponse }from'next/server'importtype{ NextRequest }from'next/server'exportfunctionmiddleware(request:NextRequest) {// Assume a ""Cookie:nextjs=fast"" header to be present on the incoming request// Getting cookies from the request using the `RequestCookies` APIletcookie=request.cookies.get('nextjs')console.log(cookie)// => { name: 'nextjs', value: 'fast', Path: '/' }constallCookies=request.cookies.getAll()console.log(allCookies)// => [{ name: 'nextjs', value: 'fast' }]request.cookies.has('nextjs')// => truerequest.cookies.delete('nextjs')request.cookies.has('nextjs')// => false// Setting cookies on the response using the `ResponseCookies` APIconstresponse=NextResponse.next()response.cookies.set('vercel','fast')response.cookies.set({name:'vercel',value:'fast',path:'/',})cookie=response.cookies.get('vercel')console.log(cookie)// => { name: 'vercel', value: 'fast', Path: '/' }// The outgoing response will have a `Set-Cookie:vercel=fast;path=/` header.returnresponse}Setting HeadersYou can set request and response headers using theNextResponseAPI (settingrequestheaders is available since Next.js v13.0.0).middleware.tsTypeScriptJavaScriptTypeScriptimport{ NextResponse }from'next/server'importtype{ NextRequest }from'next/server'exportfunctionmiddleware(request:NextRequest) {// Clone the request headers and set a new header `x-hello-from-middleware1`constrequestHeaders=newHeaders(request.headers)requestHeaders.set('x-hello-from-middleware1','hello')// You can also set request headers in NextResponse.nextconstresponse=NextResponse.next({request:{// New request headersheaders:requestHeaders,},})// Set a new response header `x-hello-from-middleware2`response.headers.set('x-hello-from-middleware2','hello')returnresponse}Good to know: Avoid setting large headers as it might cause431 Request Header Fields Too Largeerror depending on your backend web server configuration.CORSYou can set CORS headers in Middleware to allow cross-origin requests, includingsimpleandpreflightedrequests.middleware.tsTypeScriptJavaScriptTypeScriptimport{ NextRequest,NextResponse }from'next/server'constallowedOrigins=['https://acme.com','https://my-app.org']constcorsOptions={'Access-Control-Allow-Methods':'GET, POST, PUT, DELETE, OPTIONS','Access-Control-Allow-Headers':'Content-Type, Authorization',}exportfunctionmiddleware(request:NextRequest) {// Check the origin from the requestconstorigin=request.headers.get('origin')??''constisAllowedOrigin=allowedOrigins.includes(origin)// Handle preflighted requestsconstisPreflight=request.method==='OPTIONS'if(isPreflight) {constpreflightHeaders={...(isAllowedOrigin&&{'Access-Control-Allow-Origin':origin }),...corsOptions,}returnNextResponse.json({},{ headers:preflightHeaders })}// Handle simple requestsconstresponse=NextResponse.next()if(isAllowedOrigin) {response.headers.set('Access-Control-Allow-Origin',origin)}Object.entries(corsOptions).forEach(([key,value])=>{response.headers.set(key,value)})returnresponse}exportconstconfig={matcher:'/api/:path*',}Producing a ResponseYou can respond from Middleware directly by returning aResponseorNextResponseinstance. (This is available sinceNext.js v13.1.0)middleware.tsTypeScriptJavaScriptTypeScriptimporttype{ NextRequest }from'next/server'import{ isAuthenticated }from'@lib/auth'// Limit the middleware to paths starting with `/api/`exportconstconfig={matcher:'/api/:function*',}exportfunctionmiddleware(request:NextRequest) {// Call our authentication function to check the requestif(!isAuthenticated(request)) {// Respond with JSON indicating an error messagereturnResponse.json({ success:false,message:'authentication failed'},{ status:401})}}waitUntilandNextFetchEventTheNextFetchEventobject extends the nativeFetchEventobject, and includes thewaitUntil()method.ThewaitUntil()method takes a promise as an argument, and extends the lifetime of the Middleware until the promise settles. This is useful for performing work in the background.middleware.tsimport{ NextResponse }from'next/server'importtype{ NextFetchEvent,NextRequest }from'next/server'exportfunctionmiddleware(req:NextRequest,event:NextFetchEvent) {event.waitUntil(fetch('https://my-analytics-platform.com',{method:'POST',body:JSON.stringify({ pathname:req.nextUrl.pathname }),}))returnNextResponse.next()}Advanced Middleware FlagsInv13.1of Next.js two additional flags were introduced for middleware,skipMiddlewareUrlNormalizeandskipTrailingSlashRedirectto handle advanced use cases.skipTrailingSlashRedirectdisables Next.js redirects for adding or removing trailing slashes. This allows custom handling inside middleware to maintain the trailing slash for some paths but not others, which can make incremental migrations easier.next.config.jsmodule.exports={skipTrailingSlashRedirect:true,}middleware.jsconstlegacyPrefixes=['/docs','/blog']exportdefaultasyncfunctionmiddleware(req) {const{pathname}=req.nextUrlif(legacyPrefixes.some((prefix)=>pathname.startsWith(prefix))) {returnNextResponse.next()}// apply trailing slash handlingif(!pathname.endsWith('/')&&!pathname.match(/((?!\.well-known(?:\/.*)?)(?:[^/]+\/)*[^/]+\.\w+)/)) {returnNextResponse.redirect(newURL(`${req.nextUrl.pathname}/`,req.nextUrl))}}skipMiddlewareUrlNormalizeallows for disabling the URL normalization in Next.js to make handling direct visits and client-transitions the same. In some advanced cases, this option provides full control by using the original URL.next.config.jsmodule.exports={skipMiddlewareUrlNormalize:true,}middleware.jsexportdefaultasyncfunctionmiddleware(req) {const{pathname}=req.nextUrl// GET /_next/data/build-id/hello.jsonconsole.log(pathname)// with the flag this now /_next/data/build-id/hello.json// without the flag this would be normalized to /hello}Unit Testing (experimental)Starting in Next.js 15.1, thenext/experimental/testing/serverpackage contains utilities to help unit test middleware files. Unit testing middleware can help ensure that it's only run on desired paths and that custom routing logic works as intended before code reaches production.Theunstable_doesMiddlewareMatchfunction can be used to assert whether middleware will run for the provided URL, headers, and cookies.import{ unstable_doesMiddlewareMatch }from'next/experimental/testing/server'expect(unstable_doesMiddlewareMatch({config,nextConfig,url:'/test',})).toEqual(false)The entire middleware function can also be tested.import{ isRewrite,getRewrittenUrl }from'next/experimental/testing/server'constrequest=newNextRequest('https://nextjs.org/docs')constresponse=awaitmiddleware(request)expect(isRewrite(response)).toEqual(true)expect(getRewrittenUrl(response)).toEqual('https://other-domain.com/docs')// getRedirectUrl could also be used if the response were a redirectRuntimeMiddleware currently only supports APIs compatible with theEdge runtime. APIs exclusive to Node.js areunsupported.Version HistoryVersionChangesv13.1.0Advanced Middleware flags addedv13.0.0Middleware can modify request headers, response headers, and send responsesv12.2.0Middleware is stable, please see theupgrade guidev12.0.9Enforce absolute URLs in Edge Runtime (PR)v12.0.0Middleware (Beta) addedPreviousInternationalizationNextRenderingWas this helpful?supported.Send"
rendering,Rendering,"Pages RouterBuilding Your ApplicationRenderingRenderingBy default, Next.jspre-rendersevery page. This means that Next.js generates HTML for each page in advance, instead of having it all done by client-side JavaScript. Pre-rendering can result in better performance and SEO.Each generated HTML is associated with minimal JavaScript code necessary for that page. When a page is loaded by the browser, its JavaScript code runs and makes the page fully interactive (this process is calledhydrationin React).Pre-renderingNext.js has two forms of pre-rendering:Static GenerationandServer-side Rendering. The difference is inwhenit generates the HTML for a page.Static Generation: The HTML is generated atbuild timeand will be reused on each request.Server-side Rendering: The HTML is generated oneach request.Importantly, Next.js lets you choose which pre-rendering form you'd like to use for each page. You can create a ""hybrid"" Next.js app by using Static Generation for most pages and using Server-side Rendering for others.We recommend using Static Generation over Server-side Rendering for performance reasons. Statically generated pages can be cached by CDN with no extra configuration to boost performance. However, in some cases, Server-side Rendering might be the only option.You can also use client-side data fetching along with Static Generation or Server-side Rendering. That means some parts of a page can be rendered entirely by clientside JavaScript. To learn more, take a look at theData Fetchingdocumentation.Server-side Rendering (SSR)Use Server-side Rendering to render pages on each request.Static Site Generation (SSG)Use Static Site Generation (SSG) to pre-render pages at build time.Automatic Static OptimizationNext.js automatically optimizes your app to be static HTML whenever possible. Learn how it works here.Client-side Rendering (CSR)Learn how to implement client-side rendering in the Pages Router.Edge and Node.js RuntimesLearn more about the switchable runtimes (Edge and Node.js) in Next.js.PreviousMiddlewareNextServer-side Rendering (SSR)Was this helpful?supported.Send"
server-side rendering (ssr),Server-side Rendering (SSR),"Building Your ApplicationRenderingServer-side Rendering (SSR)Server-side Rendering (SSR)Also referred to as ""SSR"" or ""Dynamic Rendering"".If a page usesServer-side Rendering, the page HTML is generated oneach request.To use Server-side Rendering for a page, you need toexportanasyncfunction calledgetServerSideProps. This function will be called by the server on every request.For example, suppose that your page needs to pre-render frequently updated data (fetched from an external API). You can writegetServerSidePropswhich fetches this data and passes it toPagelike below:exportdefaultfunctionPage({ data }) {// Render data...}// This gets called on every requestexportasyncfunctiongetServerSideProps() {// Fetch data from external APIconstres=awaitfetch(`https://.../data`)constdata=awaitres.json()// Pass data to the page via propsreturn{ props:{ data } }}As you can see,getServerSidePropsis similar togetStaticProps, but the difference is thatgetServerSidePropsis run on every request instead of on build time.To learn more about howgetServerSidePropsworks, check out ourData Fetching documentation.PreviousRenderingNextStatic Site Generation (SSG)Was this helpful?supported.Send"
static site generation (ssg),Static Site Generation (SSG),"Building Your ApplicationRenderingStatic Site Generation (SSG)Static Site Generation (SSG)ExamplesAgility CMS Example(Demo)Builder.io Example(Demo)ButterCMS Example(Demo)Contentful Example(Demo)Cosmic Example(Demo)DatoCMS Example(Demo)DotCMS Example(Demo)Drupal Example(Demo)Enterspeed Example(Demo)GraphCMS Example(Demo)Keystone Example(Demo)Kontent.ai Example(Demo)Makeswift Example(Demo)Plasmic Example(Demo)Prepr Example(Demo)Prismic Example(Demo)Sanity Example(Demo)Sitecore XM Cloud Example(Demo)Storyblok Example(Demo)Strapi Example(Demo)TakeShape Example(Demo)Tina Example(Demo)Umbraco Example(Demo)Umbraco Heartcore Example(Demo)Webiny Example(Demo)WordPress Example(Demo)Blog Starter Example(Demo)Static Tweet (Demo)If a page usesStatic Generation, the page HTML is generated atbuild time. That means in production, the page HTML is generated when you runnext build. This HTML will then be reused on each request. It can be cached by a CDN.In Next.js, you can statically generate pageswith or without data. Let's take a look at each case.Static Generation without dataBy default, Next.js pre-renders pages using Static Generation without fetching data. Here's an example:functionAbout() {return<div>About</div>}exportdefaultAboutNote that this page does not need to fetch any external data to be pre-rendered. In cases like this, Next.js generates a single HTML file per page during build time.Static Generation with dataSome pages require fetching external data for pre-rendering. There are two scenarios, and one or both might apply. In each case, you can use these functions that Next.js provides:Your pagecontentdepends on external data: UsegetStaticProps.Your pagepathsdepend on external data: UsegetStaticPaths(usually in addition togetStaticProps).Scenario 1: Your page content depends on external dataExample: Your blog page might need to fetch the list of blog posts from a CMS (content management system).// TODO: Need to fetch `posts` (by calling some API endpoint)//       before this page can be pre-rendered.exportdefaultfunctionBlog({ posts }) {return(<ul>{posts.map((post)=>(<li>{post.title}</li>))}</ul>)}To fetch this data on pre-render, Next.js allows you toexportanasyncfunction calledgetStaticPropsfrom the same file. This function gets called at build time and lets you pass fetched data to the page'spropson pre-render.exportdefaultfunctionBlog({ posts }) {// Render posts...}// This function gets called at build timeexportasyncfunctiongetStaticProps() {// Call an external API endpoint to get postsconstres=awaitfetch('https://.../posts')constposts=awaitres.json()// By returning { props: { posts } }, the Blog component// will receive `posts` as a prop at build timereturn{props:{posts,},}}To learn more about howgetStaticPropsworks, check out theData Fetching documentation.Scenario 2: Your page paths depend on external dataNext.js allows you to create pages withdynamic routes. For example, you can create a file calledpages/posts/[id].jsto show a single blog post based onid. This will allow you to show a blog post withid: 1when you accessposts/1.To learn more about dynamic routing, check theDynamic Routing documentation.However, whichidyou want to pre-render at build time might depend on external data.Example: suppose that you've only added one blog post (withid: 1) to the database. In this case, you'd only want to pre-renderposts/1at build time.Later, you might add the second post withid: 2. Then you'd want to pre-renderposts/2as well.So your pagepathsthat are pre-rendered depend on external data. To handle this, Next.js lets youexportanasyncfunction calledgetStaticPathsfrom a dynamic page (pages/posts/[id].jsin this case). This function gets called at build time and lets you specify which paths you want to pre-render.// This function gets called at build timeexportasyncfunctiongetStaticPaths() {// Call an external API endpoint to get postsconstres=awaitfetch('https://.../posts')constposts=awaitres.json()// Get the paths we want to pre-render based on postsconstpaths=posts.map((post)=>({params:{ id:post.id },}))// We'll pre-render only these paths at build time.// { fallback: false } means other routes should 404.return{ paths,fallback:false}}Also inpages/posts/[id].js, you need to exportgetStaticPropsso that you can fetch the data about the post with thisidand use it to pre-render the page:exportdefaultfunctionPost({ post }) {// Render post...}exportasyncfunctiongetStaticPaths() {// ...}// This also gets called at build timeexportasyncfunctiongetStaticProps({ params }) {// params contains the post `id`.// If the route is like /posts/1, then params.id is 1constres=awaitfetch(`https://.../posts/${params.id}`)constpost=awaitres.json()// Pass post data to the page via propsreturn{ props:{ post } }}To learn more about howgetStaticPathsworks, check out theData Fetching documentation.When should I use Static Generation?We recommend usingStatic Generation(with and without data) whenever possible because your page can be built once and served by CDN, which makes it much faster than having a server render the page on every request.You can use Static Generation for many types of pages, including:Marketing pagesBlog posts and portfoliosE-commerce product listingsHelp and documentationYou should ask yourself: ""Can I pre-render this pageaheadof a user's request?"" If the answer is yes, then you should choose Static Generation.On the other hand, Static Generation isnota good idea if you cannot pre-render a page ahead of a user's request. Maybe your page shows frequently updated data, and the page content changes on every request.In cases like this, you can do one of the following:Use Static Generation withClient-side data fetching:You can skip pre-rendering some parts of a page and then use client-side JavaScript to populate them. To learn more about this approach, check out theData Fetching documentation.UseServer-Side Rendering:Next.js pre-renders a page on each request. It will be slower because the page cannot be cached by a CDN, but the pre-rendered page will always be up-to-date. We'll talk about this approach below.PreviousServer-side Rendering (SSR)NextAutomatic Static OptimizationWas this helpful?supported.Send"
automatic static optimization,Automatic Static Optimization,"Building Your ApplicationRenderingAutomatic Static OptimizationAutomatic Static OptimizationNext.js automatically determines that a page is static (can be prerendered) if it has no blocking data requirements. This determination is made by the absence ofgetServerSidePropsandgetInitialPropsin the page.This feature allows Next.js to emit hybrid applications that containboth server-rendered and statically generated pages.Good to know: Statically generated pages are still reactive. Next.js will hydrate your application client-side to give it full interactivity.One of the main benefits of this feature is that optimized pages require no server-side computation, and can be instantly streamed to the end-user from multiple CDN locations. The result is anultra fastloading experience for your users.How it worksIfgetServerSidePropsorgetInitialPropsis present in a page, Next.js will switch to render the page on-demand, per-request (meaningServer-Side Rendering).If the above is not the case, Next.js willstatically optimizeyour page automatically by prerendering the page to static HTML.During prerendering, the router'squeryobject will be empty since we do not havequeryinformation to provide during this phase. After hydration, Next.js will trigger an update to your application to provide the route parameters in thequeryobject.The cases where the query will be updated after hydration triggering another render are:The page is adynamic-route.The page has query values in the URL.Rewritesare configured in yournext.config.jssince these can have parameters that may need to be parsed and provided in thequery.To be able to distinguish if the query is fully updated and ready for use, you can leverage theisReadyfield onnext/router.Good to know: Parameters added withdynamic routesto a page that's usinggetStaticPropswill always be available inside thequeryobject.next buildwill emit.htmlfiles for statically optimized pages. For example, the result for the pagepages/about.jswould be:Terminal.next/server/pages/about.htmlAnd if you addgetServerSidePropsto the page, it will then be JavaScript, like so:Terminal.next/server/pages/about.jsCaveatsIf you have acustomAppwithgetInitialPropsthen this optimization will be turned off in pages withoutStatic Generation.If you have acustomDocumentwithgetInitialPropsbe sure you check ifctx.reqis defined before assuming the page is server-side rendered.ctx.reqwill beundefinedfor pages that are prerendered.Avoid using theasPathvalue onnext/routerin the rendering tree until the router'sisReadyfield istrue. Statically optimized pages only knowasPathon the client and not the server, so using it as a prop may lead to mismatch errors. Theactive-class-nameexampledemonstrates one way to useasPathas a prop.PreviousStatic Site Generation (SSG)NextClient-side Rendering (CSR)Was this helpful?supported.Send"
client-side rendering (csr),Client-side Rendering (CSR),"Building Your ApplicationRenderingClient-side Rendering (CSR)Client-side Rendering (CSR)In Client-Side Rendering (CSR) with React, the browser downloads a minimal HTML page and the JavaScript needed for the page. The JavaScript is then used to update the DOM and render the page. When the application is first loaded, the user may notice a slight delay before they can see the full page, this is because the page isn't fully rendered until all the JavaScript is downloaded, parsed, and executed.After the page has been loaded for the first time, navigating to other pages on the same website is typically faster, as only necessary data needs to be fetched, and JavaScript can re-render parts of the page without requiring a full page refresh.In Next.js, there are two ways you can implement client-side rendering:Using React'suseEffect()hook inside your pages instead of the server-side rendering methods (getStaticPropsandgetServerSideProps).Using a data fetching library likeSWRorTanStack Queryto fetch data on the client (recommended).Here's an example of usinguseEffect()inside a Next.js page:pages/index.jsimportReact,{ useState,useEffect }from'react'exportfunctionPage() {const[data,setData]=useState(null)useEffect(()=>{constfetchData=async()=>{constresponse=awaitfetch('https://api.example.com/data')if(!response.ok) {thrownewError(`HTTP error! status:${response.status}`)}constresult=awaitresponse.json()setData(result)}fetchData().catch((e)=>{// handle the error as neededconsole.error('An error occurred while fetching the data: ',e)})},[])return<p>{data?`Your data:${data}`:'Loading...'}</p>}In the example above, the component starts by renderingLoading.... Then, once the data is fetched, it re-renders and displays the data.Although fetching data in auseEffectis a pattern you may see in older React Applications, we recommend using a data-fetching library for better performance, caching, optimistic updates, and more. Here's a minimum example usingSWRto fetch data on the client:pages/index.jsimportuseSWRfrom'swr'exportfunctionPage() {const{data,error,isLoading}=useSWR('https://api.example.com/data',fetcher)if(error)return<p>Failed to load.</p>if(isLoading)return<p>Loading...</p>return<p>Your Data: {data}</p>}Good to know:Keep in mind that CSR can impact SEO. Some search engine crawlers might not execute JavaScript and therefore only see the initial empty or loading state of your application. It can also lead to performance issues for users with slower internet connections or devices, as they need to wait for all the JavaScript to load and run before they can see the full page. Next.js promotes a hybrid approach that allows you to use a combination ofserver-side rendering,static site generation, and client-side rendering,depending on the needs of each pagein your application. In the App Router, you can also useLoading UI with Suspenseto show a loading indicator while the page is being rendered.Next StepsLearn about the alternative rendering methods in Next.js.Server-side Rendering (SSR)Use Server-side Rendering to render pages on each request.Static Site Generation (SSG)Use Static Site Generation (SSG) to pre-render pages at build time.Incremental Static Regeneration (ISR)Learn how to create or update static pages at runtime with Incremental Static Regeneration.Loading UI and StreamingBuilt on top of Suspense, Loading UI allows you to create a fallback for specific route segments, and automatically stream content as it becomes ready.PreviousAutomatic Static OptimizationNextEdge and Node.js RuntimesWas this helpful?supported.Send"
edge and node.js runtimes,Edge and Node.js Runtimes,"Building Your ApplicationRenderingEdge and Node.js RuntimesEdge and Node.js RuntimesNext.js has two server runtimes you can use in your application:TheNode.js Runtime(default), which has access to all Node.js APIs and compatible packages from the ecosystem.TheEdge Runtimewhich contains a more limitedset of APIs.Use CasesThe Node.js Runtime is used for rendering your application.The Edge Runtime is used for Middleware (routing rules like redirects, rewrites, and setting headers).CaveatsThe Edge Runtime does not support all Node.js APIs. Some packages may not work as expected. Learn more about the unsupported APIs in theEdge Runtime.The Edge Runtime does not support Incremental Static Regeneration (ISR).Both runtimes can supportstreamingdepending on your deployment infrastructure.PreviousClient-side Rendering (CSR)NextData FetchingWas this helpful?supported.Send"
data fetching,Data Fetching,"Pages RouterBuilding Your ApplicationData FetchingData FetchingData fetching in Next.js allows you to render your content in different ways, depending on your application's use case. These include pre-rendering withServer-side RenderingorStatic Generation, and updating or creating content at runtime withIncremental Static Regeneration.ExamplesAgility CMS Example(Demo)Builder.io Example(Demo)ButterCMS Example(Demo)Contentful Example(Demo)Cosmic Example(Demo)DatoCMS Example(Demo)DotCMS Example(Demo)Drupal Example(Demo)Enterspeed Example(Demo)GraphCMS Example(Demo)Keystone Example(Demo)Kontent.ai Example(Demo)Makeswift Example(Demo)Plasmic Example(Demo)Prepr Example(Demo)Prismic Example(Demo)Sanity Example(Demo)Sitecore XM Cloud Example(Demo)Storyblok Example(Demo)Strapi Example(Demo)TakeShape Example(Demo)Tina Example(Demo)Umbraco Example(Demo)Umbraco Heartcore Example(Demo)Webiny Example(Demo)WordPress Example(Demo)Blog Starter Example(Demo)Static Tweet (Demo)getStaticPropsFetch data and generate static pages with `getStaticProps`. Learn more about this API for data fetching in Next.js.getStaticPathsFetch data and generate static pages with `getStaticPaths`. Learn more about this API for data fetching in Next.js.Forms and MutationsLearn how to handle form submissions and data mutations with Next.js.getServerSidePropsFetch data on each request with `getServerSideProps`.Incremental Static Regeneration (ISR)Learn how to create or update static pages at runtime with Incremental Static Regeneration.Client-side FetchingLearn about client-side data fetching, and how to use SWR, a data fetching React hook library that handles caching, revalidation, focus tracking, refetching on interval and more.PreviousEdge and Node.js RuntimesNextgetStaticPropsWas this helpful?supported.Send"
getstaticprops,getStaticProps,"Building Your ApplicationData FetchinggetStaticPropsgetStaticPropsIf you export a function calledgetStaticProps(Static Site Generation) from a page, Next.js will pre-render this page at build time using the props returned bygetStaticProps.pages/index.tsxTypeScriptJavaScriptTypeScriptimporttype{ InferGetStaticPropsType,GetStaticProps }from'next'typeRepo={name:stringstargazers_count:number}exportconstgetStaticProps=(async(context)=>{constres=awaitfetch('https://api.github.com/repos/vercel/next.js')constrepo=awaitres.json()return{ props:{ repo } }})satisfiesGetStaticProps<{repo:Repo}>exportdefaultfunctionPage({repo,}:InferGetStaticPropsType<typeofgetStaticProps>) {returnrepo.stargazers_count}Note that irrespective of rendering type, anypropswill be passed to the page component and can be viewed on the client-side in the initial HTML. This is to allow the page to behydratedcorrectly. Make sure that you don't pass any sensitive information that shouldn't be available on the client inprops.ThegetStaticPropsAPI referencecovers all parameters and props that can be used withgetStaticProps.When should I use getStaticProps?You should usegetStaticPropsif:The data required to render the page is available at build time ahead of a user’s requestThe data comes from a headless CMSThe page must be pre-rendered (for SEO) and be very fast —getStaticPropsgeneratesHTMLandJSONfiles, both of which can be cached by a CDN for performanceThe data can be publicly cached (not user-specific). This condition can be bypassed in certain specific situation by using a Middleware to rewrite the path.When does getStaticProps rungetStaticPropsalways runs on the server and never on the client. You can validate code written insidegetStaticPropsis removed from the client-side bundlewith this tool.getStaticPropsalways runs duringnext buildgetStaticPropsruns in the background when usingfallback: truegetStaticPropsis called before initial render when usingfallback: blockinggetStaticPropsruns in the background when usingrevalidategetStaticPropsruns on-demand in the background when usingrevalidate()When combined withIncremental Static Regeneration,getStaticPropswill run in the background while the stale page is being revalidated, and the fresh page served to the browser.getStaticPropsdoes not have access to the incoming request (such as query parameters or HTTP headers) as it generates static HTML. If you need access to the request for your page, consider usingMiddlewarein addition togetStaticProps.Using getStaticProps to fetch data from a CMSThe following example shows how you can fetch a list of blog posts from a CMS.pages/blog.tsxTypeScriptJavaScriptTypeScript// posts will be populated at build time by getStaticProps()exportdefaultfunctionBlog({ posts }) {return(<ul>{posts.map((post)=>(<li>{post.title}</li>))}</ul>)}// This function gets called at build time on server-side.// It won't be called on client-side, so you can even do// direct database queries.exportasyncfunctiongetStaticProps() {// Call an external API endpoint to get posts.// You can use any data fetching libraryconstres=awaitfetch('https://.../posts')constposts=awaitres.json()// By returning { props: { posts } }, the Blog component// will receive `posts` as a prop at build timereturn{props:{posts,},}}ThegetStaticPropsAPI referencecovers all parameters and props that can be used withgetStaticProps.Write server-side code directlyAsgetStaticPropsruns only on the server-side, it will never run on the client-side. It won’t even be included in the JS bundle for the browser, so you can write direct database queries without them being sent to browsers.This means that instead of fetching anAPI routefromgetStaticProps(that itself fetches data from an external source), you can write the server-side code directly ingetStaticProps.Take the following example. An API route is used to fetch some data from a CMS. That API route is then called directly fromgetStaticProps. This produces an additional call, reducing performance. Instead, the logic for fetching the data from the CMS can be shared by using alib/directory. Then it can be shared withgetStaticProps.lib/load-posts.js// The following function is shared// with getStaticProps and API routes// from a `lib/` directoryexportasyncfunctionloadPosts() {// Call an external API endpoint to get postsconstres=awaitfetch('https://.../posts/')constdata=awaitres.json()returndata}pages/blog.js// pages/blog.jsimport{ loadPosts }from'../lib/load-posts'// This function runs only on the server sideexportasyncfunctiongetStaticProps() {// Instead of fetching your `/api` route you can call the same// function directly in `getStaticProps`constposts=awaitloadPosts()// Props returned will be passed to the page componentreturn{ props:{ posts } }}Alternatively, if you arenotusing API routes to fetch data, then thefetch()APIcanbe used directly ingetStaticPropsto fetch data.To verify what Next.js eliminates from the client-side bundle, you can use thenext-code-elimination tool.Statically generates both HTML and JSONWhen a page withgetStaticPropsis pre-rendered at build time, in addition to the page HTML file, Next.js generates a JSON file holding the result of runninggetStaticProps.This JSON file will be used in client-side routing throughnext/linkornext/router. When you navigate to a page that’s pre-rendered usinggetStaticProps, Next.js fetches this JSON file (pre-computed at build time) and uses it as the props for the page component. This means that client-side page transitions willnotcallgetStaticPropsas only the exported JSON is used.When using Incremental Static Generation,getStaticPropswill be executed in the background to generate the JSON needed for client-side navigation. You may see this in the form of multiple requests being made for the same page, however, this is intended and has no impact on end-user performance.Where can I use getStaticPropsgetStaticPropscan only be exported from apage. Youcannotexport it from non-page files,_app,_document, or_error.One of the reasons for this restriction is that React needs to have all the required data before the page is rendered.Also, you must use exportgetStaticPropsas a standalone function — it willnotwork if you addgetStaticPropsas a property of the page component.Good to know: if you have created acustom app, ensure you are passing thepagePropsto the page component as shown in the linked document, otherwise the props will be empty.Runs on every request in developmentIn development (next dev),getStaticPropswill be called on every request.Preview ModeYou can temporarily bypass static generation and render the page atrequest timeinstead of build time usingPreview Mode. For example, you might be using a headless CMS and want to preview drafts before they're published.PreviousData FetchingNextgetStaticPathsWas this helpful?supported.Send"
getstaticpaths,getStaticPaths,"Building Your ApplicationData FetchinggetStaticPathsgetStaticPathsIf a page hasDynamic Routesand usesgetStaticProps, it needs to define a list of paths to be statically generated.When you export a function calledgetStaticPaths(Static Site Generation) from a page that uses dynamic routes, Next.js will statically pre-render all the paths specified bygetStaticPaths.pages/repo/[name].tsxTypeScriptJavaScriptTypeScriptimporttype{InferGetStaticPropsType,GetStaticProps,GetStaticPaths,}from'next'typeRepo={name:stringstargazers_count:number}exportconstgetStaticPaths=(async()=>{return{paths:[{params:{name:'next.js',},},// See the ""paths"" section below],fallback:true,// false or ""blocking""}})satisfiesGetStaticPathsexportconstgetStaticProps=(async(context)=>{constres=awaitfetch('https://api.github.com/repos/vercel/next.js')constrepo=awaitres.json()return{ props:{repo} }})satisfiesGetStaticProps<{repo:Repo}>exportdefaultfunctionPage({repo,}:InferGetStaticPropsType<typeofgetStaticProps>) {returnrepo.stargazers_count}ThegetStaticPathsAPI referencecovers all parameters and props that can be used withgetStaticPaths.When should I use getStaticPaths?You should usegetStaticPathsif you’re statically pre-rendering pages that use dynamic routes and:The data comes from a headless CMSThe data comes from a databaseThe data comes from the filesystemThe data can be publicly cached (not user-specific)The page must be pre-rendered (for SEO) and be very fast —getStaticPropsgeneratesHTMLandJSONfiles, both of which can be cached by a CDN for performanceWhen does getStaticPaths rungetStaticPathswill only run during build in production, it will not be called during runtime. You can validate code written insidegetStaticPathsis removed from the client-side bundlewith this tool.How does getStaticProps run with regards to getStaticPathsgetStaticPropsruns duringnext buildfor anypathsreturned during buildgetStaticPropsruns in the background when usingfallback: truegetStaticPropsis called before initial render when usingfallback: blockingWhere can I use getStaticPathsgetStaticPathsmustbe used withgetStaticPropsYoucannotusegetStaticPathswithgetServerSidePropsYou can exportgetStaticPathsfrom aDynamic Routethat also usesgetStaticPropsYoucannotexportgetStaticPathsfrom non-page file (e.g. yourcomponentsfolder)You must exportgetStaticPathsas a standalone function, and not a property of the page componentRuns on every request in developmentIn development (next dev),getStaticPathswill be called on every request.Generating paths on-demandgetStaticPathsallows you to control which pages are generated during the build instead of on-demand withfallback. Generating more pages during a build will cause slower builds.You can defer generating all pages on-demand by returning an empty array forpaths. This can be especially helpful when deploying your Next.js application to multiple environments. For example, you can have faster builds by generating all pages on-demand for previews (but not production builds). This is helpful for sites with hundreds/thousands of static pages.pages/posts/[id].jsexportasyncfunctiongetStaticPaths() {// When this is true (in preview environments) don't// prerender any static pages// (faster builds, but slower initial page load)if(process.env.SKIP_BUILD_STATIC_GENERATION) {return{paths:[],fallback:'blocking',}}// Call an external API endpoint to getpostsconstres=awaitfetch('https://.../posts')constposts=awaitres.json()// Get the paths we want to prerender based onposts// In production environments, prerender all pages// (slower builds, but faster initial page load)constpaths=posts.map((post)=>({params:{ id:post.id },}))// { fallback: false } means other routes should 404return{ paths,fallback:false}}PreviousgetStaticPropsNextForms and MutationsWas this helpful?supported.Send"
forms and mutations,Forms and Mutations,"Building Your ApplicationData FetchingForms and MutationsForms and MutationsForms enable you to create and update data in web applications. Next.js provides a powerful way to handle form submissions and data mutations usingAPI Routes.Good to know:We will soon recommendincrementally adoptingthe App Router and usingServer Actionsfor handling form submissions and data mutations. Server Actions allow you to define asynchronous server functions that can be called directly from your components, without needing to manually create an API Route.API Routesdo not specify CORS headers, meaning they are same-origin only by default.Since API Routes run on the server, we're able to use sensitive values (like API keys) throughEnvironment Variableswithout exposing them to the client. This is critical for the security of your application.ExamplesServer-only formWith the Pages Router, you need to manually create API endpoints to handle securely mutating data on the server.pages/api/submit.tsTypeScriptJavaScriptTypeScriptimporttype{ NextApiRequest,NextApiResponse }from'next'exportdefaultasyncfunctionhandler(req:NextApiRequest,res:NextApiResponse) {constdata=req.bodyconstid=awaitcreateItem(data)res.status(200).json({ id })}Then, call the API Route from the client with an event handler:pages/index.tsxTypeScriptJavaScriptTypeScriptimport{ FormEvent }from'react'exportdefaultfunctionPage() {asyncfunctiononSubmit(event:FormEvent<HTMLFormElement>) {event.preventDefault()constformData=newFormData(event.currentTarget)constresponse=awaitfetch('/api/submit',{method:'POST',body:formData,})// Handle response if necessaryconstdata=awaitresponse.json()// ...}return(<formonSubmit={onSubmit}><inputtype=""text""name=""name""/><buttontype=""submit"">Submit</button></form>)}Form validationWe recommend using HTML validation likerequiredandtype=""email""for basic client-side form validation.For more advanced server-side validation, you can use a schema validation library likezodto validate the form fields before mutating the data:pages/api/submit.tsTypeScriptJavaScriptTypeScriptimporttype{ NextApiRequest,NextApiResponse }from'next'import{ z }from'zod'constschema=z.object({// ...})exportdefaultasyncfunctionhandler(req:NextApiRequest,res:NextApiResponse) {constparsed=schema.parse(req.body)// ...}Error handlingYou can use React state to show an error message when a form submission fails:pages/index.tsxTypeScriptJavaScriptTypeScriptimportReact,{ useState,FormEvent }from'react'exportdefaultfunctionPage() {const[isLoading,setIsLoading]=useState<boolean>(false)const[error,setError]=useState<string|null>(null)asyncfunctiononSubmit(event:FormEvent<HTMLFormElement>) {event.preventDefault()setIsLoading(true)setError(null)// Clear previous errors when a new request startstry{constformData=newFormData(event.currentTarget)constresponse=awaitfetch('/api/submit',{method:'POST',body:formData,})if(!response.ok) {thrownewError('Failed to submit the data. Please try again.')}// Handle response if necessaryconstdata=awaitresponse.json()// ...}catch(error) {// Capture the error message to display to the usersetError(error.message)console.error(error)}finally{setIsLoading(false)}}return(<div>{error&&<divstyle={{ color:'red'}}>{error}</div>}<formonSubmit={onSubmit}><inputtype=""text""name=""name""/><buttontype=""submit""disabled={isLoading}>{isLoading?'Loading...':'Submit'}</button></form></div>)}Displaying loading stateYou can use React state to show a loading state when a form is submitting on the server:pages/index.tsxTypeScriptJavaScriptTypeScriptimportReact,{ useState,FormEvent }from'react'exportdefaultfunctionPage() {const[isLoading,setIsLoading]=useState<boolean>(false)asyncfunctiononSubmit(event:FormEvent<HTMLFormElement>) {event.preventDefault()setIsLoading(true)// Set loading to true when the request startstry{constformData=newFormData(event.currentTarget)constresponse=awaitfetch('/api/submit',{method:'POST',body:formData,})// Handle response if necessaryconstdata=awaitresponse.json()// ...}catch(error) {// Handle error if necessaryconsole.error(error)}finally{setIsLoading(false)// Set loading to false when the request completes}}return(<formonSubmit={onSubmit}><inputtype=""text""name=""name""/><buttontype=""submit""disabled={isLoading}>{isLoading?'Loading...':'Submit'}</button></form>)}RedirectingIf you would like to redirect the user to a different route after a mutation, you canredirectto any absolute or relative URL:pages/api/submit.tsTypeScriptJavaScriptTypeScriptimporttype{ NextApiRequest,NextApiResponse }from'next'exportdefaultasyncfunctionhandler(req:NextApiRequest,res:NextApiResponse) {constid=awaitaddPost()res.redirect(307,`/post/${id}`)}Setting cookiesYou can set cookies inside an API Route using thesetHeadermethod on the response:pages/api/cookie.tsTypeScriptJavaScriptTypeScriptimporttype{ NextApiRequest,NextApiResponse }from'next'exportdefaultasyncfunctionhandler(req:NextApiRequest,res:NextApiResponse) {res.setHeader('Set-Cookie','username=lee; Path=/; HttpOnly')res.status(200).send('Cookie has been set.')}Reading cookiesYou can read cookies inside an API Route using thecookiesrequest helper:pages/api/cookie.tsTypeScriptJavaScriptTypeScriptimporttype{ NextApiRequest,NextApiResponse }from'next'exportdefaultasyncfunctionhandler(req:NextApiRequest,res:NextApiResponse) {constauth=req.cookies.authorization// ...}Deleting cookiesYou can delete cookies inside an API Route using thesetHeadermethod on the response:pages/api/cookie.tsTypeScriptJavaScriptTypeScriptimporttype{ NextApiRequest,NextApiResponse }from'next'exportdefaultasyncfunctionhandler(req:NextApiRequest,res:NextApiResponse) {res.setHeader('Set-Cookie','username=; Path=/; HttpOnly; Max-Age=0')res.status(200).send('Cookie has been deleted.')}PreviousgetStaticPathsNextgetServerSidePropsWas this helpful?supported.Send"
getserversideprops,getServerSideProps,"Building Your ApplicationData FetchinggetServerSidePropsgetServerSidePropsgetServerSidePropsis a Next.js function that can be used to fetch data and render the contents of a page at request time.ExampleYou can usegetServerSidePropsby exporting it from a Page Component. The example below shows how you can fetch data from a 3rd party API ingetServerSideProps, and pass the data to the page as props:pages/index.tsxTypeScriptJavaScriptTypeScriptimporttype{ InferGetServerSidePropsType,GetServerSideProps }from'next'typeRepo={name:stringstargazers_count:number}exportconstgetServerSideProps=(async()=>{// Fetch data from external APIconstres=awaitfetch('https://api.github.com/repos/vercel/next.js')constrepo:Repo=awaitres.json()// Pass data to the page via propsreturn{ props:{ repo } }})satisfiesGetServerSideProps<{ repo:Repo}>exportdefaultfunctionPage({repo,}:InferGetServerSidePropsType<typeofgetServerSideProps>) {return(<main><p>{repo.stargazers_count}</p></main>)}When should I usegetServerSideProps?You should usegetServerSidePropsif you need to render a page that relies on personalized user data, or information that can only be known at request time. For example,authorizationheaders or a geolocation.If you do not need to fetch the data at request time, or would prefer to cache the data and pre-rendered HTML, we recommend usinggetStaticProps.BehaviorgetServerSidePropsruns on the server.getServerSidePropscan only be exported from apage.getServerSidePropsreturns JSON.When a user visits a page,getServerSidePropswill be used to fetch data at request time, and the data is used to render the initial HTML of the page.propspassed to the page component can be viewed on the client as part of the initial HTML. This is to allow the page to behydratedcorrectly. Make sure that you don't pass any sensitive information that shouldn't be available on the client inprops.When a user visits the page throughnext/linkornext/router, Next.js sends an API request to the server, which runsgetServerSideProps.You do not have to call a Next.jsAPI Routeto fetch data when usinggetServerSidePropssince the function runs on the server. Instead, you can call a CMS, database, or other third-party APIs directly from insidegetServerSideProps.Good to know:SeegetServerSidePropsAPI referencefor parameters and props that can be used withgetServerSideProps.You can use thenext-code-elimination toolto verify what Next.js eliminates from the client-side bundle.Error HandlingIf an error is thrown insidegetServerSideProps, it will show thepages/500.jsfile. Check out the documentation for500 pageto learn more on how to create it. During development, this file will not be used and the development error overlay will be shown instead.Edge CasesCaching with Server-Side Rendering (SSR)You can use caching headers (Cache-Control) insidegetServerSidePropsto cache dynamic responses. For example, usingstale-while-revalidate.// This value is considered fresh for ten seconds (s-maxage=10).// If a request is repeated within the next 10 seconds, the previously// cached value will still be fresh. If the request is repeated before 59 seconds,// the cached value will be stale but still render (stale-while-revalidate=59).//// In the background, a revalidation request will be made to populate the cache// with a fresh value. If you refresh the page, you will see the new value.exportasyncfunctiongetServerSideProps({ req,res }) {res.setHeader('Cache-Control','public, s-maxage=10, stale-while-revalidate=59')return{props:{},}}However, before reaching forcache-control, we recommend seeing ifgetStaticPropswithISRis a better fit for your use case.PreviousForms and MutationsNextIncremental Static Regeneration (ISR)Was this helpful?supported.Send"
incremental static regeneration (isr),Incremental Static Regeneration (ISR),"Building Your ApplicationData FetchingIncremental Static Regeneration (ISR)Incremental Static Regeneration (ISR)ExamplesNext.js CommerceOn-Demand ISRNext.js FormsIncremental Static Regeneration (ISR) enables you to:Update static content without rebuilding the entire siteReduce server load by serving prerendered, static pages for most requestsEnsure propercache-controlheaders are automatically added to pagesHandle large amounts of content pages without longnext buildtimesHere's a minimal example:pages/blog/[id].tsxTypeScriptJavaScriptTypeScriptimporttype{ GetStaticPaths,GetStaticProps }from'next'interfacePost{id:stringtitle:stringcontent:string}interfaceProps{post:Post}exportconstgetStaticPaths:GetStaticPaths=async()=>{constposts=awaitfetch('https://api.vercel.app/blog').then((res)=>res.json())constpaths=posts.map((post:Post)=>({params:{ id:String(post.id) },}))// We'll prerender only these paths at build time.// { fallback: 'blocking' } will server-render pages// on-demand if the path doesn't exist.return{ paths,fallback:false}}exportconstgetStaticProps:GetStaticProps<Props>=async({params,}:{params:{ id:string}})=>{constpost=awaitfetch(`https://api.vercel.app/blog/${params.id}`).then((res)=>res.json())return{props:{ post },// Next.js will invalidate the cache when a// request comes in, at most once every 60 seconds.revalidate:60,}}exportdefaultfunctionPage({ post }:Props) {return(<main><h1>{post.title}</h1><p>{post.content}</p></main>)}Here's how this example works:Duringnext build, all known blog posts are generated (there are 25 in this example)All requests made to these pages (e.g./blog/1) are cached and instantaneousAfter 60 seconds has passed, the next request will still show the cached (stale) pageThe cache is invalidated and a new version of the page begins generating in the backgroundOnce generated successfully, Next.js will display and cache the updated pageIf/blog/26is requested, Next.js will generate and cache this page on-demandReferenceFunctionsgetStaticPropsres.revalidateExamplesOn-demand validation withres.revalidate()For a more precise method of revalidation, useres.revalidateto generate a new page on-demand from an API Router.For example, this API Route can be called at/api/revalidate?secret=<token>to revalidate a given blog post. Create a secret token only known by your Next.js app. This secret will be used to prevent unauthorized access to the revalidation API Route.pages/api/revalidate.tsTypeScriptJavaScriptTypeScriptimporttype{ NextApiRequest,NextApiResponse }from'next'exportdefaultasyncfunctionhandler(req:NextApiRequest,res:NextApiResponse) {// Check for secret to confirm this is a valid requestif(req.query.secret!==process.env.MY_SECRET_TOKEN) {returnres.status(401).json({ message:'Invalid token'})}try{// This should be the actual path not a rewritten path// e.g. for ""/posts/[id]"" this should be ""/posts/1""awaitres.revalidate('/posts/1')returnres.json({ revalidated:true})}catch(err) {// If there was an error, Next.js will continue// to show the last successfully generated pagereturnres.status(500).send('Error revalidating')}}If you are using on-demand revalidation, you do not need to specify arevalidatetime inside ofgetStaticProps. Next.js will use the default value offalse(no revalidation) and only revalidate the page on-demand whenres.revalidate()is called.Handling uncaught exceptionsIf there is an error insidegetStaticPropswhen handling background regeneration, or you manually throw an error, the last successfully generated page will continue to show. On the next subsequent request, Next.js will retry callinggetStaticProps.pages/blog/[id].tsxTypeScriptJavaScriptTypeScriptimporttype{ GetStaticProps }from'next'interfacePost{id:stringtitle:stringcontent:string}interfaceProps{post:Post}exportconstgetStaticProps:GetStaticProps<Props>=async({params,}:{params:{ id:string}})=>{// If this request throws an uncaught error, Next.js will// not invalidate the currently shown page and// retry getStaticProps on the next request.constres=awaitfetch(`https://api.vercel.app/blog/${params.id}`)constpost:Post=awaitres.json()if(!res.ok) {// If there is a server error, you might want to// throw an error instead of returning so that the cache is not updated// until the next successful request.thrownewError(`Failed to fetch posts, received status${res.status}`)}return{props:{ post },// Next.js will invalidate the cache when a// request comes in, at most once every 60 seconds.revalidate:60,}}Customizing the cache locationCaching and revalidating pages (with Incremental Static Regeneration) use the same shared cache. Whendeploying to Vercel, the ISR cache is automatically persisted to durable storage.When self-hosting, the ISR cache is stored to the filesystem (on disk) on your Next.js server. This works automatically when self-hosting using both the Pages and App Router.You can configure the Next.js cache location if you want to persist cached pages and data to durable storage, or share the cache across multiple containers or instances of your Next.js application.Learn more.TroubleshootingDebugging cached data in local developmentIf you are using thefetchAPI, you can add additional logging to understand which requests are cached or uncached.Learn more about theloggingoption.next.config.jsmodule.exports={logging:{fetches:{fullUrl:true,},},}Verifying correct production behaviorTo verify your pages are cached and revalidated correctly in production, you can test locally by runningnext buildand thennext startto run the production Next.js server.This will allow you to test ISR behavior as it would work in a production environment. For further debugging, add the following environment variable to your.envfile:.envNEXT_PRIVATE_DEBUG_CACHE=1This will make the Next.js server console log ISR cache hits and misses. You can inspect the output to see which pages are generated duringnext build, as well as how pages are updated as paths are accessed on-demand.CaveatsISR is only supported when using the Node.js runtime (default).ISR is not supported when creating aStatic Export.Middleware won't be executed for on-demand ISR requests, meaning any path rewrites or logic in Middleware will not be applied. Ensure you are revalidating the exact path. For example,/post/1instead of a rewritten/post-1.Version historyVersionChangesv14.1.0CustomcacheHandleris stable.v13.0.0App Router is introduced.v12.2.0Pages Router: On-Demand ISR is stablev12.0.0Pages Router:Bot-aware ISR fallbackadded.v9.5.0Pages Router:Stable ISR introduced.PreviousgetServerSidePropsNextClient-side FetchingWas this helpful?supported.Send"
client-side fetching,Client-side Fetching,"Building Your ApplicationData FetchingClient-side FetchingClient-side FetchingClient-side data fetching is useful when your page doesn't require SEO indexing, when you don't need to pre-render your data, or when the content of your pages needs to update frequently. Unlike the server-side rendering APIs, you can use client-side data fetching at the component level.If done at the page level, the data is fetched at runtime, and the content of the page is updated as the data changes. When used at the component level, the data is fetched at the time of the component mount, and the content of the component is updated as the data changes.It's important to note that using client-side data fetching can affect the performance of your application and the load speed of your pages. This is because the data fetching is done at the time of the component or pages mount, and the data is not cached.Client-side data fetching with useEffectThe following example shows how you can fetch data on the client side using the useEffect hook.import{ useState,useEffect }from'react'functionProfile() {const[data,setData]=useState(null)const[isLoading,setLoading]=useState(true)useEffect(()=>{fetch('/api/profile-data').then((res)=>res.json()).then((data)=>{setData(data)setLoading(false)})},[])if(isLoading)return<p>Loading...</p>if(!data)return<p>No profile data</p>return(<div><h1>{data.name}</h1><p>{data.bio}</p></div>)}Client-side data fetching with SWRThe team behind Next.js has created a React hook library for data fetching calledSWR. It ishighly recommendedif you are fetching data on the client-side. It handles caching, revalidation, focus tracking, refetching on intervals, and more.Using the same example as above, we can now use SWR to fetch the profile data. SWR will automatically cache the data for us and will revalidate the data if it becomes stale.For more information on using SWR, check out theSWR docs.importuseSWRfrom'swr'constfetcher=(...args)=>fetch(...args).then((res)=>res.json())functionProfile() {const{data,error}=useSWR('/api/profile-data',fetcher)if(error)return<div>Failed to load</div>if(!data)return<div>Loading...</div>return(<div><h1>{data.name}</h1><p>{data.bio}</p></div>)}PreviousIncremental Static Regeneration (ISR)NextStylingWas this helpful?supported.Send"
styling,Styling,"Pages RouterBuilding Your ApplicationStylingStylingNext.js supports different ways of styling your application, including:CSS Modules: Create locally scoped CSS classes to avoid naming conflicts and improve maintainability.Global CSS: Simple to use and familiar for those experienced with traditional CSS, but can lead to larger CSS bundles and difficulty managing styles as the application grows.Tailwind CSS: A utility-first CSS framework that allows for rapid custom designs by composing utility classes.Sass: A popular CSS preprocessor that extends CSS with features like variables, nested rules, and mixins.CSS-in-JS: Embed CSS directly in your JavaScript components, enabling dynamic and scoped styling.Learn more about each approach by exploring their respective documentation:CSSStyle your Next.js Application using CSS.Tailwind CSSStyle your Next.js Application using Tailwind CSS.CSS-in-JSUse CSS-in-JS libraries with Next.jsSassLearn how to use Sass in your Next.js application.PreviousClient-side FetchingNextCSSWas this helpful?supported.Send"
css,CSS,"Building Your ApplicationStylingCSSCSSExamplesBasic CSS ExampleNext.js supports multiple ways of handling CSS, including:CSS ModulesGlobal StylesExternal StylesheetsCSS ModulesNext.js has built-in support for CSS Modules using the.module.cssextension.CSS Modules locally scope CSS by automatically creating a unique class name. This allows you to use the same class name in different files without worrying about collisions. This behavior makes CSS Modules the ideal way to include component-level CSS.ExampleFor example, consider a reusableButtoncomponent in thecomponents/folder:First, createcomponents/Button.module.csswith the following content:Button.module.css/*You do not need to worry about .error {} colliding with any other `.css` or`.module.css` files!*/.error{color:white;background-color:red;}Then, createcomponents/Button.js, importing and using the above CSS file:components/Button.jsimportstylesfrom'./Button.module.css'exportfunctionButton() {return(<buttontype=""button""// Note how the ""error"" class is accessed as a property on the imported// `styles` object.className={styles.error}>Destroy</button>)}CSS Modules areonly enabled for files with the.module.cssand.module.sassextensions.In production, all CSS Module files will be automatically concatenated intomany minified and code-split.cssfiles.
These.cssfiles represent hot execution paths in your application, ensuring the minimal amount of CSS is loaded for your application to paint.Global StylesTo add a stylesheet to your application, import the CSS file withinpages/_app.js.For example, consider the following stylesheet namedstyles.css:styles.cssbody{font-family:'SF Pro Text','SF Pro Icons','Helvetica Neue','Helvetica','Arial',sans-serif;padding:20px20px60px;max-width:680px;margin:0 auto;}Create apages/_app.jsfileif not already present.
Then,importthestyles.cssfile.pages/_app.jsimport'../styles.css'// This default export is required in a new `pages/_app.js` file.exportdefaultfunctionMyApp({ Component,pageProps }) {return<Component{...pageProps} />}These styles (styles.css) will apply to all pages and components in your application.
Due to the global nature of stylesheets, and to avoid conflicts, you mayonly import them insidepages/_app.js.In development, expressing stylesheets this way allows your styles to be hot reloaded as you edit them—meaning you can keep application state.In production, all CSS files will be automatically concatenated into a single minified.cssfile. The order that the CSS is concatenated will match the order the CSS is imported into the_app.jsfile. Pay special attention to imported JS modules that include their own CSS; the JS module's CSS will be concatenated following the same ordering rules as imported CSS files. For example:import'../styles.css'// The CSS in ErrorBoundary depends on the global CSS in styles.css,// so we import it after styles.css.importErrorBoundaryfrom'../components/ErrorBoundary'exportdefaultfunctionMyApp({ Component,pageProps }) {return(<ErrorBoundary><Component{...pageProps} /></ErrorBoundary>)}External StylesheetsNext.js allows you to import CSS files from a JavaScript file.
This is possible because Next.js extends the concept ofimportbeyond JavaScript.Import styles fromnode_modulesSince Next.js9.5.4, importing a CSS file fromnode_modulesis permitted anywhere in your application.For global stylesheets, likebootstrapornprogress, you should import the file insidepages/_app.js.
For example:pages/_app.jsimport'bootstrap/dist/css/bootstrap.css'exportdefaultfunctionMyApp({ Component,pageProps }) {return<Component{...pageProps} />}For importing CSS required by a third-party component, you can do so in your component. For example:components/example-dialog.jsimport{ useState }from'react'import{ Dialog }from'@reach/dialog'importVisuallyHiddenfrom'@reach/visually-hidden'import'@reach/dialog/styles.css'functionExampleDialog(props) {const[showDialog,setShowDialog]=useState(false)constopen=()=>setShowDialog(true)constclose=()=>setShowDialog(false)return(<div><buttononClick={open}>Open Dialog</button><DialogisOpen={showDialog}onDismiss={close}><buttonclassName=""close-button""onClick={close}><VisuallyHidden>Close</VisuallyHidden><spanaria-hidden>×</span></button><p>Hello there. I am a dialog</p></Dialog></div>)}Additional FeaturesNext.js includes additional features to improve the authoring experience of adding styles:When running locally withnext dev, local stylesheets (either global or CSS modules) will take advantage ofFast Refreshto instantly reflect changes as edits are saved.When building for production withnext build, CSS files will be bundled into fewer minified.cssfiles to reduce the number of network requests needed to retrieve styles.If you disable JavaScript, styles will still be loaded in the production build (next start). However, JavaScript is still required fornext devto enableFast Refresh.PreviousStylingNextTailwind CSSWas this helpful?supported.Send"
tailwind css,Tailwind CSS,"Building Your ApplicationStylingTailwind CSSTailwind CSSTailwind CSSis a utility-first CSS framework that works exceptionally well with Next.js.Installing TailwindInstall the Tailwind CSS packages and run theinitcommand to generate both thetailwind.config.jsandpostcss.config.jsfiles:Terminalnpminstall-Dtailwindcsspostcssautoprefixernpxtailwindcssinit-pConfiguring TailwindInside your Tailwind configuration file, add paths to the files that will use Tailwind class names:tailwind.config.tsTypeScriptJavaScriptTypeScriptimporttype{ Config }from'tailwindcss'exportdefault{content:['./app/**/*.{js,ts,jsx,tsx,mdx}',// Note the addition of the `app` directory.'./pages/**/*.{js,ts,jsx,tsx,mdx}','./components/**/*.{js,ts,jsx,tsx,mdx}',// Or if using `src` directory:'./src/**/*.{js,ts,jsx,tsx,mdx}',],theme:{extend:{},},plugins:[],}satisfiesConfigYou do not need to modifypostcss.config.js.Importing StylesAdd theTailwind CSS directivesthat Tailwind will use to inject its generated styles to aGlobal Stylesheetin your application, for example:styles/globals.css@tailwindbase;@tailwindcomponents;@tailwindutilities;Inside thecustom app file(pages/_app.js), import theglobals.cssstylesheet to apply the styles to every route in your application.pages/_app.tsxTypeScriptJavaScriptTypeScript// These styles apply to every route in the applicationimport'@/styles/globals.css'importtype{ AppProps }from'next/app'exportdefaultfunctionApp({ Component,pageProps }:AppProps) {return<Component{...pageProps} />}Using ClassesAfter installing Tailwind CSS and adding the global styles, you can use Tailwind's utility classes in your application.pages/index.tsxTypeScriptJavaScriptTypeScriptexportdefaultfunctionPage() {return<h1className=""text-3xl font-bold underline"">Hello, Next.js!</h1>}Usage with TurbopackAs of Next.js 13.1, Tailwind CSS and PostCSS are supported withTurbopack.PreviousCSSNextCSS-in-JSWas this helpful?supported.Send"
css-in-js,CSS-in-JS,"Building Your ApplicationStylingCSS-in-JSCSS-in-JSExamplesStyled JSXStyled ComponentsEmotionLinariaStyletronCxsFelaStitchesIt's possible to use any existing CSS-in-JS solution. The simplest one is inline styles:functionHiThere() {return<pstyle={{ color:'red'}}>hi there</p>}exportdefaultHiThereWe bundlestyled-jsxto provide support for isolated scoped CSS.
The aim is to support ""shadow CSS"" similar to Web Components, which unfortunatelydo not support server-rendering and are JS-only.See the above examples for other popular CSS-in-JS solutions (like Styled Components).A component usingstyled-jsxlooks like this:functionHelloWorld() {return(<div>Hello world<p>scoped!</p><stylejsx>{`p {color: blue;}div {background: red;}@media (max-width: 600px) {div {background: blue;}}`}</style><styleglobaljsx>{`body {background: black;}`}</style></div>)}exportdefaultHelloWorldPlease see thestyled-jsx documentationfor more examples.Disabling JavaScriptYes, if you disable JavaScript the CSS will still be loaded in the production build (next start). During development, we require JavaScript to be enabled to provide the best developer experience withFast Refresh.PreviousTailwind CSSNextSassWas this helpful?supported.Send"
sass,Sass,"Building Your ApplicationStylingSassSassNext.js has built-in support for integrating with Sass after the package is installed using both the.scssand.sassextensions. You can use component-level Sass via CSS Modules and the.module.scssor.module.sassextension.First, installsass:Terminalnpminstall--save-devsassGood to know:Sass supportstwo different syntaxes, each with their own extension.
The.scssextension requires you use theSCSS syntax,
while the.sassextension requires you use theIndented Syntax (""Sass"").If you're not sure which to choose, start with the.scssextension which is a superset of CSS, and doesn't require you learn the
Indented Syntax (""Sass"").Customizing Sass OptionsIf you want to configure your Sass options, usesassOptionsinnext.config.next.config.tsTypeScriptJavaScriptTypeScriptimporttype{ NextConfig }from'next'constnextConfig:NextConfig={sassOptions:{additionalData:`$var: red;`,},}exportdefaultnextConfigImplementationYou can use theimplementationproperty to specify the Sass implementation to use. By default, Next.js uses thesasspackage.next.config.tsTypeScriptJavaScriptTypeScriptimporttype{ NextConfig }from'next'constnextConfig:NextConfig={sassOptions:{implementation:'sass-embedded',},}exportdefaultnextConfigSass VariablesNext.js supports Sass variables exported from CSS Module files.For example, using the exportedprimaryColorSass variable:app/variables.module.scss$primary-color:#64ff00;:export {primaryColor:$primary-color;}pages/_app.jsimportvariablesfrom'../styles/variables.module.scss'exportdefaultfunctionMyApp({ Component,pageProps }) {return(<Layoutcolor={variables.primaryColor}><Component{...pageProps} /></Layout>)}PreviousCSS-in-JSNextOptimizingWas this helpful?supported.Send"
optimizing,Optimizing,"Pages RouterBuilding Your ApplicationOptimizingOptimizationsNext.js comes with a variety of built-in optimizations designed to improve your application's speed andCore Web Vitals. This guide will cover the optimizations you can leverage to enhance your user experience.Built-in ComponentsBuilt-in components abstract away the complexity of implementing common UI optimizations. These components are:Images: Built on the native<img>element. The Image Component optimizes images for performance by lazy loading and automatically resizing images based on device size.Link: Built on the native<a>tags. The Link Component prefetches pages in the background, for faster and smoother page transitions.Scripts: Built on the native<script>tags. The Script Component gives you control over loading and execution of third-party scripts.MetadataMetadata helps search engines understand your content better (which can result in better SEO), and allows you to customize how your content is presented on social media, helping you create a more engaging and consistent user experience across various platforms.The Head Component in Next.js allows you to modify the<head>of a page. Learn more in theHead Componentdocumentation.Static AssetsNext.js/publicfolder can be used to serve static assets like images, fonts, and other files. Files inside/publiccan also be cached by CDN providers so that they are delivered efficiently.Analytics and MonitoringFor large applications, Next.js integrates with popular analytics and monitoring tools to help you understand how your application is performing. Learn more in theAnalytics,OpenTelemetry,andInstrumentationguides.ImagesOptimize your images with the built-in `next/image` component.FontsOptimize your application's web fonts with the built-in `next/font` loaders.ScriptsOptimize 3rd party scripts with the built-in Script component.Static AssetsNext.js allows you to serve static files, like images, in the public directory. You can learn how it works here.BundlingLearn how to optimize your application's server and client bundles.AnalyticsMeasure and track page performance using Next.js Speed InsightsLazy LoadingLazy load imported libraries and React Components to improve your application's overall loading performance.InstrumentationLearn how to use instrumentation to run code at server startup in your Next.js appOpenTelemetryLearn how to instrument your Next.js app with OpenTelemetry.Third Party LibrariesOptimize the performance of third-party libraries in your application with the `@next/third-parties` package.PreviousSassNextImagesWas this helpful?supported.Send"
images,Images,"Building Your ApplicationOptimizingImagesImage OptimizationExamplesImage ComponentAccording toWeb Almanac, images account for a huge portion of the typical website’spage weightand can have a sizable impact on your website'sLCP performance.The Next.js Image component extends the HTML<img>element with features for automatic image optimization:Size Optimization:Automatically serve correctly sized images for each device, using modern image formats like WebP.Visual Stability:Preventlayout shiftautomatically when images are loading.Faster Page Loads:Images are only loaded when they enter the viewport using native browser lazy loading, with optional blur-up placeholders.Asset Flexibility:On-demand image resizing, even for images stored on remote servers🎥 Watch:Learn more about how to usenext/image→YouTube (9 minutes).UsageimportImagefrom'next/image'You can then define thesrcfor your image (either local or remote).Local ImagesTo use a local image,importyour.jpg,.png, or.webpimage files.Next.js willautomatically determinethe intrinsicwidthandheightof your image based on the imported file. These values are used to determine the image ratio and preventCumulative Layout Shiftwhile your image is loading.pages/index.jsimportImagefrom'next/image'importprofilePicfrom'../public/me.png'exportdefaultfunctionPage() {return(<Imagesrc={profilePic}alt=""Picture of the author""// width={500} automatically provided// height={500} automatically provided// blurDataURL=""data:..."" automatically provided// placeholder=""blur"" // Optional blur-up while loading/>)}Warning:Dynamicawait import()orrequire()arenotsupported. Theimportmust be static so it can be analyzed at build time.You can optionally configurelocalPatternsin yournext.config.jsfile in order to allow specific images and block all others.next.config.jsmodule.exports={images:{localPatterns:[{pathname:'/assets/images/**',search:'',},],},}Remote ImagesTo use a remote image, thesrcproperty should be a URL string.Since Next.js does not have access to remote files during the build process, you'll need to provide thewidth,heightand optionalblurDataURLprops manually.Thewidthandheightattributes are used to infer the correct aspect ratio of image and avoid layout shift from the image loading in. Thewidthandheightdonotdetermine the rendered size of the image file. Learn more aboutImage Sizing.app/page.jsimportImagefrom'next/image'exportdefaultfunctionPage() {return(<Imagesrc=""https://s3.amazonaws.com/my-bucket/profile.png""alt=""Picture of the author""width={500}height={500}/>)}To safely allow optimizing images, define a list of supported URL patterns innext.config.js. Be as specific as possible to prevent malicious usage. For example, the following configuration will only allow images from a specific AWS S3 bucket:next.config.jsmodule.exports={images:{remotePatterns:[{protocol:'https',hostname:'s3.amazonaws.com',port:'',pathname:'/my-bucket/**',search:'',},],},}Learn more aboutremotePatternsconfiguration. If you want to use relative URLs for the imagesrc, use aloader.DomainsSometimes you may want to optimize a remote image, but still use the built-in Next.js Image Optimization API. To do this, leave theloaderat its default setting and enter an absolute URL for the Imagesrcprop.To protect your application from malicious users, you must define a list of remote hostnames you intend to use with thenext/imagecomponent.Learn more aboutremotePatternsconfiguration.LoadersNote that in theexample earlier, a partial URL (""/me.png"") is provided for a local image. This is possible because of the loader architecture.A loader is a function that generates the URLs for your image. It modifies the providedsrc, and generates multiple URLs to request the image at different sizes. These multiple URLs are used in the automaticsrcsetgeneration, so that visitors to your site will be served an image that is the right size for their viewport.The default loader for Next.js applications uses the built-in Image Optimization API, which optimizes images from anywhere on the web, and then serves them directly from the Next.js web server. If you would like to serve your images directly from a CDN or image server, you can write your own loader function with a few lines of JavaScript.You can define a loader per-image with theloaderprop, or at the application level with theloaderFileconfiguration.PriorityYou should add thepriorityproperty to the image that will be theLargest Contentful Paint (LCP) elementfor each page. Doing so allows Next.js topreloadthe image, leading to a meaningful boost in LCP.The LCP element is typically the largest image or text block visible within the viewport of the page. When you runnext dev, you'll see a console warning if the LCP element is an<Image>without thepriorityproperty.Once you've identified the LCP image, you can add the property like this:app/page.jsimportImagefrom'next/image'exportdefaultfunctionHome() {return(<><h1>My Homepage</h1><Imagesrc=""/me.png""alt=""Picture of the author""width={500}height={500}priority/><p>Welcome to my homepage!</p></>)}See more about priority in thenext/imagecomponent documentation.Image SizingOne of the ways that images most commonly hurt performance is throughlayout shift, where the image pushes other elements around on the page as it loads in. This performance problem is so annoying to users that it has its own Core Web Vital, calledCumulative Layout Shift. The way to avoid image-based layout shifts is toalways size your images. This allows the browser to reserve precisely enough space for the image before it loads.Becausenext/imageis designed to guarantee good performance results, it cannot be used in a way that will contribute to layout shift, andmustbe sized in one of three ways:Automatically, using astatic importManually, by including awidthandheightproperty used to determine the image's aspect ratio.Implicitly, by usingfillwhich causes the image to expand to fill its parent element.What if I don't know the size of my images?If you are accessing images from a source without knowledge of the images' sizes, there are several things you can do:UsefillThefillprop allows your image to be sized by its parent element. Consider using CSS to give the image's parent element space on the page alongsizesprop to match any media query break points. You can also useobject-fitwithfill,contain, orcover, andobject-positionto define how the image should occupy that space.Normalize your imagesIf you're serving images from a source that you control, consider modifying your image pipeline to normalize the images to a specific size.Modify your API callsIf your application is retrieving image URLs using an API call (such as to a CMS), you may be able to modify the API call to return the image dimensions along with the URL.If none of the suggested methods works for sizing your images, thenext/imagecomponent is designed to work well on a page alongside standard<img>elements.StylingStyling the Image component is similar to styling a normal<img>element, but there are a few guidelines to keep in mind:UseclassNameorstyle, notstyled-jsx.In most cases, we recommend using theclassNameprop. This can be an importedCSS Module, aglobal stylesheet, etc.You can also use thestyleprop to assign inline styles.You cannot usestyled-jsxbecause it's scoped to the current component (unless you mark the style asglobal).When usingfill, the parent element must haveposition: relativeThis is necessary for the proper rendering of the image element in that layout mode.When usingfill, the parent element must havedisplay: blockThis is the default for<div>elements but should be specified otherwise.ExamplesResponsiveimportImagefrom'next/image'importmountainsfrom'../public/mountains.jpg'exportdefaultfunctionResponsive() {return(<divstyle={{ display:'flex',flexDirection:'column'}}><Imagealt=""Mountains""// Importing an image will// automatically set the width and heightsrc={mountains}sizes=""100vw""// Make the image display full widthstyle={{width:'100%',height:'auto',}}/></div>)}Fill ContainerimportImagefrom'next/image'importmountainsfrom'../public/mountains.jpg'exportdefaultfunctionFill() {return(<divstyle={{display:'grid',gridGap:'8px',gridTemplateColumns:'repeat(auto-fit, minmax(400px, auto))',}}><divstyle={{ position:'relative',height:'400px'}}><Imagealt=""Mountains""src={mountains}fillsizes=""(min-width: 808px) 50vw, 100vw""style={{objectFit:'cover',// cover, contain, none}}/></div>{/* And more images in the grid... */}</div>)}Background ImageimportImagefrom'next/image'importmountainsfrom'../public/mountains.jpg'exportdefaultfunctionBackground() {return(<Imagealt=""Mountains""src={mountains}placeholder=""blur""quality={100}fillsizes=""100vw""style={{objectFit:'cover',}}/>)}For examples of the Image component used with the various styles, see theImage Component Demo.Other PropertiesView all properties available to thenext/imagecomponent.ConfigurationThenext/imagecomponent and Next.js Image Optimization API can be configured in thenext.config.jsfile. These configurations allow you toenable remote images,define custom image breakpoints,change caching behaviorand more.Read the full image configuration documentation for more information.PreviousOptimizingNextFontsWas this helpful?supported.Send"
fonts,Fonts,"Building Your ApplicationOptimizingFontsFont Optimizationnext/fontwill automatically optimize your fonts (including custom fonts) and remove external network requests for improved privacy and performance.🎥 Watch:Learn more about usingnext/font→YouTube (6 minutes).next/fontincludesbuilt-in automatic self-hostingforanyfont file. This means you can optimally load web fonts with zero layout shift, thanks to the underlying CSSsize-adjustproperty used.This new font system also allows you to conveniently use all Google Fonts with performance and privacy in mind. CSS and font files are downloaded at build time and self-hosted with the rest of your static assets.No requests are sent to Google by the browser.Google FontsAutomatically self-host any Google Font. Fonts are included in the deployment and served from the same domain as your deployment.No requests are sent to Google by the browser.Get started by importing the font you would like to use fromnext/font/googleas a function. We recommend usingvariable fontsfor the best performance and flexibility.To use the font in all your pages, add it to_app.jsfileunder/pagesas shown below:pages/_app.jsimport{ Inter }from'next/font/google'// If loading a variable font, you don't need to specify the font weightconstinter=Inter({ subsets:['latin'] })exportdefaultfunctionMyApp({ Component,pageProps }) {return(<mainclassName={inter.className}><Component{...pageProps} /></main>)}If you can't use a variable font, you willneed to specify a weight:pages/_app.jsimport{ Roboto }from'next/font/google'constroboto=Roboto({weight:'400',subsets:['latin'],})exportdefaultfunctionMyApp({ Component,pageProps }) {return(<mainclassName={roboto.className}><Component{...pageProps} /></main>)}You can specify multiple weights and/or styles by using an array:app/layout.jsconstroboto=Roboto({weight:['400','700'],style:['normal','italic'],subsets:['latin'],display:'swap',})Good to know: Use an underscore (_) for font names with multiple words. E.g.Roboto Monoshould be imported asRoboto_Mono.Apply the font in<head>You can also use the font without a wrapper andclassNameby injecting it inside the<head>as follows:pages/_app.jsimport{ Inter }from'next/font/google'constinter=Inter({ subsets:['latin'] })exportdefaultfunctionMyApp({ Component,pageProps }) {return(<><stylejsxglobal>{`html {font-family:${inter.style.fontFamily};}`}</style><Component{...pageProps} /></>)}Single page usageTo use the font on a single page, add it to the specific page as shown below:pages/index.jsimport{ Inter }from'next/font/google'constinter=Inter({ subsets:['latin'] })exportdefaultfunctionHome() {return(<divclassName={inter.className}><p>Hello World</p></div>)}Specifying a subsetGoogle Fonts are automaticallysubset. This reduces the size of the font file and improves performance. You'll need to define which of these subsets you want to preload. Failing to specify any subsets whilepreloadistruewill result in a warning.This can be done by adding it to the function call:pages/_app.jsconstinter=Inter({ subsets:['latin'] })View theFont API Referencefor more information.Using Multiple FontsYou can import and use multiple fonts in your application. There are two approaches you can take.The first approach is to create a utility function that exports a font, imports it, and applies itsclassNamewhere needed. This ensures the font is preloaded only when it's rendered:app/fonts.tsTypeScriptJavaScriptTypeScriptimport{ Inter,Roboto_Mono }from'next/font/google'exportconstinter=Inter({subsets:['latin'],display:'swap',})exportconstroboto_mono=Roboto_Mono({subsets:['latin'],display:'swap',})In the example above,Interwill be applied globally, andRoboto Monocan be imported and applied as needed.Alternatively, you can create aCSS variableand use it with your preferred CSS solution:app/global.csshtml{font-family:var(--font-inter);}h1{font-family:var(--font-roboto-mono);}In the example above,Interwill be applied globally, and any<h1>tags will be styled withRoboto Mono.Recommendation: Use multiple fonts conservatively since each new font is an additional resource the client has to download.Local FontsImportnext/font/localand specify thesrcof your local font file. We recommend usingvariable fontsfor the best performance and flexibility.pages/_app.jsimportlocalFontfrom'next/font/local'// Font files can be colocated inside of `pages`constmyFont=localFont({ src:'./my-font.woff2'})exportdefaultfunctionMyApp({ Component,pageProps }) {return(<mainclassName={myFont.className}><Component{...pageProps} /></main>)}If you want to use multiple files for a single font family,srccan be an array:constroboto=localFont({src:[{path:'./Roboto-Regular.woff2',weight:'400',style:'normal',},{path:'./Roboto-Italic.woff2',weight:'400',style:'italic',},{path:'./Roboto-Bold.woff2',weight:'700',style:'normal',},{path:'./Roboto-BoldItalic.woff2',weight:'700',style:'italic',},],})View theFont API Referencefor more information.With Tailwind CSSnext/fontcan be used withTailwind CSSthrough aCSS variable.In the example below, we use the fontInterfromnext/font/google(you can use any font from Google or Local Fonts). Load your font with thevariableoption to define your CSS variable name and assign it tointer. Then, useinter.variableto add the CSS variable to your HTML document.pages/_app.jsimport{ Inter }from'next/font/google'constinter=Inter({subsets:['latin'],variable:'--font-inter',})exportdefaultfunctionMyApp({ Component,pageProps }) {return(<mainclassName={`${inter.variable}font-sans`}><Component{...pageProps} /></main>)}Finally, add the CSS variable to yourTailwind CSS config:tailwind.config.js/**@type{import('tailwindcss').Config}*/module.exports={content:['./pages/**/*.{js,ts,jsx,tsx}','./components/**/*.{js,ts,jsx,tsx}','./app/**/*.{js,ts,jsx,tsx}',],theme:{extend:{fontFamily:{sans:['var(--font-inter)'],mono:['var(--font-roboto-mono)'],},},},plugins:[],}You can now use thefont-sansandfont-monoutility classes to apply the font to your elements.PreloadingWhen a font function is called on a page of your site, it is not globally available and preloaded on all routes. Rather, the font is only preloaded on the related route/s based on the type of file where it is used:if it's aunique page, it is preloaded on the unique route for that pageif it's in thecustom App, it is preloaded on all the routes of the site under/pagesReusing fontsEvery time you call thelocalFontor Google font function, that font is hosted as one instance in your application. Therefore, if you load the same font function in multiple files, multiple instances of the same font are hosted. In this situation, it is recommended to do the following:Call the font loader function in one shared fileExport it as a constantImport the constant in each file where you would like to use this fontPreviousImagesNextScriptsWas this helpful?supported.Send"
scripts,Scripts,"Building Your ApplicationOptimizingScriptsScript OptimizationApplication ScriptsTo load a third-party script for all routes, importnext/scriptand include the script directly in your custom_app:pages/_app.jsimportScriptfrom'next/script'exportdefaultfunctionMyApp({ Component,pageProps }) {return(<><Component{...pageProps} /><Scriptsrc=""https://example.com/script.js""/></>)}This script will load and execute whenanyroute in your application is accessed. Next.js will ensure the script willonly load once, even if a user navigates between multiple pages.Recommendation: We recommend only including third-party scripts in specific pages or layouts in order to minimize any unnecessary impact to performance.StrategyAlthough the default behavior ofnext/scriptallows you to load third-party scripts in any page or layout, you can fine-tune its loading behavior by using thestrategyproperty:beforeInteractive: Load the script before any Next.js code and before any page hydration occurs.afterInteractive: (default) Load the script early but after some hydration on the page occurs.lazyOnload: Load the script later during browser idle time.worker: (experimental) Load the script in a web worker.Refer to thenext/scriptAPI reference documentation to learn more about each strategy and their use cases.Offloading Scripts To A Web Worker (experimental)Warning:Theworkerstrategy is not yet stable and does not yet work with the App Router. Use with caution.Scripts that use theworkerstrategy are offloaded and executed in a web worker withPartytown. This can improve the performance of your site by dedicating the main thread to the rest of your application code.This strategy is still experimental and can only be used if thenextScriptWorkersflag is enabled innext.config.js:next.config.jsmodule.exports={experimental:{nextScriptWorkers:true,},}Then, runnext(normallynpm run devoryarn dev) and Next.js will guide you through the installation of the required packages to finish the setup:TerminalnpmrundevYou'll see instructions like these: Please install Partytown by runningnpm install @builder.io/partytownOnce setup is complete, definingstrategy=""worker""will automatically instantiate Partytown in your application and offload the script to a web worker.pages/home.tsxTypeScriptJavaScriptTypeScriptimportScriptfrom'next/script'exportdefaultfunctionHome() {return(<><Scriptsrc=""https://example.com/script.js""strategy=""worker""/></>)}There are a number of trade-offs that need to be considered when loading a third-party script in a web worker. Please see Partytown'stradeoffsdocumentation for more information.Using custom Partytown configurationAlthough theworkerstrategy does not require any additional configuration to work, Partytown supports the use of a config object to modify some of its settings, including enablingdebugmode and forwarding events and triggers.If you would like to add additional configuration options, you can include it within the<Head />component used in acustom_document.js:_pages/document.jsximport{ Html,Head,Main,NextScript }from'next/document'exportdefaultfunctionDocument() {return(<Html><Head><scriptdata-partytown-configdangerouslySetInnerHTML={{__html:`partytown = {lib: ""/_next/static/~partytown/"",debug: true};`,}}/></Head><body><Main/><NextScript/></body></Html>)}In order to modify Partytown's configuration, the following conditions must be met:Thedata-partytown-configattribute must be used in order to overwrite the default configuration used by Next.jsUnless you decide to save Partytown's library files in a separate directory, thelib: ""/_next/static/~partytown/""property and value must be included in the configuration object in order to let Partytown know where Next.js stores the necessary static files.Note: If you are using anasset prefixand would like to modify Partytown's default configuration, you must include it as part of thelibpath.Take a look at Partytown'sconfiguration optionsto see the full list of other properties that can be added.Inline ScriptsInline scripts, or scripts not loaded from an external file, are also supported by the Script component. They can be written by placing the JavaScript within curly braces:<Scriptid=""show-banner"">{`document.getElementById('banner').classList.remove('hidden')`}</Script>Or by using thedangerouslySetInnerHTMLproperty:<Scriptid=""show-banner""dangerouslySetInnerHTML={{__html:`document.getElementById('banner').classList.remove('hidden')`,}}/>Warning: Anidproperty must be assigned for inline scripts in order for Next.js to track and optimize the script.Executing Additional CodeEvent handlers can be used with the Script component to execute additional code after a certain event occurs:onLoad: Execute code after the script has finished loading.onReady: Execute code after the script has finished loading and every time the component is mounted.onError: Execute code if the script fails to load.These handlers will only work whennext/scriptis imported and used inside of aClient Componentwhere""use client""is defined as the first line of code:pages/index.tsxTypeScriptJavaScriptTypeScriptimportScriptfrom'next/script'exportdefaultfunctionPage() {return(<><Scriptsrc=""https://example.com/script.js""onLoad={()=>{console.log('Script has loaded')}}/></>)}Refer to thenext/scriptAPI reference to learn more about each event handler and view examples.Additional AttributesThere are many DOM attributes that can be assigned to a<script>element that are not used by the Script component, likenonceorcustom data attributes. Including any additional attributes will automatically forward it to the final, optimized<script>element that is included in the HTML.pages/index.tsxTypeScriptJavaScriptTypeScriptimportScriptfrom'next/script'exportdefaultfunctionPage() {return(<><Scriptsrc=""https://example.com/script.js""id=""example-script""nonce=""XUENAJFW""data-test=""script""/></>)}PreviousFontsNextStatic AssetsWas this helpful?supported.Send"
static assets,Static Assets,"Building Your ApplicationOptimizingStatic AssetsStatic AssetsNext.js can serve static files, like images, under a folder calledpublicin the root directory. Files insidepubliccan then be referenced by your code starting from the base URL (/).For example, the filepublic/avatars/me.pngcan be viewed by visiting the/avatars/me.pngpath. The code to display that image might look like:avatar.jsimportImagefrom'next/image'exportfunctionAvatar({ id,alt }) {return<Imagesrc={`/avatars/${id}.png`}alt={alt}width=""64""height=""64""/>}exportfunctionAvatarOfMe() {return<Avatarid=""me""alt=""A portrait of me""/>}CachingNext.js cannot safely cache assets in thepublicfolder because they may change. The default caching headers applied are:Cache-Control:public,max-age=0Robots, Favicons, and othersThe folder is also useful forrobots.txt,favicon.ico, Google Site Verification, and any other static files (including.html). But make sure to not have a static file with the same name as a file in thepages/directory, as this will result in an error.Read more.Good to know:The directory must be namedpublic. The name cannot be changed and it's the only directory used to serve static assets.Only assets that are in thepublicdirectory atbuild timewill be served by Next.js. Files added at request time won't be available. We recommend using a third-party service likeVercel Blobfor persistent file storage.PreviousScriptsNextBundlingWas this helpful?supported.Send"
bundling,Bundling,"Building Your ApplicationOptimizingBundlingOptimizing BundlingBundling external packages can significantly improve the performance of your application.By default, packages imported into your application are not bundled. This can impact performance or might not work if external packages are not pre-bundled, for example, if imported from a monorepo ornode_modules. This page will guide you through how to analyze and configure package bundling.Analyzing JavaScript bundles@next/bundle-analyzeris a plugin for Next.js that helps you manage the size of your application bundles. It generates a visual report of the size of each package and their dependencies. You can use the information to remove large dependencies, split, orlazy-loadyour code.InstallationInstall the plugin by running the following command:npmi@next/bundle-analyzer# oryarnadd@next/bundle-analyzer# orpnpmadd@next/bundle-analyzerThen, add the bundle analyzer's settings to yournext.config.js.next.config.js/**@type{import('next').NextConfig}*/constnextConfig={}constwithBundleAnalyzer=require('@next/bundle-analyzer')({enabled:process.env.ANALYZE==='true',})module.exports=withBundleAnalyzer(nextConfig)Generating a reportRun the following command to analyze your bundles:ANALYZE=truenpmrunbuild# orANALYZE=trueyarnbuild# orANALYZE=truepnpmbuildThe report will open three new tabs in your browser, which you can inspect. Periodically evaluating your application's bundles can help you maintain application performance over time.Optimizing package importsSome packages, such as icon libraries, can export hundreds of modules, which can cause performance issues in development and production.You can optimize how these packages are imported by adding theoptimizePackageImportsoption to yournext.config.js. This option will only load the modules youactuallyuse, while still giving you the convenience of writing import statements with many named exports.next.config.js/**@type{import('next').NextConfig}*/constnextConfig={experimental:{optimizePackageImports:['icon-library'],},}module.exports=nextConfigNext.js also optimizes some libraries automatically, thus they do not need to be included in the optimizePackageImports list. See thefull list.Bundling specific packagesTo bundle specific packages, you can use thetranspilePackagesoption in yournext.config.js. This option is useful for bundling external packages that are not pre-bundled, for example, in a monorepo or imported fromnode_modules.next.config.js/**@type{import('next').NextConfig}*/constnextConfig={transpilePackages:['package-name'],}module.exports=nextConfigBundling all packagesTo automatically bundle all packages (default behavior in the App Router), you can use thebundlePagesRouterDependenciesoption in yournext.config.js.next.config.js/**@type{import('next').NextConfig}*/constnextConfig={bundlePagesRouterDependencies:true,}module.exports=nextConfigOpting specific packages out of bundlingIf you have thebundlePagesRouterDependenciesoption enabled, you can opt specific packages out of automatic bundling using theserverExternalPackagesoption in yournext.config.js:next.config.js/**@type{import('next').NextConfig}*/constnextConfig={// Automatically bundle external packages in the Pages Router:bundlePagesRouterDependencies:true,// Opt specific packages out of bundling for both App and Pages Router:serverExternalPackages:['package-name'],}module.exports=nextConfigNext StepsLearn more about optimizing your application for production.Production ChecklistRecommendations to ensure the best performance and user experience before taking your Next.js application to production.PreviousStatic AssetsNextAnalyticsWas this helpful?supported.Send"
analytics,Analytics,"Building Your ApplicationOptimizingAnalyticsAnalyticsNext.js has built-in support for measuring and reporting performance metrics. You can either use theuseReportWebVitalshook to manage reporting yourself, or alternatively, Vercel provides amanaged serviceto automatically collect and visualize metrics for you.Build Your Ownpages/_app.jsimport{ useReportWebVitals }from'next/web-vitals'functionMyApp({ Component,pageProps }) {useReportWebVitals((metric)=>{console.log(metric)})return<Component{...pageProps} />}View theAPI Referencefor more information.Web VitalsWeb Vitalsare a set of useful metrics that aim to capture the user
experience of a web page. The following web vitals are all included:Time to First Byte(TTFB)First Contentful Paint(FCP)Largest Contentful Paint(LCP)First Input Delay(FID)Cumulative Layout Shift(CLS)Interaction to Next Paint(INP)You can handle all the results of these metrics using thenameproperty.pages/_app.jsimport{ useReportWebVitals }from'next/web-vitals'functionMyApp({ Component,pageProps }) {useReportWebVitals((metric)=>{switch(metric.name) {case'FCP': {// handle FCP results}case'LCP': {// handle LCP results}// ...}})return<Component{...pageProps} />}Custom MetricsIn addition to the core metrics listed above, there are some additional custom metrics that
measure the time it takes for the page to hydrate and render:Next.js-hydration: Length of time it takes for the page to start and finish hydrating (in ms)Next.js-route-change-to-render: Length of time it takes for a page to start rendering after a
route change (in ms)Next.js-render: Length of time it takes for a page to finish render after a route change (in ms)You can handle all the results of these metrics separately:exportfunctionreportWebVitals(metric) {switch(metric.name) {case'Next.js-hydration':// handle hydration resultsbreakcase'Next.js-route-change-to-render':// handle route-change to render resultsbreakcase'Next.js-render':// handle render resultsbreakdefault:break}}These metrics work in all browsers that support theUser Timing API.Sending results to external systemsYou can send results to any endpoint to measure and track
real user performance on your site. For example:useReportWebVitals((metric)=>{constbody=JSON.stringify(metric)consturl='https://example.com/analytics'// Use `navigator.sendBeacon()` if available, falling back to `fetch()`.if(navigator.sendBeacon) {navigator.sendBeacon(url,body)}else{fetch(url,{ body,method:'POST',keepalive:true})}})Good to know: If you useGoogle Analytics, using theidvalue can allow you to construct metric distributions manually (to calculate percentiles,
etc.)useReportWebVitals((metric)=>{// Use `window.gtag` if you initialized Google Analytics as this example:// https://github.com/vercel/next.js/blob/canary/examples/with-google-analyticswindow.gtag('event',metric.name,{value:Math.round(metric.name==='CLS'?metric.value*1000:metric.value),// values must be integersevent_label:metric.id,// id unique to current page loadnon_interaction:true,// avoids affecting bounce rate.})})Read more aboutsending results to Google Analytics.PreviousBundlingNextLazy LoadingWas this helpful?supported.Send"
lazy loading,Lazy Loading,"Building Your ApplicationOptimizingLazy LoadingLazy LoadingLazy loadingin Next.js helps improve the initial loading performance of an application by decreasing the amount of JavaScript needed to render a route.It allows you to defer loading ofClient Componentsand imported libraries, and only include them in the client bundle when they're needed. For example, you might want to defer loading a modal until a user clicks to open it.There are two ways you can implement lazy loading in Next.js:UsingDynamic Importswithnext/dynamicUsingReact.lazy()withSuspenseBy default, Server Components are automaticallycode split, and you can usestreamingto progressively send pieces of UI from the server to the client. Lazy loading applies to Client Components.next/dynamicnext/dynamicis a composite ofReact.lazy()andSuspense. It behaves the same way in theappandpagesdirectories to allow for incremental migration.ExamplesBy usingnext/dynamic, the header component will not be included in the page's initial JavaScript bundle. The page will render the Suspensefallbackfirst, followed by theHeadercomponent when theSuspenseboundary is resolved.importdynamicfrom'next/dynamic'constDynamicHeader=dynamic(()=>import('../components/header'),{loading:()=><p>Loading...</p>,})exportdefaultfunctionHome() {return<DynamicHeader/>}Good to know: Inimport('path/to/component'), the path must be explicitly written. It can't be a template string nor a variable. Furthermore theimport()has to be inside thedynamic()call for Next.js to be able to match webpack bundles / module ids to the specificdynamic()call and preload them before rendering.dynamic()can't be used inside of React rendering as it needs to be marked in the top level of the module for preloading to work, similar toReact.lazy.With named exportsTo dynamically import a named export, you can return it from thePromisereturned byimport():components/hello.jsexportfunctionHello() {return<p>Hello!</p>}// pages/index.jsimportdynamicfrom'next/dynamic'constDynamicComponent=dynamic(()=>import('../components/hello').then((mod)=>mod.Hello))With no SSRTo dynamically load a component on the client side, you can use thessroption to disable server-rendering. This is useful if an external dependency or component relies on browser APIs likewindow.'use client'importdynamicfrom'next/dynamic'constDynamicHeader=dynamic(()=>import('../components/header'),{ssr:false,})With external librariesThis example uses the external libraryfuse.jsfor fuzzy search. The module is only loaded in the browser after the user types in the search input.import{ useState }from'react'constnames=['Tim','Joe','Bel','Lee']exportdefaultfunctionPage() {const[results,setResults]=useState()return(<div><inputtype=""text""placeholder=""Search""onChange={async(e)=>{const{value}=e.currentTarget// Dynamically load fuse.jsconstFuse=(awaitimport('fuse.js')).defaultconstfuse=newFuse(names)setResults(fuse.search(value))}}/><pre>Results: {JSON.stringify(results,null,2)}</pre></div>)}PreviousAnalyticsNextInstrumentationWas this helpful?supported.Send"
instrumentation,Instrumentation,"Building Your ApplicationOptimizingInstrumentationInstrumentationInstrumentation is the process of using code to integrate monitoring and logging tools into your application. This allows you to track the performance and behavior of your application, and to debug issues in production.ConventionTo set up instrumentation, createinstrumentation.ts|jsfile in theroot directoryof your project (or inside thesrcfolder if using one).Then, export aregisterfunction in the file. This function will be calledoncewhen a new Next.js server instance is initiated.For example, to use Next.js withOpenTelemetryand@vercel/otel:instrumentation.tsTypeScriptJavaScriptTypeScriptimport{ registerOTel }from'@vercel/otel'exportfunctionregister() {registerOTel('next-app')}See theNext.js with OpenTelemetry examplefor a complete implementation.Good to know:Theinstrumentationfile should be in the root of your project and not inside theapporpagesdirectory. If you're using thesrcfolder, then place the file insidesrcalongsidepagesandapp.If you use thepageExtensionsconfig optionto add a suffix, you will also need to update theinstrumentationfilename to match.ExamplesImporting files with side effectsSometimes, it may be useful to import a file in your code because of the side effects it will cause. For example, you might import a file that defines a set of global variables, but never explicitly use the imported file in your code. You would still have access to the global variables the package has declared.We recommend importing files using JavaScriptimportsyntax within yourregisterfunction. The following example demonstrates a basic usage ofimportin aregisterfunction:instrumentation.tsTypeScriptJavaScriptTypeScriptexportasyncfunctionregister() {awaitimport('package-with-side-effect')}Good to know:We recommend importing the file from within theregisterfunction, rather than at the top of the file. By doing this, you can colocate all of your side effects in one place in your code, and avoid any unintended consequences from importing globally at the top of the file.Importing runtime-specific codeNext.js callsregisterin all environments, so it's important to conditionally import any code that doesn't support specific runtimes (e.g.Edge or Node.js). You can use theNEXT_RUNTIMEenvironment variable to get the current environment:instrumentation.tsTypeScriptJavaScriptTypeScriptexportasyncfunctionregister() {if(process.env.NEXT_RUNTIME==='nodejs') {awaitimport('./instrumentation-node')}if(process.env.NEXT_RUNTIME==='edge') {awaitimport('./instrumentation-edge')}}PreviousLazy LoadingNextOpenTelemetryWas this helpful?supported.Send"
opentelemetry,OpenTelemetry,"Building Your ApplicationOptimizingOpenTelemetryOpenTelemetryObservability is crucial for understanding and optimizing the behavior and performance of your Next.js app.As applications become more complex, it becomes increasingly difficult to identify and diagnose issues that may arise. By leveraging observability tools, such as logging and metrics, developers can gain insights into their application's behavior and identify areas for optimization. With observability, developers can proactively address issues before they become major problems and provide a better user experience. Therefore, it is highly recommended to use observability in your Next.js applications to improve performance, optimize resources, and enhance user experience.We recommend using OpenTelemetry for instrumenting your apps.
It's a platform-agnostic way to instrument apps that allows you to change your observability provider without changing your code.
ReadOfficial OpenTelemetry docsfor more information about OpenTelemetry and how it works.This documentation uses terms likeSpan,TraceorExporterthroughout this doc, all of which can be found inthe OpenTelemetry Observability Primer.Next.js supports OpenTelemetry instrumentation out of the box, which means that we already instrumented Next.js itself.
When you enable OpenTelemetry we will automatically wrap all your code likegetStaticPropsinspanswith helpful attributes.Getting StartedOpenTelemetry is extensible but setting it up properly can be quite verbose.
That's why we prepared a package@vercel/otelthat helps you get started quickly.Using@vercel/otelTo get started, install the following packages:Terminalnpminstall@vercel/otel@opentelemetry/sdk-logs@opentelemetry/api-logs@opentelemetry/instrumentationNext, create a custominstrumentation.ts(or.js) file in theroot directoryof the project (or insidesrcfolder if using one):your-project/instrumentation.tsTypeScriptJavaScriptTypeScriptimport{ registerOTel }from'@vercel/otel'exportfunctionregister() {registerOTel({ serviceName:'next-app'})}See the@vercel/oteldocumentationfor additional configuration options.Good to know:Theinstrumentationfile should be in the root of your project and not inside theapporpagesdirectory. If you're using thesrcfolder, then place the file insidesrcalongsidepagesandapp.If you use thepageExtensionsconfig optionto add a suffix, you will also need to update theinstrumentationfilename to match.We have created a basicwith-opentelemetryexample that you can use.Manual OpenTelemetry configurationThe@vercel/otelpackage provides many configuration options and should serve most of common use cases. But if it doesn't suit your needs, you can configure OpenTelemetry manually.Firstly you need to install OpenTelemetry packages:Terminalnpminstall@opentelemetry/sdk-node@opentelemetry/resources@opentelemetry/semantic-conventions@opentelemetry/sdk-trace-node@opentelemetry/exporter-trace-otlp-httpNow you can initializeNodeSDKin yourinstrumentation.ts.
Unlike@vercel/otel,NodeSDKis not compatible with edge runtime, so you need to make sure that you are importing them only whenprocess.env.NEXT_RUNTIME === 'nodejs'. We recommend creating a new fileinstrumentation.node.tswhich you conditionally import only when using node:instrumentation.tsTypeScriptJavaScriptTypeScriptexportasyncfunctionregister() {if(process.env.NEXT_RUNTIME==='nodejs') {awaitimport('./instrumentation.node.ts')}}instrumentation.node.tsTypeScriptJavaScriptTypeScriptimport{ OTLPTraceExporter }from'@opentelemetry/exporter-trace-otlp-http'import{ Resource }from'@opentelemetry/resources'import{ NodeSDK }from'@opentelemetry/sdk-node'import{ SimpleSpanProcessor }from'@opentelemetry/sdk-trace-node'import{ ATTR_SERVICE_NAME }from'@opentelemetry/semantic-conventions'constsdk=newNodeSDK({resource:newResource({[ATTR_SERVICE_NAME]:'next-app',}),spanProcessor:newSimpleSpanProcessor(newOTLPTraceExporter()),})sdk.start()Doing this is equivalent to using@vercel/otel, but it's possible to modify and extend some features that are not exposed by the@vercel/otel. If edge runtime support is necessary, you will have to use@vercel/otel.Testing your instrumentationYou need an OpenTelemetry collector with a compatible backend to test OpenTelemetry traces locally.
We recommend using ourOpenTelemetry dev environment.If everything works well you should be able to see the root server span labeled asGET /requested/pathname.
All other spans from that particular trace will be nested under it.Next.js traces more spans than are emitted by default.
To see more spans, you must setNEXT_OTEL_VERBOSE=1.DeploymentUsing OpenTelemetry CollectorWhen you are deploying with OpenTelemetry Collector, you can use@vercel/otel.
It will work both on Vercel and when self-hosted.Deploying on VercelWe made sure that OpenTelemetry works out of the box on Vercel.FollowVercel documentationto connect your project to an observability provider.Self-hostingDeploying to other platforms is also straightforward. You will need to spin up your own OpenTelemetry Collector to receive and process the telemetry data from your Next.js app.To do this, follow theOpenTelemetry Collector Getting Started guide, which will walk you through setting up the collector and configuring it to receive data from your Next.js app.Once you have your collector up and running, you can deploy your Next.js app to your chosen platform following their respective deployment guides.Custom ExportersOpenTelemetry Collector is not necessary. You can use a custom OpenTelemetry exporter with@vercel/otelormanual OpenTelemetry configuration.Custom SpansYou can add a custom span withOpenTelemetry APIs.Terminalnpminstall@opentelemetry/apiThe following example demonstrates a function that fetches GitHub stars and adds a customfetchGithubStarsspan to track the fetch request's result:import{ trace }from'@opentelemetry/api'exportasyncfunctionfetchGithubStars() {returnawaittrace.getTracer('nextjs-example').startActiveSpan('fetchGithubStars',async(span)=>{try{returnawaitgetValue()}finally{span.end()}})}Theregisterfunction will execute before your code runs in a new environment.
You can start creating new spans, and they should be correctly added to the exported trace.Default Spans in Next.jsNext.js automatically instruments several spans for you to provide useful insights into your application's performance.Attributes on spans followOpenTelemetry semantic conventions. We also add some custom attributes under thenextnamespace:next.span_name- duplicates span namenext.span_type- each span type has a unique identifiernext.route- The route pattern of the request (e.g.,/[param]/user).next.rsc(true/false) - Whether the request is an RSC request, such as prefetch.next.pageThis is an internal value used by an app router.You can think about it as a route to a special file (likepage.ts,layout.ts,loading.tsand others)It can be used as a unique identifier only when paired withnext.routebecause/layoutcan be used to identify both/(groupA)/layout.tsand/(groupB)/layout.ts[http.method] [next.route]next.span_type:BaseServer.handleRequestThis span represents the root span for each incoming request to your Next.js application. It tracks the HTTP method, route, target, and status code of the request.Attributes:Common HTTP attributeshttp.methodhttp.status_codeServer HTTP attributeshttp.routehttp.targetnext.span_namenext.span_typenext.routerender route (app) [next.route]next.span_type:AppRender.getBodyResult.This span represents the process of rendering a route in the app router.Attributes:next.span_namenext.span_typenext.routefetch [http.method] [http.url]next.span_type:AppRender.fetchThis span represents the fetch request executed in your code.Attributes:Common HTTP attributeshttp.methodClient HTTP attributeshttp.urlnet.peer.namenet.peer.port(only if specified)next.span_namenext.span_typeThis span can be turned off by settingNEXT_OTEL_FETCH_DISABLED=1in your environment. This is useful when you want to use a custom fetch instrumentation library.executing api route (app) [next.route]next.span_type:AppRouteRouteHandlers.runHandler.This span represents the execution of an API Route Handler in the app router.Attributes:next.span_namenext.span_typenext.routegetServerSideProps [next.route]next.span_type:Render.getServerSideProps.This span represents the execution ofgetServerSidePropsfor a specific route.Attributes:next.span_namenext.span_typenext.routegetStaticProps [next.route]next.span_type:Render.getStaticProps.This span represents the execution ofgetStaticPropsfor a specific route.Attributes:next.span_namenext.span_typenext.routerender route (pages) [next.route]next.span_type:Render.renderDocument.This span represents the process of rendering the document for a specific route.Attributes:next.span_namenext.span_typenext.routegenerateMetadata [next.page]next.span_type:ResolveMetadata.generateMetadata.This span represents the process of generating metadata for a specific page (a single route can have multiple of these spans).Attributes:next.span_namenext.span_typenext.pageresolve page componentsnext.span_type:NextNodeServer.findPageComponents.This span represents the process of resolving page components for a specific page.Attributes:next.span_namenext.span_typenext.routeresolve segment modulesnext.span_type:NextNodeServer.getLayoutOrPageModule.This span represents loading of code modules for a layout or a page.Attributes:next.span_namenext.span_typenext.segmentstart responsenext.span_type:NextNodeServer.startResponse.This zero-length span represents the time when the first byte has been sent in the response.PreviousInstrumentationNextThird Party LibrariesWas this helpful?supported.Send"
third party libraries,Third Party Libraries,"Building Your ApplicationOptimizingThird Party LibrariesThird Party Libraries@next/third-partiesis a library that provides a collection of components and utilities that improve the performance and developer experience of loading popular third-party libraries in your Next.js application.All third-party integrations provided by@next/third-partieshave been optimized for performance and ease of use.Getting StartedTo get started, install the@next/third-partieslibrary:Terminalnpminstall@next/third-parties@latestnext@latest@next/third-partiesis currently anexperimentallibrary under active development. We recommend installing it with thelatestorcanaryflags while we work on adding more third-party integrations.Google Third-PartiesAll supported third-party libraries from Google can be imported from@next/third-parties/google.Google Tag ManagerTheGoogleTagManagercomponent can be used to instantiate aGoogle Tag Managercontainer to your page. By default, it fetches the original inline script after hydration occurs on the page.To load Google Tag Manager for all routes, include the component directly in your custom_appand
pass in your GTM container ID:pages/_app.jsimport{ GoogleTagManager }from'@next/third-parties/google'exportdefaultfunctionMyApp({ Component,pageProps }) {return(<><Component{...pageProps} /><GoogleTagManagergtmId=""GTM-XYZ""/></>)}To load Google Tag Manager for a single route, include the component in your page file:pages/index.jsimport{ GoogleTagManager }from'@next/third-parties/google'exportdefaultfunctionPage() {return<GoogleTagManagergtmId=""GTM-XYZ""/>}Sending EventsThesendGTMEventfunction can be used to track user interactions on your page by sending events
using thedataLayerobject. For this function to work, the<GoogleTagManager />component must be
included in either a parent layout, page, or component, or directly in the same file.pages/index.jsimport{ sendGTMEvent }from'@next/third-parties/google'exportfunctionEventButton() {return(<div><buttononClick={()=>sendGTMEvent({ event:'buttonClicked',value:'xyz'})}>Send Event</button></div>)}Refer to the Tag Managerdeveloper
documentationto learn about the
different variables and events that can be passed into the function.Server-side TaggingIf you're using a server-side tag manager and servinggtm.jsscripts from your tagging server you can
usegtmScriptUrloption to specify the URL of the script.OptionsOptions to pass to the Google Tag Manager. For a full list of options, read theGoogle Tag Manager
docs.NameTypeDescriptiongtmIdRequiredYour GTM container ID. Usually starts withGTM-.gtmScriptUrlOptionalGTM script URL. Defaults tohttps://www.googletagmanager.com/gtm.js.dataLayerOptionalData layer object to instantiate the container with.dataLayerNameOptionalName of the data layer. Defaults todataLayer.authOptionalValue of authentication parameter (gtm_auth) for environment snippets.previewOptionalValue of preview parameter (gtm_preview) for environment snippets.Google AnalyticsTheGoogleAnalyticscomponent can be used to includeGoogle Analytics
4to your page via the Google tag
(gtag.js). By default, it fetches the original scripts after hydration occurs on the page.Recommendation: If Google Tag Manager is already included in your application, you can
configure Google Analytics directly using it, rather than including Google Analytics as a separate
component. Refer to thedocumentationto learn more about the differences between Tag Manager andgtag.js.To load Google Analytics for all routes, include the component directly in your custom_appand
pass in your measurement ID:pages/_app.jsimport{ GoogleAnalytics }from'@next/third-parties/google'exportdefaultfunctionMyApp({ Component,pageProps }) {return(<><Component{...pageProps} /><GoogleAnalyticsgaId=""G-XYZ""/></>)}To load Google Analytics for a single route, include the component in your page file:pages/index.jsimport{ GoogleAnalytics }from'@next/third-parties/google'exportdefaultfunctionPage() {return<GoogleAnalyticsgaId=""G-XYZ""/>}Sending EventsThesendGAEventfunction can be used to measure user interactions on your page by sending events
using thedataLayerobject. For this function to work, the<GoogleAnalytics />component must be
included in either a parent layout, page, or component, or directly in the same file.pages/index.jsimport{ sendGAEvent }from'@next/third-parties/google'exportfunctionEventButton() {return(<div><buttononClick={()=>sendGAEvent('event','buttonClicked',{ value:'xyz'})}>Send Event</button></div>)}Refer to the Google Analyticsdeveloper
documentationto learn
more about event parameters.Tracking PageviewsGoogle Analytics automatically tracks pageviews when the browser history state changes. This means
that client-side navigations between Next.js routes will send pageview data without any configuration.To ensure that client-side navigations are being measured correctly, verify that the“Enhanced
Measurement”property is
enabled in your Admin panel and the“Page changes based on browser history events”checkbox is
selected.Note: If you decide to manually send pageview events, make sure to disable the default
pageview measurement to avoid having duplicate data. Refer to the Google Analyticsdeveloper
documentationto learn more.OptionsOptions to pass to the<GoogleAnalytics>component.NameTypeDescriptiongaIdRequiredYourmeasurement ID. Usually starts withG-.dataLayerNameOptionalName of the data layer. Defaults todataLayer.nonceOptionalAnonce.Google Maps EmbedTheGoogleMapsEmbedcomponent can be used to add aGoogle Maps
Embedto your page. By
default, it uses theloadingattribute to lazy-load the embed below the fold.pages/index.jsimport{ GoogleMapsEmbed }from'@next/third-parties/google'exportdefaultfunctionPage() {return(<GoogleMapsEmbedapiKey=""XYZ""height={200}width=""100%""mode=""place""q=""Brooklyn+Bridge,New+York,NY""/>)}OptionsOptions to pass to the Google Maps Embed. For a full list of options, read theGoogle Map Embed
docs.NameTypeDescriptionapiKeyRequiredYour api key.modeRequiredMap modeheightOptionalHeight of the embed. Defaults toauto.widthOptionalWidth of the embed. Defaults toauto.styleOptionalPass styles to the iframe.allowfullscreenOptionalProperty to allow certain map parts to go full screen.loadingOptionalDefaults to lazy. Consider changing if you know your embed will be above the fold.qOptionalDefines map marker location.This may be required depending on the map mode.centerOptionalDefines the center of the map view.zoomOptionalSets initial zoom level of the map.maptypeOptionalDefines type of map tiles to load.languageOptionalDefines the language to use for UI elements and for the display of labels on map tiles.regionOptionalDefines the appropriate borders and labels to display, based on geo-political sensitivities.YouTube EmbedTheYouTubeEmbedcomponent can be used to load and display a YouTube embed. This component loads
faster by usinglite-youtube-embedunder the
hood.pages/index.jsimport{ YouTubeEmbed }from'@next/third-parties/google'exportdefaultfunctionPage() {return<YouTubeEmbedvideoid=""ogfYd705cRs""height={400}params=""controls=0""/>}OptionsNameTypeDescriptionvideoidRequiredYouTube video id.widthOptionalWidth of the video container. Defaults toautoheightOptionalHeight of the video container. Defaults toautoplaylabelOptionalA visually hidden label for the play button for accessibility.paramsOptionalThe video player params definedhere.Params are passed as a query param string.Eg:params=""controls=0&start=10&end=30""styleOptionalUsed to apply styles to the video container.PreviousOpenTelemetryNextConfiguringWas this helpful?supported.Send"
configuring,Configuring,"Pages RouterBuilding Your ApplicationConfiguringConfiguringNext.js allows you to customize your project to meet specific requirements. This includes integrations with TypeScript, ESlint, and more, as well as internal configuration options such as Absolute Imports and Environment Variables.Environment VariablesLearn to add and access environment variables in your Next.js application.src DirectorySave pages under the `src` directory as an alternative to the root `pages` directory.MDXLearn how to configure MDX to write JSX in your markdown files.AMPWith minimal config, and without leaving React, you can start adding AMP and improve the performance and speed of your pages.BabelExtend the babel preset added by Next.js with your own configs.PostCSSExtend the PostCSS config and plugins added by Next.js with your own.Custom ServerStart a Next.js app programmatically using a custom server.Draft ModeNext.js has draft mode to toggle between static and dynamic pages. You can learn how it works with Pages Router.Error HandlingHandle errors in your Next.js app.Preview ModeNext.js has the preview mode for statically generated pages. You can learn how it works here.Content Security PolicyLearn how to set a Content Security Policy (CSP) for your Next.js application.DebuggingLearn how to debug your Next.js application with VS Code or Chrome DevTools.PreviousThird Party LibrariesNextEnvironment VariablesWas this helpful?supported.Send"
environment variables,Environment Variables,"Building Your ApplicationConfiguringEnvironment VariablesEnvironment VariablesExamplesEnvironment VariablesNext.js comes with built-in support for environment variables, which allows you to do the following:Use.envto load environment variablesBundle environment variables for the browser by prefixing withNEXT_PUBLIC_Warning:The defaultcreate-next-apptemplate ensures all.envfiles are added to your.gitignore. You almost never want to commit these files to your repository.Loading Environment VariablesNext.js has built-in support for loading environment variables from.env*files intoprocess.env..envDB_HOST=localhostDB_USER=myuserDB_PASS=mypasswordThis loadsprocess.env.DB_HOST,process.env.DB_USER, andprocess.env.DB_PASSinto the Node.js environment automatically allowing you to use them inNext.js data fetching methodsandAPI routes.For example, usinggetStaticProps:pages/index.jsexportasyncfunctiongetStaticProps() {constdb=awaitmyDB.connect({host:process.env.DB_HOST,username:process.env.DB_USER,password:process.env.DB_PASS,})// ...}Loading Environment Variables with@next/envIf you need to load environment variables outside of the Next.js runtime, such as in a root config file for an ORM or test runner, you can use the@next/envpackage.This package is used internally by Next.js to load environment variables from.env*files.To use it, install the package and use theloadEnvConfigfunction to load the environment variables:npminstall@next/envenvConfig.tsTypeScriptJavaScriptTypeScriptimport{ loadEnvConfig }from'@next/env'constprojectDir=process.cwd()loadEnvConfig(projectDir)Then, you can import the configuration where needed. For example:orm.config.tsTypeScriptJavaScriptTypeScriptimport'./envConfig.ts'exportdefaultdefineConfig({dbCredentials:{connectionString:process.env.DATABASE_URL!,},})Referencing Other VariablesNext.js will automatically expand variables that use$to reference other variables e.g.$VARIABLEinside of your.env*files. This allows you to reference other secrets. For example:.envTWITTER_USER=nextjsTWITTER_URL=https://x.com/$TWITTER_USERIn the above example,process.env.TWITTER_URLwould be set tohttps://x.com/nextjs.Good to know: If you need to use variable with a$in the actual value, it needs to be escaped e.g.\$.Bundling Environment Variables for the BrowserNon-NEXT_PUBLIC_environment variables are only available in the Node.js environment, meaning they aren't accessible to the browser (the client runs in a differentenvironment).In order to make the value of an environment variable accessible in the browser, Next.js can ""inline"" a value, at build time, into the js bundle that is delivered to the client, replacing all references toprocess.env.[variable]with a hard-coded value. To tell it to do this, you just have to prefix the variable withNEXT_PUBLIC_. For example:TerminalNEXT_PUBLIC_ANALYTICS_ID=abcdefghijkThis will tell Next.js to replace all references toprocess.env.NEXT_PUBLIC_ANALYTICS_IDin the Node.js environment with the value from the environment in which you runnext build, allowing you to use it anywhere in your code. It will be inlined into any JavaScript sent to the browser.Note: After being built, your app will no longer respond to changes to these environment variables. For instance, if you use a Heroku pipeline to promote slugs built in one environment to another environment, or if you build and deploy a single Docker image to multiple environments, allNEXT_PUBLIC_variables will be frozen with the value evaluated at build time, so these values need to be set appropriately when the project is built. If you need access to runtime environment values, you'll have to setup your own API to provide them to the client (either on demand or during initialization).pages/index.jsimportsetupAnalyticsServicefrom'../lib/my-analytics-service'// 'NEXT_PUBLIC_ANALYTICS_ID' can be used here as it's prefixed by 'NEXT_PUBLIC_'.// It will be transformed at build time to `setupAnalyticsService('abcdefghijk')`.setupAnalyticsService(process.env.NEXT_PUBLIC_ANALYTICS_ID)functionHomePage() {return<h1>Hello World</h1>}exportdefaultHomePageNote that dynamic lookups willnotbe inlined, such as:// This will NOT be inlined, because it uses a variableconstvarName='NEXT_PUBLIC_ANALYTICS_ID'setupAnalyticsService(process.env[varName])// This will NOT be inlined, because it uses a variableconstenv=process.envsetupAnalyticsService(env.NEXT_PUBLIC_ANALYTICS_ID)Runtime Environment VariablesNext.js can support both build time and runtime environment variables.By default, environment variables are only available on the server. To expose an environment variable to the browser, it must be prefixed withNEXT_PUBLIC_. However, these public environment variables will be inlined into the JavaScript bundle duringnext build.To read runtime environment variables, we recommend usinggetServerSidePropsorincrementally adopting the App Router.This allows you to use a singular Docker image that can be promoted through multiple environments with different values.Good to know:You can run code on server startup using theregisterfunction.We do not recommend using theruntimeConfigoption, as this does not work with the standalone output mode. Instead, we recommendincrementally adoptingthe App Router if you need this feature.Environment Variables on VercelWhen deploying your Next.js application toVercel, Environment Variables can be configuredin the Project Settings.All types of Environment Variables should be configured there. Even Environment Variables used in Development – which can bedownloaded onto your local deviceafterwards.If you've configuredDevelopment Environment Variablesyou can pull them into a.env.localfor usage on your local machine using the following command:TerminalvercelenvpullGood to know: When deploying your Next.js application toVercel, your environment variables in.env*files will not be made available to Edge Runtime, unless their name are prefixed withNEXT_PUBLIC_. We strongly recommend managing your environment variables inProject Settingsinstead, from where all environment variables are available.Test Environment VariablesApart fromdevelopmentandproductionenvironments, there is a 3rd option available:test. In the same way you can set defaults for development or production environments, you can do the same with a.env.testfile for thetestingenvironment (though this one is not as common as the previous two). Next.js will not load environment variables from.env.developmentor.env.productionin thetestingenvironment.This one is useful when running tests with tools likejestorcypresswhere you need to set specific environment vars only for testing purposes. Test default values will be loaded ifNODE_ENVis set totest, though you usually don't need to do this manually as testing tools will address it for you.There is a small difference betweentestenvironment, and bothdevelopmentandproductionthat you need to bear in mind:.env.localwon't be loaded, as you expect tests to produce the same results for everyone. This way every test execution will use the same env defaults across different executions by ignoring your.env.local(which is intended to override the default set).Good to know: similar to Default Environment Variables,.env.testfile should be included in your repository, but.env.test.localshouldn't, as.env*.localare intended to be ignored through.gitignore.While running unit tests you can make sure to load your environment variables the same way Next.js does by leveraging theloadEnvConfigfunction from the@next/envpackage.// The below can be used in a Jest global setup file or similar for your testing set-upimport{ loadEnvConfig }from'@next/env'exportdefaultasync()=>{constprojectDir=process.cwd()loadEnvConfig(projectDir)}Environment Variable Load OrderEnvironment variables are looked up in the following places, in order, stopping once the variable is found.process.env.env.$(NODE_ENV).local.env.local(Not checked whenNODE_ENVistest.).env.$(NODE_ENV).envFor example, ifNODE_ENVisdevelopmentand you define a variable in both.env.development.localand.env, the value in.env.development.localwill be used.Good to know: The allowed values forNODE_ENVareproduction,developmentandtest.Good to knowIf you are using a/srcdirectory,.env.*files should remain in the root of your project.If the environment variableNODE_ENVis unassigned, Next.js automatically assignsdevelopmentwhen running thenext devcommand, orproductionfor all other commands.Version HistoryVersionChangesv9.4.0Support.envandNEXT_PUBLIC_introduced.PreviousConfiguringNextsrc DirectoryWas this helpful?supported.Send"
src directory,src Directory,"Building Your ApplicationConfiguringsrc Directorysrc DirectoryAs an alternative to having the special Next.jsapporpagesdirectories in the root of your project, Next.js also supports the common pattern of placing application code under thesrcdirectory.This separates application code from project configuration files which mostly live in the root of a project, which is preferred by some individuals and teams.To use thesrcdirectory, move theappRouter folder orpagesRouter folder tosrc/apporsrc/pagesrespectively.Good to know:The/publicdirectory should remain in the root of your project.Config files likepackage.json,next.config.jsandtsconfig.jsonshould remain in the root of your project..env.*files should remain in the root of your project.src/apporsrc/pageswill be ignored ifapporpagesare present in the root directory.If you're usingsrc, you'll probably also move other application folders such as/componentsor/lib.If you're using Middleware, ensure it is placed inside thesrcdirectory.If you're using Tailwind CSS, you'll need to add the/srcprefix to thetailwind.config.jsfile in thecontent section.If you are using TypeScript paths for imports such as@/*, you should update thepathsobject intsconfig.jsonto includesrc/.PreviousEnvironment VariablesNextMDXWas this helpful?supported.Send"
mdx,MDX,"Building Your ApplicationConfiguringMDXMarkdown and MDXMarkdownis a lightweight markup language used to format text. It allows you to write using plain text syntax and convert it to structurally valid HTML. It's commonly used for writing content on websites and blogs.You write...I**love**using[Next.js](https://nextjs.org/)Output:<p>I <strong>love</strong> using <ahref=""https://nextjs.org/"">Next.js</a></p>MDXis a superset of markdown that lets you writeJSXdirectly in your markdown files. It is a powerful way to add dynamic interactivity and embed React components within your content.Next.js can support both local MDX content inside your application, as well as remote MDX files fetched dynamically on the server. The Next.js plugin handles transforming markdown and React components into HTML, including support for usage in Server Components (the default in App Router).Good to know: View thePortfolio Starter Kittemplate for a complete working example.Install dependenciesThe@next/mdxpackage, and related packages, are used to configure Next.js so it can process markdown and MDX.It sources data from local files, allowing you to create pages with a.mdor.mdxextension, directly in your/pagesor/appdirectory.Install these packages to render MDX with Next.js:Terminalnpminstall@next/mdx@mdx-js/loader@mdx-js/react@types/mdxConfigurenext.config.mjsUpdate thenext.config.mjsfile at your project's root to configure it to use MDX:next.config.mjsimportcreateMDXfrom'@next/mdx'/**@type{import('next').NextConfig}*/constnextConfig={// Configure `pageExtensions` to include markdown and MDX filespageExtensions:['js','jsx','md','mdx','ts','tsx'],// Optionally, add any other Next.js config below}constwithMDX=createMDX({// Add markdown plugins here, as desired})// Merge MDX config with Next.js configexportdefaultwithMDX(nextConfig)This allows.mdand.mdxfiles to act as pages, routes, or imports in your application.Add anmdx-components.tsxfileCreate anmdx-components.tsx(or.js) file in the root of your project to define global MDX Components. For example, at the same level aspagesorapp, or insidesrcif applicable.mdx-components.tsxTypeScriptJavaScriptTypeScriptimporttype{ MDXComponents }from'mdx/types'exportfunctionuseMDXComponents(components:MDXComponents):MDXComponents{return{...components,}}Good to know:mdx-components.tsxisrequiredto use@next/mdxwith App Router and will not work without it.Learn more about themdx-components.tsxfile convention.Learn how touse custom styles and components.Rendering MDXYou can render MDX using Next.js's file based routing or by importing MDX files into other pages.Using file based routingWhen using file based routing, you can use MDX pages like any other page.Create a new MDX page within the/pagesdirectory:my-project|── mdx-components.(tsx/js)├── pages│   └── mdx-page.(mdx/md)└── package.jsonYou can use MDX in these files, and even import React components, directly inside your MDX page:import{ MyComponent }from'my-component'# Welcome to myMDXpage!This is some**bold**and _italics_ text.This is a listinmarkdown:-One-Two-ThreeCheckout my React component:<MyComponent/>Navigating to the/mdx-pageroute should display your rendered MDX page.Using importsCreate a new page within the/pagesdirectory and an MDX file wherever you'd like:my-project├── pages│   └── mdx-page.(tsx/js)├── markdown│   └── welcome.(mdx/md)|── mdx-components.(tsx/js)└── package.jsonYou can use MDX in these files, and even import React components, directly inside your MDX page:Import the MDX file inside the page to display the content:pages/mdx-page.tsxTypeScriptJavaScriptTypeScriptimportWelcomefrom'@/markdown/welcome.mdx'exportdefaultfunctionPage() {return<Welcome/>}Navigating to the/mdx-pageroute should display your rendered MDX page.Using custom styles and componentsMarkdown, when rendered, maps to native HTML elements. For example, writing the following markdown:## This is a headingThis is a list in markdown:- One- Two- ThreeGenerates the following HTML:<h2>This is a heading</h2><p>This is a list in markdown:</p><ul><li>One</li><li>Two</li><li>Three</li></ul>To style your markdown, you can provide custom components that map to the generated HTML elements. Styles and components can be implemented globally, locally, and with shared layouts.Global styles and componentsAdding styles and components inmdx-components.tsxwill affectallMDX files in your application.mdx-components.tsxTypeScriptJavaScriptTypeScriptimporttype{ MDXComponents }from'mdx/types'importImage,{ ImageProps }from'next/image'// This file allows you to provide custom React components// to be used in MDX files. You can import and use any// React component you want, including inline styles,// components from other libraries, and more.exportfunctionuseMDXComponents(components:MDXComponents):MDXComponents{return{// Allows customizing built-in components, e.g. to add styling.h1:({ children })=>(<h1style={{ color:'red',fontSize:'48px'}}>{children}</h1>),img:(props)=>(<Imagesizes=""100vw""style={{ width:'100%',height:'auto'}}{...(propsasImageProps)}/>),...components,}}Local styles and componentsYou can apply local styles and components to specific pages by passing them into imported MDX components. These will merge with and overrideglobal styles and components.pages/mdx-page.tsxTypeScriptJavaScriptTypeScriptimportWelcomefrom'@/markdown/welcome.mdx'functionCustomH1({ children }) {return<h1style={{ color:'blue',fontSize:'100px'}}>{children}</h1>}constoverrideComponents={h1:CustomH1,}exportdefaultfunctionPage() {return<Welcomecomponents={overrideComponents} />}Shared layoutsTo share a layout around MDX pages, create a layout component:components/mdx-layout.tsxTypeScriptJavaScriptTypeScriptexportdefaultfunctionMdxLayout({ children }:{ children:React.ReactNode}) {// Create any shared layout or styles herereturn<divstyle={{ color:'blue'}}>{children}</div>}Then, import the layout component into the MDX page, wrap the MDX content in the layout, and export it:importMdxLayoutfrom'../components/mdx-layout'# Welcome to myMDXpage!exportdefaultfunctionMDXPage({ children }) {return<MdxLayout>{children}</MdxLayout>}Using Tailwind typography pluginIf you are usingTailwindto style your application, using the@tailwindcss/typographypluginwill allow you to reuse your Tailwind configuration and styles in your markdown files.The plugin adds a set ofproseclasses that can be used to add typographic styles to content blocks that come from sources, like markdown.Install Tailwind typographyand use withshared layoutsto add theproseyou want.To share a layout around MDX pages, create a layout component:components/mdx-layout.tsxTypeScriptJavaScriptTypeScriptexportdefaultfunctionMdxLayout({ children }:{ children:React.ReactNode}) {// Create any shared layout or styles herereturn(<divclassName=""prose prose-headings:mt-8 prose-headings:font-semibold prose-headings:text-black prose-h1:text-5xl prose-h2:text-4xl prose-h3:text-3xl prose-h4:text-2xl prose-h5:text-xl prose-h6:text-lg dark:prose-headings:text-white"">{children}</div>)}Then, import the layout component into the MDX page, wrap the MDX content in the layout, and export it:importMdxLayoutfrom'../components/mdx-layout'# Welcome to myMDXpage!exportdefaultfunctionMDXPage({ children }) {return<MdxLayout>{children}</MdxLayout>}FrontmatterFrontmatter is a YAML like key/value pairing that can be used to store data about a page.@next/mdxdoesnotsupport frontmatter by default, though there are many solutions for adding frontmatter to your MDX content, such as:remark-frontmatterremark-mdx-frontmattergray-matter@next/mdxdoesallow you to use exports like any other JavaScript component:Metadata can now be referenced outside of the MDX file:pages/blog.tsxTypeScriptJavaScriptTypeScriptimportBlogPost,{ metadata }from'@/content/blog-post.mdx'exportdefaultfunctionPage() {console.log('metadata: ',metadata)//=> { author: 'John Doe' }return<BlogPost/>}A common use case for this is when you want to iterate over a collection of MDX and extract data. For example, creating a blog index page from all blog posts. You can use packages likeNode'sfsmoduleorglobbyto read a directory of posts and extract the metadata.Good to know:Usingfs,globby, etc. can only be used server-side.View thePortfolio Starter Kittemplate for a complete working example.remark and rehype PluginsYou can optionally provide remark and rehype plugins to transform the MDX content.For example, you can useremark-gfmto support GitHub Flavored Markdown.Since the remark and rehype ecosystem is ESM only, you'll need to usenext.config.mjsornext.config.tsas the configuration file.next.config.mjsimportremarkGfmfrom'remark-gfm'importcreateMDXfrom'@next/mdx'/**@type{import('next').NextConfig}*/constnextConfig={// Allow .mdx extensions for filespageExtensions:['js','jsx','md','mdx','ts','tsx'],// Optionally, add any other Next.js config below}constwithMDX=createMDX({// Add markdown plugins here, as desiredoptions:{remarkPlugins:[remarkGfm],rehypePlugins:[],},})// Combine MDX and Next.js configexportdefaultwithMDX(nextConfig)Using Plugins with TurbopackTo use plugins withTurbopack, upgrade to the latest@next/mdxand specify plugin names using a string:next.config.mjsimportcreateMDXfrom'@next/mdx'/**@type{import('next').NextConfig}*/constnextConfig={pageExtensions:['js','jsx','md','mdx','ts','tsx'],}constwithMDX=createMDX({options:{remarkPlugins:[],rehypePlugins:[['rehype-katex',{ strict:true,throwOnError:true}]],},})exportdefaultwithMDX(nextConfig)Good to know:remark and rehype plugins without serializable options cannot be used yet withTurbopack, due toinability to pass JavaScript functions to RustRemote MDXIf your MDX files or content livessomewhere else, you can fetch it dynamically on the server. This is useful for content stored in a CMS, database, or anywhere else. A popular community package for this use isnext-mdx-remote.Good to know: Please proceed with caution. MDX compiles to JavaScript and is executed on the server. You should only fetch MDX content from a trusted source, otherwise this can lead to remote code execution (RCE).The following example usesnext-mdx-remote:pages/mdx-page-remote.tsxTypeScriptJavaScriptTypeScriptimport{ serialize }from'next-mdx-remote/serialize'import{ MDXRemote,MDXRemoteSerializeResult }from'next-mdx-remote'interfaceProps{mdxSource:MDXRemoteSerializeResult}exportdefaultfunctionRemoteMdxPage({ mdxSource }:Props) {return<MDXRemote{...mdxSource} />}exportasyncfunctiongetStaticProps() {// MDX text - can be from a database, CMS, fetch, anywhere...constres=awaitfetch('https:...')constmdxText=awaitres.text()constmdxSource=awaitserialize(mdxText)return{ props:{ mdxSource } }}Navigating to the/mdx-page-remoteroute should display your rendered MDX.Deep Dive: How do you transform markdown into HTML?React does not natively understand markdown. The markdown plaintext needs to first be transformed into HTML. This can be accomplished withremarkandrehype.remarkis an ecosystem of tools around markdown.rehypeis the same, but for HTML. For example, the following code snippet transforms markdown into HTML:import{ unified }from'unified'importremarkParsefrom'remark-parse'importremarkRehypefrom'remark-rehype'importrehypeSanitizefrom'rehype-sanitize'importrehypeStringifyfrom'rehype-stringify'main()asyncfunctionmain() {constfile=awaitunified().use(remarkParse)// Convert into markdown AST.use(remarkRehype)// Transform to HTML AST.use(rehypeSanitize)// Sanitize HTML input.use(rehypeStringify)// Convert AST into serialized HTML.process('Hello, Next.js!')console.log(String(file))// <p>Hello, Next.js!</p>}Theremarkandrehypeecosystem contains plugins forsyntax highlighting,linking headings,generating a table of contents, and more.When using@next/mdxas shown above, youdo notneed to useremarkorrehypedirectly, as it is handled for you. We're describing it here for a deeper understanding of what the@next/mdxpackage is doing underneath.Using the Rust-based MDX compiler (experimental)Next.js supports a new MDX compiler written in Rust. This compiler is still experimental and is not recommended for production use. To use the new compiler, you need to configurenext.config.jswhen you pass it towithMDX:next.config.jsmodule.exports=withMDX({experimental:{mdxRs:true,},})mdxRsalso accepts an object to configure how to transform mdx files.next.config.jsmodule.exports=withMDX({experimental:{mdxRs:{jsxRuntime?:string// Custom jsx runtimejsxImportSource?:string// Custom jsx import source,mdxType?:'gfm'|'commonmark'// Configure what kind of mdx syntax will be used to parse & transform},},})Helpful LinksMDX@next/mdxremarkrehypeMarkdocPrevioussrc DirectoryNextAMPWas this helpful?supported.Send"
amp,AMP,"Building Your ApplicationConfiguringAMPAMPExamplesAMPWith Next.js you can turn any React page into an AMP page, with minimal config, and without leaving React.You can read more about AMP in the officialamp.devsite.Enabling AMPTo enable AMP support for a page, and to learn more about the different AMP configs, read theAPI documentation fornext/amp.CaveatsOnly CSS-in-JS is supported.CSS Modulesaren't supported by AMP pages at the moment. You cancontribute CSS Modules support to Next.js.Adding AMP ComponentsThe AMP community providesmany componentsto make AMP pages more interactive. Next.js will automatically import all components used on a page and there is no need to manually import AMP component scripts:exportconstconfig={ amp:true}functionMyAmpPage() {constdate=newDate()return(<div><p>Some time: {date.toJSON()}</p><amp-timeagowidth=""0""height=""15""datetime={date.toJSON()}layout=""responsive"">.</amp-timeago></div>)}exportdefaultMyAmpPageThe above example uses theamp-timeagocomponent.By default, the latest version of a component is always imported. If you want to customize the version, you can usenext/head, as in the following example:importHeadfrom'next/head'exportconstconfig={ amp:true}functionMyAmpPage() {constdate=newDate()return(<div><Head><scriptasynckey=""amp-timeago""custom-element=""amp-timeago""src=""https://cdn.ampproject.org/v0/amp-timeago-0.1.js""/></Head><p>Some time: {date.toJSON()}</p><amp-timeagowidth=""0""height=""15""datetime={date.toJSON()}layout=""responsive"">.</amp-timeago></div>)}exportdefaultMyAmpPageAMP ValidationAMP pages are automatically validated withamphtml-validatorduring development. Errors and warnings will appear in the terminal where you started Next.js.Pages are also validated duringStatic HTML exportand any warnings / errors will be printed to the terminal. Any AMP errors will cause the export to exit with status code1because the export is not valid AMP.Custom ValidatorsYou can set up custom AMP validator innext.config.jsas shown below:module.exports={amp:{validator:'./custom_validator.js',},}Skip AMP ValidationTo turn off AMP validation add the following code tonext.config.jsexperimental:{amp:{skipValidation:true}}AMP in Static HTML ExportWhen usingStatic HTML exportstatically prerender pages, Next.js will detect if the page supports AMP and change the exporting behavior based on that.For example, the hybrid AMP pagepages/about.jswould output:out/about.html- HTML page with client-side React runtimeout/about.amp.html- AMP pageAnd ifpages/about.jsis an AMP-only page, then it would output:out/about.html- Optimized AMP pageNext.js will automatically insert a link to the AMP version of your page in the HTML version, so you don't have to, like so:<linkrel=""amphtml""href=""/about.amp.html""/>And the AMP version of your page will include a link to the HTML page:<linkrel=""canonical""href=""/about""/>WhentrailingSlashis enabled the exported pages forpages/about.jswould be:out/about/index.html- HTML pageout/about.amp/index.html- AMP pageTypeScriptAMP currently doesn't have built-in types for TypeScript, but it's in their roadmap (#13791).As a workaround you can manually create a file calledamp.d.tsinside your project and add thesecustom types.PreviousMDXNextBabelWas this helpful?supported.Send"
babel,Babel,"Building Your ApplicationConfiguringBabelBabelExamplesCustomizing babel configurationNext.js includes thenext/babelpreset to your app, which includes everything needed to compile React applications and server-side code. But if you want to extend the default Babel configs, it's also possible.Adding Presets and PluginsTo start, you only need to define a.babelrcfile (orbabel.config.js) in the root directory of your project. If such a file is found, it will be considered as thesource of truth, and therefore it needs to define what Next.js needs as well, which is thenext/babelpreset.Here's an example.babelrcfile:.babelrc{""presets"":[""next/babel""],""plugins"":[]}You cantake a look at this fileto learn about the presets included bynext/babel.To add presets/pluginswithout configuring them, you can do it this way:.babelrc{""presets"":[""next/babel""],""plugins"":[""@babel/plugin-proposal-do-expressions""]}Customizing Presets and PluginsTo add presets/pluginswith custom configuration, do it on thenext/babelpreset like so:.babelrc{""presets"":[[""next/babel"",{""preset-env"":{},""transform-runtime"":{},""styled-jsx"":{},""class-properties"":{}}]],""plugins"":[]}To learn more about the available options for each config, visit babel'sdocumentationsite.Good to know:Next.js uses thecurrentNode.js versionfor server-side compilations.Themodulesoption on""preset-env""should be kept tofalse, otherwise webpack code splitting is turned off.PreviousAMPNextPostCSSWas this helpful?supported.Send"
postcss,PostCSS,"Building Your ApplicationConfiguringPostCSSPostCSSDefault BehaviorNext.js compiles CSS for itsbuilt-in CSS supportusing PostCSS.Out of the box, with no configuration, Next.js compiles CSS with the following transformations:Autoprefixerautomatically adds vendor prefixes to CSS rules (back to IE11).Cross-browser Flexbox bugsare corrected to behave likethe spec.New CSS features are automatically compiled for Internet Explorer 11 compatibility:allPropertyBreak Propertiesfont-variantPropertyGap PropertiesMedia Query RangesBy default,CSS GridandCustom Properties(CSS variables) arenot compiledfor IE11 support.To compileCSS Grid Layoutfor IE11, you can place the following comment at the top of your CSS file:/* autoprefixer grid: autoplace */You can also enable IE11 support forCSS Grid Layoutin your entire project by configuring autoprefixer with the configuration shown below (collapsed).
See""Customizing Plugins""below for more information.Click to view the configuration to enable CSS Grid Layoutpostcss.config.json{""plugins"":[""postcss-flexbugs-fixes"",[""postcss-preset-env"",{""autoprefixer"":{""flexbox"":""no-2009"",""grid"":""autoplace""},""stage"":3,""features"":{""custom-properties"":false}}]]}CSS variables are not compiled because it isnot possible to safely do so.
If you must use variables, consider using something likeSass variableswhich are compiled away bySass.Customizing Target BrowsersNext.js allows you to configure the target browsers (forAutoprefixerand compiled css features) throughBrowserslist.To customize browserslist, create abrowserslistkey in yourpackage.jsonlike so:package.json{""browserslist"":["">0.3%"",""not dead"",""not op_mini all""]}You can use thebrowsersl.isttool to visualize what browsers you are targeting.CSS ModulesNo configuration is needed to support CSS Modules. To enable CSS Modules for a file, rename the file to have the extension.module.css.You can learn more aboutNext.js' CSS Module support here.Customizing PluginsWarning: When you define a custom PostCSS configuration file, Next.jscompletely disablesthedefault behavior.
Be sure to manually configure all the features you need compiled, includingAutoprefixer.
You also need to install any plugins included in your custom configuration manually, i.e.npm install postcss-flexbugs-fixes postcss-preset-env.To customize the PostCSS configuration, create apostcss.config.jsonfile in the root of your project.This is the default configuration used by Next.js:postcss.config.json{""plugins"":[""postcss-flexbugs-fixes"",[""postcss-preset-env"",{""autoprefixer"":{""flexbox"":""no-2009""},""stage"":3,""features"":{""custom-properties"":false}}]]}Good to know: Next.js also allows the file to be named.postcssrc.json, or, to be read from thepostcsskey inpackage.json.It is also possible to configure PostCSS with apostcss.config.jsfile, which is useful when you want to conditionally include plugins based on environment:postcss.config.jsmodule.exports={plugins:process.env.NODE_ENV==='production'?['postcss-flexbugs-fixes',['postcss-preset-env',{autoprefixer:{flexbox:'no-2009',},stage:3,features:{'custom-properties':false,},},],]:[// No transformations in development],}Good to know: Next.js also allows the file to be named.postcssrc.js.Donot userequire()to import the PostCSS Plugins. Plugins must be provided as strings.Good to know: If yourpostcss.config.jsneeds to support other non-Next.js tools in the same project, you must use the interoperable object-based format instead:module.exports={plugins:{'postcss-flexbugs-fixes':{},'postcss-preset-env':{autoprefixer:{flexbox:'no-2009',},stage:3,features:{'custom-properties':false,},},},}PreviousBabelNextCustom ServerWas this helpful?supported.Send"
custom server,Custom Server,"Building Your ApplicationConfiguringCustom ServerCustom ServerNext.js includes its own server withnext startby default. If you have an existing backend, you can still use it with Next.js (this is not a custom server). A custom Next.js server allows you to programmatically start a server for custom patterns. The majority of the time, you will not need this approach. However, it's available if you need to eject.Good to know:Before deciding to use a custom server, keep in mind that it should only be used when the integrated router of Next.js can't meet your app requirements. A custom server will remove important performance optimizations, likeAutomatic Static Optimization.A custom servercannotbe deployed onVercel.When using standalone output mode, it does not trace custom server files. This mode outputs a separate minimalserver.jsfile, instead. These cannot be used together.Take a look at thefollowing exampleof a custom server:server.tsTypeScriptJavaScriptTypeScriptimport{ createServer }from'http'import{ parse }from'url'importnextfrom'next'constport=parseInt(process.env.PORT||'3000',10)constdev=process.env.NODE_ENV!=='production'constapp=next({ dev })consthandle=app.getRequestHandler()app.prepare().then(()=>{createServer((req,res)=>{constparsedUrl=parse(req.url!,true)handle(req,res,parsedUrl)}).listen(port)console.log(`> Server listening at http://localhost:${port}as${dev?'development':process.env.NODE_ENV}`)})server.jsdoes not run through the Next.js Compiler or bundling process. Make sure the syntax and source code this file requires are compatible with the current Node.js version you are using.View an example.To run the custom server, you'll need to update thescriptsinpackage.jsonlike so:package.json{""scripts"":{""dev"":""node server.js"",""build"":""next build"",""start"":""NODE_ENV=production node server.js""}}Alternatively, you can set upnodemon(example). The custom server uses the following import to connect the server with the Next.js application:importnextfrom'next'constapp=next({})The abovenextimport is a function that receives an object with the following options:OptionTypeDescriptionconfObjectThe same object you would use innext.config.js. Defaults to{}devBoolean(Optional) Whether or not to launch Next.js in dev mode. Defaults tofalsedirString(Optional) Location of the Next.js project. Defaults to'.'quietBoolean(Optional) Hide error messages containing server information. Defaults tofalsehostnameString(Optional) The hostname the server is running behindportNumber(Optional) The port the server is running behindhttpServernode:http#Server(Optional) The HTTP Server that Next.js is running behindturboBoolean(Optional) Enable TurbopackThe returnedappcan then be used to let Next.js handle requests as required.Disabling file-system routingBy default,Nextwill serve each file in thepagesfolder under a pathname matching the filename. If your project uses a custom server, this behavior may result in the same content being served from multiple paths, which can present problems with SEO and UX.To disable this behavior and prevent routing based on files inpages, opennext.config.jsand disable theuseFileSystemPublicRoutesconfig:next.config.jsmodule.exports={useFileSystemPublicRoutes:false,}Note thatuseFileSystemPublicRoutesdisables filename routes from SSR; client-side routing may still access those paths. When using this option, you should guard against navigation to routes you do not want programmatically.You may also wish to configure the client-side router to disallow client-side redirects to filename routes; for that refer torouter.beforePopState.PreviousPostCSSNextDraft ModeWas this helpful?supported.Send"
draft mode,Draft Mode,"Building Your ApplicationConfiguringDraft ModeDraft ModeIn thePages documentationand theData Fetching documentation, we talked about how to pre-render a page at build time (Static Generation) usinggetStaticPropsandgetStaticPaths.Static Generation is useful when your pages fetch data from a headless CMS. However, it’s not ideal when you’re writing a draft on your headless CMS and want to view the draft immediately on your page. You’d want Next.js to render these pages atrequest timeinstead of build time and fetch the draft content instead of the published content. You’d want Next.js to bypass Static Generation only for this specific case.Next.js has a feature calledDraft Modewhich solves this problem. Here are instructions on how to use it.Step 1: Create and access the API routeTake a look at theAPI Routes documentationfirst if you’re not familiar with Next.js API Routes.First, create theAPI route. It can have any name - e.g.pages/api/draft.tsIn this API route, you need to callsetDraftModeon the response object.exportdefaultfunctionhandler(req,res) {// ...res.setDraftMode({ enable:true})// ...}This will set acookieto enable draft mode. Subsequent requests containing this cookie will triggerDraft Modechanging the behavior for statically generated pages (more on this later).You can test this manually by creating an API route like below and accessing it from your browser manually:pages/api/draft.ts// simple example for testing it manually from your browser.exportdefaultfunctionhandler(req,res) {res.setDraftMode({ enable:true})res.end('Draft mode is enabled')}If you open your browser’s developer tools and visit/api/draft, you’ll notice aSet-Cookieresponse header with a cookie named__prerender_bypass.Securely accessing it from your Headless CMSIn practice, you’d want to call this API routesecurelyfrom your headless CMS. The specific steps will vary depending on which headless CMS you’re using, but here are some common steps you could take.These steps assume that the headless CMS you’re using supports settingcustom draft URLs. If it doesn’t, you can still use this method to secure your draft URLs, but you’ll need to construct and access the draft URL manually.First, you should create asecret token stringusing a token generator of your choice. This secret will only be known by your Next.js app and your headless CMS. This secret prevents people who don’t have access to your CMS from accessing draft URLs.Second, if your headless CMS supports setting custom draft URLs, specify the following as the draft URL. This assumes that your draft API route is located atpages/api/draft.ts.Terminalhttps://<your-site>/api/draft?secret=<token>&slug=<path><your-site>should be your deployment domain.<token>should be replaced with the secret token you generated.<path>should be the path for the page that you want to view. If you want to view/posts/foo, then you should use&slug=/posts/foo.Your headless CMS might allow you to include a variable in the draft URL so that<path>can be set dynamically based on the CMS’s data like so:&slug=/posts/{entry.fields.slug}Finally, in the draft API route:Check that the secret matches and that theslugparameter exists (if not, the request should fail).Callres.setDraftMode.Then redirect the browser to the path specified byslug. (The following example uses a307 redirect).exportdefaultasync(req,res)=>{// Check the secret and next parameters// This secret should only be known to this API route and the CMSif(req.query.secret!=='MY_SECRET_TOKEN'||!req.query.slug) {returnres.status(401).json({ message:'Invalid token'})}// Fetch the headless CMS to check if the provided `slug` exists// getPostBySlug would implement the required fetching logic to the headless CMSconstpost=awaitgetPostBySlug(req.query.slug)// If the slug doesn't exist prevent draft mode from being enabledif(!post) {returnres.status(401).json({ message:'Invalid slug'})}// Enable Draft Mode by setting the cookieres.setDraftMode({ enable:true})// Redirect to the path from the fetched post// We don't redirect to req.query.slug as that might lead to open redirect vulnerabilitiesres.redirect(post.slug)}If it succeeds, then the browser will be redirected to the path you want to view with the draft mode cookie.Step 2: UpdategetStaticPropsThe next step is to updategetStaticPropsto support draft mode.If you request a page which hasgetStaticPropswith the cookie set (viares.setDraftMode), thengetStaticPropswill be called atrequest time(instead of at build time).Furthermore, it will be called with acontextobject wherecontext.draftModewill betrue.exportasyncfunctiongetStaticProps(context) {if(context.draftMode) {// dynamic data}}We usedres.setDraftModein the draft API route, socontext.draftModewill betrue.If you’re also usinggetStaticPaths, thencontext.paramswill also be available.Fetch draft dataYou can updategetStaticPropsto fetch different data based oncontext.draftMode.For example, your headless CMS might have a different API endpoint for draft posts. If so, you can modify the API endpoint URL like below:exportasyncfunctiongetStaticProps(context) {consturl=context.draftMode?'https://draft.example.com':'https://production.example.com'constres=awaitfetch(url)// ...}That’s it! If you access the draft API route (withsecretandslug) from your headless CMS or manually, you should now be able to see the draft content. And if you update your draft without publishing, you should be able to view the draft.Set this as the draft URL on your headless CMS or access manually, and you should be able to see the draft.Terminalhttps://<your-site>/api/draft?secret=<token>&slug=<path>More DetailsClear the Draft Mode cookieBy default, the Draft Mode session ends when the browser is closed.To clear the Draft Mode cookie manually, create an API route that callssetDraftMode({ enable: false }):pages/api/disable-draft.tsexportdefaultfunctionhandler(req,res) {res.setDraftMode({ enable:false})}Then, send a request to/api/disable-draftto invoke the API Route. If calling this route usingnext/link, you must passprefetch={false}to prevent accidentally deleting the cookie on prefetch.Works withgetServerSidePropsDraft Mode works withgetServerSideProps, and is available as adraftModekey in thecontextobject.Good to know: You shouldn't set theCache-Controlheader when using Draft Mode because it cannot be bypassed. Instead, we recommend usingISR.Works with API RoutesAPI Routes will have access todraftModeon the request object. For example:exportdefaultfunctionmyApiRoute(req,res) {if(req.draftMode) {// get draft data}}Unique pernext buildA new bypass cookie value will be generated each time you runnext build.This ensures that the bypass cookie can’t be guessed.Good to know: To test Draft Mode locally over HTTP, your browser will need to allow third-party cookies and local storage access.PreviousCustom ServerNextError HandlingWas this helpful?supported.Send"
error handling,Error Handling,"Building Your ApplicationConfiguringError HandlingError HandlingThis documentation explains how you can handle development, server-side, and client-side errors.Handling Errors in DevelopmentWhen there is a runtime error during the development phase of your Next.js application, you will encounter anoverlay. It is a modal that covers the webpage. It isonlyvisible when the development server runs usingnext devviapnpm dev,npm run dev,yarn dev, orbun devand will not be shown in production. Fixing the error will automatically dismiss the overlay.Here is an example of an overlay:Handling Server ErrorsNext.js provides a static 500 page by default to handle server-side errors that occur in your application. You can alsocustomize this pageby creating apages/500.jsfile.Having a 500 page in your application does not show specific errors to the app user.You can also use404 pageto handle specific runtime error likefile not found.Handling Client ErrorsReactError Boundariesis a graceful way to handle a JavaScript error on the client so that the other parts of the application continue working. In addition to preventing the page from crashing, it allows you to provide a custom fallback component and even log error information.To use Error Boundaries for your Next.js application, you must create a class componentErrorBoundaryand wrap theComponentprop in thepages/_app.jsfile. This component will be responsible to:Render a fallback UI after an error is thrownProvide a way to reset the Application's stateLog error informationYou can create anErrorBoundaryclass component by extendingReact.Component. For example:classErrorBoundaryextendsReact.Component{constructor(props) {super(props)// Define a state variable to track whether is an error or notthis.state={ hasError:false}}staticgetDerivedStateFromError(error) {// Update state so the next render will show the fallback UIreturn{ hasError:true}}componentDidCatch(error,errorInfo) {// You can use your own error logging service hereconsole.log({ error,errorInfo })}render() {// Check if the error is thrownif(this.state.hasError) {// You can render any custom fallback UIreturn(<div><h2>Oops, there is an error!</h2><buttontype=""button""onClick={()=>this.setState({ hasError:false})}>Try again?</button></div>)}// Return children components in case of no errorreturnthis.props.children}}exportdefaultErrorBoundaryTheErrorBoundarycomponent keeps track of anhasErrorstate. The value of this state variable is a boolean. When the value ofhasErroristrue, then theErrorBoundarycomponent will render a fallback UI. Otherwise, it will render the children components.After creating anErrorBoundarycomponent, import it in thepages/_app.jsfile to wrap theComponentprop in your Next.js application.// Import the ErrorBoundary componentimportErrorBoundaryfrom'../components/ErrorBoundary'functionMyApp({ Component,pageProps }) {return(// Wrap the Component prop with ErrorBoundary component<ErrorBoundary><Component{...pageProps} /></ErrorBoundary>)}exportdefaultMyAppYou can learn more aboutError Boundariesin React's documentation.Reporting ErrorsTo monitor client errors, use a service likeSentry, Bugsnag or Datadog.PreviousDraft ModeNextPreview ModeWas this helpful?supported.Send"
preview mode,Preview Mode,"Building Your ApplicationConfiguringPreview ModePreview ModeNote: This feature is superseded byDraft Mode.ExamplesAgility CMS Example(Demo)Builder.io Example(Demo)ButterCMS Example(Demo)Contentful Example(Demo)Cosmic Example(Demo)DatoCMS Example(Demo)DotCMS Example(Demo)Drupal Example(Demo)Enterspeed Example(Demo)GraphCMS Example(Demo)Keystone Example(Demo)Kontent.ai Example(Demo)Makeswift Example(Demo)Plasmic Example(Demo)Prepr Example(Demo)Prismic Example(Demo)Sanity Example(Demo)Sitecore XM Cloud Example(Demo)Storyblok Example(Demo)Strapi Example(Demo)TakeShape Example(Demo)Tina Example(Demo)Umbraco Example(Demo)Umbraco Heartcore Example(Demo)Webiny Example(Demo)WordPress Example(Demo)Blog Starter Example(Demo)In thePages documentationand theData Fetching documentation, we talked about how to pre-render a page at build time (Static Generation) usinggetStaticPropsandgetStaticPaths.Static Generation is useful when your pages fetch data from a headless CMS. However, it’s not ideal when you’re writing a draft on your headless CMS and want topreviewthe draft immediately on your page. You’d want Next.js to render these pages atrequest timeinstead of build time and fetch the draft content instead of the published content. You’d want Next.js to bypass Static Generation only for this specific case.Next.js has a feature calledPreview Modewhich solves this problem. Here are instructions on how to use it.Step 1: Create and access a preview API routeTake a look at theAPI Routes documentationfirst if you’re not familiar with Next.js API Routes.First, create apreview API route. It can have any name - e.g.pages/api/preview.js(or.tsif using TypeScript).In this API route, you need to callsetPreviewDataon the response object. The argument forsetPreviewDatashould be an object, and this can be used bygetStaticProps(more on this later). For now, we’ll use{}.exportdefaultfunctionhandler(req,res) {// ...res.setPreviewData({})// ...}res.setPreviewDatasets somecookieson the browser which turns on the preview mode. Any requests to Next.js containing these cookies will be considered as thepreview mode, and the behavior for statically generated pages will change (more on this later).You can test this manually by creating an API route like below and accessing it from your browser manually:pages/api/preview.js// simple example for testing it manually from your browser.exportdefaultfunctionhandler(req,res) {res.setPreviewData({})res.end('Preview mode enabled')}If you open your browser’s developer tools and visit/api/preview, you’ll notice that the__prerender_bypassand__next_preview_datacookies will be set on this request.Securely accessing it from your Headless CMSIn practice, you’d want to call this API routesecurelyfrom your headless CMS. The specific steps will vary depending on which headless CMS you’re using, but here are some common steps you could take.These steps assume that the headless CMS you’re using supports settingcustom preview URLs. If it doesn’t, you can still use this method to secure your preview URLs, but you’ll need to construct and access the preview URL manually.First, you should create asecret token stringusing a token generator of your choice. This secret will only be known by your Next.js app and your headless CMS. This secret prevents people who don’t have access to your CMS from accessing preview URLs.Second, if your headless CMS supports setting custom preview URLs, specify the following as the preview URL. This assumes that your preview API route is located atpages/api/preview.js.Terminalhttps://<your-site>/api/preview?secret=<token>&slug=<path><your-site>should be your deployment domain.<token>should be replaced with the secret token you generated.<path>should be the path for the page that you want to preview. If you want to preview/posts/foo, then you should use&slug=/posts/foo.Your headless CMS might allow you to include a variable in the preview URL so that<path>can be set dynamically based on the CMS’s data like so:&slug=/posts/{entry.fields.slug}Finally, in the preview API route:Check that the secret matches and that theslugparameter exists (if not, the request should fail).Callres.setPreviewData.Then redirect the browser to the path specified byslug. (The following example uses a307 redirect).exportdefaultasync(req,res)=>{// Check the secret and next parameters// This secret should only be known to this API route and the CMSif(req.query.secret!=='MY_SECRET_TOKEN'||!req.query.slug) {returnres.status(401).json({ message:'Invalid token'})}// Fetch the headless CMS to check if the provided `slug` exists// getPostBySlug would implement the required fetching logic to the headless CMSconstpost=awaitgetPostBySlug(req.query.slug)// If the slug doesn't exist prevent preview mode from being enabledif(!post) {returnres.status(401).json({ message:'Invalid slug'})}// Enable Preview Mode by setting the cookiesres.setPreviewData({})// Redirect to the path from the fetched post// We don't redirect to req.query.slug as that might lead to open redirect vulnerabilitiesres.redirect(post.slug)}If it succeeds, then the browser will be redirected to the path you want to preview with the preview mode cookies being set.Step 2: UpdategetStaticPropsThe next step is to updategetStaticPropsto support the preview mode.If you request a page which hasgetStaticPropswith the preview mode cookies set (viares.setPreviewData), thengetStaticPropswill be called atrequest time(instead of at build time).Furthermore, it will be called with acontextobject where:context.previewwill betrue.context.previewDatawill be the same as the argument used forsetPreviewData.exportasyncfunctiongetStaticProps(context) {// If you request this page with the preview mode cookies set://// - context.preview will be true// - context.previewData will be the same as//   the argument used for `setPreviewData`.}We usedres.setPreviewData({})in the preview API route, socontext.previewDatawill be{}. You can use this to pass session information from the preview API route togetStaticPropsif necessary.If you’re also usinggetStaticPaths, thencontext.paramswill also be available.Fetch preview dataYou can updategetStaticPropsto fetch different data based oncontext.previewand/orcontext.previewData.For example, your headless CMS might have a different API endpoint for draft posts. If so, you can usecontext.previewto modify the API endpoint URL like below:exportasyncfunctiongetStaticProps(context) {// If context.preview is true, append ""/preview"" to the API endpoint// to request draft data instead of published data. This will vary// based on which headless CMS you're using.constres=awaitfetch(`https://.../${context.preview?'preview':''}`)// ...}That’s it! If you access the preview API route (withsecretandslug) from your headless CMS or manually, you should now be able to see the preview content. And if you update your draft without publishing, you should be able to preview the draft.Set this as the preview URL on your headless CMS or access manually, and you should be able to see the preview.Terminalhttps://<your-site>/api/preview?secret=<token>&slug=<path>More DetailsGood to know: during renderingnext/routerexposes anisPreviewflag, see therouter object docsfor more info.Specify the Preview Mode durationsetPreviewDatatakes an optional second parameter which should be an options object. It accepts the following keys:maxAge: Specifies the number (in seconds) for the preview session to last for.path: Specifies the path the cookie should be applied under. Defaults to/enabling preview mode for all paths.setPreviewData(data,{maxAge:60*60,// The preview mode cookies expire in 1 hourpath:'/about',// The preview mode cookies apply to paths with /about})Clear the Preview Mode cookiesBy default, no expiration date is set for Preview Mode cookies, so the preview session ends when the browser is closed.To clear the Preview Mode cookies manually, create an API route that callsclearPreviewData():pages/api/clear-preview-mode-cookies.jsexportdefaultfunctionhandler(req,res) {res.clearPreviewData({})}Then, send a request to/api/clear-preview-mode-cookiesto invoke the API Route. If calling this route usingnext/link, you must passprefetch={false}to prevent callingclearPreviewDataduring link prefetching.If a path was specified in thesetPreviewDatacall, you must pass the same path toclearPreviewData:pages/api/clear-preview-mode-cookies.jsexportdefaultfunctionhandler(req,res) {const{path}=req.queryres.clearPreviewData({ path })}previewDatasize limitsYou can pass an object tosetPreviewDataand have it be available ingetStaticProps. However, because the data will be stored in a cookie, there’s a size limitation. Currently, preview data is limited to 2KB.Works withgetServerSidePropsThe preview mode works ongetServerSidePropsas well. It will also be available on thecontextobject containingpreviewandpreviewData.Good to know: You shouldn't set theCache-Controlheader when using Preview Mode because it cannot be bypassed. Instead, we recommend usingISR.Works with API RoutesAPI Routes will have access topreviewandpreviewDataunder the request object. For example:exportdefaultfunctionmyApiRoute(req,res) {constisPreview=req.previewconstpreviewData=req.previewData// ...}Unique pernext buildBoth the bypass cookie value and the private key for encrypting thepreviewDatachange whennext buildis completed.
This ensures that the bypass cookie can’t be guessed.Good to know: To test Preview Mode locally over HTTP your browser will need to allow third-party cookies and local storage access.PreviousError HandlingNextContent Security PolicyWas this helpful?supported.Send"
content security policy,Content Security Policy,"Building Your ApplicationConfiguringContent Security PolicyContent Security PolicyContent Security Policy (CSP)is important to guard your Next.js application against various security threats such as cross-site scripting (XSS), clickjacking, and other code injection attacks.By using CSP, developers can specify which origins are permissible for content sources, scripts, stylesheets, images, fonts, objects, media (audio, video), iframes, and more.ExamplesStrict CSPNoncesAnonceis a unique, random string of characters created for a one-time use. It is used in conjunction with CSP to selectively allow certain inline scripts or styles to execute, bypassing strict CSP directives.Why use a nonce?Even though CSPs are designed to block malicious scripts, there are legitimate scenarios where inline scripts are necessary. In such cases, nonces offer a way to allow these scripts to execute if they have the correct nonce.Adding a nonce with MiddlewareMiddlewareenables you to add headers and generate nonces before the page renders.Every time a page is viewed, a fresh nonce should be generated. This means that youmust use dynamic rendering to add nonces.For example:middleware.tsTypeScriptJavaScriptTypeScriptimport{ NextRequest,NextResponse }from'next/server'exportfunctionmiddleware(request:NextRequest) {constnonce=Buffer.from(crypto.randomUUID()).toString('base64')constcspHeader=`default-src 'self';script-src 'self' 'nonce-${nonce}' 'strict-dynamic';style-src 'self' 'nonce-${nonce}';img-src 'self' blob: data:;font-src 'self';object-src 'none';base-uri 'self';form-action 'self';frame-ancestors 'none';upgrade-insecure-requests;`// Replace newline characters and spacesconstcontentSecurityPolicyHeaderValue=cspHeader.replace(/\s{2,}/g,' ').trim()constrequestHeaders=newHeaders(request.headers)requestHeaders.set('x-nonce',nonce)requestHeaders.set('Content-Security-Policy',contentSecurityPolicyHeaderValue)constresponse=NextResponse.next({request:{headers:requestHeaders,},})response.headers.set('Content-Security-Policy',contentSecurityPolicyHeaderValue)returnresponse}By default, Middleware runs on all requests. You can filter Middleware to run on specific paths using amatcher.We recommend ignoring matching prefetches (fromnext/link) and static assets that don't need the CSP header.middleware.tsTypeScriptJavaScriptTypeScriptexportconstconfig={matcher:[/** Match all request paths except for the ones starting with:* - api (API routes)* - _next/static (static files)* - _next/image (image optimization files)* - favicon.ico (favicon file)*/{source:'/((?!api|_next/static|_next/image|favicon.ico).*)',missing:[{ type:'header',key:'next-router-prefetch'},{ type:'header',key:'purpose',value:'prefetch'},],},],}Reading the nonceYou can now read the nonce from aServer Componentusingheaders:app/page.tsxTypeScriptJavaScriptTypeScriptimport{ headers }from'next/headers'importScriptfrom'next/script'exportdefaultasyncfunctionPage() {constnonce=(awaitheaders()).get('x-nonce')return(<Scriptsrc=""https://www.googletagmanager.com/gtag/js""strategy=""afterInteractive""nonce={nonce}/>)}Without NoncesFor applications that do not require nonces, you can set the CSP header directly in yournext.config.jsfile:next.config.jsconstcspHeader=`default-src 'self';script-src 'self' 'unsafe-eval' 'unsafe-inline';style-src 'self' 'unsafe-inline';img-src 'self' blob: data:;font-src 'self';object-src 'none';base-uri 'self';form-action 'self';frame-ancestors 'none';upgrade-insecure-requests;`module.exports={asyncheaders() {return[{source:'/(.*)',headers:[{key:'Content-Security-Policy',value:cspHeader.replace(/\n/g,''),},],},]},}Version HistoryWe recommend usingv13.4.20+of Next.js to properly handle and apply nonces.PreviousPreview ModeNextDebuggingWas this helpful?supported.Send"
debugging,Debugging,"Building Your ApplicationConfiguringDebuggingDebuggingThis documentation explains how you can debug your Next.js frontend and backend code with full source maps support using theVS Code debugger,Chrome DevTools, orFirefox DevTools.Any debugger that can attach to Node.js can also be used to debug a Next.js application. You can find more details in the Node.jsDebugging Guide.Debugging with VS CodeCreate a file named.vscode/launch.jsonat the root of your project with the following content:launch.json{""version"":""0.2.0"",""configurations"":[{""name"":""Next.js: debug server-side"",""type"":""node-terminal"",""request"":""launch"",""command"":""npm run dev""},{""name"":""Next.js: debug client-side"",""type"":""chrome"",""request"":""launch"",""url"":""http://localhost:3000""},{""name"":""Next.js: debug client-side (Firefox)"",""type"":""firefox"",""request"":""launch"",""url"":""http://localhost:3000"",""reAttach"":true,""pathMappings"":[{""url"":""webpack://_N_E"",""path"":""${workspaceFolder}""}]},{""name"":""Next.js: debug full stack"",""type"":""node"",""request"":""launch"",""program"":""${workspaceFolder}/node_modules/.bin/next"",""runtimeArgs"":[""--inspect""],""skipFiles"":[""<node_internals>/**""],""serverReadyAction"":{""action"":""debugWithEdge"",""killOnServerStop"":true,""pattern"":""- Local:.+(https?://.+)"",""uriFormat"":""%s"",""webRoot"":""${workspaceFolder}""}}]}Note: To use Firefox debugging in VS Code, you'll need to install theFirefox Debugger extension.npm run devcan be replaced withyarn devif you're using Yarn orpnpm devif you're using pnpm.In the ""Next.js: debug full stack"" configuration,serverReadyAction.actionspecifies which browser to open when the server is ready.debugWithEdgemeans to launch the Edge browser. If you are using Chrome, change this value todebugWithChrome.If you'rechanging the port numberyour application starts on, replace the3000inhttp://localhost:3000with the port you're using instead.If you're running Next.js from a directory other than root (for example, if you're using Turborepo) then you need to addcwdto the server-side and full stack debugging tasks. For example,""cwd"": ""${workspaceFolder}/apps/web"".Now go to the Debug panel (Ctrl+Shift+Don Windows/Linux,⇧+⌘+Don macOS), select a launch configuration, then pressF5or selectDebug: Start Debuggingfrom the Command Palette to start your debugging session.Using the Debugger in Jetbrains WebStormClick the drop down menu listing the runtime configuration, and clickEdit Configurations.... Create aJavaScript Debugdebug configuration withhttp://localhost:3000as the URL. Customize to your liking (e.g. Browser for debugging, store as project file), and clickOK. Run this debug configuration, and the selected browser should automatically open. At this point, you should have 2 applications in debug mode: the NextJS node application, and the client/browser application.Debugging with Browser DevToolsClient-side codeStart your development server as usual by runningnext dev,npm run dev, oryarn dev. Once the server starts, openhttp://localhost:3000(or your alternate URL) in your preferred browser.For Chrome:Open Chrome's Developer Tools (Ctrl+Shift+Jon Windows/Linux,⌥+⌘+Ion macOS)Go to theSourcestabFor Firefox:Open Firefox's Developer Tools (Ctrl+Shift+Ion Windows/Linux,⌥+⌘+Ion macOS)Go to theDebuggertabIn either browser, any time your client-side code reaches adebuggerstatement, code execution will pause and that file will appear in the debug area. You can also search for files to set breakpoints manually:In Chrome: PressCtrl+Pon Windows/Linux or⌘+Pon macOSIn Firefox: PressCtrl+Pon Windows/Linux or⌘+Pon macOS, or use the file tree in the left panelNote that when searching, your source files will have paths starting withwebpack://_N_E/./.Server-side codeTo debug server-side Next.js code with browser DevTools, you need to pass the--inspectflag to the underlying Node.js process:TerminalNODE_OPTIONS='--inspect'nextdevGood to know: UseNODE_OPTIONS='--inspect=0.0.0.0'to allow remote debugging access outside localhost, such as when running the app in a Docker container.If you're usingnpm run devoryarn devthen you should update thedevscript on yourpackage.json:package.json{""scripts"":{""dev"":""NODE_OPTIONS='--inspect' next dev""}}Launching the Next.js dev server with the--inspectflag will look something like this:TerminalDebuggerlisteningonws://127.0.0.1:9229/0cf90313-350d-4466-a748-cd60f4e47c95Forhelp,see:https://nodejs.org/en/docs/inspectorready-startedserveron0.0.0.0:3000,url:http://localhost:3000For Chrome:Open a new tab and visitchrome://inspectClickConfigure...to ensure both debugging ports are listedAdd bothlocalhost:9229andlocalhost:9230if they're not already presentLook for your Next.js application in theRemote TargetsectionClickinspectto open a separate DevTools windowGo to theSourcestabFor Firefox:Open a new tab and visitabout:debuggingClickThis Firefoxin the left sidebarUnderRemote Targets, find your Next.js applicationClickInspectto open the debuggerGo to theDebuggertabDebugging server-side code works similarly to client-side debugging. When searching for files (Ctrl+P/⌘+P), your source files will have paths starting withwebpack://{application-name}/./(where{application-name}will be replaced with the name of your application according to yourpackage.jsonfile).Inspect Server Errors with Browser DevToolsWhen you encounter an error, inspecting the source code can help trace the root cause of errors.Next.js will display a Node.js icon underneath the Next.js version indicator on the error overlay. By clicking that icon, the DevTools URL is copied to your clipboard. You can open a new browser tab with that URL to inspect the Next.js server process.Debugging on WindowsWindows users may run into an issue when usingNODE_OPTIONS='--inspect'as that syntax is not supported on Windows platforms. To get around this, install thecross-envpackage as a development dependency (-Dwithnpmandyarn) and replace thedevscript with the following.package.json{""scripts"":{""dev"":""cross-env NODE_OPTIONS='--inspect' next dev""}}cross-envwill set theNODE_OPTIONSenvironment variable regardless of which platform you are on (including Mac, Linux, and Windows) and allow you to debug consistently across devices and operating systems.Good to know: Ensure Windows Defender is disabled on your machine. This external service will checkevery file read, which has been reported to greatly increase Fast Refresh time withnext dev. This is a known issue, not related to Next.js, but it does affect Next.js development.More informationTo learn more about how to use a JavaScript debugger, take a look at the following documentation:Node.js debugging in VS Code: BreakpointsChrome DevTools: Debug JavaScriptFirefox DevTools: DebuggerPreviousContent Security PolicyNextTestingWas this helpful?supported.Send"
testing,Testing,"Pages RouterBuilding Your ApplicationTestingTestingIn React and Next.js, there are a few different types of tests you can write, each with its own purpose and use cases. This page provides an overview of types and commonly used tools you can use to test your application.Types of testsUnit Testinginvolves testing individual units (or blocks of code) in isolation. In React, a unit can be a single function, hook, or component.Component Testingis a more focused version of unit testing where the primary subject of the tests is React components. This may involve testing how components are rendered, their interaction with props, and their behavior in response to user events.Integration Testinginvolves testing how multiple units work together. This can be a combination of components, hooks, and functions.End-to-End (E2E) Testinginvolves testing user flows in an environment that simulates real user scenarios, like the browser. This means testing specific tasks (e.g. signup flow) in a production-like environment.Snapshot Testinginvolves capturing the rendered output of a component and saving it to a snapshot file. When tests run, the current rendered output of the component is compared against the saved snapshot. Changes in the snapshot are used to indicate unexpected changes in behavior.GuidesSee the guides below to learn how to set up Next.js with these commonly used testing tools:VitestLearn how to set up Next.js with Vitest and React Testing Library - two popular unit testing libraries.JestLearn how to set up Next.js with Jest for Unit Testing.PlaywrightLearn how to set up Next.js with Playwright for End-to-End (E2E) and Integration testing.CypressLearn how to set up Next.js with Cypress for End-to-End (E2E) and Component Testing.PreviousDebuggingNextVitestWas this helpful?supported.Send"
vitest,Vitest,"Building Your ApplicationTestingVitestSetting up Vitest with Next.jsVite and React Testing Library are frequently used together forUnit Testing. This guide will show you how to setup Vitest with Next.js and write your first tests.Good to know:SinceasyncServer Components are new to the React ecosystem, Vitest currently does not support them. While you can still rununit testsfor synchronous Server and Client Components, we recommend using anE2E testsforasynccomponents.QuickstartYou can usecreate-next-appwith the Next.jswith-vitestexample to quickly get started:Terminalnpxcreate-next-app@latest--examplewith-vitestwith-vitest-appManual SetupTo manually set up Vitest, installvitestand the following packages as dev dependencies:Terminal# Using TypeScriptnpminstall-Dvitest@vitejs/plugin-reactjsdom@testing-library/react@testing-library/domvite-tsconfig-paths# Using JavaScriptnpminstall-Dvitest@vitejs/plugin-reactjsdom@testing-library/react@testing-library/domCreate avitest.config.mts|jsfile in the root of your project, and add the following options:vitest.config.mtsTypeScriptJavaScriptTypeScriptimport{ defineConfig }from'vitest/config'importreactfrom'@vitejs/plugin-react'importtsconfigPathsfrom'vite-tsconfig-paths'exportdefaultdefineConfig({plugins:[tsconfigPaths(),react()],test:{environment:'jsdom',},})For more information on configuring Vitest, please refer to theVitest Configurationdocs.Then, add atestscript to yourpackage.json:package.json{""scripts"":{""dev"":""next dev"",""build"":""next build"",""start"":""next start"",""test"":""vitest""}}When you runnpm run test, Vitest willwatchfor changes in your project by default.Creating your first Vitest Unit TestCheck that everything is working by creating a test to check if the<Page />component successfully renders a heading:pages/index.tsxTypeScriptJavaScriptTypeScriptimportLinkfrom'next/link'exportdefaultfunctionPage() {return(<div><h1>Home</h1><Linkhref=""/about"">About</Link></div>)}__tests__/index.test.tsxTypeScriptJavaScriptTypeScriptimport{ expect,test }from'vitest'import{ render,screen }from'@testing-library/react'importPagefrom'../pages/index'test('Page',()=>{render(<Page/>)expect(screen.getByRole('heading',{ level:1,name:'Home'})).toBeDefined()})Running your testsThen, run the following command to run your tests:Terminalnpmruntest# oryarntest# orpnpmtest# orbuntestAdditional ResourcesYou may find these resources helpful:Next.js with Vitest exampleVitest DocsReact Testing Library DocsPreviousTestingNextJestWas this helpful?supported.Send"
jest,Jest,"Building Your ApplicationTestingJestSetting up Jest with Next.jsJest and React Testing Library are frequently used together forUnit TestingandSnapshot Testing. This guide will show you how to set up Jest with Next.js and write your first tests.Good to know:SinceasyncServer Components are new to the React ecosystem, Jest currently does not support them. While you can still rununit testsfor synchronous Server and Client Components, we recommend using anE2E testsforasynccomponents.QuickstartYou can usecreate-next-appwith the Next.jswith-jestexample to quickly get started:Terminalnpxcreate-next-app@latest--examplewith-jestwith-jest-appManual setupSince the release ofNext.js 12, Next.js now has built-in configuration for Jest.To set up Jest, installjestand the following packages as dev dependencies:Terminalnpminstall-Djestjest-environment-jsdom@testing-library/react@testing-library/dom@testing-library/jest-domts-node# oryarnadd-Djestjest-environment-jsdom@testing-library/react@testing-library/dom@testing-library/jest-domts-node# orpnpminstall-Djestjest-environment-jsdom@testing-library/react@testing-library/dom@testing-library/jest-domts-nodeGenerate a basic Jest configuration file by running the following command:Terminalnpminitjest@latest# oryarncreatejest@latest# orpnpmcreatejest@latestThis will take you through a series of prompts to setup Jest for your project, including automatically creating ajest.config.ts|jsfile.Update your config file to usenext/jest. This transformer has all the necessary configuration options for Jest to work with Next.js:jest.config.tsTypeScriptJavaScriptTypeScriptimporttype{ Config }from'jest'importnextJestfrom'next/jest.js'constcreateJestConfig=nextJest({// Provide the path to your Next.js app to load next.config.js and .env files in your test environmentdir:'./',})// Add any custom config to be passed to Jestconstconfig:Config={coverageProvider:'v8',testEnvironment:'jsdom',// Add more setup options before each test is run// setupFilesAfterEnv: ['<rootDir>/jest.setup.ts'],}// createJestConfig is exported this way to ensure that next/jest can load the Next.js config which is asyncexportdefaultcreateJestConfig(config)Under the hood,next/jestis automatically configuring Jest for you, including:Setting uptransformusing theNext.js Compiler.Auto mocking stylesheets (.css,.module.css, and their scss variants), image imports andnext/font.Loading.env(and all variants) intoprocess.env.Ignoringnode_modulesfrom test resolving and transforms.Ignoring.nextfrom test resolving.Loadingnext.config.jsfor flags that enable SWC transforms.Good to know: To test environment variables directly, load them manually in a separate setup script or in yourjest.config.tsfile. For more information, please seeTest Environment Variables.Setting up Jest (with Babel)If you opt out of theNext.js Compilerand use Babel instead, you will need to manually configure Jest and installbabel-jestandidentity-obj-proxyin addition to the packages above.Here are the recommended options to configure Jest for Next.js:jest.config.jsmodule.exports={collectCoverage:true,// on node 14.x coverage provider v8 offers good speed and more or less good reportcoverageProvider:'v8',collectCoverageFrom:['**/*.{js,jsx,ts,tsx}','!**/*.d.ts','!**/node_modules/**','!<rootDir>/out/**','!<rootDir>/.next/**','!<rootDir>/*.config.js','!<rootDir>/coverage/**',],moduleNameMapper:{// Handle CSS imports (with CSS modules)// https://jestjs.io/docs/webpack#mocking-css-modules'^.+\\.module\\.(css|sass|scss)$':'identity-obj-proxy',// Handle CSS imports (without CSS modules)'^.+\\.(css|sass|scss)$':'<rootDir>/__mocks__/styleMock.js',// Handle image imports// https://jestjs.io/docs/webpack#handling-static-assets'^.+\\.(png|jpg|jpeg|gif|webp|avif|ico|bmp|svg)$':`<rootDir>/__mocks__/fileMock.js`,// Handle module aliases'^@/components/(.*)$':'<rootDir>/components/$1',// Handle @next/font'@next/font/(.*)':`<rootDir>/__mocks__/nextFontMock.js`,// Handle next/font'next/font/(.*)':`<rootDir>/__mocks__/nextFontMock.js`,// Disable server-only'server-only':`<rootDir>/__mocks__/empty.js`,},// Add more setup options before each test is run// setupFilesAfterEnv: ['<rootDir>/jest.setup.js'],testPathIgnorePatterns:['<rootDir>/node_modules/','<rootDir>/.next/'],testEnvironment:'jsdom',transform:{// Use babel-jest to transpile tests with the next/babel preset// https://jestjs.io/docs/configuration#transform-objectstring-pathtotransformer--pathtotransformer-object'^.+\\.(js|jsx|ts|tsx)$':['babel-jest',{ presets:['next/babel'] }],},transformIgnorePatterns:['/node_modules/','^.+\\.module\\.(css|sass|scss)$',],}You can learn more about each configuration option in theJest docs. We also recommend reviewingnext/jestconfigurationto see how Next.js configures Jest.Handling stylesheets and image importsStylesheets and images aren't used in the tests but importing them may cause errors, so they will need to be mocked.Create the mock files referenced in the configuration above -fileMock.jsandstyleMock.js- inside a__mocks__directory:__mocks__/fileMock.jsmodule.exports='test-file-stub'__mocks__/styleMock.jsmodule.exports={}For more information on handling static assets, please refer to theJest Docs.Handling FontsTo handle fonts, create thenextFontMock.jsfile inside the__mocks__directory, and add the following configuration:__mocks__/nextFontMock.jsmodule.exports=newProxy({},{get:functiongetter() {return()=>({className:'className',variable:'variable',style:{ fontFamily:'fontFamily'},})},})Optional: Handling Absolute Imports and Module Path AliasesIf your project is usingModule Path Aliases, you will need to configure Jest to resolve the imports by matching the paths option in thejsconfig.jsonfile with themoduleNameMapperoption in thejest.config.jsfile. For example:tsconfig.json or jsconfig.json{""compilerOptions"":{""module"":""esnext"",""moduleResolution"":""bundler"",""baseUrl"":""./"",""paths"":{""@/components/*"":[""components/*""]}}}jest.config.jsmoduleNameMapper:{// ...'^@/components/(.*)$':'<rootDir>/components/$1',}Optional: Extend Jest with custom matchers@testing-library/jest-domincludes a set of convenientcustom matcherssuch as.toBeInTheDocument()making it easier to write tests. You can import the custom matchers for every test by adding the following option to the Jest configuration file:jest.config.tsTypeScriptJavaScriptTypeScriptsetupFilesAfterEnv:['<rootDir>/jest.setup.ts']Then, insidejest.setup, add the following import:jest.setup.tsTypeScriptJavaScriptTypeScriptimport'@testing-library/jest-dom'Good to know:extend-expectwas removed inv6.0, so if you are using@testing-library/jest-dombefore version 6, you will need to import@testing-library/jest-dom/extend-expectinstead.If you need to add more setup options before each test, you can add them to thejest.setupfile above.Add a test script topackage.jsonFinally, add a Jesttestscript to yourpackage.jsonfile:package.json{""scripts"":{""dev"":""next dev"",""build"":""next build"",""start"":""next start"",""test"":""jest"",""test:watch"":""jest --watch""}}jest --watchwill re-run tests when a file is changed. For more Jest CLI options, please refer to theJest Docs.Creating your first testYour project is now ready to run tests. Create a folder called__tests__in your project's root directory.For example, we can add a test to check if the<Home />component successfully renders a heading:exportdefaultfunctionHome() {return<h1>Home</h1>}__tests__/index.test.jsimport'@testing-library/jest-dom'import{ render,screen }from'@testing-library/react'importHomefrom'../pages/index'describe('Home',()=>{it('renders a heading',()=>{render(<Home/>)constheading=screen.getByRole('heading',{ level:1})expect(heading).toBeInTheDocument()})})Optionally, add asnapshot testto keep track of any unexpected changes in your component:__tests__/snapshot.jsimport{ render }from'@testing-library/react'importHomefrom'../pages/index'it('renders homepage unchanged',()=>{const{container}=render(<Home/>)expect(container).toMatchSnapshot()})Good to know: Test files should not be included inside the Pages Router because any files inside the Pages Router are considered routes.Running your testsThen, run the following command to run your tests:Terminalnpmruntest# oryarntest# orpnpmtestAdditional ResourcesFor further reading, you may find these resources helpful:Next.js with Jest exampleJest DocsReact Testing Library DocsTesting Playground- use good testing practices to match elements.PreviousVitestNextPlaywrightWas this helpful?supported.Send"
playwright,Playwright,"Building Your ApplicationTestingPlaywrightSetting up Playwright with Next.jsPlaywright is a testing framework that lets you automate Chromium, Firefox, and WebKit with a single API. You can use it to writeEnd-to-End (E2E)testing. This guide will show you how to set up Playwright with Next.js and write your first tests.QuickstartThe fastest way to get started is to usecreate-next-appwith thewith-playwright example. This will create a Next.js project complete with Playwright configured.Terminalnpxcreate-next-app@latest--examplewith-playwrightwith-playwright-appManual setupTo install Playwright, run the following command:Terminalnpminitplaywright# oryarncreateplaywright# orpnpmcreateplaywrightThis will take you through a series of prompts to setup and configure Playwright for your project, including adding aplaywright.config.tsfile. Please refer to thePlaywright installation guidefor the step-by-step guide.Creating your first Playwright E2E testCreate two new Next.js pages:pages/index.tsimportLinkfrom'next/link'exportdefaultfunctionHome() {return(<div><h1>Home</h1><Linkhref=""/about"">About</Link></div>)}pages/about.tsimportLinkfrom'next/link'exportdefaultfunctionAbout() {return(<div><h1>About</h1><Linkhref=""/"">Home</Link></div>)}Then, add a test to verify that your navigation is working correctly:tests/example.spec.tsimport{ test,expect }from'@playwright/test'test('should navigate to the about page',async({ page })=>{// Start from the index page (the baseURL is set via the webServer in the playwright.config.ts)awaitpage.goto('http://localhost:3000/')// Find an element with the text 'About' and click on itawaitpage.click('text=About')// The new URL should be ""/about"" (baseURL is used there)awaitexpect(page).toHaveURL('http://localhost:3000/about')// The new page should contain an h1 with ""About""awaitexpect(page.locator('h1')).toContainText('About')})Good to know: You can usepage.goto(""/"")instead ofpage.goto(""http://localhost:3000/""), if you add""baseURL"": ""http://localhost:3000""to theplaywright.config.tsconfiguration file.Running your Playwright testsPlaywright will simulate a user navigating your application using three browsers: Chromium, Firefox and Webkit, this requires your Next.js server to be running. We recommend running your tests against your production code to more closely resemble how your application will behave.Runnpm run buildandnpm run start, then runnpx playwright testin another terminal window to run the Playwright tests.Good to know: Alternatively, you can use thewebServerfeature to let Playwright start the development server and wait until it's fully available.Running Playwright on Continuous Integration (CI)Playwright will by default run your tests in theheadless mode. To install all the Playwright dependencies, runnpx playwright install-deps.You can learn more about Playwright and Continuous Integration from these resources:Next.js with Playwright examplePlaywright on your CI providerPlaywright DiscordPreviousJestNextCypressWas this helpful?supported.Send"
cypress,Cypress,"Building Your ApplicationTestingCypressSetting up Cypress with Next.jsCypressis a test runner used forEnd-to-End (E2E)andComponent Testing. This page will show you how to set up Cypress with Next.js and write your first tests.Warning:Cypress versions below 13.6.3 do not supportTypeScript version 5withmoduleResolution:""bundler"". However, this issue has been resolved in Cypress version 13.6.3 and later.cypress v13.6.3Manual setupTo manually set up Cypress, installcypressas a dev dependency:Terminalnpminstall-Dcypress# oryarnadd-Dcypress# orpnpminstall-DcypressAdd the Cypressopencommand to thepackage.jsonscripts field:package.json{""scripts"":{""dev"":""next dev"",""build"":""next build"",""start"":""next start"",""lint"":""next lint"",""cypress:open"":""cypress open""}}Run Cypress for the first time to open the Cypress testing suite:Terminalnpmruncypress:openYou can choose to configureE2E Testingand/orComponent Testing. Selecting any of these options will automatically create acypress.config.jsfile and acypressfolder in your project.Creating your first Cypress E2E testEnsure yourcypress.configfile has the following configuration:cypress.config.tsTypeScriptJavaScriptTypeScriptimport{ defineConfig }from'cypress'exportdefaultdefineConfig({e2e:{setupNodeEvents(on,config) {},},})Then, create two new Next.js files:pages/index.jsimportLinkfrom'next/link'exportdefaultfunctionHome() {return(<div><h1>Home</h1><Linkhref=""/about"">About</Link></div>)}pages/about.jsimportLinkfrom'next/link'exportdefaultfunctionAbout() {return(<div><h1>About</h1><Linkhref=""/"">Home</Link></div>)}Add a test to check your navigation is working correctly:cypress/e2e/app.cy.jsdescribe('Navigation',()=>{it('should navigate to the about page',()=>{// Start from the index pagecy.visit('http://localhost:3000/')// Find a link with an href attribute containing ""about"" and click itcy.get('a[href*=""about""]').click()// The new url should include ""/about""cy.url().should('include','/about')// The new page should contain an h1 with ""About""cy.get('h1').contains('About')})})Running E2E TestsCypress will simulate a user navigating your application, this requires your Next.js server to be running. We recommend running your tests against your production code to more closely resemble how your application will behave.Runnpm run build && npm run startto build your Next.js application, then runnpm run cypress:openin another terminal window to start Cypress and run your E2E Testing suite.Good to know:You can usecy.visit(""/"")instead ofcy.visit(""http://localhost:3000/"")by addingbaseUrl: 'http://localhost:3000'to thecypress.config.jsconfiguration file.Alternatively, you can install thestart-server-and-testpackage to run the Next.js production server in conjunction with Cypress. After installation, add""test"": ""start-server-and-test start http://localhost:3000 cypress""to yourpackage.jsonscripts field. Remember to rebuild your application after new changes.Creating your first Cypress component testComponent tests build and mount a specific component without having to bundle your whole application or start a server.SelectComponent Testingin the Cypress app, then selectNext.jsas your front-end framework. Acypress/componentfolder will be created in your project, and acypress.config.jsfile will be updated to enable Component Testing.Ensure yourcypress.configfile has the following configuration:cypress.config.tsTypeScriptJavaScriptTypeScriptimport{ defineConfig }from'cypress'exportdefaultdefineConfig({component:{devServer:{framework:'next',bundler:'webpack',},},})Assuming the same components from the previous section, add a test to validate a component is rendering the expected output:cypress/component/about.cy.jsimportAboutPagefrom'../../pages/about'describe('<AboutPage />',()=>{it('should render and display expected content',()=>{// Mount the Reactcomponentfor the About pagecy.mount(<AboutPage/>)// The new page should contain an h1 with ""About page""cy.get('h1').contains('About')// Validate that a link with the expected URL is present// *Following* the link is better suited to an E2E testcy.get('a[href=""/""]').should('be.visible')})})Good to know:Cypress currently doesn't support Component Testing forasyncServer Components. We recommend using E2E testing.Since component tests do not require a Next.js server, features like<Image />that rely on a server being available may not function out-of-the-box.Running Component TestsRunnpm run cypress:openin your terminal to start Cypress and run your Component Testing suite.Continuous Integration (CI)In addition to interactive testing, you can also run Cypress headlessly using thecypress runcommand, which is better suited for CI environments:package.json{""scripts"":{//...""e2e"":""start-server-and-test dev http://localhost:3000 \""cypress open --e2e\"""",""e2e:headless"":""start-server-and-test dev http://localhost:3000 \""cypress run --e2e\"""",""component"":""cypress open --component"",""component:headless"":""cypress run --component""}}You can learn more about Cypress and Continuous Integration from these resources:Next.js with Cypress exampleCypress Continuous Integration DocsCypress GitHub Actions GuideOfficial Cypress GitHub ActionCypress DiscordPreviousPlaywrightNextAuthenticationWas this helpful?supported.Send"
authentication,Authentication,"Pages RouterBuilding Your ApplicationAuthenticationAuthenticationUnderstanding authentication is crucial for protecting your application's data. This page will guide you through what React and Next.js features to use to implement auth.Before starting, it helps to break down the process into three concepts:Authentication: Verifies if the user is who they say they are. It requires the user to prove their identity with something they have, such as a username and password.Session Management: Tracks the user's auth state across requests.Authorization: Decides what routes and data the user can access.This diagram shows the authentication flow using React and Next.js features:The examples on this page walk through basic username and password auth for educational purposes. While you can implement a custom auth solution, for increased security and simplicity, we recommend using an authentication library. These offer built-in solutions for authentication, session management, and authorization, as well as additional features such as social logins, multi-factor authentication, and role-based access control. You can find a list in theAuth Librariessection.AuthenticationHere are the steps to implement a sign-up and/or login form:The user submits their credentials through a form.The form sends a request that is handled by an API route.Upon successful verification, the process is completed, indicating the user's successful authentication.If verification is unsuccessful, an error message is shown.Consider a login form where users can input their credentials:pages/login.tsxTypeScriptJavaScriptTypeScriptimport{ FormEvent }from'react'import{ useRouter }from'next/router'exportdefaultfunctionLoginPage() {constrouter=useRouter()asyncfunctionhandleSubmit(event:FormEvent<HTMLFormElement>) {event.preventDefault()constformData=newFormData(event.currentTarget)constemail=formData.get('email')constpassword=formData.get('password')constresponse=awaitfetch('/api/auth/login',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({ email,password }),})if(response.ok) {router.push('/profile')}else{// Handle errors}}return(<formonSubmit={handleSubmit}><inputtype=""email""name=""email""placeholder=""Email""required/><inputtype=""password""name=""password""placeholder=""Password""required/><buttontype=""submit"">Login</button></form>)}The form above has two input fields for capturing the user's email and password. On submission, it triggers a function that sends a POST request to an API route (/api/auth/login).You can then call your Authentication Provider's API in the API route to handle authentication:pages/api/auth/login.tsTypeScriptJavaScriptTypeScriptimporttype{ NextApiRequest,NextApiResponse }from'next'import{ signIn }from'@/auth'exportdefaultasyncfunctionhandler(req:NextApiRequest,res:NextApiResponse) {try{const{email,password}=req.bodyawaitsignIn('credentials',{ email,password })res.status(200).json({ success:true})}catch(error) {if(error.type==='CredentialsSignin') {res.status(401).json({ error:'Invalid credentials.'})}else{res.status(500).json({ error:'Something went wrong.'})}}}Session ManagementSession management ensures that the user's authenticated state is preserved across requests. It involves creating, storing, refreshing, and deleting sessions or tokens.There are two types of sessions:Stateless: Session data (or a token) is stored in the browser's cookies. The cookie is sent with each request, allowing the session to be verified on the server. This method is simpler, but can be less secure if not implemented correctly.Database: Session data is stored in a database, with the user's browser only receiving the encrypted session ID. This method is more secure, but can be complex and use more server resources.Good to know:While you can use either method, or both, we recommend using a session management library such asiron-sessionorJose.Stateless SessionsSetting and deleting cookiesYou can useAPI Routesto set the session as a cookie on the server:pages/api/login.tsTypeScriptJavaScriptTypeScriptimport{ serialize }from'cookie'importtype{ NextApiRequest,NextApiResponse }from'next'import{ encrypt }from'@/app/lib/session'exportdefaultfunctionhandler(req:NextApiRequest,res:NextApiResponse) {constsessionData=req.bodyconstencryptedSessionData=encrypt(sessionData)constcookie=serialize('session',encryptedSessionData,{httpOnly:true,secure:process.env.NODE_ENV==='production',maxAge:60*60*24*7,// One weekpath:'/',})res.setHeader('Set-Cookie',cookie)res.status(200).json({ message:'Successfully set cookie!'})}Database SessionsTo create and manage database sessions, you'll need to follow these steps:Create a table in your database to store session and data (or check if your Auth Library handles this).Implement functionality to insert, update, and delete sessionsEncrypt the session ID before storing it in the user's browser, and ensure the database and cookie stay in sync (this is optional, but recommended for optimistic auth checks inMiddleware).Creating a Session on the Server:pages/api/create-session.tsTypeScriptJavaScriptTypeScriptimportdbfrom'../../lib/db'importtype{ NextApiRequest,NextApiResponse }from'next'exportdefaultasyncfunctionhandler(req:NextApiRequest,res:NextApiResponse) {try{constuser=req.bodyconstsessionId=generateSessionId()awaitdb.insertSession({sessionId,userId:user.id,createdAt:newDate(),})res.status(200).json({ sessionId })}catch(error) {res.status(500).json({ error:'Internal Server Error'})}}AuthorizationOnce a user is authenticated and a session is created, you can implement authorization to control what the user can access and do within your application.There are two main types of authorization checks:Optimistic: Checks if the user is authorized to access a route or perform an action using the session data stored in the cookie. These checks are useful for quick operations, such as showing/hiding UI elements or redirecting users based on permissions or roles.Secure: Checks if the user is authorized to access a route or perform an action using the session data stored in the database. These checks are more secure and are used for operations that require access to sensitive data or actions.For both cases, we recommend:Creating aData Access Layerto centralize your authorization logicUsingData Transfer Objects (DTO)to only return the necessary dataOptionally useMiddlewareto perform optimistic checks.Optimistic checks with Middleware (Optional)There are some cases where you may want to useMiddlewareand redirect users based on permissions:To perform optimistic checks. Since Middleware runs on every route, it's a good way to centralize redirect logic and pre-filter unauthorized users.To protect static routes that share data between users (e.g. content behind a paywall).However, since Middleware runs on every route, includingprefetchedroutes, it's important to only read the session from the cookie (optimistic checks), and avoid database checks to prevent performance issues.For example:middleware.tsTypeScriptJavaScriptTypeScriptimport{ NextRequest,NextResponse }from'next/server'import{ decrypt }from'@/app/lib/session'import{ cookies }from'next/headers'// 1. Specify protected and public routesconstprotectedRoutes=['/dashboard']constpublicRoutes=['/login','/signup','/']exportdefaultasyncfunctionmiddleware(req:NextRequest) {// 2. Check if the current route is protected or publicconstpath=req.nextUrl.pathnameconstisProtectedRoute=protectedRoutes.includes(path)constisPublicRoute=publicRoutes.includes(path)// 3. Decrypt the session from the cookieconstcookie=(awaitcookies()).get('session')?.valueconstsession=awaitdecrypt(cookie)// 4. Redirect to /login if the user is not authenticatedif(isProtectedRoute&&!session?.userId) {returnNextResponse.redirect(newURL('/login',req.nextUrl))}// 5. Redirect to /dashboard if the user is authenticatedif(isPublicRoute&&session?.userId&&!req.nextUrl.pathname.startsWith('/dashboard')) {returnNextResponse.redirect(newURL('/dashboard',req.nextUrl))}returnNextResponse.next()}// Routes Middleware should not run onexportconstconfig={matcher:['/((?!api|_next/static|_next/image|.*\\.png$).*)'],}While Middleware can be useful for initial checks, it should not be your only line of defense in protecting your data. The majority of security checks should be performed as close as possible to your data source, seeData Access Layerfor more information.Tips:In Middleware, you can also read cookies usingreq.cookies.get('session').value.Middleware uses theEdge Runtime, check if your Auth library and session management library are compatible.You can use thematcherproperty in the Middleware to specify which routes Middleware should run on. Although, for auth, it's recommended Middleware runs on all routes.Creating a Data Access Layer (DAL)Protecting API RoutesAPI Routes in Next.js are essential for handling server-side logic and data management. It's crucial to secure these routes to ensure that only authorized users can access specific functionalities. This typically involves verifying the user's authentication status and their role-based permissions.Here's an example of securing an API Route:pages/api/route.tsTypeScriptJavaScriptTypeScriptimport{ NextApiRequest,NextApiResponse }from'next'exportdefaultasyncfunctionhandler(req:NextApiRequest,res:NextApiResponse) {constsession=awaitgetSession(req)// Check if the user is authenticatedif(!session) {res.status(401).json({error:'User is not authenticated',})return}// Check if the user has the 'admin' roleif(session.user.role!=='admin') {res.status(401).json({error:'Unauthorized access: User does not have admin privileges.',})return}// Proceed with the route for authorized users// ... implementation of the API Route}This example demonstrates an API Route with a two-tier security check for authentication and authorization. It first checks for an active session, and then verifies if the logged-in user is an 'admin'. This approach ensures secure access, limited to authenticated and authorized users, maintaining robust security for request processing.ResourcesNow that you've learned about authentication in Next.js, here are Next.js-compatible libraries and resources to help you implement secure authentication and session management:Auth LibrariesAuth0ClerkKindeLogtoNextAuth.jsOryStack AuthSupabaseStytchWorkOSSession Management LibrariesIron SessionJoseFurther ReadingTo continue learning about authentication and security, check out the following resources:How to think about security in Next.jsUnderstanding XSS AttacksUnderstanding CSRF AttacksThe Copenhagen BookPreviousCypressNextDeployingWas this helpful?supported.Send"
deploying,Deploying,"Pages RouterBuilding Your ApplicationDeployingDeployingCongratulations, it's time to ship to production.You can deploymanaged Next.js with Vercel, or self-host on a Node.js server, Docker image, or even static HTML files. When deploying usingnext start, all Next.js features are supported.Production BuildsRunningnext buildgenerates an optimized version of your application for production. HTML, CSS, and JavaScript files are created based on your pages. JavaScript iscompiledand browser bundles areminifiedusing theNext.js Compilerto help achieve the best performance and supportall modern browsers.Next.js produces a standard deployment output used by managed and self-hosted Next.js. This ensures all features are supported across both methods of deployment. In the next major version, we will be transforming this output into ourBuild Output API specification.Managed Next.js with VercelVercel, the creators and maintainers of Next.js, provide managed infrastructure and a developer experience platform for your Next.js applications.Deploying to Vercel is zero-configuration and provides additional enhancements for scalability, availability, and performance globally. However, all Next.js features are still supported when self-hosted.Learn more aboutNext.js on Vercelordeploy a template for freeto try it out.Self-HostingYou can self-host Next.js in three different ways:A Node.js serverA Docker containerA static export🎥 Watch:Learn more about self-hosting Next.js →YouTube (45 minutes).We have community maintained deployment examples with the following providers:DenoDigitalOceanFlightcontrolFly.ioGitHub PagesGoogle Cloud RunRailwayRenderSSTNode.js ServerNext.js can be deployed to any hosting provider that supports Node.js. Ensure yourpackage.jsonhas the""build""and""start""scripts:package.json{""scripts"":{""dev"":""next dev"",""build"":""next build"",""start"":""next start""}}Then, runnpm run buildto build your application. Finally, runnpm run startto start the Node.js server. This server supports all Next.js features.Docker ImageNext.js can be deployed to any hosting provider that supportsDockercontainers. You can use this approach when deploying to container orchestrators such asKubernetesor when running inside a container in any cloud provider.Install Dockeron your machineClone our example(or themulti-environment example)Build your container:docker build -t nextjs-docker .Run your container:docker run -p 3000:3000 nextjs-dockerNext.js through Docker supports all Next.js features.Static HTML ExportNext.js enables starting as a static site or Single-Page Application (SPA), then later optionally upgrading to use features that require a server.Since Next.js supports thisstatic export, it can be deployed and hosted on any web server that can serve HTML/CSS/JS static assets. This includes tools like AWS S3, Nginx, or Apache.Running as astatic exportdoes not support Next.js features that require a server.Learn more.Good to know:Server Componentsare supported with static exports.FeaturesImage OptimizationImage Optimizationthroughnext/imageworks self-hosted with zero configuration when deploying usingnext start. If you would prefer to have a separate service to optimize images, you canconfigure an image loader.Image Optimization can be used with astatic exportby defining a custom image loader innext.config.js. Note that images are optimized at runtime, not during the build.Good to know:On glibc-based Linux systems, Image Optimization may requireadditional configurationto prevent excessive memory usage.Learn more about thecaching behavior of optimized imagesand how to configure the TTL.You can alsodisable Image Optimizationand still retain other benefits of usingnext/imageif you prefer. For example, if you are optimizing images yourself separately.MiddlewareMiddlewareworks self-hosted with zero configuration when deploying usingnext start. Since it requires access to the incoming request, it is not supported when using astatic export.Middleware uses aruntimethat is a subset of all available Node.js APIs to help ensure low latency, since it may run in front of every route or asset in your application. This runtime does not require running “at the edge” and works in a single-region server. Additional configuration and infrastructure are required to run Middleware in multiple regions.If you are looking to add logic (or use an external package) that requires all Node.js APIs, you might be able to move this logic to alayoutas aServer Component. For example, checkingheadersandredirecting. You can also use headers, cookies, or query parameters toredirectorrewritethroughnext.config.js. If that does not work, you can also use acustom server.Environment VariablesNext.js can support both build time and runtime environment variables.By default, environment variables are only available on the server. To expose an environment variable to the browser, it must be prefixed withNEXT_PUBLIC_. However, these public environment variables will be inlined into the JavaScript bundle duringnext build.To read runtime environment variables, we recommend usinggetServerSidePropsorincrementally adopting the App Router.This allows you to use a singular Docker image that can be promoted through multiple environments with different values.Good to know:You can run code on server startup using theregisterfunction.We do not recommend using theruntimeConfigoption, as this does not work with the standalone output mode. Instead, we recommendincrementally adoptingthe App Router.Caching and ISRNext.js can cache responses, generated static pages, build outputs, and other static assets like images, fonts, and scripts.Caching and revalidating pages (withIncremental Static Regeneration) use thesame shared cache. By default, this cache is stored to the filesystem (on disk) on your Next.js server.This works automatically when self-hostingusing both the Pages and App Router.You can configure the Next.js cache location if you want to persist cached pages and data to durable storage, or share the cache across multiple containers or instances of your Next.js application.Automatic CachingNext.js sets theCache-Controlheader ofpublic, max-age=31536000, immutableto truly immutable assets. It cannot be overridden. These immutable files contain a SHA-hash in the file name, so they can be safely cached indefinitely. For example,Static Image Imports. You canconfigure the TTLfor images.Incremental Static Regeneration (ISR) sets theCache-Controlheader ofs-maxage: <revalidate in getStaticProps>, stale-while-revalidate. This revalidation time is defined in yourgetStaticPropsfunctionin seconds. If you setrevalidate: false, it will default to a one-year cache duration.Dynamically rendered pages set aCache-Controlheader ofprivate, no-cache, no-store, max-age=0, must-revalidateto prevent user-specific data from being cached. This applies to both the App Router and Pages Router. This also includesDraft Mode.Static AssetsIf you want to host static assets on a different domain or CDN, you can use theassetPrefixconfigurationinnext.config.js. Next.js will use this asset prefix when retrieving JavaScript or CSS files. Separating your assets to a different domain does come with the downside of extra time spent on DNS and TLS resolution.Learn more aboutassetPrefix.Configuring CachingBy default, generated cache assets will be stored in memory (defaults to 50mb) and on disk. If you are hosting Next.js using a container orchestration platform like Kubernetes, each pod will have a copy of the cache. To prevent stale data from being shown since the cache is not shared between pods by default, you can configure the Next.js cache to provide a cache handler and disable in-memory caching.To configure the ISR/Data Cache location when self-hosting, you can configure a custom handler in yournext.config.jsfile:next.config.jsmodule.exports={cacheHandler:require.resolve('./cache-handler.js'),cacheMaxMemorySize:0,// disable default in-memory caching}Then, createcache-handler.jsin the root of your project, for example:cache-handler.jsconstcache=newMap()module.exports=classCacheHandler{constructor(options) {this.options=options}asyncget(key) {// This could be stored anywhere, like durable storagereturncache.get(key)}asyncset(key,data,ctx) {// This could be stored anywhere, like durable storagecache.set(key,{value:data,lastModified:Date.now(),tags:ctx.tags,})}asyncrevalidateTag(tags) {// tags is either a string or an array of stringstags=[tags].flat()// Iterate over all entries in the cachefor(let[key,value]ofcache) {// If the value's tags include the specified tag, delete this entryif(value.tags.some((tag)=>tags.includes(tag))) {cache.delete(key)}}}// If you want to have temporary in memory cache for a single request that is reset// before the next request you can leverage this methodresetRequestCache() {}}Using a custom cache handler will allow you to ensure consistency across all pods hosting your Next.js application. For instance, you can save the cached values anywhere, likeRedisor AWS S3.Good to know:revalidatePathis a convenience layer on top of cache tags. CallingrevalidatePathwill call therevalidateTagfunction with a special default tag for the provided page.Build CacheNext.js generates an ID duringnext buildto identify which version of your application is being served. The same build should be used and boot up multiple containers.If you are rebuilding for each stage of your environment, you will need to generate a consistent build ID to use between containers. Use thegenerateBuildIdcommand innext.config.js:next.config.jsmodule.exports={generateBuildId:async()=>{// This could be anything, using the latest git hashreturnprocess.env.GIT_HASH},}Version SkewNext.js will automatically mitigate most instances ofversion skewand automatically reload the application to retrieve new assets when detected. For example, if there is a mismatch in thedeploymentId, transitions between pages will perform a hard navigation versus using a prefetched value.When the application is reloaded, there may be a loss of application state if it's not designed to persist between page navigations. For example, using URL state or local storage would persist state after a page refresh. However, component state likeuseStatewould be lost in such navigations.Vercel provides additionalskew protectionfor Next.js applications to ensure assets and functions from the previous version are still available to older clients, even after the new version is deployed.You can manually configure thedeploymentIdproperty in yournext.config.jsfile to ensure each request uses either?dplquery string orx-deployment-idheader.Manual Graceful ShutdownsWhen self-hosting, you might want to run code when the server shuts down onSIGTERMorSIGINTsignals.You can set the env variableNEXT_MANUAL_SIG_HANDLEtotrueand then register a handler for that signal inside your_document.jsfile. You will need to register the environment variable directly in thepackage.jsonscript, and not in the.envfile.Good to know: Manual signal handling is not available innext dev.package.json{""scripts"":{""dev"":""next dev"",""build"":""next build"",""start"":""NEXT_MANUAL_SIG_HANDLE=true next start""}}pages/_document.jsif(process.env.NEXT_MANUAL_SIG_HANDLE) {process.on('SIGTERM',()=>{console.log('Received SIGTERM: cleaning up')process.exit(0)})process.on('SIGINT',()=>{console.log('Received SIGINT: cleaning up')process.exit(0)})}Production ChecklistRecommendations to ensure the best performance and user experience before taking your Next.js application to production.Static ExportsNext.js enables starting as a static site or Single-Page Application (SPA), then later optionally upgrading to use features that require a server.Multi-ZonesLearn how to build micro-frontends using Next.js Multi-Zones to deploy multiple Next.js apps under a single domain.Continuous Integration (CI) Build CachingLearn how to configure CI to cache Next.js buildsPreviousAuthenticationNextProduction ChecklistWas this helpful?supported.Send"
production checklist,Production Checklist,"Building Your ApplicationDeployingProduction ChecklistProduction ChecklistBefore taking your Next.js application to production, there are some optimizations and patterns you should consider implementing for the best user experience, performance, and security.This page provides best practices that you can use as a reference whenbuilding your application,before going to production, andafter deployment- as well as theautomatic Next.js optimizationsyou should be aware of.Automatic optimizationsThese Next.js optimizations are enabled by default and require no configuration:Code-splitting:Next.js automatically code-splits your application code by pages. This means only the code needed for the current page is loaded on navigation. You may also considerlazy loadingthird-party libraries, where appropriate.Prefetching:When a link to a new route enters the user's viewport, Next.js prefetches the route in background. This makes navigation to new routes almost instant. You can opt out of prefetching, where appropriate.Automatic Static Optimization:Next.js automatically determines that a page is static (can be pre-rendered) if it has no blocking data requirements. Optimized pages can be cached, and served to the end-user from multiple CDN locations. You may opt intoServer-side Rendering, where appropriate.These defaults aim to improve your application's performance, and reduce the cost and amount of data transferred on each network request.During developmentWhile building your application, we recommend using the following features to ensure the best performance and user experience:Routing and rendering<Link>component:Use the<Link>component for client-side navigation and prefetching.Custom Errors:Gracefully handle500and404 errorsData fetching and cachingAPI Routes:Use Route Handlers to access your backend resources, and prevent sensitive secrets from being exposed to the client.Data Caching:Verify whether your data requests are being cached or not, and opt into caching, where appropriate. Ensure requests that don't usegetStaticPropsare cached where appropriate.Incremental Static Regeneration:Use Incremental Static Regeneration to update static pages after they've been built, without rebuilding your entire site.Static Images:Use thepublicdirectory to automatically cache your application's static assets, e.g. images.UI and accessibilityFont Module:Optimize fonts by using the Font Module, which automatically hosts your font files with other static assets, removes external network requests, and reduceslayout shift.<Image>Component:Optimize images by using the Image Component, which automatically optimizes images, prevents layout shift, and serves them in modern formats like WebP.<Script>Component:Optimize third-party scripts by using the Script Component, which automatically defers scripts and prevents them from blocking the main thread.ESLint:Use the built-ineslint-plugin-jsx-a11yplugin to catch accessibility issues early.SecurityEnvironment Variables:Ensure your.env.*files are added to.gitignoreand only public variables are prefixed withNEXT_PUBLIC_.Content Security Policy:Consider adding a Content Security Policy to protect your application against various security threats such as cross-site scripting, clickjacking, and other code injection attacks.Metadata and SEO<Head>Component:Use thenext/headcomponent to add page titles, descriptions, and more.Type safetyTypeScript andTS Plugin:Use TypeScript and the TypeScript plugin for better type-safety, and to help you catch errors early.Before going to productionBefore going to production, you can runnext buildto build your application locally and catch any build errors, then runnext startto measure the performance of your application in a production-like environment.Core Web VitalsLighthouse:Run lighthouse in incognito to gain a better understanding of how your users will experience your site, and to identify areas for improvement. This is a simulated test and should be paired with looking at field data (such as Core Web Vitals).Analyzing bundlesUse the@next/bundle-analyzerpluginto analyze the size of your JavaScript bundles and identify large modules and dependencies that might be impacting your application's performance.Additionally, the following tools can help you understand the impact of adding new dependencies to your application:Import CostPackage PhobiaBundle PhobiabundlejsAfter deploymentDepending on where you deploy your application, you might have access to additional tools and integrations to help you monitor and improve your application's performance.For Vercel deployments, we recommend the following:Analytics:A built-in analytics dashboard to help you understand your application's traffic, including the number of unique visitors, page views, and more.Speed Insights:Real-world performance insights based on visitor data, offering a practical view of how your website is performing in the field.Logging:Runtime and Activity logs to help you debug issues and monitor your application in production. Alternatively, see theintegrations pagefor a list of third-party tools and services.Good to know:To get a comprehensive understanding of the best practices for production deployments on Vercel, including detailed strategies for improving website performance, refer to theVercel Production Checklist.Following these recommendations will help you build a faster, more reliable, and secure application for your users.PreviousDeployingNextStatic ExportsWas this helpful?supported.Send"
static exports,Static Exports,"Building Your ApplicationDeployingStatic ExportsStatic ExportsNext.js enables starting as a static site or Single-Page Application (SPA), then later optionally upgrading to use features that require a server.When runningnext build, Next.js generates an HTML file per route. By breaking a strict SPA into individual HTML files, Next.js can avoid loading unnecessary JavaScript code on the client-side, reducing the bundle size and enabling faster page loads.Since Next.js supports this static export, it can be deployed and hosted on any web server that can serve HTML/CSS/JS static assets.ConfigurationTo enable a static export, change the output mode insidenext.config.js:next.config.js/***@type{import('next').NextConfig}*/constnextConfig={output:'export',// Optional: Change links `/me` -> `/me/` and emit `/me.html` -> `/me/index.html`// trailingSlash: true,// Optional: Prevent automatic `/me` -> `/me/`, instead preserve `href`// skipTrailingSlashRedirect: true,// Optional: Change the output directory `out` -> `dist`// distDir: 'dist',}module.exports=nextConfigAfter runningnext build, Next.js will create anoutfolder with the HTML/CSS/JS assets for your application.You can utilizegetStaticPropsandgetStaticPathsto generate an HTML file for each page in yourpagesdirectory (or more fordynamic routes).Supported FeaturesThe majority of core Next.js features needed to build a static site are supported, including:Dynamic Routes when usinggetStaticPathsPrefetching withnext/linkPreloading JavaScriptDynamic ImportsAny styling options (e.g. CSS Modules, styled-jsx)Client-side data fetchinggetStaticPropsgetStaticPathsImage OptimizationImage Optimizationthroughnext/imagecan be used with a static export by defining a custom image loader innext.config.js. For example, you can optimize images with a service like Cloudinary:next.config.js/**@type{import('next').NextConfig}*/constnextConfig={output:'export',images:{loader:'custom',loaderFile:'./my-loader.ts',},}module.exports=nextConfigThis custom loader will define how to fetch images from a remote source. For example, the following loader will construct the URL for Cloudinary:my-loader.tsTypeScriptJavaScriptTypeScriptexportdefaultfunctioncloudinaryLoader({src,width,quality,}:{src:stringwidth:numberquality?:number}) {constparams=['f_auto','c_limit',`w_${width}`,`q_${quality||'auto'}`]return`https://res.cloudinary.com/demo/image/upload/${params.join(',')}${src}`}You can then usenext/imagein your application, defining relative paths to the image in Cloudinary:app/page.tsxTypeScriptJavaScriptTypeScriptimportImagefrom'next/image'exportdefaultfunctionPage() {return<Imagealt=""turtles""src=""/turtles.jpg""width={300}height={300} />}Unsupported FeaturesFeatures that require a Node.js server, or dynamic logic that cannot be computed during the build process, arenotsupported:Internationalized RoutingAPI RoutesRewritesRedirectsHeadersMiddlewareIncremental Static RegenerationImage Optimizationwith the defaultloaderDraft ModegetStaticPathswithfallback: truegetStaticPathswithfallback: 'blocking'getServerSidePropsDeployingWith a static export, Next.js can be deployed and hosted on any web server that can serve HTML/CSS/JS static assets.When runningnext build, Next.js generates the static export into theoutfolder. For example, let's say you have the following routes://blog/[id]After runningnext build, Next.js will generate the following files:/out/index.html/out/404.html/out/blog/post-1.html/out/blog/post-2.htmlIf you are using a static host like Nginx, you can configure rewrites from incoming requests to the correct files:nginx.confserver{listen80;server_nameacme.com;root/var/www/out;location/ {try_files$uri $uri.html $uri/=404;}# This is necessary when `trailingSlash: false`.# You can omit this when `trailingSlash: true`.location/blog/ {rewrite^/blog/(.*)$/blog/$1.htmlbreak;}error_page404 /404.html;location=/404.html{internal;}}Version HistoryVersionChangesv14.0.0next exporthas been removed in favor of""output"": ""export""v13.4.0App Router (Stable) adds enhanced static export support, including using React Server Components and Route Handlers.v13.3.0next exportis deprecated and replaced with""output"": ""export""PreviousProduction ChecklistNextMulti-ZonesWas this helpful?supported.Send"
multi-zones,Multi-Zones,"Building Your ApplicationDeployingMulti-ZonesMulti-ZonesExamplesWith ZonesMulti-Zones are an approach to micro-frontends that separate a large application on a domain into smaller Next.js applications that each serve a set of paths. This is useful when there are collections of pages unrelated to the other pages in the application. By moving those pages to a separate zone (i.e., a separate application), you can reduce the size of each application which improves build times and removes code that is only necessary for one of the zones. Since applications are decoupled, Multi-Zones also allows other applications on the domain to use their own choice of framework.For example, let's say you have the following set of pages that you would like to split up:/blog/*for all blog posts/dashboard/*for all pages when the user is logged-in to the dashboard/*for the rest of your website not covered by other zonesWith Multi-Zones support, you can create three applications that all are served on the same domain and look the same to the user, but you can develop and deploy each of the applications independently.Navigating between pages in the same zone will perform soft navigations, a navigation that does not require reloading the page. For example, in this diagram, navigating from/to/productswill be a soft navigation.Navigating from a page in one zone to a page in another zone, such as from/to/dashboard, will perform a hard navigation, unloading the resources of the current page and loading the resources of the new page. Pages that are frequently visited together should live in the same zone to avoid hard navigations.How to define a zoneA zone is a normal Next.js application where you also configure anassetPrefixto avoid conflicts with pages and static files in other zones.next.config.js/**@type{import('next').NextConfig}*/constnextConfig={assetPrefix:'/blog-static',}Next.js assets, such as JavaScript and CSS, will be prefixed withassetPrefixto make sure that they don't conflict with assets from other zones. These assets will be served under/assetPrefix/_next/...for each of the zones.The default application handling all paths not routed to another more specific zone does not need anassetPrefix.In versions older than Next.js 15, you may also need an additional rewrite to handle the static assets. This is no longer necessary in Next.js 15.next.config.js/**@type{import('next').NextConfig}*/constnextConfig={assetPrefix:'/blog-static',asyncrewrites() {return{beforeFiles:[{source:'/blog-static/_next/:path+',destination:'/_next/:path+',},],}},}How to route requests to the right zoneWith the Multi Zones set-up, you need to route the paths to the correct zone since they are served by different applications. You can use any HTTP proxy to do this, but one of the Next.js applications can also be used to route requests for the entire domain.To route to the correct zone using a Next.js application, you can userewrites. For each path served by a different zone, you would add a rewrite rule to send that path to the domain of the other zone. For example:next.config.jsasyncrewrites() {return[{source:'/blog',destination:`${process.env.BLOG_DOMAIN}/blog`,},{source:'/blog/:path+',destination:`${process.env.BLOG_DOMAIN}/blog/:path+`,}];}destinationshould be a URL that is served by the zone, including scheme and domain. This should point to the zone's production domain, but it can also be used to route requests tolocalhostin local development.Good to know: URL paths should be unique to a zone. For example, two zones trying to serve/blogwould create a routing conflict.Routing requests using middlewareRouting requests throughrewritesis recommended to minimize latency overhead for the requests, but middleware can also be used when there is a need for a dynamic decision when routing. For example, if you are using a feature flag to decide where a path should be routed such as during a migration, you can use middleware.middleware.jsexportasyncfunctionmiddleware(request) {const{pathname,search}=req.nextUrl;if(pathname==='/your-path'&&myFeatureFlag.isEnabled()) {returnNextResponse.rewrite(`${rewriteDomain}${pathname}${search});}}Linking between zonesLinks to paths in a different zone should use anatag instead of the Next.js<Link>component. This is because Next.js will try to prefetch and soft navigate to any relative path in<Link>component, which will not work across zones.Sharing codeThe Next.js applications that make up the different zones can live in any repository. However, it is often convenient to put these zones in amonorepoto more easily share code. For zones that live in different repositories, code can also be shared using public or private NPM packages.Since the pages in different zones may be released at different times, feature flags can be useful for enabling or disabling features in unison across the different zones.ForNext.js on Vercelapplications, you can use amonorepoto deploy all affected zones with a singlegit push.PreviousStatic ExportsNextContinuous Integration (CI) Build CachingWas this helpful?supported.Send"
continuous integration (ci) build caching,Continuous Integration (CI) Build Caching,"Building Your ApplicationDeployingContinuous Integration (CI) Build CachingContinuous Integration (CI) Build CachingTo improve build performance, Next.js saves a cache to.next/cachethat is shared between builds.To take advantage of this cache in Continuous Integration (CI) environments, your CI workflow will need to be configured to correctly persist the cache between builds.If your CI is not configured to persist.next/cachebetween builds, you may see aNo Cache Detectederror.Here are some example cache configurations for common CI providers:VercelNext.js caching is automatically configured for you. There's no action required on your part. If you are using Turborepo on Vercel,learn more here.CircleCIEdit yoursave_cachestep in.circleci/config.ymlto include.next/cache:steps:-save_cache:key:dependency-cache-{{ checksum ""yarn.lock"" }}paths:-./node_modules-./.next/cacheIf you do not have asave_cachekey, please follow CircleCI'sdocumentation on setting up build caching.Travis CIAdd or merge the following into your.travis.yml:cache:directories:-$HOME/.cache/yarn-node_modules-.next/cacheGitLab CIAdd or merge the following into your.gitlab-ci.yml:cache:key:${CI_COMMIT_REF_SLUG}paths:-node_modules/-.next/cache/Netlify CIUseNetlify Pluginswith@netlify/plugin-nextjs.AWS CodeBuildAdd (or merge in) the following to yourbuildspec.yml:cache:paths:-'node_modules/**/*'# Cache `node_modules` for faster `yarn` or `npm i`-'.next/cache/**/*'# Cache Next.js for faster application rebuildsGitHub ActionsUsing GitHub'sactions/cache, add the following step in your workflow file:uses:actions/cache@v4with:# See here for caching with `yarn` https://github.com/actions/cache/blob/main/examples.md#node---yarn or you can leverage caching with actions/setup-node https://github.com/actions/setup-nodepath:|~/.npm${{ github.workspace }}/.next/cache# Generate a new cache whenever packages or source files change.key:${{ runner.os }}-nextjs-${{ hashFiles('**/package-lock.json') }}-${{ hashFiles('**/*.js', '**/*.jsx', '**/*.ts', '**/*.tsx') }}# If source files changed but packages didn't, rebuild from a prior cache.restore-keys:|${{ runner.os }}-nextjs-${{ hashFiles('**/package-lock.json') }}-Bitbucket PipelinesAdd or merge the following into yourbitbucket-pipelines.ymlat the top level (same level aspipelines):definitions:caches:nextcache:.next/cacheThen reference it in thecachessection of your pipeline'sstep:-step:name:your_step_namecaches:-node-nextcacheHerokuUsing Heroku'scustom cache, add acacheDirectoriesarray in your top-level package.json:""cacheDirectories"": ["".next/cache""]Azure PipelinesUsing Azure Pipelines'Cache task, add the following task to your pipeline yaml file somewhere prior to the task that executesnext build:-task:Cache@2displayName:'Cache .next/cache'inputs:key:next | $(Agent.OS) | yarn.lockpath:'$(System.DefaultWorkingDirectory)/.next/cache'Jenkins (Pipeline)Using Jenkins'Job Cacherplugin, add the following build step to yourJenkinsfilewhere you would normally runnext buildornpm install:stage(""Restore npm packages"") {steps {// Writes lock-file to cache based on the GIT_COMMIT hashwriteFile file:""next-lock.cache"",text:""$GIT_COMMIT""cache(caches:[arbitraryFileCache(path:""node_modules"",includes:""**/*"",cacheValidityDecidingFile:""package-lock.json"")]) {sh ""npm install""}}}stage(""Build"") {steps {// Writes lock-file to cache based on the GIT_COMMIT hashwriteFile file:""next-lock.cache"",text:""$GIT_COMMIT""cache(caches:[arbitraryFileCache(path:"".next/cache"",includes:""**/*"",cacheValidityDecidingFile:""next-lock.cache"")]) {// aka `next build`sh ""npm run build""}}}PreviousMulti-ZonesNextUpgradingWas this helpful?supported.Send"
upgrading,Upgrading,Pages RouterBuilding Your ApplicationUpgradingUpgradingUpgrade your application to newer versions of Next.js or migrate from the Pages Router to the App Router.CodemodsUse codemods to upgrade your Next.js codebase when new features are released.From Pages to AppLearn how to upgrade your existing Next.js application from the Pages Router to the App Router.Migrating from ViteLearn how to migrate your existing React application from Vite to Next.js.Migrating from Create React AppLearn how to migrate your existing React application from Create React App to Next.js.Version 14Upgrade your Next.js Application from Version 13 to 14.Version 13Upgrade your Next.js Application from Version 12 to 13.Version 12Upgrade your Next.js Application from Version 11 to Version 12.Version 11Upgrade your Next.js Application from Version 10 to Version 11.Version 10Upgrade your Next.js Application from Version 9 to Version 10.Version 9Upgrade your Next.js Application from Version 8 to Version 9.PreviousContinuous Integration (CI) Build CachingNextCodemodsWas this helpful?supported.Send
codemods,Codemods,"Building Your ApplicationUpgradingCodemodsCodemodsCodemods are transformations that run on your codebase programmatically. This allows a large number of changes to be programmatically applied without having to manually go through every file.Next.js provides Codemod transformations to help upgrade your Next.js codebase when an API is updated or deprecated.UsageIn your terminal, navigate (cd) into your project's folder, then run:Terminalnpx@next/codemod<transform><path>Replacing<transform>and<path>with appropriate values.transform- name of transformpath- files or directory to transform--dryDo a dry-run, no code will be edited--printPrints the changed output for comparisonCodemods15.0Transform App Router Route Segment Configruntimevalue fromexperimental-edgetoedgeapp-dir-runtime-config-experimental-edgeNote: This codemod is App Router specific.Terminalnpx@next/codemod@latestapp-dir-runtime-config-experimental-edge.This codemod transformsRoute Segment Configruntimevalueexperimental-edgetoedge.For example:exportconstruntime='experimental-edge'Transforms into:exportconstruntime='edge'Migrate to async Dynamic APIsAPIs that opted into dynamic rendering that previously supported synchronous access are now asynchronous. You can read more about this breaking change in theupgrade guide.next-async-request-apiTerminalnpx@next/codemod@latestnext-async-request-api.This codemod will transform dynamic APIs (cookies(),headers()anddraftMode()fromnext/headers) that are now asynchronous to be properly awaited or wrapped withReact.use()if applicable.
When an automatic migration isn't possible, the codemod will either add a typecast (if a TypeScript file) or a comment to inform the user that it needs to be manually reviewed & updated.For example:import{ cookies,headers }from'next/headers'consttoken=cookies().get('token')functionuseToken() {consttoken=cookies().get('token')returntoken}exportdefaultfunctionPage() {constname=cookies().get('name')}functiongetHeader() {returnheaders().get('x-foo')}Transforms into:import{ use }from'react'import{cookies,headers,typeUnsafeUnwrappedCookies,typeUnsafeUnwrappedHeaders,}from'next/headers'consttoken=(cookies()asunknownasUnsafeUnwrappedCookies).get('token')functionuseToken() {consttoken=use(cookies()).get('token')returntoken}exportdefaultasyncfunctionPage() {constname=(awaitcookies()).get('name')}functiongetHeader() {return(headers()asunknownasUnsafeUnwrappedHeaders).get('x-foo')}When we detect property access on theparamsorsearchParamsprops in the page / route entries (page.js,layout.js,route.js, ordefault.js) or thegenerateMetadata/generateViewportAPIs,
it will attempt to transform the callsite from a sync to an async function, and await the property access. If it can't be made async (such as with a client component), it will useReact.useto unwrap the promise .For example:// page.tsxexportdefaultfunctionPage({params,searchParams,}:{params:{ slug:string}searchParams:{ [key:string]:string|string[]|undefined}}) {const{value}=searchParamsif(value==='foo') {// ...}}exportfunctiongenerateMetadata({ params }:{ params:{ slug:string} }) {const{slug}=paramsreturn{title:`My Page -${slug}`,}}Transforms into:// page.tsxexportdefaultasyncfunctionPage(props:{params:Promise<{ slug:string}>searchParams:Promise<{ [key:string]:string|string[]|undefined}>}) {constsearchParams=awaitprops.searchParamsconst{value}=searchParamsif(value==='foo') {// ...}}exportasyncfunctiongenerateMetadata(props:{params:Promise<{ slug:string}>}) {constparams=awaitprops.paramsconst{slug}=paramsreturn{title:`My Page -${slug}`,}}Good to know:When this codemod identifies a spot that might require manual intervention, but we aren't able to determine the exact fix, it will add a comment or typecast to the code to inform the user that it needs to be manually updated. These comments are prefixed with@next/codemod, and typecasts are prefixed withUnsafeUnwrapped.
Your build will error until these comments are explicitly removed.Read more.Replacegeoandipproperties ofNextRequestwith@vercel/functionsnext-request-geo-ipTerminalnpx@next/codemod@latestnext-request-geo-ip.This codemod installs@vercel/functionsand transformsgeoandipproperties ofNextRequestwith corresponding@vercel/functionsfeatures.For example:importtype{ NextRequest }from'next/server'exportfunctionGET(req:NextRequest) {const{geo,ip}=req}Transforms into:importtype{ NextRequest }from'next/server'import{ geolocation,ipAddress }from'@vercel/functions'exportfunctionGET(req:NextRequest) {constgeo=geolocation(req)constip=ipAddress(req)}14.0MigrateImageResponseimportsnext-og-importTerminalnpx@next/codemod@latestnext-og-import.This codemod moves transforms imports fromnext/servertonext/ogfor usage ofDynamic OG Image Generation.For example:import{ ImageResponse }from'next/server'Transforms into:import{ ImageResponse }from'next/og'Useviewportexportmetadata-to-viewport-exportTerminalnpx@next/codemod@latestmetadata-to-viewport-export.This codemod migrates certain viewport metadata toviewportexport.For example:exportconstmetadata={title:'My App',themeColor:'dark',viewport:{width:1,},}Transforms into:exportconstmetadata={title:'My App',}exportconstviewport={width:1,themeColor:'dark',}13.2Use Built-in Fontbuilt-in-next-fontTerminalnpx@next/codemod@latestbuilt-in-next-font.This codemod uninstalls the@next/fontpackage and transforms@next/fontimports into the built-innext/font.For example:import{ Inter }from'@next/font/google'Transforms into:import{ Inter }from'next/font/google'13.0Rename Next Image Importsnext-image-to-legacy-imageTerminalnpx@next/codemod@latestnext-image-to-legacy-image.Safely renamesnext/imageimports in existing Next.js 10, 11, or 12 applications tonext/legacy/imagein Next.js 13. Also renamesnext/future/imagetonext/image.For example:pages/index.jsimportImage1from'next/image'importImage2from'next/future/image'exportdefaultfunctionHome() {return(<div><Image1src=""/test.jpg""width=""200""height=""300""/><Image2src=""/test.png""width=""500""height=""400""/></div>)}Transforms into:pages/index.js// 'next/image' becomes 'next/legacy/image'importImage1from'next/legacy/image'// 'next/future/image' becomes 'next/image'importImage2from'next/image'exportdefaultfunctionHome() {return(<div><Image1src=""/test.jpg""width=""200""height=""300""/><Image2src=""/test.png""width=""500""height=""400""/></div>)}Migrate to the New Image Componentnext-image-experimentalTerminalnpx@next/codemod@latestnext-image-experimental.Dangerously migrates fromnext/legacy/imageto the newnext/imageby adding inline styles and removing unused props.Removeslayoutprop and addsstyle.RemovesobjectFitprop and addsstyle.RemovesobjectPositionprop and addsstyle.RemoveslazyBoundaryprop.RemoveslazyRootprop.Remove<a>Tags From Link Componentsnew-linkTerminalnpx@next/codemod@latestnew-link.Remove<a>tags insideLink Components, or add alegacyBehaviorprop to Links that cannot be auto-fixed.For example:<Linkhref=""/about""><a>About</a></Link>// transforms into<Linkhref=""/about"">About</Link><Linkhref=""/about""><aonClick={()=>console.log('clicked')}>About</a></Link>// transforms into<Linkhref=""/about""onClick={()=>console.log('clicked')}>About</Link>In cases where auto-fixing can't be applied, thelegacyBehaviorprop is added. This allows your app to keep functioning using the old behavior for that particular link.constComponent=()=><a>About</a><Linkhref=""/about""><Component/></Link>// becomes<Linkhref=""/about""legacyBehavior><Component/></Link>11Migrate from CRAcra-to-nextTerminalnpx@next/codemodcra-to-nextMigrates a Create React App project to Next.js; creating a Pages Router and necessary config to match behavior. Client-side only rendering is leveraged initially to prevent breaking compatibility due towindowusage during SSR and can be enabled seamlessly to allow the gradual adoption of Next.js specific features.Please share any feedback related to this transformin this discussion.10Add React importsadd-missing-react-importTerminalnpx@next/codemodadd-missing-react-importTransforms files that do not importReactto include the import in order for the newReact JSX transformto work.For example:my-component.jsexportdefaultclassHomeextendsReact.Component{render() {return<div>Hello World</div>}}Transforms into:my-component.jsimportReactfrom'react'exportdefaultclassHomeextendsReact.Component{render() {return<div>Hello World</div>}}9Transform Anonymous Components into Named Componentsname-default-componentTerminalnpx@next/codemodname-default-componentVersions 9 and above.Transforms anonymous components into named components to make sure they work withFast Refresh.For example:my-component.jsexportdefaultfunction() {return<div>Hello World</div>}Transforms into:my-component.jsexportdefaultfunctionMyComponent() {return<div>Hello World</div>}The component will have a camel-cased name based on the name of the file, and it also works with arrow functions.8Transform AMP HOC into page configwithamp-to-configTerminalnpx@next/codemodwithamp-to-configTransforms thewithAmpHOC into Next.js 9 page configuration.For example:// Beforeimport{ withAmp }from'next/amp'functionHome() {return<h1>My AMP Page</h1>}exportdefaultwithAmp(Home)// AfterexportdefaultfunctionHome() {return<h1>My AMP Page</h1>}exportconstconfig={amp:true,}6UsewithRouterurl-to-withrouterTerminalnpx@next/codemodurl-to-withrouterTransforms the deprecated automatically injectedurlproperty on top level pages to usingwithRouterand therouterproperty it injects. Read more here:https://nextjs.org/docs/messages/url-deprecatedFor example:FromimportReactfrom'react'exportdefaultclassextendsReact.Component{render() {const{pathname}=this.props.urlreturn<div>Current pathname: {pathname}</div>}}ToimportReactfrom'react'import{ withRouter }from'next/router'exportdefaultwithRouter(classextendsReact.Component{render() {const{pathname}=this.props.routerreturn<div>Current pathname: {pathname}</div>}})This is one case. All the cases that are transformed (and tested) can be found in the__testfixtures__directory.PreviousUpgradingNextFrom Pages to AppWas this helpful?supported.Send"
from pages to app,From Pages to App,"Building Your ApplicationUpgradingFrom Pages to AppFrom Pages to AppThis guide will help you:Update your Next.js application from version 12 to version 13Upgrade features that work in both thepagesand theappdirectoriesIncrementally migrate your existing application frompagestoappUpgradingNode.js VersionThe minimum Node.js version is nowv18.17. See theNode.js documentationfor more information.Next.js VersionTo update to Next.js version 13, run the following command using your preferred package manager:Terminalnpminstallnext@latestreact@latestreact-dom@latestESLint VersionIf you're using ESLint, you need to upgrade your ESLint version:Terminalnpminstall-Deslint-config-next@latestGood to know: You may need to restart the ESLint server in VS Code for the ESLint changes to take effect. Open the Command Palette (cmd+shift+pon Mac;ctrl+shift+pon Windows) and search forESLint: Restart ESLint Server.Next StepsAfter you've updated, see the following sections for next steps:Upgrade new features: A guide to help you upgrade to new features such as the improved Image and Link Components.Migrate from thepagestoappdirectory: A step-by-step guide to help you incrementally migrate from thepagesto theappdirectory.Upgrading New FeaturesNext.js 13 introduced the newApp Routerwith new features and conventions. The new Router is available in theappdirectory and co-exists with thepagesdirectory.Upgrading to Next.js 13 doesnotrequire using the App Router. You can continue usingpageswith new features that work in both directories, such as the updatedImage component,Link component,Script component, andFont optimization.<Image/>ComponentNext.js 12 introduced new improvements to the Image Component with a temporary import:next/future/image. These improvements included less client-side JavaScript, easier ways to extend and style images, better accessibility, and native browser lazy loading.In version 13, this new behavior is now the default fornext/image.There are two codemods to help you migrate to the new Image Component:next-image-to-legacy-imagecodemod: Safely and automatically renamesnext/imageimports tonext/legacy/image. Existing components will maintain the same behavior.next-image-experimentalcodemod: Dangerously adds inline styles and removes unused props. This will change the behavior of existing components to match the new defaults. To use this codemod, you need to run thenext-image-to-legacy-imagecodemod first.<Link>ComponentThe<Link>Componentno longer requires manually adding an<a>tag as a child. This behavior was added as an experimental option inversion 12.2and is now the default. In Next.js 13,<Link>always renders<a>and allows you to forward props to the underlying tag.For example:importLinkfrom'next/link'// Next.js 12: `<a>` has to be nested otherwise it's excluded<Linkhref=""/about""><a>About</a></Link>// Next.js 13: `<Link>` always renders `<a>` under the hood<Linkhref=""/about"">About</Link>To upgrade your links to Next.js 13, you can use thenew-linkcodemod.<Script>ComponentThe behavior ofnext/scripthas been updated to support bothpagesandapp, but some changes need to be made to ensure a smooth migration:Move anybeforeInteractivescripts you previously included in_document.jsto the root layout file (app/layout.tsx).The experimentalworkerstrategy does not yet work inappand scripts denoted with this strategy will either have to be removed or modified to use a different strategy (e.g.lazyOnload).onLoad,onReady, andonErrorhandlers will not work in Server Components so make sure to move them to aClient Componentor remove them altogether.Font OptimizationPreviously, Next.js helped you optimize fonts byinlining font CSS. Version 13 introduces the newnext/fontmodule which gives you the ability to customize your font loading experience while still ensuring great performance and privacy.next/fontis supported in both thepagesandappdirectories.Whileinlining CSSstill works inpages, it does not work inapp. You should usenext/fontinstead.See theFont Optimizationpage to learn how to usenext/font.Migrating frompagestoapp🎥 Watch:Learn how to incrementally adopt the App Router →YouTube (16 minutes).Moving to the App Router may be the first time using React features that Next.js builds on top of such as Server Components, Suspense, and more. When combined with new Next.js features such asspecial filesandlayouts, migration means new concepts, mental models, and behavioral changes to learn.We recommend reducing the combined complexity of these updates by breaking down your migration into smaller steps. Theappdirectory is intentionally designed to work simultaneously with thepagesdirectory to allow for incremental page-by-page migration.Theappdirectory supports nested routesandlayouts.Learn more.Use nested folders to define routes and a specialpage.jsfile to make a route segment publicly accessible.Learn more.Special file conventionsare used to create UI for each route segment. The most common special files arepage.jsandlayout.js.Usepage.jsto define UI unique to a route.Uselayout.jsto define UI that is shared across multiple routes..js,.jsx, or.tsxfile extensions can be used for special files.You can colocate other files inside theappdirectory such as components, styles, tests, and more.Learn more.Data fetching functions likegetServerSidePropsandgetStaticPropshave been replaced witha new APIinsideapp.getStaticPathshas been replaced withgenerateStaticParams.pages/_app.jsandpages/_document.jshave been replaced with a singleapp/layout.jsroot layout.Learn more.pages/_error.jshas been replaced with more granularerror.jsspecial files.Learn more.pages/404.jshas been replaced with thenot-found.jsfile.pages/api/*API Routes have been replaced with theroute.js(Route Handler) special file.Step 1: Creating theappdirectoryUpdate to the latest Next.js version (requires 13.4 or greater):npminstallnext@latestThen, create a newappdirectory at the root of your project (orsrc/directory).Step 2: Creating a Root LayoutCreate a newapp/layout.tsxfile inside theappdirectory. This is aroot layoutthat will apply to all routes insideapp.app/layout.tsxTypeScriptJavaScriptTypeScriptexportdefaultfunctionRootLayout({// Layouts must accept a children prop.// This will be populated with nested layouts or pageschildren,}:{children:React.ReactNode}) {return(<htmllang=""en""><body>{children}</body></html>)}Theappdirectorymustinclude a root layout.The root layout must define<html>, and<body>tags since Next.js does not automatically create themThe root layout replaces thepages/_app.tsxandpages/_document.tsxfiles..js,.jsx, or.tsxextensions can be used for layout files.To manage<head>HTML elements, you can use thebuilt-in SEO support:app/layout.tsxTypeScriptJavaScriptTypeScriptimporttype{ Metadata }from'next'exportconstmetadata:Metadata={title:'Home',description:'Welcome to Next.js',}Migrating_document.jsand_app.jsIf you have an existing_appor_documentfile, you can copy the contents (e.g. global styles) to the root layout (app/layout.tsx). Styles inapp/layout.tsxwillnotapply topages/*. You should keep_app/_documentwhile migrating to prevent yourpages/*routes from breaking. Once fully migrated, you can then safely delete them.If you are using any React Context providers, they will need to be moved to aClient Component.Migrating thegetLayout()pattern to Layouts (Optional)Next.js recommended adding aproperty to Page componentsto achieve per-page layouts in thepagesdirectory. This pattern can be replaced with native support fornested layoutsin theappdirectory.See before and after exampleBeforecomponents/DashboardLayout.jsexportdefaultfunctionDashboardLayout({ children }) {return(<div><h2>My Dashboard</h2>{children}</div>)}pages/dashboard/index.jsimportDashboardLayoutfrom'../components/DashboardLayout'exportdefaultfunctionPage() {return<p>My Page</p>}Page.getLayout=functiongetLayout(page) {return<DashboardLayout>{page}</DashboardLayout>}AfterRemove thePage.getLayoutproperty frompages/dashboard/index.jsand follow thesteps for migrating pagesto theappdirectory.app/dashboard/page.jsexportdefaultfunctionPage() {return<p>My Page</p>}Move the contents ofDashboardLayoutinto a newClient Componentto retainpagesdirectory behavior.app/dashboard/DashboardLayout.js'use client'// this directive should be at top of the file, before any imports.// This is a Client ComponentexportdefaultfunctionDashboardLayout({ children }) {return(<div><h2>My Dashboard</h2>{children}</div>)}Import theDashboardLayoutinto a newlayout.jsfile inside theappdirectory.app/dashboard/layout.jsimportDashboardLayoutfrom'./DashboardLayout'// This is a Server ComponentexportdefaultfunctionLayout({ children }) {return<DashboardLayout>{children}</DashboardLayout>}You can incrementally move non-interactive parts ofDashboardLayout.js(Client Component) intolayout.js(Server Component) to reduce the amount of component JavaScript you send to the client.Step 3: Migratingnext/headIn thepagesdirectory, thenext/headReact component is used to manage<head>HTML elements such astitleandmeta. In theappdirectory,next/headis replaced with the newbuilt-in SEO support.Before:pages/index.tsxTypeScriptJavaScriptTypeScriptimportHeadfrom'next/head'exportdefaultfunctionPage() {return(<><Head><title>My page title</title></Head></>)}After:app/page.tsxTypeScriptJavaScriptTypeScriptimporttype{ Metadata }from'next'exportconstmetadata:Metadata={title:'My Page Title',}exportdefaultfunctionPage() {return'...'}See all metadata options.Step 4: Migrating PagesPages in theappdirectoryareServer Componentsby default. This is different from thepagesdirectory where pages areClient Components.Data fetchinghas changed inapp.getServerSideProps,getStaticPropsandgetInitialPropshave been replaced with a simpler API.Theappdirectory uses nested folders to define routes and a specialpage.jsfile to make a route segment publicly accessible.pagesDirectoryappDirectoryRouteindex.jspage.js/about.jsabout/page.js/aboutblog/[slug].jsblog/[slug]/page.js/blog/post-1We recommend breaking down the migration of a page into two main steps:Step 1: Move the default exported Page Component into a new Client Component.Step 2: Import the new Client Component into a newpage.jsfile inside theappdirectory.Good to know: This is the easiest migration path because it has the most comparable behavior to thepagesdirectory.Step 1: Create a new Client ComponentCreate a new separate file inside theappdirectory (i.e.app/home-page.tsxor similar) that exports a Client Component. To define Client Components, add the'use client'directive to the top of the file (before any imports).Similar to the Pages Router, there is anoptimization stepto prerender Client Components to static HTML on the initial page load.Move the default exported page component frompages/index.jstoapp/home-page.tsx.app/home-page.tsxTypeScriptJavaScriptTypeScript'use client'// This is a Client Component (same as components in the `pages` directory)// It receives data as props, has access to state and effects, and is// prerendered on the server during the initial page load.exportdefaultfunctionHomePage({ recentPosts }) {return(<div>{recentPosts.map((post)=>(<divkey={post.id}>{post.title}</div>))}</div>)}Step 2: Create a new pageCreate a newapp/page.tsxfile inside theappdirectory. This is a Server Component by default.Import thehome-page.tsxClient Component into the page.If you were fetching data inpages/index.js, move the data fetching logic directly into the Server Component using the newdata fetching APIs. See thedata fetching upgrade guidefor more details.app/page.tsxTypeScriptJavaScriptTypeScript// Import your Client ComponentimportHomePagefrom'./home-page'asyncfunctiongetPosts() {constres=awaitfetch('https://...')constposts=awaitres.json()returnposts}exportdefaultasyncfunctionPage() {// Fetch data directly in a Server ComponentconstrecentPosts=awaitgetPosts()// Forward fetched data to your Client Componentreturn<HomePagerecentPosts={recentPosts} />}If your previous page useduseRouter, you'll need to update to the new routing hooks.Learn more.Start your development server and visithttp://localhost:3000. You should see your existing index route, now served through the app directory.Step 5: Migrating Routing HooksA new router has been added to support the new behavior in theappdirectory.Inapp, you should use the three new hooks imported fromnext/navigation:useRouter(),usePathname(), anduseSearchParams().The newuseRouterhook is imported fromnext/navigationand has different behavior to theuseRouterhook inpageswhich is imported fromnext/router.TheuseRouterhook imported fromnext/routeris not supported in theappdirectory but can continue to be used in thepagesdirectory.The newuseRouterdoes not return thepathnamestring. Use the separateusePathnamehook instead.The newuseRouterdoes not return thequeryobject. Search parameters and dynamic route parameters are now separate. Use theuseSearchParamsanduseParamshooks instead.You can useuseSearchParamsandusePathnametogether to listen to page changes. See theRouter Eventssection for more details.These new hooks are only supported in Client Components. They cannot be used in Server Components.app/example-client-component.tsxTypeScriptJavaScriptTypeScript'use client'import{ useRouter,usePathname,useSearchParams }from'next/navigation'exportdefaultfunctionExampleClientComponent() {constrouter=useRouter()constpathname=usePathname()constsearchParams=useSearchParams()// ...}In addition, the newuseRouterhook has the following changes:isFallbackhas been removed becausefallbackhasbeen replaced.Thelocale,locales,defaultLocales,domainLocalesvalues have been removed because built-in i18n Next.js features are no longer necessary in theappdirectory.Learn more about i18n.basePathhas been removed. The alternative will not be part ofuseRouter. It has not yet been implemented.asPathhas been removed because the concept ofashas been removed from the new router.isReadyhas been removed because it is no longer necessary. Duringstatic rendering, any component that uses theuseSearchParams()hook will skip the prerendering step and instead be rendered on the client at runtime.routehas been removed.usePathnameoruseSelectedLayoutSegments()provide an alternative.View theuseRouter()API reference.Sharing components betweenpagesandappTo keep components compatible between thepagesandapprouters, refer to theuseRouterhook fromnext/compat/router.
This is theuseRouterhook from thepagesdirectory, but intended to be used while sharing components between routers. Once you are ready to use it only on theapprouter, update to the newuseRouterfromnext/navigation.Step 6: Migrating Data Fetching MethodsThepagesdirectory usesgetServerSidePropsandgetStaticPropsto fetch data for pages. Inside theappdirectory, these previous data fetching functions are replaced with asimpler APIbuilt on top offetch()andasyncReact Server Components.app/page.tsxTypeScriptJavaScriptTypeScriptexportdefaultasyncfunctionPage() {// This request should be cached until manually invalidated.// Similar to `getStaticProps`.// `force-cache` is the default and can be omitted.conststaticData=awaitfetch(`https://...`,{ cache:'force-cache'})// This request should be refetched on every request.// Similar to `getServerSideProps`.constdynamicData=awaitfetch(`https://...`,{ cache:'no-store'})// This request should be cached with a lifetime of 10 seconds.// Similar to `getStaticProps` with the `revalidate` option.constrevalidatedData=awaitfetch(`https://...`,{next:{ revalidate:10},})return<div>...</div>}Server-side Rendering (getServerSideProps)In thepagesdirectory,getServerSidePropsis used to fetch data on the server and forward props to the default exported React component in the file. The initial HTML for the page is prerendered from the server, followed by ""hydrating"" the page in the browser (making it interactive).pages/dashboard.js// `pages` directoryexportasyncfunctiongetServerSideProps() {constres=awaitfetch(`https://...`)constprojects=awaitres.json()return{ props:{ projects } }}exportdefaultfunctionDashboard({ projects }) {return(<ul>{projects.map((project)=>(<likey={project.id}>{project.name}</li>))}</ul>)}In the App Router, we can colocate our data fetching inside our React components usingServer Components. This allows us to send less JavaScript to the client, while maintaining the rendered HTML from the server.By setting thecacheoption tono-store, we can indicate that the fetched data shouldnever be cached. This is similar togetServerSidePropsin thepagesdirectory.app/dashboard/page.tsxTypeScriptJavaScriptTypeScript// `app` directory// This function can be named anythingasyncfunctiongetProjects() {constres=awaitfetch(`https://...`,{ cache:'no-store'})constprojects=awaitres.json()returnprojects}exportdefaultasyncfunctionDashboard() {constprojects=awaitgetProjects()return(<ul>{projects.map((project)=>(<likey={project.id}>{project.name}</li>))}</ul>)}Accessing Request ObjectIn thepagesdirectory, you can retrieve request-based data based on the Node.js HTTP API.For example, you can retrieve thereqobject fromgetServerSidePropsand use it to retrieve the request's cookies and headers.pages/index.js// `pages` directoryexportasyncfunctiongetServerSideProps({ req,query }) {constauthHeader=req.getHeaders()['authorization'];consttheme=req.cookies['theme'];return{ props:{...}}}exportdefaultfunctionPage(props) {return...}Theappdirectory exposes new read-only functions to retrieve request data:headers: Based on the Web Headers API, and can be used insideServer Componentsto retrieve request headers.cookies: Based on the Web Cookies API, and can be used insideServer Componentsto retrieve cookies.app/page.tsxTypeScriptJavaScriptTypeScript// `app` directoryimport{ cookies,headers }from'next/headers'asyncfunctiongetData() {constauthHeader=(awaitheaders()).get('authorization')return'...'}exportdefaultasyncfunctionPage() {// You can use `cookies` or `headers` inside Server Components// directly or in your data fetching functionconsttheme=(awaitcookies()).get('theme')constdata=awaitgetData()return'...'}Static Site Generation (getStaticProps)In thepagesdirectory, thegetStaticPropsfunction is used to pre-render a page at build time. This function can be used to fetch data from an external API or directly from a database, and pass this data down to the entire page as it's being generated during the build.pages/index.js// `pages` directoryexportasyncfunctiongetStaticProps() {constres=awaitfetch(`https://...`)constprojects=awaitres.json()return{ props:{ projects } }}exportdefaultfunctionIndex({ projects }) {returnprojects.map((project)=><div>{project.name}</div>)}In theappdirectory, data fetching withfetch()will default tocache: 'force-cache', which will cache the request data until manually invalidated. This is similar togetStaticPropsin thepagesdirectory.app/page.js// `app` directory// This function can be named anythingasyncfunctiongetProjects() {constres=awaitfetch(`https://...`)constprojects=awaitres.json()returnprojects}exportdefaultasyncfunctionIndex() {constprojects=awaitgetProjects()returnprojects.map((project)=><div>{project.name}</div>)}Dynamic paths (getStaticPaths)In thepagesdirectory, thegetStaticPathsfunction is used to define the dynamic paths that should be pre-rendered at build time.pages/posts/[id].js// `pages` directoryimportPostLayoutfrom'@/components/post-layout'exportasyncfunctiongetStaticPaths() {return{paths:[{ params:{ id:'1'} },{ params:{ id:'2'} }],}}exportasyncfunctiongetStaticProps({ params }) {constres=awaitfetch(`https://.../posts/${params.id}`)constpost=awaitres.json()return{ props:{ post } }}exportdefaultfunctionPost({ post }) {return<PostLayoutpost={post} />}In theappdirectory,getStaticPathsis replaced withgenerateStaticParams.generateStaticParamsbehaves similarly togetStaticPaths, but has a simplified API for returning route parameters and can be used insidelayouts. The return shape ofgenerateStaticParamsis an array of segments instead of an array of nestedparamobjects or a string of resolved paths.app/posts/[id]/page.js// `app` directoryimportPostLayoutfrom'@/components/post-layout'exportasyncfunctiongenerateStaticParams() {return[{ id:'1'},{ id:'2'}]}asyncfunctiongetPost(params) {constres=awaitfetch(`https://.../posts/${(awaitparams).id}`)constpost=awaitres.json()returnpost}exportdefaultasyncfunctionPost({ params }) {constpost=awaitgetPost(params)return<PostLayoutpost={post} />}Using the namegenerateStaticParamsis more appropriate thangetStaticPathsfor the new model in theappdirectory. Thegetprefix is replaced with a more descriptivegenerate, which sits better alone now thatgetStaticPropsandgetServerSidePropsare no longer necessary. ThePathssuffix is replaced byParams, which is more appropriate for nested routing with multiple dynamic segments.ReplacingfallbackIn thepagesdirectory, thefallbackproperty returned fromgetStaticPathsis used to define the behavior of a page that isn't pre-rendered at build time. This property can be set totrueto show a fallback page while the page is being generated,falseto show a 404 page, orblockingto generate the page at request time.pages/posts/[id].js// `pages` directoryexportasyncfunctiongetStaticPaths() {return{paths:[],fallback:'blocking'};}exportasyncfunctiongetStaticProps({ params }) {...}exportdefaultfunctionPost({ post }) {return...}In theappdirectory theconfig.dynamicParamspropertycontrols how params outside ofgenerateStaticParamsare handled:true: (default) Dynamic segments not included ingenerateStaticParamsare generated on demand.false: Dynamic segments not included ingenerateStaticParamswill return a 404.This replaces thefallback: true | false | 'blocking'option ofgetStaticPathsin thepagesdirectory. Thefallback: 'blocking'option is not included indynamicParamsbecause the difference between'blocking'andtrueis negligible with streaming.app/posts/[id]/page.js// `app` directoryexportconstdynamicParams=true;exportasyncfunctiongenerateStaticParams() {return[...]}asyncfunctiongetPost(params) {...}exportdefaultasyncfunctionPost({ params }) {constpost=awaitgetPost(params);return...}WithdynamicParamsset totrue(the default), when a route segment is requested that hasn't been generated, it will be server-rendered and cached.Incremental Static Regeneration (getStaticPropswithrevalidate)In thepagesdirectory, thegetStaticPropsfunction allows you to add arevalidatefield to automatically regenerate a page after a certain amount of time.pages/index.js// `pages` directoryexportasyncfunctiongetStaticProps() {constres=awaitfetch(`https://.../posts`)constposts=awaitres.json()return{props:{ posts },revalidate:60,}}exportdefaultfunctionIndex({ posts }) {return(<Layout><PostListposts={posts} /></Layout>)}In theappdirectory, data fetching withfetch()can userevalidate, which will cache the request for the specified amount of seconds.app/page.js// `app` directoryasyncfunctiongetPosts() {constres=awaitfetch(`https://.../posts`,{ next:{ revalidate:60} })constdata=awaitres.json()returndata.posts}exportdefaultasyncfunctionPostList() {constposts=awaitgetPosts()returnposts.map((post)=><div>{post.name}</div>)}API RoutesAPI Routes continue to work in thepages/apidirectory without any changes. However, they have been replaced byRoute Handlersin theappdirectory.Route Handlers allow you to create custom request handlers for a given route using the WebRequestandResponseAPIs.app/api/route.tsTypeScriptJavaScriptTypeScriptexportasyncfunctionGET(request:Request) {}Good to know: If you previously used API routes to call an external API from the client, you can now useServer Componentsinstead to securely fetch data. Learn more aboutdata fetching.Single-Page ApplicationsIf you are also migrating to Next.js from a Single-Page Application (SPA) at the same time, see ourdocumentationto learn more.Step 7: StylingIn thepagesdirectory, global stylesheets are restricted to onlypages/_app.js. With theappdirectory, this restriction has been lifted. Global styles can be added to any layout, page, or component.CSS ModulesTailwind CSSGlobal StylesCSS-in-JSExternal StylesheetsSassTailwind CSSIf you're using Tailwind CSS, you'll need to add theappdirectory to yourtailwind.config.jsfile:tailwind.config.jsmodule.exports={content:['./app/**/*.{js,ts,jsx,tsx,mdx}',// <-- Add this line'./pages/**/*.{js,ts,jsx,tsx,mdx}','./components/**/*.{js,ts,jsx,tsx,mdx}',],}You'll also need to import your global styles in yourapp/layout.jsfile:app/layout.jsimport'../styles/globals.css'exportdefaultfunctionRootLayout({ children }) {return(<htmllang=""en""><body>{children}</body></html>)}Learn more aboutstyling with Tailwind CSSUsing App Router together with Pages RouterWhen navigating between routes served by the different Next.js routers, there will be a hard navigation. Automatic link prefetching withnext/linkwill not prefetch across routers.Instead, you canoptimize navigationsbetween App Router and Pages Router to retain the prefetched and fast page transitions.Learn more.CodemodsNext.js provides Codemod transformations to help upgrade your codebase when a feature is deprecated. SeeCodemodsfor more information.PreviousCodemodsNextMigrating from ViteWas this helpful?supported.Send"
migrating from vite,Migrating from Vite,"Building Your ApplicationUpgradingMigrating from ViteMigrating from ViteThis guide will help you migrate an existing Vite application to Next.js.Why Switch?There are several reasons why you might want to switch from Vite to Next.js:Slow initial page loading timeIf you have built your application with thedefault Vite plugin for React, your application is a purely client-side application. Client-side only applications, also known as single-page applications (SPAs), often experience slow initial page loading time. This happens due to a couple of reasons:The browser needs to wait for the React code and your entire application bundle to download and run before your code is able to send requests to load some data.Your application code grows with every new feature and extra dependency you add.No automatic code splittingThe previous issue of slow loading times can be somewhat managed with code splitting. However, if you try to do code splitting manually, you'll often make performance worse. It's easy to inadvertently introduce network waterfalls when code-splitting manually. Next.js provides automatic code splitting built into its router.Network waterfallsA common cause of poor performance occurs when applications make sequential client-server requests to fetch data. One common pattern for data fetching in an SPA is to initially render a placeholder, and then fetch data after the component has mounted. Unfortunately, this means that a child component that fetches data can't start fetching until the parent component has finished loading its own data.While fetching data on the client is supported with Next.js, it also gives you the option to shift data fetching to the server, which can eliminate client-server waterfalls.Fast and intentional loading statesWith built-in support forstreaming through React Suspense, you can be more intentional about which parts of your UI you want to load first and in what order without introducing network waterfalls.This enables you to build pages that are faster to load and eliminatelayout shifts.Choose the data fetching strategyDepending on your needs, Next.js allows you to choose your data fetching strategy on a page and component basis. You can decide to fetch at build time, at request time on the server, or on the client. For example, you can fetch data from your CMS and render your blog posts at build time, which can then be efficiently cached on a CDN.MiddlewareNext.js Middlewareallows you to run code on the server before a request is completed. This is especially useful to avoid having a flash of unauthenticated content when the user visits an authenticated-only page by redirecting the user to a login page. The middleware is also useful for experimentation andinternationalization.Built-in OptimizationsImages,fonts, andthird-party scriptsoften have significant impact on an application's performance. Next.js comes with built-in components that automatically optimize those for you.Migration StepsOur goal with this migration is to get a working Next.js application as quickly as possible, so that
you can then adopt Next.js features incrementally. To begin with, we'll keep it as a purely
client-side application (SPA) without migrating your existing router. This helps minimize the
chances of encountering issues during the migration process and reduces merge conflicts.Step 1: Install the Next.js DependencyThe first thing you need to do is to installnextas a dependency:Terminalnpminstallnext@latestStep 2: Create the Next.js Configuration FileCreate anext.config.mjsat the root of your project. This file will hold yourNext.js configuration options.next.config.mjs/**@type{import('next').NextConfig}*/constnextConfig={output:'export',// Outputs a Single-Page Application (SPA).distDir:'./dist',// Changes the build output directory to `./dist/`.}exportdefaultnextConfigGood to know:You can use either.jsor.mjsfor your Next.js configuration file.Step 3: Update TypeScript ConfigurationIf you're using TypeScript, you need to update yourtsconfig.jsonfile with the following changes
to make it compatible with Next.js. If you're not using TypeScript, you can skip this step.Remove theproject referencetotsconfig.node.jsonAdd./dist/types/**/*.tsand./next-env.d.tsto theincludearrayAdd./node_modulesto theexcludearrayAdd{ ""name"": ""next"" }to thepluginsarray incompilerOptions:""plugins"": [{ ""name"": ""next"" }]SetesModuleInteroptotrue:""esModuleInterop"": trueSetjsxtopreserve:""jsx"": ""preserve""SetallowJstotrue:""allowJs"": trueSetforceConsistentCasingInFileNamestotrue:""forceConsistentCasingInFileNames"": trueSetincrementaltotrue:""incremental"": trueHere's an example of a workingtsconfig.jsonwith those changes:tsconfig.json{""compilerOptions"":{""target"":""ES2020"",""useDefineForClassFields"":true,""lib"":[""ES2020"",""DOM"",""DOM.Iterable""],""module"":""ESNext"",""esModuleInterop"":true,""skipLibCheck"":true,""moduleResolution"":""bundler"",""allowImportingTsExtensions"":true,""resolveJsonModule"":true,""isolatedModules"":true,""noEmit"":true,""jsx"":""preserve"",""strict"":true,""noUnusedLocals"":true,""noUnusedParameters"":true,""noFallthroughCasesInSwitch"":true,""allowJs"":true,""forceConsistentCasingInFileNames"":true,""incremental"":true,""plugins"":[{""name"":""next""}]},""include"":[""./src"",""./dist/types/**/*.ts"",""./next-env.d.ts""],""exclude"":[""./node_modules""]}You can find more information about configuring TypeScript on theNext.js docs.Step 4: Create the Root LayoutA Next.jsApp Routerapplication must include aroot layoutfile, which is aReact Server Componentthat will wrap all pages in your application. This file is defined at the top level of theappdirectory.The closest equivalent to the root layout file in a Vite application is theindex.htmlfile, which contains your<html>,<head>, and<body>tags.In this step, you'll convert yourindex.htmlfile into a root layout file:Create a newappdirectory in yoursrcdirectory.Create a newlayout.tsxfile inside thatappdirectory:app/layout.tsxTypeScriptJavaScriptTypeScriptexportdefaultfunctionRootLayout({children,}:{children:React.ReactNode}) {return'...'}Good to know:.js,.jsx, or.tsxextensions can be used for Layout files.Copy the content of yourindex.htmlfile into the previously created<RootLayout>component while
replacing thebody.div#rootandbody.scripttags with<div id=""root"">{children}</div>:app/layout.tsxTypeScriptJavaScriptTypeScriptexportdefaultfunctionRootLayout({children,}:{children:React.ReactNode}) {return(<htmllang=""en""><head><metacharset=""UTF-8""/><linkrel=""icon""type=""image/svg+xml""href=""/icon.svg""/><metaname=""viewport""content=""width=device-width, initial-scale=1.0""/><title>My App</title><metaname=""description""content=""My App is a...""/></head><body><divid=""root"">{children}</div></body></html>)}Next.js already includes by default themeta charsetandmeta viewporttags, so you
can safely remove those from your<head>:app/layout.tsxTypeScriptJavaScriptTypeScriptexportdefaultfunctionRootLayout({children,}:{children:React.ReactNode}) {return(<htmllang=""en""><head><linkrel=""icon""type=""image/svg+xml""href=""/icon.svg""/><title>My App</title><metaname=""description""content=""My App is a...""/></head><body><divid=""root"">{children}</div></body></html>)}Anymetadata filessuch asfavicon.ico,icon.png,robots.txtare automatically added to the application<head>tag as long as you have them placed into the top level of theappdirectory. After
movingall supported filesinto theappdirectory you can safely delete their<link>tags:app/layout.tsxTypeScriptJavaScriptTypeScriptexportdefaultfunctionRootLayout({children,}:{children:React.ReactNode}) {return(<htmllang=""en""><head><title>My App</title><metaname=""description""content=""My App is a...""/></head><body><divid=""root"">{children}</div></body></html>)}Finally, Next.js can manage your last<head>tags with theMetadata API. Move your final metadata
info into an exportedmetadataobject:app/layout.tsxTypeScriptJavaScriptTypeScriptimporttype{ Metadata }from'next'exportconstmetadata:Metadata={title:'My App',description:'My App is a...',}exportdefaultfunctionRootLayout({children,}:{children:React.ReactNode}) {return(<htmllang=""en""><body><divid=""root"">{children}</div></body></html>)}With the above changes, you shifted from declaring everything in yourindex.htmlto using Next.js'
convention-based approach built into the framework
(Metadata API). This approach enables you
to more easily improve your SEO and web shareability of your pages.Step 5: Create the Entrypoint PageOn Next.js you declare an entrypoint for your application by creating apage.tsxfile. The
closest equivalent of this file on Vite is yourmain.tsxfile. In this step, you’ll set up the
entrypoint of your application.Create a[[...slug]]directory in yourappdirectory.Since in this guide we're aiming first to set up our Next.js as an SPA (Single Page Application), you need your page entrypoint to catch all possible routes of your application. For that, create a new[[...slug]]directory in yourappdirectory.This directory is what is called anoptional catch-all route segment. Next.js uses a file-system based router where folders are used to define routes. This special directory will make sure that all routes of your application will be directed to its containingpage.tsxfile.Create a newpage.tsxfile inside theapp/[[...slug]]directory with the following content:app/[[...slug]]/page.tsxTypeScriptJavaScriptTypeScriptimport'../../index.css'exportfunctiongenerateStaticParams() {return[{ slug:[''] }]}exportdefaultfunctionPage() {return'...'// We'll update this}Good to know:.js,.jsx, or.tsxextensions can be used for Page files.This file is aServer Component. When you runnext build, the file is prerendered into a static asset. It doesnotrequire any dynamic code.This file imports our global CSS and tellsgenerateStaticParamswe are only going to generate one route, the index route at/.Now, let's move the rest of our Vite application which will run client-only.app/[[...slug]]/client.tsxTypeScriptJavaScriptTypeScript'use client'importReactfrom'react'importdynamicfrom'next/dynamic'constApp=dynamic(()=>import('../../App'),{ ssr:false})exportfunctionClientOnly() {return<App/>}This file is aClient Component, defined by the'use client'directive. Client Components are stillprerendered to HTMLon the server before being sent to the client.Since we want a client-only application to start, we can configure Next.js to disable prerendering from theAppcomponent down.constApp=dynamic(()=>import('../../App'),{ ssr:false})Now, update your entrypoint page to use the new component:app/[[...slug]]/page.tsxTypeScriptJavaScriptTypeScriptimport'../../index.css'import{ ClientOnly }from'./client'exportfunctiongenerateStaticParams() {return[{ slug:[''] }]}exportdefaultfunctionPage() {return<ClientOnly/>}Step 6: Update Static Image ImportsNext.js handles static image imports slightly different from Vite. With Vite, importing an image
file will return its public URL as a string:App.tsximportimagefrom'./img.png'// `image` will be '/assets/img.2d8efhg.png' in productionexportdefaultfunctionApp() {return<imgsrc={image} />}With Next.js, static image imports return an object. The object can then be used directly with the
Next.js<Image>component, or you can use the object'ssrcproperty with your existing<img>tag.The<Image>component has the added benefits ofautomatic image optimization. The<Image>component automatically sets thewidthandheightattributes of the resulting<img>based on
the image's dimensions. This prevents layout shifts when the image loads. However, this can cause
issues if your app contains images with only one of their dimensions being styled without the other
styled toauto. When not styled toauto, the dimension will default to the<img>dimension
attribute's value, which can cause the image to appear distorted.Keeping the<img>tag will reduce the amount of changes in your application and prevent the above
issues. You can then optionally later migrate to the<Image>component to take advantage of optimizing images byconfiguring a loader, or moving to the default Next.js server which has automatic image optimization.Convert absolute import paths for images imported from/publicinto relative imports:// Beforeimportlogofrom'/logo.png'// Afterimportlogofrom'../public/logo.png'Pass the imagesrcproperty instead of the whole image object to your<img>tag:// Before<imgsrc={logo} />// After<imgsrc={logo.src} />Alternatively, you can reference the public URL for the image asset based on the filename. For example,public/logo.pngwill serve the image at/logo.pngfor your application, which would be thesrcvalue.Warning:If you're using TypeScript, you might encounter type errors when accessing thesrcproperty. You can safely ignore those for now. They will be fixed by the end of this guide.Step 7: Migrate the Environment VariablesNext.js has support for.envenvironment variablessimilar to Vite. The main difference is the prefix used to expose environment variables on the
client-side.Change all environment variables with theVITE_prefix toNEXT_PUBLIC_.Vite exposes a few built-in environment variables on the specialimport.meta.envobject which
aren’t supported by Next.js. You need to update their usage as follows:import.meta.env.MODE⇒process.env.NODE_ENVimport.meta.env.PROD⇒process.env.NODE_ENV === 'production'import.meta.env.DEV⇒process.env.NODE_ENV !== 'production'import.meta.env.SSR⇒typeof window !== 'undefined'Next.js also doesn't provide a built-inBASE_URLenvironment variable. However, you can still
configure one, if you need it:Add the following to your.envfile:.env# ...NEXT_PUBLIC_BASE_PATH=""/some-base-path""SetbasePathtoprocess.env.NEXT_PUBLIC_BASE_PATHin yournext.config.mjsfile:next.config.mjs/**@type{import('next').NextConfig}*/constnextConfig={output:'export',// Outputs a Single-Page Application (SPA).distDir:'./dist',// Changes the build output directory to `./dist/`.basePath:process.env.NEXT_PUBLIC_BASE_PATH,// Sets the base path to `/some-base-path`.}exportdefaultnextConfigUpdateimport.meta.env.BASE_URLusages toprocess.env.NEXT_PUBLIC_BASE_PATHStep 8: Update Scripts inpackage.jsonYou should now be able to run your application to test if you successfully migrated to Next.js. But
before that, you need to update yourscriptsin yourpackage.jsonwith Next.js related commands,
and add.nextandnext-env.d.tsto your.gitignore:package.json{""scripts"":{""dev"":""next dev"",""build"":""next build"",""start"":""next start""}}.gitignore# ....nextnext-env.d.tsdistNow runnpm run dev, and openhttp://localhost:3000. You should see your application now running on Next.js.Example:Check outthis pull requestfor a
working example of a Vite application migrated to Next.js.Step 9: Clean UpYou can now clean up your codebase from Vite related artifacts:Deletemain.tsxDeleteindex.htmlDeletevite-env.d.tsDeletetsconfig.node.jsonDeletevite.config.tsUninstall Vite dependenciesNext StepsIf everything went according to plan, you now have a functioning Next.js application running as a
single-page application. However, you aren't yet taking advantage of most of Next.js' benefits, but
you can now start making incremental changes to reap all the benefits. Here's what you might want to
do next:Migrate from React Router to theNext.js App Routerto get:Automatic code splittingStreaming Server-RenderingReact Server ComponentsOptimize images with the<Image>componentOptimize fonts withnext/fontOptimize third-party scripts with the<Script>componentUpdate your ESLint configuration to support Next.js rulesPreviousFrom Pages to AppNextMigrating from Create React AppWas this helpful?supported.Send"
migrating from create react app,Migrating from Create React App,"Building Your ApplicationUpgradingMigrating from Create React AppMigrating from Create React AppThis guide will help you migrate an existing Create React App (CRA) site to Next.js.Why Switch?There are several reasons why you might want to switch from Create React App to Next.js:Slow initial page loading timeCreate React App uses purely client-side React. Client-side only applications, also known assingle-page applications (SPAs), often experience slow initial page loading time. This happens due to a couple of reasons:The browser needs to wait for the React code and your entire application bundle to download and run before your code is able to send requests to load data.Your application code grows with every new feature and dependency you add.No automatic code splittingThe previous issue of slow loading times can be somewhat mitigated with code splitting. However, if you try to do code splitting manually, you can inadvertently introduce network waterfalls. Next.js provides automatic code splitting and tree-shaking built into its router and build pipeline.Network waterfallsA common cause of poor performance occurs when applications make sequential client-server requests to fetch data. One pattern for data fetching in aSPAis to render a placeholder, and then fetch data after the component has mounted. Unfortunately, a child component can only begin fetching data after its parent has finished loading its own data, resulting in a “waterfall” of requests.While client-side data fetching is supported in Next.js, Next.js also lets you move data fetching to the server. This often eliminates client-server waterfalls altogether.Fast and intentional loading statesWith built-in support forstreaming through React Suspense, you can define which parts of your UI load first and in what order, without creating network waterfalls.This enables you to build pages that are faster to load and eliminatelayout shifts.Choose the data fetching strategyDepending on your needs, Next.js allows you to choose your data fetching strategy on a page or component-level basis. For example, you could fetch data from your CMS and render blog posts at build time (SSG) for quick load speeds, or fetch data at request time (SSR) when necessary.MiddlewareNext.js Middlewareallows you to run code on the server before a request is completed. For instance, you can avoid a flash of unauthenticated content by redirecting a user to a login page in the middleware for authenticated-only pages. You can also use it for features like A/B testing, experimentation, andinternationalization.Built-in OptimizationsImages,fonts, andthird-party scriptsoften have a large impact on an application’s performance. Next.js includes specialized components and APIs that automatically optimize them for you.Migration StepsOur goal is to get a working Next.js application as quickly as possible so that you can then adopt Next.js features incrementally. To begin with, we’ll treat your application as a purely client-side application (SPA) without immediately replacing your existing router. This reduces complexity and merge conflicts.Note: If you are using advanced CRA configurations such as a customhomepagefield in yourpackage.json, a custom service worker, or specific Babel/webpack tweaks, please see theAdditional Considerationssection at the end of this guide for tips on replicating or adapting these features in Next.js.Step 1: Install the Next.js DependencyInstall Next.js in your existing project:Terminalnpminstallnext@latestStep 2: Create the Next.js Configuration FileCreate anext.config.tsat the root of your project (same level as yourpackage.json). This file holds yourNext.js configuration options.next.config.tsimporttype{ NextConfig }from'next'constnextConfig:NextConfig={output:'export',// Outputs a Single-Page Application (SPA)distDir:'build',// Changes the build output directory to `build`}exportdefaultnextConfigNote: Usingoutput: 'export'means you’re doing a static export. You willnothave access to server-side features like SSR or APIs. You can remove this line to leverage Next.js server features.Step 3: Create the Root LayoutA Next.jsApp Routerapplication must include aroot layoutfile, which is aReact Server Componentthat will wrap all your pages.The closest equivalent of the root layout file in a CRA application ispublic/index.html, which includes your<html>,<head>, and<body>tags.Create a newappdirectory inside yoursrcdirectory (or at your project root if you preferappat the root).Inside theappdirectory, create alayout.tsx(orlayout.js) file:app/layout.tsxTypeScriptJavaScriptTypeScriptexportdefaultfunctionRootLayout({children,}:{children:React.ReactNode}) {return'...'}Now copy the content of your oldindex.htmlinto this<RootLayout>component. Replacebody div#root(andbody noscript) with<div id=""root"">{children}</div>.app/layout.tsxTypeScriptJavaScriptTypeScriptexportdefaultfunctionRootLayout({children,}:{children:React.ReactNode}) {return(<htmllang=""en""><head><metacharSet=""UTF-8""/><linkrel=""icon""href=""%PUBLIC_URL%/favicon.ico""/><metaname=""viewport""content=""width=device-width, initial-scale=1""/><title>React App</title><metaname=""description""content=""Web site created...""/></head><body><divid=""root"">{children}</div></body></html>)}Good to know: Next.js ignores CRA’spublic/manifest.json, additional iconography, andtesting configurationby default. If you need these, Next.js has support with itsMetadata APIandTestingsetup.Step 4: MetadataNext.js automatically includes the<meta charset=""UTF-8"" />and<meta name=""viewport"" content=""width=device-width, initial-scale=1"" />tags, so you can remove them from<head>:app/layout.tsxTypeScriptJavaScriptTypeScriptexportdefaultfunctionRootLayout({children,}:{children:React.ReactNode}) {return(<htmllang=""en""><head><linkrel=""icon""href=""%PUBLIC_URL%/favicon.ico""/><title>React App</title><metaname=""description""content=""Web site created...""/></head><body><divid=""root"">{children}</div></body></html>)}Anymetadata filessuch asfavicon.ico,icon.png,robots.txtare automatically added to the application<head>tag as long as you have them placed into the top level of theappdirectory. After movingall supported filesinto theappdirectory you can safely delete their<link>tags:app/layout.tsxTypeScriptJavaScriptTypeScriptexportdefaultfunctionRootLayout({children,}:{children:React.ReactNode}) {return(<htmllang=""en""><head><title>React App</title><metaname=""description""content=""Web site created...""/></head><body><divid=""root"">{children}</div></body></html>)}Finally, Next.js can manage your last<head>tags with theMetadata API. Move your final metadata info into an exportedmetadataobject:app/layout.tsxTypeScriptJavaScriptTypeScriptimporttype{ Metadata }from'next'exportconstmetadata:Metadata={title:'React App',description:'Web site created with Next.js.',}exportdefaultfunctionRootLayout({children,}:{children:React.ReactNode}) {return(<htmllang=""en""><body><divid=""root"">{children}</div></body></html>)}With the above changes, you shifted from declaring everything in yourindex.htmlto using Next.js' convention-based approach built into the framework (Metadata API). This approach enables you to more easily improve your SEO and web shareability of your pages.Step 5: StylesLike CRA, Next.js supportsCSS Modulesout of the box. It also supportsglobal CSS imports.If you have a global CSS file, import it into yourapp/layout.tsx:app/layout.tsxTypeScriptJavaScriptTypeScriptimport'../index.css'exportconstmetadata={title:'React App',description:'Web site created with Next.js.',}exportdefaultfunctionRootLayout({children,}:{children:React.ReactNode}) {return(<htmllang=""en""><body><divid=""root"">{children}</div></body></html>)}If you’re using Tailwind CSS, see ourinstallation docs.Step 6: Create the Entrypoint PageCreate React App usessrc/index.tsx(orindex.js) as the entry point. In Next.js (App Router), each folder inside theappdirectory corresponds to a route, and each folder should have apage.tsx.Since we want to keep the app as an SPA for now and interceptallroutes, we’ll use anoptional catch-all route.Create a[[...slug]]directory insideapp.app┣[[...slug]]┃┗page.tsx┣layout.tsxAdd the following topage.tsx:app/[[...slug]]/page.tsxTypeScriptJavaScriptTypeScriptexportfunctiongenerateStaticParams() {return[{ slug:[''] }]}exportdefaultfunctionPage() {return'...'// We'll update this}This tells Next.js to generate a single route for the empty slug (/), effectively mappingallroutes to the same page. This page is aServer Component, prerendered into static HTML.Step 7: Add a Client-Only EntrypointNext, we’ll embed your CRA’s root App component inside aClient Componentso that all logic remains client-side. If this is your first time using Next.js, it's worth knowing that clients components (by default) are still prerendered on the server. You can think about them as having the additional capability of running client-side JavaScript.Create aclient.tsx(orclient.js) inapp/[[...slug]]/:app/[[...slug]]/client.tsxTypeScriptJavaScriptTypeScript'use client'importdynamicfrom'next/dynamic'constApp=dynamic(()=>import('../../App'),{ ssr:false})exportfunctionClientOnly() {return<App/>}The'use client'directive makes this file aClient Component.Thedynamicimport withssr: falsedisables server-side rendering for the<App />component, making it truly client-only (SPA).Now update yourpage.tsx(orpage.js) to use your new component:app/[[...slug]]/page.tsxTypeScriptJavaScriptTypeScriptimport{ ClientOnly }from'./client'exportfunctiongenerateStaticParams() {return[{ slug:[''] }]}exportdefaultfunctionPage() {return<ClientOnly/>}Step 8: Update Static Image ImportsIn CRA, importing an image file returns its public URL as a string:importimagefrom'./img.png'exportdefaultfunctionApp() {return<imgsrc={image} />}With Next.js, static image imports return an object. The object can then be used directly with the Next.js<Image>component, or you can use the object'ssrcproperty with your existing<img>tag.The<Image>component has the added benefits ofautomatic image optimization. The<Image>component automatically sets thewidthandheightattributes of the resulting<img>based on the image's dimensions. This prevents layout shifts when the image loads. However, this can cause issues if your app contains images with only one of their dimensions being styled without the other styled toauto. When not styled toauto, the dimension will default to the<img>dimension attribute's value, which can cause the image to appear distorted.Keeping the<img>tag will reduce the amount of changes in your application and prevent the above issues. You can then optionally later migrate to the<Image>component to take advantage of optimizing images byconfiguring a loader, or moving to the default Next.js server which has automatic image optimization.Convert absolute import paths for images imported from/publicinto relative imports:// Beforeimportlogofrom'/logo.png'// Afterimportlogofrom'../public/logo.png'Pass the imagesrcproperty instead of the whole image object to your<img>tag:// Before<imgsrc={logo} />// After<imgsrc={logo.src} />Alternatively, you can reference the public URL for the image asset based on the filename. For example,public/logo.pngwill serve the image at/logo.pngfor your application, which would be thesrcvalue.Warning:If you're using TypeScript, you might encounter type errors when accessing thesrcproperty. To fix them, you need to addnext-env.d.tsto theincludearrayof yourtsconfig.jsonfile. Next.js will automatically generate this file when you run your application on step 9.Step 9: Migrate Environment VariablesNext.js supportsenvironment variablessimilarly to CRA butrequiresaNEXT_PUBLIC_prefix for any variable you want to expose in the browser.The main difference is the prefix used to expose environment variables on the client-side. Change all environment variables with theREACT_APP_prefix toNEXT_PUBLIC_.Step 10: Update Scripts inpackage.jsonUpdate yourpackage.jsonscripts to use Next.js commands. Also, add.nextandnext-env.d.tsto your.gitignore:package.json{""scripts"":{""dev"":""next dev --turbopack"",""build"":""next build"",""start"":""npx serve@latest ./build""}}.gitignore# ....nextnext-env.d.tsNow you can run:npmrundevOpenhttp://localhost:3000. You should see your application now running on Next.js (in SPA mode).Step 11: Clean UpYou can now remove artifacts that are specific to Create React App:public/index.htmlsrc/index.tsxsrc/react-app-env.d.tsThereportWebVitalssetupThereact-scriptsdependency (uninstall it frompackage.json)Additional ConsiderationsUsing a Customhomepagein CRAIf you used thehomepagefield in your CRApackage.jsonto serve the app under a specific subpath, you can replicate that in Next.js using thebasePathconfigurationinnext.config.ts:next.config.tsimport{ NextConfig }from'next'constnextConfig:NextConfig={basePath:'/my-subpath',// ...}exportdefaultnextConfigHandling a CustomService WorkerIf you used CRA’s service worker (e.g.,serviceWorker.jsfromcreate-react-app), you can learn how to createProgressive Web Applications (PWAs)with Next.js.Proxying API RequestsIf your CRA app used theproxyfield inpackage.jsonto forward requests to a backend server, you can replicate this withNext.js rewritesinnext.config.ts:next.config.tsimport{ NextConfig }from'next'constnextConfig:NextConfig={asyncrewrites() {return[{source:'/api/:path*',destination:'https://your-backend.com/:path*',},]},}Custom Webpack / Babel ConfigIf you had a custom webpack or Babel configuration in CRA, you can extend Next.js’s config innext.config.ts:next.config.tsimport{ NextConfig }from'next'constnextConfig:NextConfig={webpack:(config,{ isServer })=>{// Modify the webpack config herereturnconfig},}exportdefaultnextConfigNote: This will require disabling Turbopack by removing--turbopackfrom yourdevscript.TypeScript SetupNext.js automatically sets up TypeScript if you have atsconfig.json. Make surenext-env.d.tsis listed in yourtsconfig.jsonincludearray:{""include"":[""next-env.d.ts"",""app/**/*"",""src/**/*""]}Bundler CompatibilityBoth Create React App and Next.js default to webpack for bundling. Next.js also offersTurbopackfor faster local development with:nextdev--turbopackYou can still provide acustom webpack configurationif you need to migrate advanced webpack settings from CRA.Next StepsIf everything worked, you now have a functioning Next.js application running as a single-page application. You aren’t yet leveraging Next.js features like server-side rendering or file-based routing, but you can now do so incrementally:Migrate from React Routerto theNext.js App Routerfor:Automatic code splittingStreaming server renderingReact Server ComponentsOptimize imageswith the<Image>componentOptimize fontswithnext/fontOptimize third-party scriptswith the<Script>componentEnable ESLintwith Next.js recommended rules by runningnpx next lintand configuring it to match your project’s needsNote: Using a static export (output: 'export')does not currently supporttheuseParamshook or other server features. To use all Next.js features, removeoutput: 'export'from yournext.config.ts.PreviousMigrating from ViteNextVersion 14Was this helpful?supported.Send"
version 14,Version 14,"Building Your ApplicationUpgradingVersion 14Version 14Upgrading from 13 to 14To update to Next.js version 14, run the following command using your preferred package manager:Terminalnpminext@next-14react@18react-dom@18&&npmieslint-config-next@next-14-DTerminalyarnaddnext@next-14react@18react-dom@18&&yarnaddeslint-config-next@next-14-DTerminalpnpminext@next-14react@18react-dom@18&&pnpmieslint-config-next@next-14-DTerminalbunaddnext@next-14react@18react-dom@18&&bunaddeslint-config-next@next-14-DGood to know:If you are using TypeScript, ensure you also upgrade@types/reactand@types/react-domto their latest versions.v14 SummaryThe minimum Node.js version has been bumped from 16.14 to 18.17, since 16.x has reached end-of-life.Thenext exportcommand has been removed in favor ofoutput: 'export'config. Please see thedocsfor more information.Thenext/serverimport forImageResponsewas renamed tonext/og. Acodemod is availableto safely and automatically rename your imports.The@next/fontpackage has been fully removed in favor of the built-innext/font. Acodemod is availableto safely and automatically rename your imports.The WASM target fornext-swchas been removed.PreviousMigrating from Create React AppNextVersion 13Was this helpful?supported.Send"
version 13,Version 13,"Building Your ApplicationUpgradingVersion 13Version 13Upgrading from 12 to 13To update to Next.js version 13, run the following command using your preferred package manager:Terminalnpminext@13react@latestreact-dom@latesteslint-config-next@13Terminalyarnaddnext@13react@latestreact-dom@latesteslint-config-next@13Terminalpnpminext@13react@latestreact-dom@latesteslint-config-next@13Terminalbunaddnext@13react@latestreact-dom@latesteslint-config-next@13Good to know:If you are using TypeScript, ensure you also upgrade@types/reactand@types/react-domto their latest versions.v13 SummaryTheSupported Browsershave been changed to drop Internet Explorer and target modern browsers.The minimum Node.js version has been bumped from 12.22.0 to 16.14.0, since 12.x and 14.x have reached end-of-life.The minimum React version has been bumped from 17.0.2 to 18.2.0.TheswcMinifyconfiguration property was changed fromfalsetotrue. SeeNext.js Compilerfor more info.Thenext/imageimport was renamed tonext/legacy/image. Thenext/future/imageimport was renamed tonext/image. Acodemod is availableto safely and automatically rename your imports.Thenext/linkchild can no longer be<a>. Add thelegacyBehaviorprop to use the legacy behavior or remove the<a>to upgrade. Acodemod is availableto automatically upgrade your code.Thetargetconfiguration property has been removed and superseded byOutput File Tracing.Migrating shared featuresNext.js 13 introduces a newappdirectorywith new features and conventions. However, upgrading to Next.js 13 doesnotrequire using the newappRouter.You can continue usingpageswith new features that work in both directories, such as the updatedImage component,Link component,Script component, andFont optimization.<Image/>ComponentNext.js 12 introduced many improvements to the Image Component with a temporary import:next/future/image. These improvements included less client-side JavaScript, easier ways to extend and style images, better accessibility, and native browser lazy loading.Starting in Next.js 13, this new behavior is now the default fornext/image.There are two codemods to help you migrate to the new Image Component:next-image-to-legacy-image: This codemod will safely and automatically renamenext/imageimports tonext/legacy/imageto maintain the same behavior as Next.js 12. We recommend running this codemod to quickly update to Next.js 13 automatically.next-image-experimental: After running the previous codemod, you can optionally run this experimental codemod to upgradenext/legacy/imageto the newnext/image, which will remove unused props and add inline styles. Please note this codemod is experimental and only covers static usage (such as<Image src={img} layout=""responsive"" />) but not dynamic usage (such as<Image {...props} />).Alternatively, you can manually update by following themigration guideand also see thelegacy comparison.<Link>ComponentThe<Link>Componentno longer requires manually adding an<a>tag as a child. This behavior was added as an experimental option inversion 12.2and is now the default. In Next.js 13,<Link>always renders<a>and allows you to forward props to the underlying tag.For example:importLinkfrom'next/link'// Next.js 12: `<a>` has to be nested otherwise it's excluded<Linkhref=""/about""><a>About</a></Link>// Next.js 13: `<Link>` always renders `<a>` under the hood<Linkhref=""/about"">About</Link>To upgrade your links to Next.js 13, you can use thenew-linkcodemod.<Script>ComponentThe behavior ofnext/scripthas been updated to support bothpagesandapp. If incrementally adoptingapp, read theupgrade guide.Font OptimizationPreviously, Next.js helped you optimize fonts by inlining font CSS. Version 13 introduces the newnext/fontmodule which gives you the ability to customize your font loading experience while still ensuring great performance and privacy.SeeOptimizing Fontsto learn how to usenext/font.PreviousVersion 14NextVersion 12Was this helpful?supported.Send"
version 12,Version 12,"Building Your ApplicationUpgradingVersion 12Version 12To upgrade to version 12, run the following command:Terminalnpminext@12react@17react-dom@17eslint-config-next@12Terminalyarnaddnext@12react@17react-dom@17eslint-config-next@12Terminalpnpmupnext@12react@17react-dom@17eslint-config-next@12Terminalbunaddnext@12react@17react-dom@17eslint-config-next@12Good to know:If you are using TypeScript, ensure you also upgrade@types/reactand@types/react-domto their corresponding versions.Upgrading to 12.2Middleware- If you were using Middleware prior to12.2, please see theupgrade guidefor more information.Upgrading to 12.0Minimum Node.js Version- The minimum Node.js version has been bumped from12.0.0to12.22.0which is the first version of Node.js with native ES Modules support.Minimum React Version- The minimum required React version is17.0.2. To upgrade you can run the following command in the terminal:Terminalnpminstallreact@latestreact-dom@latestyarnaddreact@latestreact-dom@latestpnpmupdatereact@latestreact-dom@latestbunaddreact@latestreact-dom@latestSWC replacing BabelNext.js now uses the Rust-based compilerSWCto compile JavaScript/TypeScript. This new compiler is up to 17x faster than Babel when compiling individual files and up to 5x faster Fast Refresh.Next.js provides full backward compatibility with applications that havecustom Babel configuration. All transformations that Next.js handles by default like styled-jsx and tree-shaking ofgetStaticProps/getStaticPaths/getServerSidePropshave been ported to Rust.When an application has a custom Babel configuration, Next.js will automatically opt-out of using SWC for compiling JavaScript/Typescript and will fall back to using Babel in the same way that it was used in Next.js 11.Many of the integrations with external libraries that currently require custom Babel transformations will be ported to Rust-based SWC transforms in the near future. These include but are not limited to:Styled ComponentsEmotionRelayIn order to prioritize transforms that will help you adopt SWC, please provide your.babelrconthis feedback thread.SWC replacing Terser for minificationYou can opt-in to replacing Terser with SWC for minifying JavaScript up to 7x faster using a flag innext.config.js:next.config.jsmodule.exports={swcMinify:true,}Minification using SWC is an opt-in flag to ensure it can be tested against more real-world Next.js applications before it becomes the default in Next.js 12.1. If you have feedback about minification, please leave it onthis feedback thread.Improvements to styled-jsx CSS parsingOn top of the Rust-based compiler we've implemented a new CSS parser based on the one used for the styled-jsx Babel transform. This new parser has improved handling of CSS and now errors when invalid CSS is used that would previously slip through and cause unexpected behavior.Because of this change invalid CSS will throw an error during development andnext build. This change only affects styled-jsx usage.next/imagechanged wrapping elementnext/imagenow renders the<img>inside a<span>instead of<div>.If your application has specific CSS targeting span such as.container span, upgrading to Next.js 12 might incorrectly match the wrapping element inside the<Image>component. You can avoid this by restricting the selector to a specific class such as.container span.itemand updating the relevant component with that className, such as<span className=""item"" />.If your application has specific CSS targeting thenext/image<div>tag, for example.container div, it may not match anymore. You can update the selector.container span, or preferably, add a new<div className=""wrapper"">wrapping the<Image>component and target that instead such as.container .wrapper.TheclassNameprop is unchanged and will still be passed to the underlying<img>element.See thedocumentationfor more info.HMR connection now uses a WebSocketPreviously, Next.js used aserver-sent eventsconnection to receive HMR events. Next.js 12 now uses a WebSocket connection.In some cases when proxying requests to the Next.js dev server, you will need to ensure the upgrade request is handled correctly. For example, innginxyou would need to add the following configuration:location/_next/webpack-hmr {proxy_passhttp://localhost:3000/_next/webpack-hmr;proxy_http_version1.1;proxy_set_headerUpgrade $http_upgrade;proxy_set_headerConnection""upgrade"";}If you are using Apache (2.x), you can add the following configuration to enable web sockets to the server. Review the port, host name and server names.<VirtualHost *:443>
 # ServerName yourwebsite.local
 ServerName ""${WEBSITE_SERVER_NAME}""
 ProxyPass / http://localhost:3000/
 ProxyPassReverse / http://localhost:3000/
 # Next.js 12 uses websocket
 <Location /_next/webpack-hmr>
    RewriteEngine On
    RewriteCond %{QUERY_STRING} transport=websocket [NC]
    RewriteCond %{HTTP:Upgrade} websocket [NC]
    RewriteCond %{HTTP:Connection} upgrade [NC]
    RewriteRule /(.*) ws://localhost:3000/_next/webpack-hmr/$1 [P,L]
    ProxyPass ws://localhost:3000/_next/webpack-hmr retry=0 timeout=30
    ProxyPassReverse ws://localhost:3000/_next/webpack-hmr
 </Location>
</VirtualHost>For custom servers, such asexpress, you may need to useapp.allto ensure the request is passed correctly, for example:app.all('/_next/webpack-hmr',(req,res)=>{nextjsRequestHandler(req,res)})Webpack 4 support has been removedIf you are already using webpack 5 you can skip this section.Next.js has adopted webpack 5 as the default for compilation in Next.js 11. As communicated in thewebpack 5 upgrading documentationNext.js 12 removes support for webpack 4.If your application is still using webpack 4 using the opt-out flag, you will now see an error linking to thewebpack 5 upgrading documentation.targetoption deprecatedIf you do not havetargetinnext.config.jsyou can skip this section.The target option has been deprecated in favor of built-in support for tracing what dependencies are needed to run a page.Duringnext build, Next.js will automatically trace each page and its dependencies to determine all of the files that are needed for deploying a production version of your application.If you are currently using thetargetoption set toserverless, please read thedocumentation on how to leverage the new output.PreviousVersion 13NextVersion 11Was this helpful?supported.Send"
version 11,Version 11,"Building Your ApplicationUpgradingVersion 11Version 11To upgrade to version 11, run the following command:Terminalnpminext@11react@17react-dom@17Terminalyarnaddnext@11react@17react-dom@17Terminalpnpmupnext@11react@17react-dom@17Terminalbunaddnext@11react@17react-dom@17Good to know:If you are using TypeScript, ensure you also upgrade@types/reactand@types/react-domto their corresponding versions.Webpack 5Webpack 5 is now the default for all Next.js applications. If you did not have a custom webpack configuration, your application is already using webpack 5. If you do have a custom webpack configuration, you can refer to theNext.js webpack 5 documentationfor upgrade guidance.Cleaning thedistDiris now a defaultThe build output directory (defaults to.next) is now cleared by default except for the Next.js caches. You can refer tothe cleaningdistDirRFCfor more information.If your application was relying on this behavior previously you can disable the new default behavior by adding thecleanDistDir: falseflag innext.config.js.PORTis now supported fornext devandnext startNext.js 11 supports thePORTenvironment variable to set the port the application runs on. Using-p/--portis still recommended but if you were prohibited from using-pin any way you can now usePORTas an alternative:Example:PORT=4000 next startnext.config.jscustomization to import imagesNext.js 11 supports static image imports withnext/image. This new feature relies on being able to process image imports. If you previously added thenext-imagesornext-optimized-imagespackages you can either move to the new built-in support usingnext/imageor disable the feature:next.config.jsmodule.exports={images:{disableStaticImages:true,},}Removesuper.componentDidCatch()frompages/_app.jsThenext/appcomponent'scomponentDidCatchwas deprecated in Next.js 9 as it's no longer needed and has since been a no-op. In Next.js 11, it was removed.If yourpages/_app.jshas a customcomponentDidCatchmethod you can removesuper.componentDidCatchas it is no longer needed.RemoveContainerfrompages/_app.jsThis export was deprecated in Next.js 9 as it's no longer needed and has since been a no-op with a warning during development. In Next.js 11 it was removed.If yourpages/_app.jsimportsContainerfromnext/appyou can removeContaineras it was removed. Learn more inthe documentation.Removeprops.urlusage from page componentsThis property was deprecated in Next.js 4 and has since shown a warning during development. With the introduction ofgetStaticProps/getServerSidePropsthese methods already disallowed the usage ofprops.url. In Next.js 11, it was removed completely.You can learn more inthe documentation.Removeunsizedproperty onnext/imageTheunsizedproperty onnext/imagewas deprecated in Next.js 10.0.1. You can uselayout=""fill""instead. In Next.js 11unsizedwas removed.Removemodulesproperty onnext/dynamicThemodulesandrenderoption fornext/dynamicwere deprecated in Next.js 9.5. This was done in order to make thenext/dynamicAPI closer toReact.lazy. In Next.js 11, themodulesandrenderoptions were removed.This option hasn't been mentioned in the documentation since Next.js 8 so it's less likely that your application is using it.If your application does usemodulesandrenderyou can refer tothe documentation.RemoveHead.rewindHead.rewindhas been a no-op since Next.js 9.5, in Next.js 11 it was removed. You can safely remove your usage ofHead.rewind.Moment.js locales excluded by defaultMoment.js includes translations for a lot of locales by default. Next.js now automatically excludes these locales by default to optimize bundle size for applications using Moment.js.To load a specific locale use this snippet:importmomentfrom'moment'import'moment/locale/ja'moment.locale('ja')You can opt-out of this new default by addingexcludeDefaultMomentLocales: falsetonext.config.jsif you do not want the new behavior, do note it's highly recommended to not disable this new optimization as it significantly reduces the size of Moment.js.Update usage ofrouter.eventsIn case you're accessingrouter.eventsduring rendering, in Next.js 11router.eventsis no longer provided during pre-rendering. Ensure you're accessingrouter.eventsinuseEffect:useEffect(()=>{consthandleRouteChange=(url,{ shallow })=>{console.log(`App is changing to${url}${shallow?'with':'without'}shallow routing`)}router.events.on('routeChangeStart',handleRouteChange)// If the component is unmounted, unsubscribe// from the event with the `off` method:return()=>{router.events.off('routeChangeStart',handleRouteChange)}},[router])If your application usesrouter.router.eventswhich was an internal property that was not public please make sure to userouter.eventsas well.React 16 to 17React 17 introduced a newJSX Transformthat brings a long-time Next.js feature to the wider React ecosystem: Not having toimport React from 'react'when using JSX. When using React 17 Next.js will automatically use the new transform. This transform does not make theReactvariable global, which was an unintended side-effect of the previous Next.js implementation. Acodemod is availableto automatically fix cases where you accidentally usedReactwithout importing it.Most applications already use the latest version of React, with Next.js 11 the minimum React version has been updated to 17.0.2.To upgrade you can run the following command:npm install react@latest react-dom@latestOr usingyarn:yarn add react@latest react-dom@latestPreviousVersion 12NextVersion 10Was this helpful?supported.Send"
version 10,Version 10,"Building Your ApplicationUpgradingVersion 10Version 10There were no breaking changes between versions 9 and 10.To upgrade to version 10, run the following command:Terminalnpminext@10Terminalyarnaddnext@10Terminalpnpmupnext@10Terminalbunaddnext@10Good to know:If you are using TypeScript, ensure you also upgrade@types/reactand@types/react-domto their corresponding versions.PreviousVersion 11NextVersion 9Was this helpful?supported.Send"
version 9,Version 9,"Building Your ApplicationUpgradingVersion 9Upgrading to Version 9To upgrade to version 9, run the following command:Terminalnpminext@9Terminalyarnaddnext@9Terminalpnpmupnext@9Terminalbunaddnext@9Good to know:If you are using TypeScript, ensure you also upgrade@types/reactand@types/react-domto their corresponding versions.Production Deployment on VercelIf you previously configuredroutesin yourvercel.jsonfile for dynamic routes, these rules can be removed when leveraging Next.js 9's newDynamic Routing feature.Next.js 9's dynamic routes areautomatically configured onVerceland do not require anyvercel.jsoncustomization.You can read more aboutDynamic Routing here.Check your Custom App File (pages/_app.js)If you previously copied theCustom<App>example, you may be able to remove yourgetInitialProps.RemovinggetInitialPropsfrompages/_app.js(when possible) is important to leverage new Next.js features!The followinggetInitialPropsdoes nothing and may be removed:classMyAppextendsApp{// Remove me, I do nothing!staticasyncgetInitialProps({ Component,ctx }) {letpageProps={}if(Component.getInitialProps) {pageProps=awaitComponent.getInitialProps(ctx)}return{ pageProps }}render() {// ... etc}}Breaking Changes@zeit/next-typescriptis no longer necessaryNext.js will now ignore usage@zeit/next-typescriptand warn you to remove it. Please remove this plugin from yournext.config.js.Remove references to@zeit/next-typescript/babelfrom your custom.babelrc(if present).The usage offork-ts-checker-webpack-pluginshould also be removed from yournext.config.js.TypeScript Definitions are published with thenextpackage, so you need to uninstall@types/nextas they would conflict.The following types are different:This list was created by the community to help you upgrade, if you find other differences please send a pull-request to this list to help other users.From:import{ NextContext }from'next'import{ NextAppContext,DefaultAppIProps }from'next/app'import{ NextDocumentContext,DefaultDocumentIProps }from'next/document'toimport{ NextPageContext }from'next'import{ AppContext,AppInitialProps }from'next/app'import{ DocumentContext,DocumentInitialProps }from'next/document'Theconfigkey is now an export on a pageYou may no longer export a custom variable namedconfigfrom a page (i.e.export { config }/export const config ...).
This exported variable is now used to specify page-level Next.js configuration like Opt-in AMP and API Route features.You must rename a non-Next.js-purposedconfigexport to something different.next/dynamicno longer renders ""loading..."" by default while loadingDynamic components will not render anything by default while loading. You can still customize this behavior by setting theloadingproperty:importdynamicfrom'next/dynamic'constDynamicComponentWithCustomLoading=dynamic(()=>import('../components/hello2'),{loading:()=><p>Loading</p>,})withAmphas been removed in favor of an exported configuration objectNext.js now has the concept of page-level configuration, so thewithAmphigher-order component has been removed for consistency.This change can beautomatically migrated by running the following commands in the root of your Next.js project:Terminalcurl-Lhttps://github.com/vercel/next-codemod/archive/master.tar.gz|tar-xz--strip=2next-codemod-master/transforms/withamp-to-config.jsnpxjscodeshift-t./withamp-to-config.jspages/**/*.jsTo perform this migration by hand, or view what the codemod will produce, see below:Beforeimport{ withAmp }from'next/amp'functionHome() {return<h1>My AMP Page</h1>}exportdefaultwithAmp(Home)// orexportdefaultwithAmp(Home,{ hybrid:true})AfterexportdefaultfunctionHome() {return<h1>My AMP Page</h1>}exportconstconfig={amp:true,// oramp:'hybrid',}next exportno longer exports pages asindex.htmlPreviously, exportingpages/about.jswould result inout/about/index.html. This behavior has been changed to result inout/about.html.You can revert to the previous behavior by creating anext.config.jswith the following content:next.config.jsmodule.exports={trailingSlash:true,}pages/api/is treated differentlyPages inpages/api/are now consideredAPI Routes.
Pages in this directory will no longer contain a client-side bundle.Deprecated Featuresnext/dynamichas deprecated loading multiple modules at onceThe ability to load multiple modules at once has been deprecated innext/dynamicto be closer to React's implementation (React.lazyandSuspense).Updating code that relies on this behavior is relatively straightforward! We've provided an example of a before/after to help you migrate your application:Beforeimportdynamicfrom'next/dynamic'constHelloBundle=dynamic({modules:()=>{constcomponents={Hello1:()=>import('../components/hello1').then((m)=>m.default),Hello2:()=>import('../components/hello2').then((m)=>m.default),}returncomponents},render:(props,{ Hello1,Hello2 })=>(<div><h1>{props.title}</h1><Hello1/><Hello2/></div>),})functionDynamicBundle() {return<HelloBundletitle=""Dynamic Bundle""/>}exportdefaultDynamicBundleAfterimportdynamicfrom'next/dynamic'constHello1=dynamic(()=>import('../components/hello1'))constHello2=dynamic(()=>import('../components/hello2'))functionHelloBundle({ title }) {return(<div><h1>{title}</h1><Hello1/><Hello2/></div>)}functionDynamicBundle() {return<HelloBundletitle=""Dynamic Bundle""/>}exportdefaultDynamicBundlePreviousVersion 10NextAPI ReferenceWas this helpful?supported.Send"
api reference,API Reference,"IntroductionPages RouterAPI ReferenceAPI ReferenceComponentsAPI Reference for Next.js built-in components in the Pages Router.FunctionsAPI Reference for Functions and Hooks in Pages Router.ConfigurationLearn how to configure your Next.js application.CLIAPI Reference for the Next.js Command Line Interface (CLI) tools.Edge RuntimeAPI Reference for the Edge Runtime.TurbopackTurbopack is an incremental bundler optimized for JavaScript and TypeScript, written in Rust, and built into Next.js.PreviousVersion 9NextComponentsWas this helpful?supported.Send"
components,Components,Pages RouterAPI ReferenceComponentsComponentsFontAPI Reference for the Font ModuleFormLearn how to use the `<Form>` component to handle form submissions and search params updates with client-side navigation.HeadAdd custom elements to the `head` of your page with the built-in Head component.ImageOptimize Images in your Next.js Application using the built-in `next/image` Component.Image (Legacy)Backwards compatible Image Optimization with the Legacy Image component.LinkAPI reference for the `<Link>` component.ScriptOptimize third-party scripts in your Next.js application using the built-in `next/script` Component.PreviousAPI ReferenceNextFontWas this helpful?supported.Send
font,Font,"API ReferenceComponentsFontFont ModuleThis API reference will help you understand how to usenext/font/googleandnext/font/local. For features and usage, please see theOptimizing Fontspage.Font Function ArgumentsFor usage, reviewGoogle FontsandLocal Fonts.Keyfont/googlefont/localTypeRequiredsrcString or Array of ObjectsYesweightString or ArrayRequired/OptionalstyleString or Array-subsetsArray of Strings-axesArray of Strings-displayString-preloadBoolean-fallbackArray of Strings-adjustFontFallbackBoolean or String-variableString-declarationsArray of Objects-srcThe path of the font file as a string or an array of objects (with typeArray<{path: string, weight?: string, style?: string}>) relative to the directory where the font loader function is called.Used innext/font/localRequiredExamples:src:'./fonts/my-font.woff2'wheremy-font.woff2is placed in a directory namedfontsinside theappdirectorysrc:[{path: './inter/Inter-Thin.ttf', weight: '100',},{path: './inter/Inter-Regular.ttf',weight: '400',},{path: './inter/Inter-Bold-Italic.ttf', weight: '700',style: 'italic',},]if the font loader function is called inapp/page.tsxusingsrc:'../styles/fonts/my-font.ttf', thenmy-font.ttfis placed instyles/fontsat the root of the projectweightThe fontweightwith the following possibilities:A string with possible values of the weights available for the specific font or a range of values if it's avariablefontAn array of weight values if the font is not avariable google font. It applies tonext/font/googleonly.Used innext/font/googleandnext/font/localRequired if the font being used isnotvariableExamples:weight: '400': A string for a single weight value - for the fontInter, the possible values are'100','200','300','400','500','600','700','800','900'or'variable'where'variable'is the default)weight: '100 900': A string for the range between100and900for a variable fontweight: ['100','400','900']: An array of 3 possible values for a non variable fontstyleThe fontstylewith the following possibilities:A stringvaluewith default value of'normal'An array of style values if the font is not avariable google font. It applies tonext/font/googleonly.Used innext/font/googleandnext/font/localOptionalExamples:style: 'italic': A string - it can benormaloritalicfornext/font/googlestyle: 'oblique': A string - it can take any value fornext/font/localbut is expected to come fromstandard font stylesstyle: ['italic','normal']: An array of 2 values fornext/font/google- the values are fromnormalanditalicsubsetsThe fontsubsetsdefined by an array of string values with the names of each subset you would like to bepreloaded. Fonts specified viasubsetswill have a link preload tag injected into the head when thepreloadoption is true, which is the default.Used innext/font/googleOptionalExamples:subsets: ['latin']: An array with the subsetlatinYou can find a list of all subsets on the Google Fonts page for your font.axesSome variable fonts have extraaxesthat can be included. By default, only the font weight is included to keep the file size down. The possible values ofaxesdepend on the specific font.Used innext/font/googleOptionalExamples:axes: ['slnt']: An array with valueslntfor theIntervariable font which hasslntas additionalaxesas shownhere. You can find the possibleaxesvalues for your font by using the filter on theGoogle variable fonts pageand looking for axes other thanwghtdisplayThe fontdisplaywith possible stringvaluesof'auto','block','swap','fallback'or'optional'with default value of'swap'.Used innext/font/googleandnext/font/localOptionalExamples:display: 'optional': A string assigned to theoptionalvaluepreloadA boolean value that specifies whether the font should bepreloadedor not. The default istrue.Used innext/font/googleandnext/font/localOptionalExamples:preload: falsefallbackThe fallback font to use if the font cannot be loaded. An array of strings of fallback fonts with no default.OptionalUsed innext/font/googleandnext/font/localExamples:fallback: ['system-ui', 'arial']: An array setting the fallback fonts tosystem-uiorarialadjustFontFallbackFornext/font/google: A boolean value that sets whether an automatic fallback font should be used to reduceCumulative Layout Shift. The default istrue.Fornext/font/local: A string or booleanfalsevalue that sets whether an automatic fallback font should be used to reduceCumulative Layout Shift. The possible values are'Arial','Times New Roman'orfalse. The default is'Arial'.Used innext/font/googleandnext/font/localOptionalExamples:adjustFontFallback: false: fornext/font/googleadjustFontFallback: 'Times New Roman': fornext/font/localvariableA string value to define the CSS variable name to be used if the style is applied with theCSS variable method.Used innext/font/googleandnext/font/localOptionalExamples:variable: '--my-font': The CSS variable--my-fontis declareddeclarationsAn array of font facedescriptorkey-value pairs that define the generated@font-facefurther.Used innext/font/localOptionalExamples:declarations: [{ prop: 'ascent-override', value: '90%' }]Applying StylesYou can apply the font styles in three ways:classNamestyleCSS VariablesclassNameReturns a read-only CSSclassNamefor the loaded font to be passed to an HTML element.<pclassName={inter.className}>Hello, Next.js!</p>styleReturns a read-only CSSstyleobject for the loaded font to be passed to an HTML element, includingstyle.fontFamilyto access the font family name and fallback fonts.<pstyle={inter.style}>Hello World</p>CSS VariablesIf you would like to set your styles in an external style sheet and specify additional options there, use the CSS variable method.In addition to importing the font, also import the CSS file where the CSS variable is defined and set the variable option of the font loader object as follows:app/page.tsxTypeScriptJavaScriptTypeScriptimport{ Inter }from'next/font/google'importstylesfrom'../styles/component.module.css'constinter=Inter({variable:'--font-inter',})To use the font, set theclassNameof the parent container of the text you would like to style to the font loader'svariablevalue and theclassNameof the text to thestylesproperty from the external CSS file.app/page.tsxTypeScriptJavaScriptTypeScript<mainclassName={inter.variable}><pclassName={styles.text}>Hello World</p></main>Define thetextselector class in thecomponent.module.cssCSS file as follows:styles/component.module.css.text{font-family:var(--font-inter);font-weight:200;font-style:italic;}In the example above, the textHello Worldis styled using theInterfont and the generated font fallback withfont-weight: 200andfont-style: italic.Using a font definitions fileEvery time you call thelocalFontor Google font function, that font will be hosted as one instance in your application. Therefore, if you need to use the same font in multiple places, you should load it in one place and import the related font object where you need it. This is done using a font definitions file.For example, create afonts.tsfile in astylesfolder at the root of your app directory.Then, specify your font definitions as follows:styles/fonts.tsTypeScriptJavaScriptTypeScriptimport{ Inter,Lora,Source_Sans_3 }from'next/font/google'importlocalFontfrom'next/font/local'// define your variable fontsconstinter=Inter()constlora=Lora()// define 2 weights of a non-variable fontconstsourceCodePro400=Source_Sans_3({ weight:'400'})constsourceCodePro700=Source_Sans_3({ weight:'700'})// define a custom local font where GreatVibes-Regular.ttf is stored in the styles folderconstgreatVibes=localFont({ src:'./GreatVibes-Regular.ttf'})export{ inter,lora,sourceCodePro400,sourceCodePro700,greatVibes }You can now use these definitions in your code as follows:app/page.tsxTypeScriptJavaScriptTypeScriptimport{ inter,lora,sourceCodePro700,greatVibes }from'../styles/fonts'exportdefaultfunctionPage() {return(<div><pclassName={inter.className}>Hello world using Inter font</p><pstyle={lora.style}>Hello world using Lora font</p><pclassName={sourceCodePro700.className}>Hello world using Source_Sans_3 font with weight 700</p><pclassName={greatVibes.className}>My title in Great Vibes font</p></div>)}To make it easier to access the font definitions in your code, you can define a path alias in yourtsconfig.jsonorjsconfig.jsonfiles as follows:tsconfig.json{""compilerOptions"":{""paths"":{""@/fonts"":[""./styles/fonts""]}}}You can now import any font definition as follows:app/about/page.tsxTypeScriptJavaScriptTypeScriptimport{ greatVibes,sourceCodePro400 }from'@/fonts'Version ChangesVersionChangesv13.2.0@next/fontrenamed tonext/font. Installation no longer required.v13.0.0@next/fontwas added.PreviousComponentsNextFormWas this helpful?supported.Send"
form,Form,"API ReferenceComponentsFormFormThe<Form>component extends the HTML<form>element to provideclient-side navigationon submission, andprogressive enhancement.It's useful for forms that update URL search params as it reduces the boilerplate code needed to achieve the above.Basic usage:/ui/search.jsTypeScriptJavaScriptTypeScriptimportFormfrom'next/form'exportdefaultfunctionPage() {return(<Formaction=""/search"">{/* On submission, the input value will be appended tothe URL, e.g. /search?query=abc */}<inputname=""query""/><buttontype=""submit"">Submit</button></Form>)}ReferenceThe behavior of the<Form>component depends on whether theactionprop is passed astringorfunction.Whenactionis astring, the<Form>behaves like a native HTML form that uses aGETmethod. The form data is encoded into the URL as search params, and when the form is submitted, it navigates to the specified URL. In addition, Next.js:Performs aclient-side navigationinstead of a full page reload when the form is submitted. This retains shared UI and client-side state.action(string) PropsWhenactionis a string, the<Form>component supports the following props:PropExampleTypeRequiredactionaction=""/search""string(URL or relative path)Yesreplacereplace={false}boolean-scrollscroll={true}boolean-action: The URL or path to navigate to when the form is submitted.An empty string""""will navigate to the same route with updated search params.replace: Replaces the current history state instead of pushing a new one to thebrowser's historystack. Default isfalse.scroll: Controls the scroll behavior during navigation. Defaults totrue, this means it will scroll to the top of the new route, and maintain the scroll position for backwards and forwards navigation.CaveatsonSubmit: Can be used to handle form submission logic. However, callingevent.preventDefault()will override<Form>behavior such as navigating to the specified URL.method,encType,target: Are not supported as they override<Form>behavior.Similarly,formMethod,formEncType, andformTargetcan be used to override themethod,encType, andtargetprops respectively, and using them will fallback to native browser behavior.If you need to use these props, use the HTML<form>element instead.<input type=""file"">: Using this input type when theactionis a string will match browser behavior by submitting the filename instead of the file object.PreviousFontNextHeadWas this helpful?supported.Send"
head,Head,"API ReferenceComponentsHeadHeadExamplesHead ElementsLayout ComponentWe expose a built-in component for appending elements to theheadof the page:importHeadfrom'next/head'functionIndexPage() {return(<div><Head><title>My page title</title></Head><p>Hello world!</p></div>)}exportdefaultIndexPageAvoid duplicated tagsTo avoid duplicate tags in yourheadyou can use thekeyproperty, which will make sure the tag is only rendered once, as in the following example:importHeadfrom'next/head'functionIndexPage() {return(<div><Head><title>My page title</title><metaproperty=""og:title""content=""My page title""key=""title""/></Head><Head><metaproperty=""og:title""content=""My new title""key=""title""/></Head><p>Hello world!</p></div>)}exportdefaultIndexPageIn this case only the second<meta property=""og:title"" />is rendered.metatags with duplicatekeyattributes are automatically handled.Good to know:<title>and<base>tags are automatically checked for duplicates by Next.js, so using key is not necessary for these tags.The contents ofheadget cleared upon unmounting the component, so make sure each page completely defines what it needs inhead, without making assumptions about what other pages added.Use minimal nestingtitle,metaor any other elements (e.g.script) need to be contained asdirectchildren of theHeadelement,
or wrapped into maximum one level of<React.Fragment>or arrays—otherwise the tags won't be correctly picked up on client-side navigations.Usenext/scriptfor scriptsWe recommend usingnext/scriptin your component instead of manually creating a<script>innext/head.NohtmlorbodytagsYoucannotuse<Head>to set attributes on<html>or<body>tags. This will result in annext-head-count is missingerror.next/headcan only handle tags inside the HTML<head>tag.PreviousFormNextImageWas this helpful?supported.Send"
image,Image,"API ReferenceComponentsImageImageExamplesImage ComponentGood to know: If you are using a version of Next.js prior to 13, you'll want to use thenext/legacy/imagedocumentation since the component was renamed.This API reference will help you understand how to usepropsandconfiguration optionsavailable for the Image Component. For features and usage, please see theImage Componentpage.app/page.jsimportImagefrom'next/image'exportdefaultfunctionPage() {return(<Imagesrc=""/profile.png""width={500}height={500}alt=""Picture of the author""/>)}PropsHere's a summary of the props available for the Image Component:PropExampleTypeStatussrcsrc=""/profile.png""StringRequiredwidthwidth={500}Integer (px)Requiredheightheight={500}Integer (px)Requiredaltalt=""Picture of the author""StringRequiredloaderloader={imageLoader}Function-fillfill={true}Boolean-sizessizes=""(max-width: 768px) 100vw, 33vw""String-qualityquality={80}Integer (1-100)-prioritypriority={true}Boolean-placeholderplaceholder=""blur""String-stylestyle={{objectFit: ""contain""}}Object-onLoadingCompleteonLoadingComplete={img => done())}FunctionDeprecatedonLoadonLoad={event => done())}Function-onErroronError(event => fail()}Function-loadingloading=""lazy""String-blurDataURLblurDataURL=""data:image/jpeg...""String-overrideSrcoverrideSrc=""/seo.png""String-Required PropsThe Image Component requires the following properties:src,alt,widthandheight(orfill).app/page.jsimportImagefrom'next/image'exportdefaultfunctionPage() {return(<div><Imagesrc=""/profile.png""width={500}height={500}alt=""Picture of the author""/></div>)}srcMust be one of the following:Astatically importedimage fileA path string. This can be either an absolute external URL, or an internal path depending on theloaderprop.When using the defaultloader, also consider the following for source images:When src is an external URL, you must also configureremotePatternsWhen src isanimatedor not a known format (JPEG, PNG, WebP, AVIF, GIF, TIFF) the image will be served as-isWhen src is SVG format, it will be blocked unlessunoptimizedordangerouslyAllowSVGis enabledwidthThewidthproperty represents theintrinsicimage width in pixels. This property is used to infer the correct aspect ratio of the image and avoid layout shift during loading. It does not determine the rendered size of the image, which is controlled by CSS, similar to thewidthattribute in the HTML<img>tag.Required, except forstatically imported imagesor images with thefillproperty.heightTheheightproperty represents theintrinsicimage height in pixels. This property is used to infer the correct aspect ratio of the image and avoid layout shift during loading. It does not determine the rendered size of the image, which is controlled by CSS, similar to theheightattribute in the HTML<img>tag.Required, except forstatically imported imagesor images with thefillproperty.Good to know:Combined, bothwidthandheightproperties are used to determine the aspect ratio of the image which used by browsers to reserve space for the image before it loads.The intrinsic size does not always mean the rendered size in the browser, which will be determined by the parent container. For example, if the parent container is smaller than the intrinsic size, the image will be scaled down to fit the container.You can use thefillproperty when the width and height are unknown.altThealtproperty is used to describe the image for screen readers and search engines. It is also the fallback text if images have been disabled or an error occurs while loading the image.It should contain text that could replace the imagewithout changing the meaning of the page. It is not meant to supplement the image and should not repeat information that is already provided in the captions above or below the image.If the image ispurely decorativeornot intended for the user, thealtproperty should be an empty string (alt="""").Learn moreOptional PropsThe<Image />component accepts a number of additional properties beyond those which are required. This section describes the most commonly-used properties of the Image component. Find details about more rarely-used properties in theAdvanced Propssection.loaderA custom function used to resolve image URLs.Aloaderis a function returning a URL string for the image, given the following parameters:srcwidthqualityHere is an example of using a custom loader:importImagefrom'next/image'constimageLoader=({ src,width,quality })=>{return`https://example.com/${src}?w=${width}&q=${quality||75}`}exportdefaultfunctionPage() {return(<Imageloader={imageLoader}src=""me.png""alt=""Picture of the author""width={500}height={500}/>)}Alternatively, you can use theloaderFileconfiguration innext.config.jsto configure every instance ofnext/imagein your application, without passing a prop.fillfill={true}// {true} | {false}A boolean that causes the image to fill the parent element, which is useful when thewidthandheightare unknown.The parent elementmustassignposition: ""relative"",position: ""fixed"", orposition: ""absolute""style.By default, the img element will automatically be assigned theposition: ""absolute""style.If no styles are applied to the image, the image will stretch to fit the container. You may prefer to setobject-fit: ""contain""for an image which is letterboxed to fit the container and preserve aspect ratio.Alternatively,object-fit: ""cover""will cause the image to fill the entire container and be cropped to preserve aspect ratio.For more information, see also:positionobject-fitobject-positionsizesA string, similar to a media query, that provides information about how wide the image will be at different breakpoints. The value ofsizeswill greatly affect performance for images usingfillor which arestyled to have a responsive size.Thesizesproperty serves two important purposes related to image performance:First, the value ofsizesis used by the browser to determine which size of the image to download, fromnext/image's automatically generatedsrcset. When the browser chooses, it does not yet know the size of the image on the page, so it selects an image that is the same size or larger than the viewport. Thesizesproperty allows you to tell the browser that the image will actually be smaller than full screen. If you don't specify asizesvalue in an image with thefillproperty, a default value of100vw(full screen width) is used.Second, thesizesproperty changes the behavior of the automatically generatedsrcsetvalue. If nosizesvalue is present, a smallsrcsetis generated, suitable for a fixed-size image (1x/2x/etc). Ifsizesis defined, a largesrcsetis generated, suitable for a responsive image (640w/750w/etc). If thesizesproperty includes sizes such as50vw, which represent a percentage of the viewport width, then thesrcsetis trimmed to not include any values which are too small to ever be necessary.For example, if you know your styling will cause an image to be full-width on mobile devices, in a 2-column layout on tablets, and a 3-column layout on desktop displays, you should include a sizes property such as the following:importImagefrom'next/image'exportdefaultfunctionPage() {return(<divclassName=""grid-element""><Imagefillsrc=""/example.png""sizes=""(max-width: 768px) 100vw, (max-width: 1200px) 50vw, 33vw""/></div>)}This examplesizescould have a dramatic effect on performance metrics. Without the33vwsizes, the image selected from the server would be 3 times as wide as it needs to be. Because file size is proportional to the square of the width, withoutsizesthe user would download an image that's 9 times larger than necessary.Learn more aboutsrcsetandsizes:web.devmdnqualityquality={75}// {number 1-100}The quality of the optimized image, an integer between1and100, where100is the best quality and therefore largest file size. Defaults to75.If thequalitiesconfiguration is defined innext.config.js, thequalityprop must match one of the values defined in the configuration.Good to know: If the original source image was already low quality, setting the quality prop too high could cause the resulting optimized image to be larger than the original source image.prioritypriority={false}// {false} | {true}When true, Next.js willpreloadthe image. Lazy loading is automatically disabled for images usingpriority. If theloadingproperty is also used and set tolazy, thepriorityproperty can't be used. Theloadingproperty is only meant for advanced use cases. Removeloadingwhenpriorityis needed.You should use thepriorityproperty on any image detected as theLargest Contentful Paint (LCP)element. It may be appropriate to have multiple priority images, as different images may be the LCP element for different viewport sizes.Should only be used when the image is visible above the fold. Defaults tofalse.placeholderplaceholder='empty'// ""empty"" | ""blur"" | ""data:image/...""A placeholder to use while the image is loading. Possible values areblur,empty, ordata:image/.... Defaults toempty.Whenblur, theblurDataURLproperty will be used as the placeholder. Ifsrcis an object from astatic importand the imported image is.jpg,.png,.webp, or.avif, thenblurDataURLwill be automatically populated, except when the image is detected to be animated.For dynamic images, you must provide theblurDataURLproperty. Solutions such asPlaiceholdercan help withbase64generation.Whendata:image/..., theData URLwill be used as the placeholder while the image is loading.Whenempty, there will be no placeholder while the image is loading, only empty space.Try it out:Demo theblurplaceholderDemo the shimmer effect with data URLplaceholderpropDemo the color effect withblurDataURLpropAdvanced PropsIn some cases, you may need more advanced usage. The<Image />component optionally accepts the following advanced properties.styleAllows passing CSS styles to the underlying image element.components/ProfileImage.jsconstimageStyle={borderRadius:'50%',border:'1px solid #fff',}exportdefaultfunctionProfileImage() {return<Imagesrc=""...""style={imageStyle} />}Remember that the required width and height props can interact with your styling. If you use styling to modify an image's width, you should also style its height toautoto preserve its intrinsic aspect ratio, or your image will be distorted.onLoadingComplete<ImageonLoadingComplete={(img)=>console.log(img.naturalWidth)} />Warning: Deprecated since Next.js 14 in favor ofonLoad.A callback function that is invoked once the image is completely loaded and theplaceholderhas been removed.The callback function will be called with one argument, a reference to the underlying<img>element.onLoad<ImageonLoad={(e)=>console.log(e.target.naturalWidth)} />A callback function that is invoked once the image is completely loaded and theplaceholderhas been removed.The callback function will be called with one argument, the Event which has atargetthat references the underlying<img>element.onError<ImageonError={(e)=>console.error(e.target.id)} />A callback function that is invoked if the image fails to load.loadingloading='lazy'// {lazy} | {eager}The loading behavior of the image. Defaults tolazy.Whenlazy, defer loading the image until it reaches a calculated distance from
the viewport.Wheneager, load the image immediately.Learn more about theloadingattribute.blurDataURLAData URLto
be used as a placeholder image before thesrcimage successfully loads. Only takes effect when combined
withplaceholder=""blur"".Must be a base64-encoded image. It will be enlarged and blurred, so a very small image (10px or
less) is recommended. Including larger images as placeholders may harm your application performance.Try it out:Demo the defaultblurDataURLpropDemo the color effect withblurDataURLpropYou can alsogenerate a solid color Data URLto match the image.unoptimizedunoptimized={false}// {false} | {true}When true, the source image will be served as-is from thesrcinstead of changing quality, size, or format. Defaults tofalse.This is useful for images that do not benefit from optimization such as small images (less than 1KB), vector images (SVG), or animated images (GIF).importImagefrom'next/image'constUnoptimizedImage=(props)=>{return<Image{...props}unoptimized/>}Since Next.js 12.3.0, this prop can be assigned to all images by updatingnext.config.jswith the following configuration:next.config.jsmodule.exports={images:{unoptimized:true,},}overrideSrcWhen providing thesrcprop to the<Image>component, both thesrcsetandsrcattributes are generated automatically for the resulting<img>.input.js<Imagesrc=""/me.jpg""/>output.html<imgsrcset=""/_next/image?url=%2Fme.jpg&w=640&q=75 1x,/_next/image?url=%2Fme.jpg&w=828&q=75 2x""src=""/_next/image?url=%2Fme.jpg&w=828&q=75""/>In some cases, it is not desirable to have thesrcattribute generated and you may wish to override it using theoverrideSrcprop.For example, when upgrading an existing website from<img>to<Image>, you may wish to maintain the samesrcattribute for SEO purposes such as image ranking or avoiding recrawl.input.js<Imagesrc=""/me.jpg""overrideSrc=""/override.jpg""/>output.html<imgsrcset=""/_next/image?url=%2Fme.jpg&w=640&q=75 1x,/_next/image?url=%2Fme.jpg&w=828&q=75 2x""src=""/override.jpg""/>decodingA hint to the browser indicating if it should wait for the image to be decoded before presenting other content updates or not. Defaults toasync.Possible values are the following:async- Asynchronously decode the image and allow other content to be rendered before it completes.sync- Synchronously decode the image for atomic presentation with other content.auto- No preference for the decoding mode; the browser decides what's best.Learn more about thedecodingattribute.Other PropsOther properties on the<Image />component will be passed to the underlyingimgelement with the exception of the following:srcSet. UseDevice Sizesinstead.Configuration OptionsIn addition to props, you can configure the Image Component innext.config.js. The following options are available:localPatternsYou can optionally configurelocalPatternsin yournext.config.jsfile in order to allow specific paths to be optimized and block all others paths.next.config.jsmodule.exports={images:{localPatterns:[{pathname:'/assets/images/**',search:'',},],},}Good to know: The example above will ensure thesrcproperty ofnext/imagemust start with/assets/images/and must not have a query string. Attempting to optimize any other path will respond with 400 Bad Request.remotePatternsTo protect your application from malicious users, configuration is required in order to use external images. This ensures that only external images from your account can be served from the Next.js Image Optimization API. These external images can be configured with theremotePatternsproperty in yournext.config.jsfile, as shown below:next.config.jsmodule.exports={images:{remotePatterns:[{protocol:'https',hostname:'example.com',port:'',pathname:'/account123/**',search:'',},],},}Good to know: The example above will ensure thesrcproperty ofnext/imagemust start withhttps://example.com/account123/and must not have a query string. Any other protocol, hostname, port, or unmatched path will respond with 400 Bad Request.Below is an example of theremotePatternsproperty in thenext.config.jsfile using a wildcard pattern in thehostname:next.config.jsmodule.exports={images:{remotePatterns:[{protocol:'https',hostname:'**.example.com',port:'',search:'',},],},}Good to know: The example above will ensure thesrcproperty ofnext/imagemust start withhttps://img1.example.comorhttps://me.avatar.example.comor any number of subdomains. It cannot have a port or query string. Any other protocol or unmatched hostname will respond with 400 Bad Request.Wildcard patterns can be used for bothpathnameandhostnameand have the following syntax:*match a single path segment or subdomain**match any number of path segments at the end or subdomains at the beginningThe**syntax does not work in the middle of the pattern.Good to know: When omittingprotocol,port,pathname, orsearchthen the wildcard**is implied. This is not recommended because it may allow malicious actors to optimize urls you did not intend.Below is an example of theremotePatternsproperty in thenext.config.jsfile usingsearch:next.config.jsmodule.exports={images:{remotePatterns:[{protocol:'https',hostname:'assets.example.com',search:'?v=1727111025337',},],},}Good to know: The example above will ensure thesrcproperty ofnext/imagemust start withhttps://assets.example.comand must have the exact query string?v=1727111025337. Any other protocol or query string will respond with 400 Bad Request.domainsWarning: Deprecated since Next.js 14 in favor of strictremotePatternsin order to protect your application from malicious users. Only usedomainsif you own all the content served from the domain.Similar toremotePatterns, thedomainsconfiguration can be used to provide a list of allowed hostnames for external images.However, thedomainsconfiguration does not support wildcard pattern matching and it cannot restrict protocol, port, or pathname.Below is an example of thedomainsproperty in thenext.config.jsfile:next.config.jsmodule.exports={images:{domains:['assets.acme.com'],},}loaderFileIf you want to use a cloud provider to optimize images instead of using the Next.js built-in Image Optimization API, you can configure theloaderFilein yournext.config.jslike the following:next.config.jsmodule.exports={images:{loader:'custom',loaderFile:'./my/image/loader.js',},}This must point to a file relative to the root of your Next.js application. The file must export a default function that returns a string, for example:my/image/loader.jsexportdefaultfunctionmyImageLoader({ src,width,quality }) {return`https://example.com/${src}?w=${width}&q=${quality||75}`}Alternatively, you can use theloaderpropto configure each instance ofnext/image.Examples:Custom Image Loader ConfigurationAdvancedThe following configuration is for advanced use cases and is usually not necessary. If you choose to configure the properties below, you will override any changes to the Next.js defaults in future updates.deviceSizesIf you know the expected device widths of your users, you can specify a list of device width breakpoints using thedeviceSizesproperty innext.config.js. These widths are used when thenext/imagecomponent usessizesprop to ensure the correct image is served for user's device.If no configuration is provided, the default below is used.next.config.jsmodule.exports={images:{deviceSizes:[640,750,828,1080,1200,1920,2048,3840],},}imageSizesYou can specify a list of image widths using theimages.imageSizesproperty in yournext.config.jsfile. These widths are concatenated with the array ofdevice sizesto form the full array of sizes used to generate imagesrcsets.The reason there are two separate lists is that imageSizes is only used for images which provide asizesprop, which indicates that the image is less than the full width of the screen.Therefore, the sizes in imageSizes should all be smaller than the smallest size in deviceSizes.If no configuration is provided, the default below is used.next.config.jsmodule.exports={images:{imageSizes:[16,32,48,64,96,128,256,384],},}qualitiesThe defaultImage Optimization APIwill automatically allow all qualities from 1 to 100. If you wish to restrict the allowed qualities, you can add configuration tonext.config.js.next.config.jsmodule.exports={images:{qualities:[25,50,75],},}In this example above, only three qualities are allowed: 25, 50, and 75. If thequalityprop does not match a value in this array, the image will fail with 400 Bad Request.formatsThe defaultImage Optimization APIwill automatically detect the browser's supported image formats via the request'sAcceptheader in order to determine the best output format.If theAcceptheader matches more than one of the configured formats, the first match in the array is used. Therefore, the array order matters. If there is no match (or the source image isanimated), the Image Optimization API will fallback to the original image's format.If no configuration is provided, the default below is used.next.config.jsmodule.exports={images:{formats:['image/webp'],},}You can enable AVIF support, which will fallback to the original format of the src image if the browserdoes not support AVIF:next.config.jsmodule.exports={images:{formats:['image/avif'],},}Good to know:We still recommend using WebP for most use cases.AVIF generally takes 50% longer to encode but it compresses 20% smaller compared to WebP. This means that the first time an image is requested, it will typically be slower and then subsequent requests that are cached will be faster.If you self-host with a Proxy/CDN in front of Next.js, you must configure the Proxy to forward theAcceptheader.Caching BehaviorThe following describes the caching algorithm for the defaultloader. For all other loaders, please refer to your cloud provider's documentation.Images are optimized dynamically upon request and stored in the<distDir>/cache/imagesdirectory. The optimized image file will be served for subsequent requests until the expiration is reached. When a request is made that matches a cached but expired file, the expired image is served stale immediately. Then the image is optimized again in the background (also called revalidation) and saved to the cache with the new expiration date.The cache status of an image can be determined by reading the value of thex-nextjs-cacheresponse header. The possible values are the following:MISS- the path is not in the cache (occurs at most once, on the first visit)STALE- the path is in the cache but exceeded the revalidate time so it will be updated in the backgroundHIT- the path is in the cache and has not exceeded the revalidate timeThe expiration (or rather Max Age) is defined by either theminimumCacheTTLconfiguration or the upstream imageCache-Controlheader, whichever is larger. Specifically, themax-agevalue of theCache-Controlheader is used. If boths-maxageandmax-ageare found, thens-maxageis preferred. Themax-ageis also passed-through to any downstream clients including CDNs and browsers.You can configureminimumCacheTTLto increase the cache duration when the upstream image does not includeCache-Controlheader or the value is very low.You can configuredeviceSizesandimageSizesto reduce the total number of possible generated images.You can configureformatsto disable multiple formats in favor of a single image format.minimumCacheTTLYou can configure the Time to Live (TTL) in seconds for cached optimized images. In many cases, it's better to use aStatic Image Importwhich will automatically hash the file contents and cache the image forever with aCache-Controlheader ofimmutable.next.config.jsmodule.exports={images:{minimumCacheTTL:60,},}The expiration (or rather Max Age) of the optimized image is defined by either theminimumCacheTTLor the upstream imageCache-Controlheader, whichever is larger.If you need to change the caching behavior per image, you can configureheadersto set theCache-Controlheader on the upstream image (e.g./some-asset.jpg, not/_next/imageitself).There is no mechanism to invalidate the cache at this time, so its best to keepminimumCacheTTLlow. Otherwise you may need to manually change thesrcprop or delete<distDir>/cache/images.disableStaticImagesThe default behavior allows you to import static files such asimport icon from './icon.png'and then pass that to thesrcproperty.In some cases, you may wish to disable this feature if it conflicts with other plugins that expect the import to behave differently.You can disable static image imports inside yournext.config.js:next.config.jsmodule.exports={images:{disableStaticImages:true,},}dangerouslyAllowSVGThe defaultloaderdoes not optimize SVG images for a few reasons. First, SVG is a vector format meaning it can be resized losslessly. Second, SVG has many of the same features as HTML/CSS, which can lead to vulnerabilities without properContent Security Policy (CSP) headers.Therefore, we recommended using theunoptimizedprop when thesrcprop is known to be SVG. This happens automatically whensrcends with"".svg"".However, if you need to serve SVG images with the default Image Optimization API, you can setdangerouslyAllowSVGinside yournext.config.js:next.config.jsmodule.exports={images:{dangerouslyAllowSVG:true,contentDispositionType:'attachment',contentSecurityPolicy:""default-src 'self'; script-src 'none'; sandbox;"",},}In addition, it is strongly recommended to also setcontentDispositionTypeto force the browser to download the image, as well ascontentSecurityPolicyto prevent scripts embedded in the image from executing.contentDispositionTypeThe defaultloadersets theContent-Dispositionheader toattachmentfor added protection since the API can serve arbitrary remote images.The default value isattachmentwhich forces the browser to download the image when visiting directly. This is particularly important whendangerouslyAllowSVGis true.You can optionally configureinlineto allow the browser to render the image when visiting directly, without downloading it.next.config.jsmodule.exports={images:{contentDispositionType:'inline',},}Animated ImagesThe defaultloaderwill automatically bypass Image Optimization for animated images and serve the image as-is.Auto-detection for animated files is best-effort and supports GIF, APNG, and WebP. If you want to explicitly bypass Image Optimization for a given animated image, use theunoptimizedprop.Responsive ImagesThe default generatedsrcsetcontains1xand2ximages in order to support different device pixel ratios. However, you may wish to render a responsive image that stretches with the viewport. In that case, you'll need to setsizesas well asstyle(orclassName).You can render a responsive image using one of the following methods below.Responsive image using a static importIf the source image is not dynamic, you can statically import to create a responsive image:components/author.jsimportImagefrom'next/image'importmefrom'../photos/me.jpg'exportdefaultfunctionAuthor() {return(<Imagesrc={me}alt=""Picture of the author""sizes=""100vw""style={{width:'100%',height:'auto',}}/>)}Try it out:Demo the image responsive to viewportResponsive image with aspect ratioIf the source image is a dynamic or a remote url, you will also need to providewidthandheightto set the correct aspect ratio of the responsive image:components/page.jsimportImagefrom'next/image'exportdefaultfunctionPage({ photoUrl }) {return(<Imagesrc={photoUrl}alt=""Picture of the author""sizes=""100vw""style={{width:'100%',height:'auto',}}width={500}height={300}/>)}Try it out:Demo the image responsive to viewportResponsive image withfillIf you don't know the aspect ratio, you will need to set thefillprop and setposition: relativeon the parent. Optionally, you can setobject-fitstyle depending on the desired stretch vs crop behavior:app/page.jsimportImagefrom'next/image'exportdefaultfunctionPage({ photoUrl }) {return(<divstyle={{ position:'relative',width:'300px',height:'500px'}}><Imagesrc={photoUrl}alt=""Picture of the author""sizes=""300px""fillstyle={{objectFit:'contain',}}/></div>)}Try it out:Demo thefillpropTheme Detection CSSIf you want to display a different image for light and dark mode, you can create a new component that wraps two<Image>components and reveals the correct one based on a CSS media query.components/theme-image.module.css.imgDark{display:none;}@media(prefers-color-scheme:dark) {.imgLight{display:none;}.imgDark{display:unset;}}components/theme-image.tsxTypeScriptJavaScriptTypeScriptimportstylesfrom'./theme-image.module.css'importImage,{ ImageProps }from'next/image'typeProps=Omit<ImageProps,'src'|'priority'|'loading'>&{srcLight:stringsrcDark:string}constThemeImage=(props:Props)=>{const{srcLight,srcDark,...rest}=propsreturn(<><Image{...rest}src={srcLight}className={styles.imgLight} /><Image{...rest}src={srcDark}className={styles.imgDark} /></>)}Good to know: The default behavior ofloading=""lazy""ensures that only the correct image is loaded. You cannot usepriorityorloading=""eager""because that would cause both images to load. Instead, you can usefetchPriority=""high"".Try it out:Demo light/dark mode theme detectiongetImagePropsFor more advanced use cases, you can callgetImageProps()to get the props that would be passed to the underlying<img>element, and instead pass to them to another component, style, canvas, etc.This also avoid calling ReactuseState()so it can lead to better performance, but it cannot be used with theplaceholderprop because the placeholder will never be removed.Theme Detection PictureIf you want to display a different image for light and dark mode, you can use the<picture>element to display a different image based on the user'spreferred color scheme.app/page.jsimport{ getImageProps }from'next/image'exportdefaultfunctionPage() {constcommon={ alt:'Theme Example',width:800,height:400}const{props: { srcSet:dark},}=getImageProps({...common,src:'/dark.png'})const{props: { srcSet:light,...rest},}=getImageProps({...common,src:'/light.png'})return(<picture><sourcemedia=""(prefers-color-scheme: dark)""srcSet={dark} /><sourcemedia=""(prefers-color-scheme: light)""srcSet={light} /><img{...rest} /></picture>)}Art DirectionIf you want to display a different image for mobile and desktop, sometimes calledArt Direction, you can provide differentsrc,width,height, andqualityprops togetImageProps().app/page.jsimport{ getImageProps }from'next/image'exportdefaultfunctionHome() {constcommon={ alt:'Art Direction Example',sizes:'100vw'}const{props: { srcSet:desktop},}=getImageProps({...common,width:1440,height:875,quality:80,src:'/desktop.jpg',})const{props: { srcSet:mobile,...rest},}=getImageProps({...common,width:750,height:1334,quality:70,src:'/mobile.jpg',})return(<picture><sourcemedia=""(min-width: 1000px)""srcSet={desktop} /><sourcemedia=""(min-width: 500px)""srcSet={mobile} /><img{...rest}style={{ width:'100%',height:'auto'}} /></picture>)}Background CSSYou can even convert thesrcSetstring to theimage-set()CSS function to optimize a background image.app/page.jsimport{ getImageProps }from'next/image'functiongetBackgroundImage(srcSet='') {constimageSet=srcSet.split(', ').map((str)=>{const[url,dpi]=str.split(' ')return`url(""${url}"")${dpi}`}).join(', ')return`image-set(${imageSet})`}exportdefaultfunctionHome() {const{props: {srcSet},}=getImageProps({ alt:'',width:128,height:128,src:'/img.png'})constbackgroundImage=getBackgroundImage(srcSet)conststyle={ height:'100vh',width:'100vw',backgroundImage }return(<mainstyle={style}><h1>Hello World</h1></main>)}Known Browser BugsThisnext/imagecomponent uses browser nativelazy loading, which may fallback to eager loading for older browsers before Safari 15.4. When using the blur-up placeholder, older browsers before Safari 12 will fallback to empty placeholder. When using styles withwidth/heightofauto, it is possible to causeLayout Shifton older browsers before Safari 15 that don'tpreserve the aspect ratio. For more details, seethis MDN video.Safari 15 - 16.3display a gray border while loading. Safari 16.4fixed this issue. Possible solutions:Use CSS@supports (font: -apple-system-body) and (-webkit-appearance: none) { img[loading=""lazy""] { clip-path: inset(0.6px) } }Usepriorityif the image is above the foldFirefox 67+displays a white background while loading. Possible solutions:EnableAVIFformatsUseplaceholderVersion HistoryVersionChangesv15.0.0contentDispositionTypeconfiguration default changed toattachment.v14.2.23qualitiesconfiguration added.v14.2.15decodingprop added andlocalPatternsconfiguration added.v14.2.14remotePatterns.searchprop added.v14.2.0overrideSrcprop added.v14.1.0getImageProps()is stable.v14.0.0onLoadingCompleteprop anddomainsconfig deprecated.v13.4.14placeholderprop support fordata:/image...v13.2.0contentDispositionTypeconfiguration added.v13.0.6refprop added.v13.0.0Thenext/imageimport was renamed tonext/legacy/image. Thenext/future/imageimport was renamed tonext/image. Acodemod is availableto safely and automatically rename your imports.<span>wrapper removed.layout,objectFit,objectPosition,lazyBoundary,lazyRootprops removed.altis required.onLoadingCompletereceives reference toimgelement. Built-in loader config removed.v12.3.0remotePatternsandunoptimizedconfiguration is stable.v12.2.0ExperimentalremotePatternsand experimentalunoptimizedconfiguration added.layout=""raw""removed.v12.1.1styleprop added. Experimental support forlayout=""raw""added.v12.1.0dangerouslyAllowSVGandcontentSecurityPolicyconfiguration added.v12.0.9lazyRootprop added.v12.0.0formatsconfiguration added.AVIF support added.Wrapper<div>changed to<span>.v11.1.0onLoadingCompleteandlazyBoundaryprops added.v11.0.0srcprop support for static import.placeholderprop added.blurDataURLprop added.v10.0.5loaderprop added.v10.0.1layoutprop added.v10.0.0next/imageintroduced.PreviousHeadNextImage (Legacy)Was this helpful?supported.Send"
image (legacy),Image (Legacy),"API ReferenceComponentsImage (Legacy)Image (Legacy)ExamplesLegacy Image ComponentStarting with Next.js 13, thenext/imagecomponent was rewritten to improve both the performance and developer experience. In order to provide a backwards compatible upgrade solution, the oldnext/imagewas renamed tonext/legacy/image.View thenewnext/imageAPI ReferenceComparisonCompared tonext/legacy/image, the newnext/imagecomponent has the following changes:Removes<span>wrapper around<img>in favor ofnative computed aspect ratioAdds support for canonicalstylepropRemoveslayoutprop in favor ofstyleorclassNameRemovesobjectFitprop in favor ofstyleorclassNameRemovesobjectPositionprop in favor ofstyleorclassNameRemovesIntersectionObserverimplementation in favor ofnative lazy loadingRemoveslazyBoundaryprop since there is no native equivalentRemoveslazyRootprop since there is no native equivalentRemovesloaderconfig in favor ofloaderpropChangedaltprop from optional to requiredChangedonLoadingCompletecallback to receive reference to<img>elementRequired PropsThe<Image />component requires the following properties.srcMust be one of the following:Astatically importedimage fileA path string. This can be either an absolute external URL, or an internal path depending on theloaderprop orloader configuration.When using the defaultloader, also consider the following for source images:When src is an external URL, you must also configureremotePatternsWhen src isanimatedor not a known format (JPEG, PNG, WebP, AVIF, GIF, TIFF) the image will be served as-isWhen src is SVG format, it will be blocked unlessunoptimizedordangerouslyAllowSVGis enabledwidthThewidthproperty can represent either therenderedwidth ororiginalwidth in pixels, depending on thelayoutandsizesproperties.When usinglayout=""intrinsic""orlayout=""fixed""thewidthproperty represents therenderedwidth in pixels, so it will affect how large the image appears.When usinglayout=""responsive"",layout=""fill"", thewidthproperty represents theoriginalwidth in pixels, so it will only affect the aspect ratio.Thewidthproperty is required, except forstatically imported images, or those withlayout=""fill"".heightTheheightproperty can represent either therenderedheight ororiginalheight in pixels, depending on thelayoutandsizesproperties.When usinglayout=""intrinsic""orlayout=""fixed""theheightproperty represents therenderedheight in pixels, so it will affect how large the image appears.When usinglayout=""responsive"",layout=""fill"", theheightproperty represents theoriginalheight in pixels, so it will only affect the aspect ratio.Theheightproperty is required, except forstatically imported images, or those withlayout=""fill"".Optional PropsThe<Image />component accepts a number of additional properties beyond those which are required. This section describes the most commonly-used properties of the Image component. Find details about more rarely-used properties in theAdvanced Propssection.layoutThe layout behavior of the image as the viewport changes size.layoutBehaviorsrcSetsizesHas wrapper and sizerintrinsic(default)Scaledownto fit width of container, up to image size1x,2x(based onimageSizes)N/AyesfixedSized towidthandheightexactly1x,2x(based onimageSizes)N/AyesresponsiveScale to fit width of container640w,750w, ...2048w,3840w(based onimageSizesanddeviceSizes)100vwyesfillGrow in both X and Y axes to fill container640w,750w, ...2048w,3840w(based onimageSizesanddeviceSizes)100vwyesDemo theintrinsiclayout (default)Whenintrinsic, the image will scale the dimensions down for smaller viewports, but maintain the original dimensions for larger viewports.Demo thefixedlayoutWhenfixed, the image dimensions will not change as the viewport changes (no responsiveness) similar to the nativeimgelement.Demo theresponsivelayoutWhenresponsive, the image will scale the dimensions down for smaller viewports and scale up for larger viewports.Ensure the parent element usesdisplay: blockin their stylesheet.Demo thefilllayoutWhenfill, the image will stretch both width and height to the dimensions of the parent element, provided the parent element is relative.This is usually paired with theobjectFitproperty.Ensure the parent element hasposition: relativein their stylesheet.Demo background imageloaderA custom function used to resolve URLs. Setting the loader as a prop on the Image component overrides the default loader defined in theimagessection ofnext.config.js.Aloaderis a function returning a URL string for the image, given the following parameters:srcwidthqualityHere is an example of using a custom loader:importImagefrom'next/legacy/image'constmyLoader=({ src,width,quality })=>{return`https://example.com/${src}?w=${width}&q=${quality||75}`}constMyImage=(props)=>{return(<Imageloader={myLoader}src=""me.png""alt=""Picture of the author""width={500}height={500}/>)}sizesA string that provides information about how wide the image will be at different breakpoints. The value ofsizeswill greatly affect performance for images usinglayout=""responsive""orlayout=""fill"". It will be ignored for images usinglayout=""intrinsic""orlayout=""fixed"".Thesizesproperty serves two important purposes related to image performance:First, the value ofsizesis used by the browser to determine which size of the image to download, fromnext/legacy/image's automatically-generated source set. When the browser chooses, it does not yet know the size of the image on the page, so it selects an image that is the same size or larger than the viewport. Thesizesproperty allows you to tell the browser that the image will actually be smaller than full screen. If you don't specify asizesvalue, a default value of100vw(full screen width) is used.Second, thesizesvalue is parsed and used to trim the values in the automatically-created source set. If thesizesproperty includes sizes such as50vw, which represent a percentage of the viewport width, then the source set is trimmed to not include any values which are too small to ever be necessary.For example, if you know your styling will cause an image to be full-width on mobile devices, in a 2-column layout on tablets, and a 3-column layout on desktop displays, you should include a sizes property such as the following:importImagefrom'next/legacy/image'constExample=()=>(<divclassName=""grid-element""><Imagesrc=""/example.png""layout=""fill""sizes=""(max-width: 768px) 100vw,(max-width: 1200px) 50vw,33vw""/></div>)This examplesizescould have a dramatic effect on performance metrics. Without the33vwsizes, the image selected from the server would be 3 times as wide as it needs to be. Because file size is proportional to the square of the width, withoutsizesthe user would download an image that's 9 times larger than necessary.Learn more aboutsrcsetandsizes:web.devmdnqualityThe quality of the optimized image, an integer between1and100where100is the best quality. Defaults to75.priorityWhen true, the image will be considered high priority andpreload. Lazy loading is automatically disabled for images usingpriority.You should use thepriorityproperty on any image detected as theLargest Contentful Paint (LCP)element. It may be appropriate to have multiple priority images, as different images may be the LCP element for different viewport sizes.Should only be used when the image is visible above the fold. Defaults tofalse.placeholderA placeholder to use while the image is loading. Possible values areblurorempty. Defaults toempty.Whenblur, theblurDataURLproperty will be used as the placeholder. Ifsrcis an object from astatic importand the imported image is.jpg,.png,.webp, or.avif, thenblurDataURLwill be automatically populated.For dynamic images, you must provide theblurDataURLproperty. Solutions such asPlaiceholdercan help withbase64generation.Whenempty, there will be no placeholder while the image is loading, only empty space.Try it out:Demo theblurplaceholderDemo the shimmer effect withblurDataURLpropDemo the color effect withblurDataURLpropAdvanced PropsIn some cases, you may need more advanced usage. The<Image />component optionally accepts the following advanced properties.styleAllowspassing CSS stylesto the underlying image element.Note that alllayoutmodes apply their own styles to the image element, and these automatic styles take precedence over thestyleprop.Also keep in mind that the requiredwidthandheightprops can interact with your styling. If you use styling to modify an image'swidth, you must set theheight=""auto""style as well, or your image will be distorted.objectFitDefines how the image will fit into its parent container when usinglayout=""fill"".This value is passed to theobject-fit CSS propertyfor thesrcimage.objectPositionDefines how the image is positioned within its parent element when usinglayout=""fill"".This value is passed to theobject-position CSS propertyapplied to the image.onLoadingCompleteA callback function that is invoked once the image is completely loaded and theplaceholderhas been removed.TheonLoadingCompletefunction accepts one parameter, an object with the following properties:naturalWidthnaturalHeightloadingThe loading behavior of the image. Defaults tolazy.Whenlazy, defer loading the image until it reaches a calculated distance from
the viewport.Wheneager, load the image immediately.Learn moreblurDataURLAData URLto
be used as a placeholder image before thesrcimage successfully loads. Only takes effect when combined
withplaceholder=""blur"".Must be a base64-encoded image. It will be enlarged and blurred, so a very small image (10px or
less) is recommended. Including larger images as placeholders may harm your application performance.Try it out:Demo the defaultblurDataURLpropDemo the shimmer effect withblurDataURLpropDemo the color effect withblurDataURLpropYou can alsogenerate a solid color Data URLto match the image.lazyBoundaryA string (with similar syntax to the margin property) that acts as the bounding box used to detect the intersection of the viewport with the image and trigger lazyloading. Defaults to""200px"".If the image is nested in a scrollable parent element other than the root document, you will also need to assign thelazyRootprop.Learn morelazyRootA ReactRefpointing to the scrollable parent element. Defaults tonull(the document viewport).The Ref must point to a DOM element or a React component thatforwards the Refto the underlying DOM element.Example pointing to a DOM elementimportImagefrom'next/legacy/image'importReactfrom'react'constExample=()=>{constlazyRoot=React.useRef(null)return(<divref={lazyRoot}style={{ overflowX:'scroll',width:'500px'}}><ImagelazyRoot={lazyRoot}src=""/one.jpg""width=""500""height=""500""/><ImagelazyRoot={lazyRoot}src=""/two.jpg""width=""500""height=""500""/></div>)}Example pointing to a React componentimportImagefrom'next/legacy/image'importReactfrom'react'constContainer=React.forwardRef((props,ref)=>{return(<divref={ref}style={{ overflowX:'scroll',width:'500px'}}>{props.children}</div>)})constExample=()=>{constlazyRoot=React.useRef(null)return(<Containerref={lazyRoot}><ImagelazyRoot={lazyRoot}src=""/one.jpg""width=""500""height=""500""/><ImagelazyRoot={lazyRoot}src=""/two.jpg""width=""500""height=""500""/></Container>)}Learn moreunoptimizedWhen true, the source image will be served as-is from thesrcinstead of changing quality, size, or format. Defaults tofalse.This is useful for images that do not benefit from optimization such as small images (less than 1KB), vector images (SVG), or animated images (GIF).importImagefrom'next/image'constUnoptimizedImage=(props)=>{return<Image{...props}unoptimized/>}Since Next.js 12.3.0, this prop can be assigned to all images by updatingnext.config.jswith the following configuration:next.config.jsmodule.exports={images:{unoptimized:true,},}Other PropsOther properties on the<Image />component will be passed to the underlyingimgelement with the exception of the following:srcSet. UseDevice Sizesinstead.ref. UseonLoadingCompleteinstead.decoding. It is always""async"".Configuration OptionsRemote PatternsTo protect your application from malicious users, configuration is required in order to use external images. This ensures that only external images from your account can be served from the Next.js Image Optimization API. These external images can be configured with theremotePatternsproperty in yournext.config.jsfile, as shown below:next.config.jsmodule.exports={images:{remotePatterns:[{protocol:'https',hostname:'example.com',port:'',pathname:'/account123/**',search:'',},],},}Good to know: The example above will ensure thesrcproperty ofnext/legacy/imagemust start withhttps://example.com/account123/and must not have a query string. Any other protocol, hostname, port, or unmatched path will respond with 400 Bad Request.Below is an example of theremotePatternsproperty in thenext.config.jsfile using a wildcard pattern in thehostname:next.config.jsmodule.exports={images:{remotePatterns:[{protocol:'https',hostname:'**.example.com',port:'',search:'',},],},}Good to know: The example above will ensure thesrcproperty ofnext/legacy/imagemust start withhttps://img1.example.comorhttps://me.avatar.example.comor any number of subdomains. It cannot have a port or query string. Any other protocol or unmatched hostname will respond with 400 Bad Request.Wildcard patterns can be used for bothpathnameandhostnameand have the following syntax:*match a single path segment or subdomain**match any number of path segments at the end or subdomains at the beginningThe**syntax does not work in the middle of the pattern.Good to know: When omittingprotocol,port,pathname, orsearchthen the wildcard**is implied. This is not recommended because it may allow malicious actors to optimize urls you did not intend.Below is an example of theremotePatternsproperty in thenext.config.jsfile usingsearch:next.config.jsmodule.exports={images:{remotePatterns:[{protocol:'https',hostname:'assets.example.com',search:'?v=1727111025337',},],},}Good to know: The example above will ensure thesrcproperty ofnext/legacy/imagemust start withhttps://assets.example.comand must have the exact query string?v=1727111025337. Any other protocol or query string will respond with 400 Bad Request.DomainsWarning: Deprecated since Next.js 14 in favor of strictremotePatternsin order to protect your application from malicious users. Only usedomainsif you own all the content served from the domain.Similar toremotePatterns, thedomainsconfiguration can be used to provide a list of allowed hostnames for external images.However, thedomainsconfiguration does not support wildcard pattern matching and it cannot restrict protocol, port, or pathname.Below is an example of thedomainsproperty in thenext.config.jsfile:next.config.jsmodule.exports={images:{domains:['assets.acme.com'],},}Loader ConfigurationIf you want to use a cloud provider to optimize images instead of using the Next.js built-in Image Optimization API, you can configure theloaderandpathprefix in yournext.config.jsfile. This allows you to use relative URLs for the Imagesrcand automatically generate the correct absolute URL for your provider.next.config.jsmodule.exports={images:{loader:'imgix',path:'https://example.com/myaccount/',},}Built-in LoadersThe following Image Optimization cloud providers are included:Default: Works automatically withnext dev,next start, or a custom serverVercel: Works automatically when you deploy on Vercel, no configuration necessary.Learn moreImgix:loader: 'imgix'Cloudinary:loader: 'cloudinary'Akamai:loader: 'akamai'Custom:loader: 'custom'use a custom cloud provider by implementing theloaderprop on thenext/legacy/imagecomponentIf you need a different provider, you can use theloaderprop withnext/legacy/image.Images can not be optimized at build time usingoutput: 'export', only on-demand. To usenext/legacy/imagewithoutput: 'export', you will need to use a different loader than the default.Read more in the discussion.AdvancedThe following configuration is for advanced use cases and is usually not necessary. If you choose to configure the properties below, you will override any changes to the Next.js defaults in future updates.Device SizesIf you know the expected device widths of your users, you can specify a list of device width breakpoints using thedeviceSizesproperty innext.config.js. These widths are used when thenext/legacy/imagecomponent useslayout=""responsive""orlayout=""fill""to ensure the correct image is served for user's device.If no configuration is provided, the default below is used.next.config.jsmodule.exports={images:{deviceSizes:[640,750,828,1080,1200,1920,2048,3840],},}Image SizesYou can specify a list of image widths using theimages.imageSizesproperty in yournext.config.jsfile. These widths are concatenated with the array ofdevice sizesto form the full array of sizes used to generate imagesrcsets.The reason there are two separate lists is that imageSizes is only used for images which provide asizesprop, which indicates that the image is less than the full width of the screen.Therefore, the sizes in imageSizes should all be smaller than the smallest size in deviceSizes.If no configuration is provided, the default below is used.next.config.jsmodule.exports={images:{imageSizes:[16,32,48,64,96,128,256,384],},}Acceptable FormatsThe defaultImage Optimization APIwill automatically detect the browser's supported image formats via the request'sAcceptheader in order to determine the best output format.If theAcceptheader matches more than one of the configured formats, the first match in the array is used. Therefore, the array order matters. If there is no match (or the source image isanimated), the Image Optimization API will fallback to the original image's format.If no configuration is provided, the default below is used.next.config.jsmodule.exports={images:{formats:['image/webp'],},}You can enable AVIF support, which will fallback to the original format of the src image if the browserdoes not support AVIF:next.config.jsmodule.exports={images:{formats:['image/avif'],},}Good to know:We still recommend using WebP for most use cases.AVIF generally takes 50% longer to encode but it compresses 20% smaller compared to WebP. This means that the first time an image is requested, it will typically be slower and then subsequent requests that are cached will be faster.If you self-host with a Proxy/CDN in front of Next.js, you must configure the Proxy to forward theAcceptheader.Caching BehaviorThe following describes the caching algorithm for the defaultloader. For all other loaders, please refer to your cloud provider's documentation.Images are optimized dynamically upon request and stored in the<distDir>/cache/imagesdirectory. The optimized image file will be served for subsequent requests until the expiration is reached. When a request is made that matches a cached but expired file, the expired image is served stale immediately. Then the image is optimized again in the background (also called revalidation) and saved to the cache with the new expiration date.The cache status of an image can be determined by reading the value of thex-nextjs-cache(x-vercel-cachewhen deployed on Vercel) response header. The possible values are the following:MISS- the path is not in the cache (occurs at most once, on the first visit)STALE- the path is in the cache but exceeded the revalidate time so it will be updated in the backgroundHIT- the path is in the cache and has not exceeded the revalidate timeThe expiration (or rather Max Age) is defined by either theminimumCacheTTLconfiguration or the upstream imageCache-Controlheader, whichever is larger. Specifically, themax-agevalue of theCache-Controlheader is used. If boths-maxageandmax-ageare found, thens-maxageis preferred. Themax-ageis also passed-through to any downstream clients including CDNs and browsers.You can configureminimumCacheTTLto increase the cache duration when the upstream image does not includeCache-Controlheader or the value is very low.You can configuredeviceSizesandimageSizesto reduce the total number of possible generated images.You can configureformatsto disable multiple formats in favor of a single image format.Minimum Cache TTLYou can configure the Time to Live (TTL) in seconds for cached optimized images. In many cases, it's better to use aStatic Image Importwhich will automatically hash the file contents and cache the image forever with aCache-Controlheader ofimmutable.next.config.jsmodule.exports={images:{minimumCacheTTL:60,},}The expiration (or rather Max Age) of the optimized image is defined by either theminimumCacheTTLor the upstream imageCache-Controlheader, whichever is larger.If you need to change the caching behavior per image, you can configureheadersto set theCache-Controlheader on the upstream image (e.g./some-asset.jpg, not/_next/imageitself).There is no mechanism to invalidate the cache at this time, so its best to keepminimumCacheTTLlow. Otherwise you may need to manually change thesrcprop or delete<distDir>/cache/images.Disable Static ImportsThe default behavior allows you to import static files such asimport icon from './icon.png'and then pass that to thesrcproperty.In some cases, you may wish to disable this feature if it conflicts with other plugins that expect the import to behave differently.You can disable static image imports inside yournext.config.js:next.config.jsmodule.exports={images:{disableStaticImages:true,},}Dangerously Allow SVGThe defaultloaderdoes not optimize SVG images for a few reasons. First, SVG is a vector format meaning it can be resized losslessly. Second, SVG has many of the same features as HTML/CSS, which can lead to vulnerabilities without properContent Security Policy (CSP) headers.Therefore, we recommended using theunoptimizedprop when thesrcprop is known to be SVG. This happens automatically whensrcends with"".svg"".However, if you need to serve SVG images with the default Image Optimization API, you can setdangerouslyAllowSVGinside yournext.config.js:next.config.jsmodule.exports={images:{dangerouslyAllowSVG:true,contentDispositionType:'attachment',contentSecurityPolicy:""default-src 'self'; script-src 'none'; sandbox;"",},}In addition, it is strongly recommended to also setcontentDispositionTypeto force the browser to download the image, as well ascontentSecurityPolicyto prevent scripts embedded in the image from executing.contentDispositionTypeThe defaultloadersets theContent-Dispositionheader toattachmentfor added protection since the API can serve arbitrary remote images.The default value isattachmentwhich forces the browser to download the image when visiting directly. This is particularly important whendangerouslyAllowSVGis true.You can optionally configureinlineto allow the browser to render the image when visiting directly, without downloading it.next.config.jsmodule.exports={images:{contentDispositionType:'inline',},}Animated ImagesThe defaultloaderwill automatically bypass Image Optimization for animated images and serve the image as-is.Auto-detection for animated files is best-effort and supports GIF, APNG, and WebP. If you want to explicitly bypass Image Optimization for a given animated image, use theunoptimizedprop.Version HistoryVersionChangesv13.0.0next/imagerenamed tonext/legacy/imagePreviousImageNextLinkWas this helpful?supported.Send"
link,Link,"API ReferenceComponentsLinkLink<Link>is a React component that extends the HTML<a>element to provideprefetchingand client-side navigation between routes. It is the primary way to navigate between routes in Next.js.Basic usage:pages/index.tsxTypeScriptJavaScriptTypeScriptimportLinkfrom'next/link'exportdefaultfunctionHome() {return<Linkhref=""/dashboard"">Dashboard</Link>}ReferenceThe following props can be passed to the<Link>component:PropExampleTypeRequiredhrefhref=""/dashboard""String or ObjectYesreplacereplace={false}Boolean-scrollscroll={false}Boolean-prefetchprefetch={false}Boolean-legacyBehaviorlegacyBehavior={true}Boolean-passHrefpassHref={true}Boolean-shallowshallow={false}Boolean-localelocale=""fr""String or Boolean-Good to know:<a>tag attributes such asclassNameortarget=""_blank""can be added to<Link>as props and will be passed to the underlying<a>element.href(required)The path or URL to navigate to.pages/index.tsxTypeScriptJavaScriptTypeScriptimportLinkfrom'next/link'// Navigate to /about?name=testexportdefaultfunctionHome() {return(<Linkhref={{pathname:'/about',query:{ name:'test'},}}>About</Link>)}replaceDefaults tofalse.Whentrue,next/linkwill replace the current history state instead of adding a new URL into thebrowser's historystack.pages/index.tsxTypeScriptJavaScriptTypeScriptimportLinkfrom'next/link'exportdefaultfunctionHome() {return(<Linkhref=""/dashboard""replace>Dashboard</Link>)}scrollDefaults totrue.The default scrolling behavior of<Link>in Next.jsis to maintain scroll position, similar to how browsers handle back and forwards navigation. When you navigate to a newPage, scroll position will stay the same as long as the Page is visible in the viewport. However, if the Page is not visible in the viewport, Next.js will scroll to the top of the first Page element.Whenscroll = {false}, Next.js will not attempt to scroll to the first Page element.Good to know: Next.js checks ifscroll: falsebefore managing scroll behavior. If scrolling is enabled, it identifies the relevant DOM node for navigation and inspects each top-level element. All non-scrollable elements and those without rendered HTML are bypassed, this includes sticky or fixed positioned elements, and non-visible elements such as those calculated withgetBoundingClientRect. Next.js then continues through siblings until it identifies a scrollable element that is visible in the viewport.pages/index.tsxTypeScriptJavaScriptTypeScriptimportLinkfrom'next/link'exportdefaultfunctionHome() {return(<Linkhref=""/dashboard""scroll={false}>Dashboard</Link>)}prefetchPrefetching happens when a<Link />component enters the user's viewport (initially or through scroll). Next.js prefetches and loads the linked route (denoted by thehref) and data in the background to improve the performance of client-side navigation's.Prefetching is only enabled in production.The following values can be passed to theprefetchprop:true(default): The full route and its data will be prefetched.false: Prefetching will not happen when entering the viewport, but will happen on hover. If you want to completely remove fetching on hover as well, consider using an<a>tag orincrementally adoptingthe App Router, which enables disabling prefetching on hover too.pages/index.tsxTypeScriptJavaScriptTypeScriptimportLinkfrom'next/link'exportdefaultfunctionHome() {return(<Linkhref=""/dashboard""prefetch={false}>Dashboard</Link>)}legacyBehaviorAn<a>element is no longer required as a child of<Link>. Add thelegacyBehaviorprop to use the legacy behavior or remove the<a>to upgrade. Acodemod is availableto automatically upgrade your code.Good to know: whenlegacyBehavioris not set totrue, allanchortag properties can be passed tonext/linkas well such as,className,onClick, etc.passHrefForcesLinkto send thehrefproperty to its child. Defaults tofalse. See thepassing a functional componentexample for more information.shallowUpdate the path of the current page without rerunninggetStaticProps,getServerSidePropsorgetInitialProps. Defaults tofalse.pages/index.tsxTypeScriptJavaScriptTypeScriptimportLinkfrom'next/link'exportdefaultfunctionHome() {return(<Linkhref=""/dashboard""shallow={false}>Dashboard</Link>)}localeThe active locale is automatically prepended.localeallows for providing a different locale. Whenfalsehrefhas to include the locale as the default behavior is disabled.pages/index.tsxTypeScriptJavaScriptTypeScriptimportLinkfrom'next/link'exportdefaultfunctionHome() {return(<>{/* Default behavior: locale is prepended */}<Linkhref=""/dashboard"">Dashboard (with locale)</Link>{/* Disable locale prepending */}<Linkhref=""/dashboard""locale={false}>Dashboard (without locale)</Link>{/* Specify a different locale */}<Linkhref=""/dashboard""locale=""fr"">Dashboard (French)</Link></>)}ExamplesThe following examples demonstrate how to use the<Link>component in different scenarios.Linking to dynamic route segmentsFordynamic route segments, it can be handy to use template literals to create the link's path.For example, you can generate a list of links to the dynamic routepages/blog/[slug].jspages/blog/index.tsxTypeScriptJavaScriptTypeScriptimportLinkfrom'next/link'functionPosts({ posts }) {return(<ul>{posts.map((post)=>(<likey={post.id}><Linkhref={`/blog/${post.slug}`}>{post.title}</Link></li>))}</ul>)}If the child is a custom component that wraps an<a>tagIf the child ofLinkis a custom component that wraps an<a>tag, you must addpassHreftoLink. This is necessary if you’re using libraries likestyled-components. Without this, the<a>tag will not have thehrefattribute, which hurts your site's accessibility and might affect SEO. If you're usingESLint, there is a built-in rulenext/link-passhrefto ensure correct usage ofpassHref.components/nav-link.tsxTypeScriptJavaScriptTypeScriptimportLinkfrom'next/link'importstyledfrom'styled-components'// This creates a custom component that wraps an <a> tagconstRedLink=styled.a`color: red;`functionNavLink({ href,name }) {return(<Linkhref={href}passHreflegacyBehavior><RedLink>{name}</RedLink></Link>)}exportdefaultNavLinkIf you’re usingemotion’s JSX pragma feature (@jsx jsx), you must usepassHrefeven if you use an<a>tag directly.The component should supportonClickproperty to trigger navigation correctly.Nesting a functional componentIf the child ofLinkis a functional component, in addition to usingpassHrefandlegacyBehavior, you must wrap the component inReact.forwardRef:pages/index.tsxTypeScriptJavaScriptTypeScriptimportLinkfrom'next/link'importReactfrom'react'// Define the props type for MyButtoninterfaceMyButtonProps{onClick?:React.MouseEventHandler<HTMLAnchorElement>href?:string}// Use React.ForwardRefRenderFunction to properly type the forwarded refconstMyButton:React.ForwardRefRenderFunction<HTMLAnchorElement,MyButtonProps>=({ onClick,href },ref)=>{return(<ahref={href}onClick={onClick}ref={ref}>Click Me</a>)}// Use React.forwardRef to wrap the componentconstForwardedMyButton=React.forwardRef(MyButton)exportdefaultfunctionHome() {return(<Linkhref=""/about""passHreflegacyBehavior><ForwardedMyButton/></Link>)}Passing a URL ObjectLinkcan also receive a URL object and it will automatically format it to create the URL string:pages/index.tsTypeScriptJavaScriptTypeScriptimportLinkfrom'next/link'functionHome() {return(<ul><li><Linkhref={{pathname:'/about',query:{ name:'test'},}}>About us</Link></li><li><Linkhref={{pathname:'/blog/[slug]',query:{ slug:'my-post'},}}>Blog Post</Link></li></ul>)}exportdefaultHomeThe above example has a link to:A predefined route:/about?name=testAdynamic route:/blog/my-postYou can use every property as defined in theNode.js URL module documentation.Replace the URL instead of pushThe default behavior of theLinkcomponent is topusha new URL into thehistorystack. You can use thereplaceprop to prevent adding a new entry, as in the following example:pages/index.jsTypeScriptJavaScriptTypeScriptimportLinkfrom'next/link'exportdefaultfunctionHome() {return(<Linkhref=""/about""replace>About us</Link>)}Disable scrolling to the top of the pageThe default behavior ofLinkis to scroll to the top of the page. When there is a hash defined it will scroll to the specific id, like a normal<a>tag. To prevent scrolling to the top / hashscroll={false}can be added toLink:pages/index.tsxTypeScriptJavaScriptTypeScriptimportLinkfrom'next/link'exportdefaultfunctionHome() {return(<Linkhref=""/#hashid""scroll={false}>Disables scrolling to the top</Link>)}Prefetching links in MiddlewareIt's common to useMiddlewarefor authentication or other purposes that involve rewriting the user to a different page. In order for the<Link />component to properly prefetch links with rewrites via Middleware, you need to tell Next.js both the URL to display and the URL to prefetch. This is required to avoid un-necessary fetches to middleware to know the correct route to prefetch.For example, if you want to serve a/dashboardroute that has authenticated and visitor views, you can add the following in your Middleware to redirect the user to the correct page:middleware.tsTypeScriptJavaScriptTypeScriptimport{ NextResponse }from'next/server'exportfunctionmiddleware(request:Request) {constnextUrl=request.nextUrlif(nextUrl.pathname==='/dashboard') {if(request.cookies.authToken) {returnNextResponse.rewrite(newURL('/auth/dashboard',request.url))}else{returnNextResponse.rewrite(newURL('/public/dashboard',request.url))}}}In this case, you would want to use the following code in your<Link />component:pages/index.tsxTypeScriptJavaScriptTypeScript'use client'importLinkfrom'next/link'importuseIsAuthedfrom'./hooks/useIsAuthed'// Your auth hookexportdefaultfunctionHome() {constisAuthed=useIsAuthed()constpath=isAuthed?'/auth/dashboard':'/public/dashboard'return(<Linkas=""/dashboard""href={path}>Dashboard</Link>)}Good to know: If you're usingDynamic Routes, you'll need to adapt yourasandhrefprops. For example, if you have a Dynamic Route like/dashboard/authed/[user]that you want to present differently via middleware, you would write:<Link href={{ pathname: '/dashboard/authed/[user]', query: { user: username } }} as=""/dashboard/[user]"">Profile</Link>.Version historyVersionChangesv13.0.0No longer requires a child<a>tag. Acodemodis provided to automatically update your codebase.v10.0.0hrefprops pointing to a dynamic route are automatically resolved and no longer require anasprop.v8.0.0Improved prefetching performance.v1.0.0next/linkintroduced.PreviousImage (Legacy)NextScriptWas this helpful?supported.Send"
script,Script,"API ReferenceComponentsScriptScriptThis API reference will help you understand how to usepropsavailable for the Script Component. For features and usage, please see theOptimizing Scriptspage.app/dashboard/page.tsxTypeScriptJavaScriptTypeScriptimportScriptfrom'next/script'exportdefaultfunctionDashboard() {return(<><Scriptsrc=""https://example.com/script.js""/></>)}PropsHere's a summary of the props available for the Script Component:PropExampleTypeRequiredsrcsrc=""http://example.com/script""StringRequired unless inline script is usedstrategystrategy=""lazyOnload""String-onLoadonLoad={onLoadFunc}Function-onReadyonReady={onReadyFunc}Function-onErroronError={onErrorFunc}Function-Required PropsThe<Script />component requires the following properties.srcA path string specifying the URL of an external script. This can be either an absolute external URL or an internal path. Thesrcproperty is required unless an inline script is used.Optional PropsThe<Script />component accepts a number of additional properties beyond those which are required.strategyThe loading strategy of the script. There are four different strategies that can be used:beforeInteractive: Load before any Next.js code and before any page hydration occurs.afterInteractive: (default) Load early but after some hydration on the page occurs.lazyOnload: Load during browser idle time.worker: (experimental) Load in a web worker.beforeInteractiveScripts that load with thebeforeInteractivestrategy are injected into the initial HTML from the server, downloaded before any Next.js module, and executed in the order they are placed beforeanyhydration occurs on the page.Scripts denoted with this strategy are preloaded and fetched before any first-party code, but their execution does not block page hydration from occurring.beforeInteractivescripts must be placed inside theDocumentComponent (pages/_document.js) and are designed to load scripts that are needed by the entire site (i.e. the script will load when any page in the application has been loaded server-side).This strategy should only be used for critical scripts that need to be fetched before any part of the page becomes interactive.pages/_document.jsimport{ Html,Head,Main,NextScript }from'next/document'importScriptfrom'next/script'exportdefaultfunctionDocument() {return(<Html><Head/><body><Main/><NextScript/><Scriptsrc=""https://example.com/script.js""strategy=""beforeInteractive""/></body></Html>)}Good to know: Scripts withbeforeInteractivewill always be injected inside theheadof the HTML document regardless of where it's placed in the component.Some examples of scripts that should be loaded as soon as possible withbeforeInteractiveinclude:Bot detectorsCookie consent managersafterInteractiveScripts that use theafterInteractivestrategy are injected into the HTML client-side and will load after some (or all) hydration occurs on the page.This is the default strategyof the Script component and should be used for any script that needs to load as soon as possible but not before any first-party Next.js code.afterInteractivescripts can be placed inside of any page or layout and will only load and execute when that page (or group of pages) is opened in the browser.app/page.jsimportScriptfrom'next/script'exportdefaultfunctionPage() {return(<><Scriptsrc=""https://example.com/script.js""strategy=""afterInteractive""/></>)}Some examples of scripts that are good candidates forafterInteractiveinclude:Tag managersAnalyticslazyOnloadScripts that use thelazyOnloadstrategy are injected into the HTML client-side during browser idle time and will load after all resources on the page have been fetched. This strategy should be used for any background or low priority scripts that do not need to load early.lazyOnloadscripts can be placed inside of any page or layout and will only load and execute when that page (or group of pages) is opened in the browser.app/page.jsimportScriptfrom'next/script'exportdefaultfunctionPage() {return(<><Scriptsrc=""https://example.com/script.js""strategy=""lazyOnload""/></>)}Examples of scripts that do not need to load immediately and can be fetched withlazyOnloadinclude:Chat support pluginsSocial media widgetsworkerWarning:Theworkerstrategy is not yet stable and does not yet work with the App Router. Use with caution.Scripts that use theworkerstrategy are off-loaded to a web worker in order to free up the main thread and ensure that only critical, first-party resources are processed on it. While this strategy can be used for any script, it is an advanced use case that is not guaranteed to support all third-party scripts.To useworkeras a strategy, thenextScriptWorkersflag must be enabled innext.config.js:next.config.jsmodule.exports={experimental:{nextScriptWorkers:true,},}workerscripts canonly currently be used in thepages/directory:pages/home.tsxTypeScriptJavaScriptTypeScriptimportScriptfrom'next/script'exportdefaultfunctionHome() {return(<><Scriptsrc=""https://example.com/script.js""strategy=""worker""/></>)}onLoadWarning:onLoaddoes not yet work with Server Components and can only be used in Client Components. Further,onLoadcan't be used withbeforeInteractive– consider usingonReadyinstead.Some third-party scripts require users to run JavaScript code once after the script has finished loading in order to instantiate content or call a function. If you are loading a script with eitherafterInteractiveorlazyOnloadas a loading strategy, you can execute code after it has loaded using theonLoadproperty.Here's an example of executing a lodash method only after the library has been loaded.app/page.tsxTypeScriptJavaScriptTypeScript'use client'importScriptfrom'next/script'exportdefaultfunctionPage() {return(<><Scriptsrc=""https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.17.20/lodash.min.js""onLoad={()=>{console.log(_.sample([1,2,3,4]))}}/></>)}onReadyWarning:onReadydoes not yet work with Server Components and can only be used in Client Components.Some third-party scripts require users to run JavaScript code after the script has finished loading and every time the component is mounted (after a route navigation for example). You can execute code after the script's load event when it first loads and then after every subsequent component re-mount using theonReadyproperty.Here's an example of how to re-instantiate a Google Maps JS embed every time the component is mounted:import{ useRef }from'react'importScriptfrom'next/script'exportdefaultfunctionPage() {constmapRef=useRef()return(<><divref={mapRef}></div><Scriptid=""google-maps""src=""https://maps.googleapis.com/maps/api/js""onReady={()=>{newgoogle.maps.Map(mapRef.current,{center:{ lat:-34.397,lng:150.644},zoom:8,})}}/></>)}onErrorWarning:onErrordoes not yet work with Server Components and can only be used in Client Components.onErrorcannot be used with thebeforeInteractiveloading strategy.Sometimes it is helpful to catch when a script fails to load. These errors can be handled with theonErrorproperty:importScriptfrom'next/script'exportdefaultfunctionPage() {return(<><Scriptsrc=""https://example.com/script.js""onError={(e:Error)=>{console.error('Script failed to load',e)}}/></>)}Version HistoryVersionChangesv13.0.0beforeInteractiveandafterInteractiveis modified to supportapp.v12.2.4onReadyprop added.v12.2.2Allownext/scriptwithbeforeInteractiveto be placed in_document.v11.0.0next/scriptintroduced.PreviousLinkNextinstrumentation.jsWas this helpful?supported.Send"
functions,Functions,"Pages RouterAPI ReferenceFunctionsFunctionsgetInitialPropsFetch dynamic data on the server for your React component with getInitialProps.getServerSidePropsAPI reference for `getServerSideProps`. Learn how to fetch data on each request with Next.js.getStaticPathsAPI reference for `getStaticPaths`. Learn how to fetch data and generate static pages with `getStaticPaths`.getStaticPropsAPI reference for `getStaticProps`. Learn how to use `getStaticProps` to generate static pages with Next.js.NextRequestAPI Reference for NextRequest.NextResponseAPI Reference for NextResponse.useAmpEnable AMP in a page, and control the way Next.js adds AMP to the page with the AMP config.useReportWebVitalsuseReportWebVitalsuseRouterLearn more about the API of the Next.js Router, and access the router instance in your page with the useRouter hook.userAgentThe userAgent helper extends the Web Request API with additional properties and methods to interact with the user agent object from the request.Previousinstrumentation.jsNextgetInitialPropsWas this helpful?supported.Send"
getinitialprops,getInitialProps,"API ReferenceFunctionsgetInitialPropsgetInitialPropsGood to know:getInitialPropsis a legacy API. We recommend usinggetStaticPropsorgetServerSidePropsinstead.getInitialPropsis anasyncfunction that can be added to the default exported React component for the page. It will run on both the server-side and again on the client-side during page transitions. The result of the function will be forwarded to the React component asprops.pages/index.tsxTypeScriptJavaScriptTypeScriptimport{ NextPageContext }from'next'Page.getInitialProps=async(ctx:NextPageContext)=>{constres=awaitfetch('https://api.github.com/repos/vercel/next.js')constjson=awaitres.json()return{ stars:json.stargazers_count }}exportdefaultfunctionPage({ stars }:{ stars:number}) {returnstars}Good to know:Data returned fromgetInitialPropsis serialized when server rendering. Ensure the returned object fromgetInitialPropsis a plainObject, and not usingDate,MaporSet.For the initial page load,getInitialPropswill run on the server only.getInitialPropswill then also run on the client when navigating to a different route with thenext/linkcomponent or by usingnext/router.IfgetInitialPropsis used in a custom_app.js, and the page being navigated to is usinggetServerSideProps, thengetInitialPropswill also run on the server.Context ObjectgetInitialPropsreceives a single argument calledcontext, which is an object with the following properties:NameDescriptionpathnameCurrent route, the path of the page in/pagesqueryQuery string of the URL, parsed as an objectasPathStringof the actual path (including the query) shown in the browserreqHTTP request object(server only)resHTTP response object(server only)errError object if any error is encountered during the renderingCaveatsgetInitialPropscan only be used inpages/top level files, and not in nested components. To have nested data fetching at the component level, consider exploring theApp Router.Regardless of whether your route is static or dynamic, any data returned fromgetInitialPropsaspropswill be able to be examined on the client-side in the initial HTML. This is to allow the page to behydratedcorrectly. Make sure that you don't pass any sensitive information that shouldn't be available on the client inprops.PreviousFunctionsNextgetServerSidePropsWas this helpful?supported.Send"
getserversideprops,getServerSideProps,"API ReferenceFunctionsgetServerSidePropsgetServerSidePropsWhen exporting a function calledgetServerSideProps(Server-Side Rendering) from a page, Next.js will pre-render this page on each request using the data returned bygetServerSideProps. This is useful if you want to fetch data that changes often, and have the page update to show the most current data.pages/index.tsxTypeScriptJavaScriptTypeScriptimporttype{ InferGetServerSidePropsType,GetServerSideProps }from'next'typeRepo={name:stringstargazers_count:number}exportconstgetServerSideProps=(async()=>{// Fetch data from external APIconstres=awaitfetch('https://api.github.com/repos/vercel/next.js')constrepo:Repo=awaitres.json()// Pass data to the page via propsreturn{ props:{ repo } }})satisfiesGetServerSideProps<{ repo:Repo}>exportdefaultfunctionPage({repo,}:InferGetServerSidePropsType<typeofgetServerSideProps>) {return(<main><p>{repo.stargazers_count}</p></main>)}You can import modules in top-level scope for use ingetServerSideProps. Imports used willnot be bundled for the client-side. This means you can writeserver-side code directly ingetServerSideProps, including fetching data from your database.Context parameterThecontextparameter is an object containing the following keys:NameDescriptionparamsIf this page uses adynamic route,paramscontains the route parameters. If the page name is[id].js, thenparamswill look like{ id: ... }.reqTheHTTPIncomingMessage object, with an additionalcookiesprop, which is an object with string keys mapping to string values of cookies.resTheHTTPresponse object.queryAn object representing the query string, including dynamic route parameters.preview(Deprecated fordraftMode)previewistrueif the page is in thePreview Modeandfalseotherwise.previewData(Deprecated fordraftMode) Thepreviewdata set bysetPreviewData.draftModedraftModeistrueif the page is in theDraft Modeandfalseotherwise.resolvedUrlA normalized version of the requestURLthat strips the_next/dataprefix for client transitions and includes original query values.localeContains the active locale (if enabled).localesContains all supported locales (if enabled).defaultLocaleContains the configured default locale (if enabled).getServerSideProps return valuesThegetServerSidePropsfunction should return an object withany one of the followingproperties:propsThepropsobject is a key-value pair, where each value is received by the page component. It should be aserializable objectso that any props passed, could be serialized withJSON.stringify.exportasyncfunctiongetServerSideProps(context) {return{props:{ message:`Next.js is awesome`},// will be passed to the page component as props}}notFoundThenotFoundboolean allows the page to return a404status and404 Page. WithnotFound: true, the page will return a404even if there was a successfully generated page before. This is meant to support use cases like user-generated content getting removed by its author.exportasyncfunctiongetServerSideProps(context) {constres=awaitfetch(`https://.../data`)constdata=awaitres.json()if(!data) {return{notFound:true,}}return{props:{ data },// will be passed to the page component as props}}redirectTheredirectobject allows redirecting to internal and external resources. It should match the shape of{ destination: string, permanent: boolean }. In some rare cases, you might need to assign a custom status code for olderHTTPclients to properly redirect. In these cases, you can use thestatusCodeproperty instead of thepermanentproperty, but not both.exportasyncfunctiongetServerSideProps(context) {constres=awaitfetch(`https://.../data`)constdata=awaitres.json()if(!data) {return{redirect:{destination:'/',permanent:false,},}}return{props:{},// will be passed to the page component as props}}Version HistoryVersionChangesv13.4.0App Routeris now stable with simplified data fetchingv10.0.0locale,locales,defaultLocale, andnotFoundoptions added.v9.3.0getServerSidePropsintroduced.PreviousgetInitialPropsNextgetStaticPathsWas this helpful?supported.Send"
getstaticpaths,getStaticPaths,"API ReferenceFunctionsgetStaticPathsgetStaticPathsWhen exporting a function calledgetStaticPathsfrom a page that usesDynamic Routes, Next.js will statically pre-render all the paths specified bygetStaticPaths.pages/repo/[name].tsxTypeScriptJavaScriptTypeScriptimporttype{InferGetStaticPropsType,GetStaticProps,GetStaticPaths,}from'next'typeRepo={name:stringstargazers_count:number}exportconstgetStaticPaths=(async()=>{return{paths:[{params:{name:'next.js',},},// See the ""paths"" section below],fallback:true,// false or ""blocking""}})satisfiesGetStaticPathsexportconstgetStaticProps=(async(context)=>{constres=awaitfetch('https://api.github.com/repos/vercel/next.js')constrepo=awaitres.json()return{ props:{repo} }})satisfiesGetStaticProps<{repo:Repo}>exportdefaultfunctionPage({repo,}:InferGetStaticPropsType<typeofgetStaticProps>) {returnrepo.stargazers_count}getStaticPaths return valuesThegetStaticPathsfunction should return an object with the followingrequiredproperties:pathsThepathskey determines which paths will be pre-rendered. For example, suppose that you have a page that usesDynamic Routesnamedpages/posts/[id].js. If you exportgetStaticPathsfrom this page and return the following forpaths:return{paths:[{ params:{ id:'1'}},{params:{ id:'2'},// with i18n configured the locale for the path can be returned as welllocale:""en"",},],fallback:...}Then, Next.js will statically generate/posts/1and/posts/2duringnext buildusing the page component inpages/posts/[id].js.The value for eachparamsobject must match the parameters used in the page name:If the page name ispages/posts/[postId]/[commentId], thenparamsshould containpostIdandcommentId.If the page name usescatch-all routeslikepages/[...slug], thenparamsshould containslug(which is an array). If this array is['hello', 'world'], then Next.js will statically generate the page at/hello/world.If the page uses anoptional catch-all route, usenull,[],undefinedorfalseto render the root-most route. For example, if you supplyslug: falseforpages/[[...slug]], Next.js will statically generate the page/.Theparamsstrings arecase-sensitiveand ideally should be normalized to ensure the paths are generated correctly. For example, ifWoRLDis returned for a param it will only match ifWoRLDis the actual path visited, notworldorWorld.Separate of theparamsobject alocalefield can be returned wheni18n is configured, which configures the locale for the path being generated.fallback: falseIffallbackisfalse, then any paths not returned bygetStaticPathswill result in a404 page.Whennext buildis run, Next.js will check ifgetStaticPathsreturnedfallback: false, it will then buildonlythe paths returned bygetStaticPaths. This option is useful if you have a small number of paths to create, or new page data is not added often. If you find that you need to add more paths, and you havefallback: false, you will need to runnext buildagain so that the new paths can be generated.The following example pre-renders one blog post per page calledpages/posts/[id].js. The list of blog posts will be fetched from a CMS and returned bygetStaticPaths. Then, for each page, it fetches the post data from a CMS usinggetStaticProps.pages/posts/[id].jsfunctionPost({ post }) {// Render post...}// This function gets called at build timeexportasyncfunctiongetStaticPaths() {// Call an external API endpoint to getpostsconstres=awaitfetch('https://.../posts')constposts=awaitres.json()// Get the paths we want to pre-render based onpostsconstpaths=posts.map((post)=>({params:{ id:post.id },}))// We'll pre-render only these paths at build time.// { fallback: false } means other routes should 404.return{ paths,fallback:false}}// This also gets called at build timeexportasyncfunctiongetStaticProps({ params }) {// params contains the post `id`.// If the route is like /posts/1, then params.id is 1constres=awaitfetch(`https://.../posts/${params.id}`)constpost=awaitres.json()// Pass post data to the page via propsreturn{ props:{ post } }}exportdefaultPostfallback: trueExamplesStatic generation of a large number of pagesIffallbackistrue, then the behavior ofgetStaticPropschanges in the following ways:The paths returned fromgetStaticPathswill be rendered toHTMLat build time bygetStaticProps.The paths that have not been generated at build time willnotresult in a 404 page. Instead, Next.js will serve a“fallback”version of the page on the first request to such a path. Web crawlers, such as Google, won't be served a fallback and instead the path will behave as infallback: 'blocking'.When a page withfallback: trueis navigated to throughnext/linkornext/router(client-side) Next.js willnotserve a fallback and instead the page will behave asfallback: 'blocking'.In the background, Next.js will statically generate the requested pathHTMLandJSON. This includes runninggetStaticProps.When complete, the browser receives theJSONfor the generated path. This will be used to automatically render the page with the required props. From the user’s perspective, the page will be swapped from the fallback page to the full page.At the same time, Next.js adds this path to the list of pre-rendered pages. Subsequent requests to the same path will serve the generated page, like other pages pre-rendered at build time.Good to know:fallback: trueis not supported when usingoutput: 'export'.When isfallback: trueuseful?fallback: trueis useful if your app has a very large number of static pages that depend on data (such as a very large e-commerce site). If you want to pre-render all product pages, the builds would take a very long time.Instead, you may statically generate a small subset of pages and usefallback: truefor the rest. When someone requests a page that is not generated yet, the user will see the page with a loading indicator or skeleton component.Shortly after,getStaticPropsfinishes and the page will be rendered with the requested data. From now on, everyone who requests the same page will get the statically pre-rendered page.This ensures that users always have a fast experience while preserving fast builds and the benefits of Static Generation.fallback: truewill notupdategenerated pages, for that take a look atIncremental Static Regeneration.fallback: 'blocking'Iffallbackis'blocking', new paths not returned bygetStaticPathswill wait for theHTMLto be generated, identical to SSR (hence whyblocking), and then be cached for future requests so it only happens once per path.getStaticPropswill behave as follows:The paths returned fromgetStaticPathswill be rendered toHTMLat build time bygetStaticProps.The paths that have not been generated at build time willnotresult in a 404 page. Instead, Next.js will SSR on the first request and return the generatedHTML.When complete, the browser receives theHTMLfor the generated path. From the user’s perspective, it will transition from ""the browser is requesting the page"" to ""the full page is loaded"". There is no flash of loading/fallback state.At the same time, Next.js adds this path to the list of pre-rendered pages. Subsequent requests to the same path will serve the generated page, like other pages pre-rendered at build time.fallback: 'blocking'will notupdategenerated pages by default. To update generated pages, useIncremental Static Regenerationin conjunction withfallback: 'blocking'.Good to know:fallback: 'blocking'is not supported when usingoutput: 'export'.Fallback pagesIn the “fallback” version of a page:The page’s props will be empty.Using therouter, you can detect if the fallback is being rendered,router.isFallbackwill betrue.The following example showcases usingisFallback:pages/posts/[id].jsimport{ useRouter }from'next/router'functionPost({ post }) {constrouter=useRouter()// If the page is not yet generated, this will be displayed// initially until getStaticProps() finishes runningif(router.isFallback) {return<div>Loading...</div>}// Render post...}// This function gets called at build timeexportasyncfunctiongetStaticPaths() {return{// Only `/posts/1` and `/posts/2` are generated at build timepaths:[{ params:{ id:'1'} },{ params:{ id:'2'} }],// Enable statically generating additional pages// For example: `/posts/3`fallback:true,}}// This also gets called at build timeexportasyncfunctiongetStaticProps({ params }) {// params contains the post `id`.// If the route is like /posts/1, then params.id is 1constres=awaitfetch(`https://.../posts/${params.id}`)constpost=awaitres.json()// Pass post data to the page via propsreturn{props:{ post },// Re-generate the post at most once per second// if a request comes inrevalidate:1,}}exportdefaultPostVersion HistoryVersionChangesv13.4.0App Routeris now stable with simplified data fetching, includinggenerateStaticParams()v12.2.0On-Demand Incremental Static Regenerationis stable.v12.1.0On-Demand Incremental Static Regenerationadded (beta).v9.5.0StableIncremental Static Regenerationv9.3.0getStaticPathsintroduced.PreviousgetServerSidePropsNextgetStaticPropsWas this helpful?supported.Send"
getstaticprops,getStaticProps,"API ReferenceFunctionsgetStaticPropsgetStaticPropsExporting a function calledgetStaticPropswill pre-render a page at build time using the props returned from the function:pages/index.tsxTypeScriptJavaScriptTypeScriptimporttype{ InferGetStaticPropsType,GetStaticProps }from'next'typeRepo={name:stringstargazers_count:number}exportconstgetStaticProps=(async(context)=>{constres=awaitfetch('https://api.github.com/repos/vercel/next.js')constrepo=awaitres.json()return{ props:{ repo } }})satisfiesGetStaticProps<{repo:Repo}>exportdefaultfunctionPage({repo,}:InferGetStaticPropsType<typeofgetStaticProps>) {returnrepo.stargazers_count}You can import modules in top-level scope for use ingetStaticProps. Imports used willnot be bundled for the client-side. This means you can writeserver-side code directly ingetStaticProps, including fetching data from your database.Context parameterThecontextparameter is an object containing the following keys:NameDescriptionparamsContains the route parameters for pages usingdynamic routes. For example, if the page name is[id].js, thenparamswill look like{ id: ... }. You should use this together withgetStaticPaths, which we'll explain later.preview(Deprecated fordraftMode)previewistrueif the page is in thePreview Modeandfalseotherwise.previewData(Deprecated fordraftMode) Thepreviewdata set bysetPreviewData.draftModedraftModeistrueif the page is in theDraft Modeandfalseotherwise.localeContains the active locale (if enabled).localesContains all supported locales (if enabled).defaultLocaleContains the configured default locale (if enabled).revalidateReasonProvides a reason for why the function was called. Can be one of: ""build"" (run at build time), ""stale"" (revalidate period expired, or running indevelopment mode), ""on-demand"" (triggered viaon-demand revalidation)getStaticProps return valuesThegetStaticPropsfunction should return an object containing eitherprops,redirect, ornotFoundfollowed by anoptionalrevalidateproperty.propsThepropsobject is a key-value pair, where each value is received by the page component. It should be aserializable objectso that any props passed, could be serialized withJSON.stringify.exportasyncfunctiongetStaticProps(context) {return{props:{ message:`Next.js is awesome`},// will be passed to the page component as props}}revalidateTherevalidateproperty is the amount in seconds after which a page re-generation can occur (defaults tofalseor no revalidation).// This function gets called at build time on server-side.// It may be called again, on a serverless function, if// revalidation is enabled and a new request comes inexportasyncfunctiongetStaticProps() {constres=awaitfetch('https://.../posts')constposts=awaitres.json()return{props:{posts,},// Next.js will attempt to re-generate the page:// - When a request comes in// - At most once every 10 secondsrevalidate:10,// In seconds}}Learn more aboutIncremental Static Regeneration.The cache status of a page leveraging ISR can be determined by reading the value of thex-nextjs-cacheresponse header. The possible values are the following:MISS- the path is not in the cache (occurs at most once, on the first visit)STALE- the path is in the cache but exceeded the revalidate time so it will be updated in the backgroundHIT- the path is in the cache and has not exceeded the revalidate timenotFoundThenotFoundboolean allows the page to return a404status and404 Page. WithnotFound: true, the page will return a404even if there was a successfully generated page before. This is meant to support use cases like user-generated content getting removed by its author. Note,notFoundfollows the samerevalidatebehaviordescribed here.exportasyncfunctiongetStaticProps(context) {constres=awaitfetch(`https://.../data`)constdata=awaitres.json()if(!data) {return{notFound:true,}}return{props:{ data },// will be passed to the page component as props}}Good to know:notFoundis not needed forfallback: falsemode as only paths returned fromgetStaticPathswill be pre-rendered.redirectTheredirectobject allows redirecting to internal or external resources. It should match the shape of{ destination: string, permanent: boolean }.In some rare cases, you might need to assign a custom status code for olderHTTPclients to properly redirect. In these cases, you can use thestatusCodeproperty instead of thepermanentproperty,but not both. You can also setbasePath: falsesimilar to redirects innext.config.js.exportasyncfunctiongetStaticProps(context) {constres=awaitfetch(`https://...`)constdata=awaitres.json()if(!data) {return{redirect:{destination:'/',permanent:false,// statusCode: 301},}}return{props:{ data },// will be passed to the page component as props}}If the redirects are known at build-time, they should be added innext.config.jsinstead.Reading files: Useprocess.cwd()Files can be read directly from the filesystem ingetStaticProps.In order to do so you have to get the full path to a file.Since Next.js compiles your code into a separate directory you can't use__dirnameas the path it returns will be different from the Pages Router.Instead you can useprocess.cwd()which gives you the directory where Next.js is being executed.import{ promisesasfs }from'fs'importpathfrom'path'// posts will be populated at build time by getStaticProps()functionBlog({ posts }) {return(<ul>{posts.map((post)=>(<li><h3>{post.filename}</h3><p>{post.content}</p></li>))}</ul>)}// This function gets called at build time on server-side.// It won't be called on client-side, so you can even do// direct database queries.exportasyncfunctiongetStaticProps() {constpostsDirectory=path.join(process.cwd(),'posts')constfilenames=awaitfs.readdir(postsDirectory)constposts=filenames.map(async(filename)=>{constfilePath=path.join(postsDirectory,filename)constfileContents=awaitfs.readFile(filePath,'utf8')// Generally you would parse/transform the contents// For example you can transform markdown to HTML herereturn{filename,content:fileContents,}})// By returning { props: { posts } }, the Blog component// will receive `posts` as a prop at build timereturn{props:{posts:awaitPromise.all(posts),},}}exportdefaultBlogVersion HistoryVersionChangesv13.4.0App Routeris now stable with simplified data fetchingv12.2.0On-Demand Incremental Static Regenerationis stable.v12.1.0On-Demand Incremental Static Regenerationadded (beta).v10.0.0locale,locales,defaultLocale, andnotFoundoptions added.v10.0.0fallback: 'blocking'return option added.v9.5.0StableIncremental Static Regenerationv9.3.0getStaticPropsintroduced.PreviousgetStaticPathsNextNextRequestWas this helpful?supported.Send"
nextrequest,NextRequest,"API ReferenceFunctionsNextRequestNextRequestNextRequest extends theWeb Request APIwith additional convenience methods.cookiesRead or mutate theSet-Cookieheader of the request.set(name, value)Given a name, set a cookie with the given value on the request.// Given incoming request /home// Set a cookie to hide the banner// request will have a `Set-Cookie:show-banner=false;path=/home` headerrequest.cookies.set('show-banner','false')get(name)Given a cookie name, return the value of the cookie. If the cookie is not found,undefinedis returned. If multiple cookies are found, the first one is returned.// Given incoming request /home// { name: 'show-banner', value: 'false', Path: '/home' }request.cookies.get('show-banner')getAll()Given a cookie name, return the values of the cookie. If no name is given, return all cookies on the request.// Given incoming request /home// [//   { name: 'experiments', value: 'new-pricing-page', Path: '/home' },//   { name: 'experiments', value: 'winter-launch', Path: '/home' },// ]request.cookies.getAll('experiments')// Alternatively, get all cookies for the requestrequest.cookies.getAll()delete(name)Given a cookie name, delete the cookie from the request.// Returns true for deleted, false is nothing is deletedrequest.cookies.delete('experiments')has(name)Given a cookie name, returntrueif the cookie exists on the request.// Returns true if cookie exists, false if it does notrequest.cookies.has('experiments')clear()Remove theSet-Cookieheader from the request.request.cookies.clear()nextUrlExtends the nativeURLAPI with additional convenience methods, including Next.js specific properties.// Given a request to /home, pathname is /homerequest.nextUrl.pathname// Given a request to /home?name=lee, searchParams is { 'name': 'lee' }request.nextUrl.searchParamsThe following options are available:PropertyTypeDescriptionbasePathstringThebase pathof the URL.buildIdstring|undefinedThe build identifier of the Next.js application. Can becustomized.defaultLocalestring|undefinedThe default locale forinternationalization.domainLocale-defaultLocalestringThe default locale within a domain.-domainstringThe domain associated with a specific locale.-httpboolean|undefinedIndicates if the domain is using HTTP.localesstring[]|undefinedAn array of available locales.localestring|undefinedThe currently active locale.urlURLThe URL object.Version HistoryVersionChangesv15.0.0ipandgeoremoved.PreviousgetStaticPropsNextNextResponseWas this helpful?supported.Send"
nextresponse,NextResponse,"API ReferenceFunctionsNextResponseNextResponseNextResponse extends theWeb Response APIwith additional convenience methods.cookiesRead or mutate theSet-Cookieheader of the response.set(name, value)Given a name, set a cookie with the given value on the response.// Given incoming request /homeletresponse=NextResponse.next()// Set a cookie to hide the bannerresponse.cookies.set('show-banner','false')// Response will have a `Set-Cookie:show-banner=false;path=/home` headerreturnresponseget(name)Given a cookie name, return the value of the cookie. If the cookie is not found,undefinedis returned. If multiple cookies are found, the first one is returned.// Given incoming request /homeletresponse=NextResponse.next()// { name: 'show-banner', value: 'false', Path: '/home' }response.cookies.get('show-banner')getAll()Given a cookie name, return the values of the cookie. If no name is given, return all cookies on the response.// Given incoming request /homeletresponse=NextResponse.next()// [//   { name: 'experiments', value: 'new-pricing-page', Path: '/home' },//   { name: 'experiments', value: 'winter-launch', Path: '/home' },// ]response.cookies.getAll('experiments')// Alternatively, get all cookies for the responseresponse.cookies.getAll()delete(name)Given a cookie name, delete the cookie from the response.// Given incoming request /homeletresponse=NextResponse.next()// Returns true for deleted, false is nothing is deletedresponse.cookies.delete('experiments')json()Produce a response with the given JSON body.app/api/route.tsTypeScriptJavaScriptTypeScriptimport{ NextResponse }from'next/server'exportasyncfunctionGET(request:Request) {returnNextResponse.json({ error:'Internal Server Error'},{ status:500})}redirect()Produce a response that redirects to aURL.import{ NextResponse }from'next/server'returnNextResponse.redirect(newURL('/new',request.url))TheURLcan be created and modified before being used in theNextResponse.redirect()method. For example, you can use therequest.nextUrlproperty to get the current URL, and then modify it to redirect to a different URL.import{ NextResponse }from'next/server'// Given an incoming request...constloginUrl=newURL('/login',request.url)// Add ?from=/incoming-url to the /login URLloginUrl.searchParams.set('from',request.nextUrl.pathname)// And redirect to the new URLreturnNextResponse.redirect(loginUrl)rewrite()Produce a response that rewrites (proxies) the givenURLwhile preserving the original URL.import{ NextResponse }from'next/server'// Incoming request: /about, browser shows /about// Rewritten request: /proxy, browser shows /aboutreturnNextResponse.rewrite(newURL('/proxy',request.url))next()Thenext()method is useful for Middleware, as it allows you to return early and continue routing.import{ NextResponse }from'next/server'returnNextResponse.next()You can also forwardheaderswhen producing the response:import{ NextResponse }from'next/server'// Given an incoming request...constnewHeaders=newHeaders(request.headers)// Add a new headernewHeaders.set('x-version','123')// And produce a response with the new headersreturnNextResponse.next({request:{// New request headersheaders:newHeaders,},})PreviousNextRequestNextuseAmpWas this helpful?supported.Send"
useamp,useAmp,"API ReferenceFunctionsuseAmpuseAmpExamplesAMPAMP support is one of our advanced features, you canread more about AMP here.To enable AMP, add the following config to your page:pages/index.jsexportconstconfig={ amp:true}Theampconfig accepts the following values:true- The page will be AMP-only'hybrid'- The page will have two versions, one with AMP and another one with HTMLTo learn more about theampconfig, read the sections below.AMP First PageTake a look at the following example:pages/about.jsexportconstconfig={ amp:true}functionAbout(props) {return<h3>My AMP About Page!</h3>}exportdefaultAboutThe page above is an AMP-only page, which means:The page has no Next.js or React client-side runtimeThe page is automatically optimized withAMP Optimizer, an optimizer that applies the same transformations as AMP caches (improves performance by up to 42%)The page has a user-accessible (optimized) version of the page and a search-engine indexable (unoptimized) version of the pageHybrid AMP PageTake a look at the following example:pages/about.jsimport{ useAmp }from'next/amp'exportconstconfig={ amp:'hybrid'}functionAbout(props) {constisAmp=useAmp()return(<div><h3>My AMP About Page!</h3>{isAmp?(<amp-imgwidth=""300""height=""300""src=""/my-img.jpg""alt=""a cool image""layout=""responsive""/>):(<imgwidth=""300""height=""300""src=""/my-img.jpg""alt=""a cool image""/>)}</div>)}exportdefaultAboutThe page above is a hybrid AMP page, which means:The page is rendered as traditional HTML (default) and AMP HTML (by adding?amp=1to the URL)The AMP version of the page only has valid optimizations applied with AMP Optimizer so that it is indexable by search-enginesThe page usesuseAmpto differentiate between modes, it's aReact Hookthat returnstrueif the page is using AMP, andfalseotherwise.PreviousNextResponseNextuseReportWebVitalsWas this helpful?supported.Send"
usereportwebvitals,useReportWebVitals,"API ReferenceFunctionsuseReportWebVitalsuseReportWebVitalsTheuseReportWebVitalshook allows you to reportCore Web Vitals, and can be used in combination with your analytics service.pages/_app.jsimport{ useReportWebVitals }from'next/web-vitals'functionMyApp({ Component,pageProps }) {useReportWebVitals((metric)=>{console.log(metric)})return<Component{...pageProps} />}useReportWebVitalsThemetricobject passed as the hook's argument consists of a number of properties:id: Unique identifier for the metric in the context of the current page loadname: The name of the performance metric. Possible values include names ofWeb Vitalsmetrics (TTFB, FCP, LCP, FID, CLS) specific to a web application.delta: The difference between the current value and the previous value of the metric. The value is typically in milliseconds and represents the change in the metric's value over time.entries: An array ofPerformance Entriesassociated with the metric. These entries provide detailed information about the performance events related to the metric.navigationType: Indicates thetype of navigationthat triggered the metric collection. Possible values include""navigate"",""reload"",""back_forward"", and""prerender"".rating: A qualitative rating of the metric value, providing an assessment of the performance. Possible values are""good"",""needs-improvement"", and""poor"". The rating is typically determined by comparing the metric value against predefined thresholds that indicate acceptable or suboptimal performance.value: The actual value or duration of the performance entry, typically in milliseconds. The value provides a quantitative measure of the performance aspect being tracked by the metric. The source of the value depends on the specific metric being measured and can come from variousPerformance APIs.Web VitalsWeb Vitalsare a set of useful metrics that aim to capture the user
experience of a web page. The following web vitals are all included:Time to First Byte(TTFB)First Contentful Paint(FCP)Largest Contentful Paint(LCP)First Input Delay(FID)Cumulative Layout Shift(CLS)Interaction to Next Paint(INP)You can handle all the results of these metrics using thenameproperty.pages/_app.jsimport{ useReportWebVitals }from'next/web-vitals'functionMyApp({ Component,pageProps }) {useReportWebVitals((metric)=>{switch(metric.name) {case'FCP': {// handle FCP results}case'LCP': {// handle LCP results}// ...}})return<Component{...pageProps} />}Custom MetricsIn addition to the core metrics listed above, there are some additional custom metrics that
measure the time it takes for the page to hydrate and render:Next.js-hydration: Length of time it takes for the page to start and finish hydrating (in ms)Next.js-route-change-to-render: Length of time it takes for a page to start rendering after a
route change (in ms)Next.js-render: Length of time it takes for a page to finish render after a route change (in ms)You can handle all the results of these metrics separately:pages/_app.jsimport{ useReportWebVitals }from'next/web-vitals'functionMyApp({ Component,pageProps }) {useReportWebVitals((metric)=>{switch(metric.name) {case'Next.js-hydration':// handle hydration resultsbreakcase'Next.js-route-change-to-render':// handle route-change to render resultsbreakcase'Next.js-render':// handle render resultsbreakdefault:break}})return<Component{...pageProps} />}These metrics work in all browsers that support theUser Timing API.Usage on VercelVercel Speed Insightsdoes notuseReportWebVitals, but@vercel/speed-insightspackage instead.useReportWebVitalshook is useful in local development, or if you're using a different service for collecting Web Vitals.Sending results to external systemsYou can send results to any endpoint to measure and track
real user performance on your site. For example:useReportWebVitals((metric)=>{constbody=JSON.stringify(metric)consturl='https://example.com/analytics'// Use `navigator.sendBeacon()` if available, falling back to `fetch()`.if(navigator.sendBeacon) {navigator.sendBeacon(url,body)}else{fetch(url,{ body,method:'POST',keepalive:true})}})Good to know: If you useGoogle Analytics, using theidvalue can allow you to construct metric distributions manually (to calculate percentiles,
etc.)useReportWebVitals(metric=>{// Use `window.gtag` if you initialized Google Analytics as this example:// https://github.com/vercel/next.js/blob/canary/examples/with-google-analyticswindow.gtag('event',metric.name,{value:Math.round(metric.name==='CLS'?metric.value*1000:metric.value),// values must be integersevent_label:metric.id,// id unique to current page loadnon_interaction:true,// avoids affecting bounce rate.});}Read more aboutsending results to Google Analytics.PrevioususeAmpNextuseRouterWas this helpful?supported.Send"
userouter,useRouter,"API ReferenceFunctionsuseRouteruseRouterIf you want to access therouterobjectinside any function component in your app, you can use theuseRouterhook, take a look at the following example:import{ useRouter }from'next/router'functionActiveLink({ children,href }) {constrouter=useRouter()conststyle={marginRight:10,color:router.asPath===href?'red':'black',}consthandleClick=(e)=>{e.preventDefault()router.push(href)}return(<ahref={href}onClick={handleClick}style={style}>{children}</a>)}exportdefaultActiveLinkuseRouteris aReact Hook, meaning it cannot be used with classes. You can either usewithRouteror wrap your class in a function component.routerobjectThe following is the definition of therouterobject returned by bothuseRouterandwithRouter:pathname:String- The path for current route file that comes after/pages. Therefore,basePath,localeand trailing slash (trailingSlash: true) are not included.query:Object- The query string parsed to an object, includingdynamic routeparameters. It will be an empty object during prerendering if the page doesn't useServer-side Rendering. Defaults to{}asPath:String- The path as shown in the browser including the search params and respecting thetrailingSlashconfiguration.basePathandlocaleare not included.isFallback:boolean- Whether the current page is infallback mode.basePath:String- The activebasePath(if enabled).locale:String- The active locale (if enabled).locales:String[]- All supported locales (if enabled).defaultLocale:String- The current default locale (if enabled).domainLocales:Array<{domain, defaultLocale, locales}>- Any configured domain locales.isReady:boolean- Whether the router fields are updated client-side and ready for use. Should only be used inside ofuseEffectmethods and not for conditionally rendering on the server. See related docs for use case withautomatically statically optimized pagesisPreview:boolean- Whether the application is currently inpreview mode.Using theasPathfield may lead to a mismatch between client and server if the page is rendered using server-side rendering orautomatic static optimization. Avoid usingasPathuntil theisReadyfield istrue.The following methods are included insiderouter:router.pushHandles client-side transitions, this method is useful for cases wherenext/linkis not enough.router.push(url,as,options)url:UrlObject | String- The URL to navigate to (seeNode.JS URL module documentationforUrlObjectproperties).as:UrlObject | String- Optional decorator for the path that will be shown in the browser URL bar. Before Next.js 9.5.3 this was used for dynamic routes.options- Optional object with the following configuration options:scroll- Optional boolean, controls scrolling to the top of the page after navigation. Defaults totrueshallow: Update the path of the current page without rerunninggetStaticProps,getServerSidePropsorgetInitialProps. Defaults tofalselocale- Optional string, indicates locale of the new pageYou don't need to userouter.pushfor external URLs.window.locationis better suited for those cases.Navigating topages/about.js, which is a predefined route:import{ useRouter }from'next/router'exportdefaultfunctionPage() {constrouter=useRouter()return(<buttontype=""button""onClick={()=>router.push('/about')}>Click me</button>)}Navigatingpages/post/[pid].js, which is a dynamic route:import{ useRouter }from'next/router'exportdefaultfunctionPage() {constrouter=useRouter()return(<buttontype=""button""onClick={()=>router.push('/post/abc')}>Click me</button>)}Redirecting the user topages/login.js, useful for pages behindauthentication:import{ useEffect }from'react'import{ useRouter }from'next/router'// Here you would fetch and return the userconstuseUser=()=>({ user:null,loading:false})exportdefaultfunctionPage() {const{user,loading}=useUser()constrouter=useRouter()useEffect(()=>{if(!(user||loading)) {router.push('/login')}},[user,loading])return<p>Redirecting...</p>}Resetting state after navigationWhen navigating to the same page in Next.js, the page's statewill notbe reset by default as React does not unmount unless the parent component has changed.pages/[slug].jsimportLinkfrom'next/link'import{ useState }from'react'import{ useRouter }from'next/router'exportdefaultfunctionPage(props) {constrouter=useRouter()const[count,setCount]=useState(0)return(<div><h1>Page: {router.query.slug}</h1><p>Count: {count}</p><buttononClick={()=>setCount(count+1)}>Increase count</button><Linkhref=""/one"">one</Link> <Linkhref=""/two"">two</Link></div>)}In the above example, navigating between/oneand/twowill notreset the count . TheuseStateis maintained between renders because the top-level React component,Page, is the same.If you do not want this behavior, you have a couple of options:Manually ensure each state is updated usinguseEffect. In the above example, that could look like:useEffect(()=>{setCount(0)},[router.query.slug])Use a Reactkeytotell React to remount the component. To do this for all pages, you can use a custom app:pages/_app.jsimport{ useRouter }from'next/router'exportdefaultfunctionMyApp({ Component,pageProps }) {constrouter=useRouter()return<Componentkey={router.asPath} {...pageProps} />}With URL objectYou can use a URL object in the same way you can use it fornext/link. Works for both theurlandasparameters:import{ useRouter }from'next/router'exportdefaultfunctionReadMore({ post }) {constrouter=useRouter()return(<buttontype=""button""onClick={()=>{router.push({pathname:'/post/[pid]',query:{ pid:post.id },})}}>Click here to read more</button>)}router.replaceSimilar to thereplaceprop innext/link,router.replacewill prevent adding a new URL entry into thehistorystack.router.replace(url,as,options)The API forrouter.replaceis exactly the same as the API forrouter.push.Take a look at the following example:import{ useRouter }from'next/router'exportdefaultfunctionPage() {constrouter=useRouter()return(<buttontype=""button""onClick={()=>router.replace('/home')}>Click me</button>)}router.prefetchPrefetch pages for faster client-side transitions. This method is only useful for navigations withoutnext/link, asnext/linktakes care of prefetching pages automatically.This is a production only feature. Next.js doesn't prefetch pages in development.router.prefetch(url,as,options)url- The URL to prefetch, including explicit routes (e.g./dashboard) and dynamic routes (e.g./product/[id])as- Optional decorator forurl. Before Next.js 9.5.3 this was used to prefetch dynamic routes.options- Optional object with the following allowed fields:locale- allows providing a different locale from the active one. Iffalse,urlhas to include the locale as the active locale won't be used.Let's say you have a login page, and after a login, you redirect the user to the dashboard. For that case, we can prefetch the dashboard to make a faster transition, like in the following example:import{ useCallback,useEffect }from'react'import{ useRouter }from'next/router'exportdefaultfunctionLogin() {constrouter=useRouter()consthandleSubmit=useCallback((e)=>{e.preventDefault()fetch('/api/login',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({/* Form data */}),}).then((res)=>{// Do a fast client-side transition to the already prefetched dashboard pageif(res.ok)router.push('/dashboard')})},[])useEffect(()=>{// Prefetch the dashboard pagerouter.prefetch('/dashboard')},[router])return(<formonSubmit={handleSubmit}>{/* Form fields */}<buttontype=""submit"">Login</button></form>)}router.beforePopStateIn some cases (for example, if using aCustom Server), you may wish to listen topopstateand do something before the router acts on it.router.beforePopState(cb)cb- The function to run on incomingpopstateevents. The function receives the state of the event as an object with the following props:url:String- the route for the new state. This is usually the name of apageas:String- the url that will be shown in the browseroptions:Object- Additional options sent byrouter.pushIfcbreturnsfalse, the Next.js router will not handlepopstate, and you'll be responsible for handling it in that case. SeeDisabling file-system routing.You could usebeforePopStateto manipulate the request, or force a SSR refresh, as in the following example:import{ useEffect }from'react'import{ useRouter }from'next/router'exportdefaultfunctionPage() {constrouter=useRouter()useEffect(()=>{router.beforePopState(({ url,as,options })=>{// I only want to allow these two routes!if(as!=='/'&&as!=='/other') {// Have SSR render bad routes as a 404.window.location.href=asreturnfalse}returntrue})},[router])return<p>Welcome to the page</p>}router.backNavigate back in history. Equivalent to clicking the browser’s back button. It executeswindow.history.back().import{ useRouter }from'next/router'exportdefaultfunctionPage() {constrouter=useRouter()return(<buttontype=""button""onClick={()=>router.back()}>Click here to go back</button>)}router.reloadReload the current URL. Equivalent to clicking the browser’s refresh button. It executeswindow.location.reload().import{ useRouter }from'next/router'exportdefaultfunctionPage() {constrouter=useRouter()return(<buttontype=""button""onClick={()=>router.reload()}>Click here to reload</button>)}router.eventsYou can listen to different events happening inside the Next.js Router. Here's a list of supported events:routeChangeStart(url, { shallow })- Fires when a route starts to changerouteChangeComplete(url, { shallow })- Fires when a route changed completelyrouteChangeError(err, url, { shallow })- Fires when there's an error when changing routes, or a route load is cancellederr.cancelled- Indicates if the navigation was cancelledbeforeHistoryChange(url, { shallow })- Fires before changing the browser's historyhashChangeStart(url, { shallow })- Fires when the hash will change but not the pagehashChangeComplete(url, { shallow })- Fires when the hash has changed but not the pageGood to know: Hereurlis the URL shown in the browser, including thebasePath.For example, to listen to the router eventrouteChangeStart, open or createpages/_app.jsand subscribe to the event, like so:import{ useEffect }from'react'import{ useRouter }from'next/router'exportdefaultfunctionMyApp({ Component,pageProps }) {constrouter=useRouter()useEffect(()=>{consthandleRouteChange=(url,{ shallow })=>{console.log(`App is changing to${url}${shallow?'with':'without'}shallow routing`)}router.events.on('routeChangeStart',handleRouteChange)// If the component is unmounted, unsubscribe// from the event with the `off` method:return()=>{router.events.off('routeChangeStart',handleRouteChange)}},[router])return<Component{...pageProps} />}We use aCustom App(pages/_app.js) for this example to subscribe to the event because it's not unmounted on page navigations, but you can subscribe to router events on any component in your application.Router events should be registered when a component mounts (useEffectorcomponentDidMount/componentWillUnmount) or imperatively when an event happens.If a route load is cancelled (for example, by clicking two links rapidly in succession),routeChangeErrorwill fire. And the passederrwill contain acancelledproperty set totrue, as in the following example:import{ useEffect }from'react'import{ useRouter }from'next/router'exportdefaultfunctionMyApp({ Component,pageProps }) {constrouter=useRouter()useEffect(()=>{consthandleRouteChangeError=(err,url)=>{if(err.cancelled) {console.log(`Route to${url}was cancelled!`)}}router.events.on('routeChangeError',handleRouteChangeError)// If the component is unmounted, unsubscribe// from the event with the `off` method:return()=>{router.events.off('routeChangeError',handleRouteChangeError)}},[router])return<Component{...pageProps} />}Thenext/compat/routerexportThis is the sameuseRouterhook, but can be used in bothappandpagesdirectories.It differs fromnext/routerin that it does not throw an error when the pages router is not mounted, and instead has a return type ofNextRouter | null.
This allows developers to convert components to support running in bothappandpagesas they transition to theapprouter.A component that previously looked like this:import{ useRouter }from'next/router'constMyComponent=()=>{const{isReady,query}=useRouter()// ...}Will error when converted over tonext/compat/router, asnullcan not be destructured. Instead, developers will be able to take advantage of new hooks:import{ useEffect }from'react'import{ useRouter }from'next/compat/router'import{ useSearchParams }from'next/navigation'constMyComponent=()=>{constrouter=useRouter()// may be null or a NextRouter instanceconstsearchParams=useSearchParams()useEffect(()=>{if(router&&!router.isReady) {return}// In `app/`, searchParams will be ready immediately with the values, in// `pages/` it will be available after the router is ready.constsearch=searchParams.get('search')// ...},[router,searchParams])// ...}This component will now work in bothpagesandappdirectories. When the component is no longer used inpages, you can remove the references to the compat router:import{ useSearchParams }from'next/navigation'constMyComponent=()=>{constsearchParams=useSearchParams()// As this component is only used in `app/`, the compat router can be removed.constsearch=searchParams.get('search')// ...}UsinguseRouteroutside of Next.js context in pagesAnother specific use case is when rendering components outside of a Next.js application context, such as insidegetServerSidePropson thepagesdirectory. In this case, the compat router can be used to avoid errors:import{ renderToString }from'react-dom/server'import{ useRouter }from'next/compat/router'constMyComponent=()=>{constrouter=useRouter()// may be null or a NextRouter instance// ...}exportasyncfunctiongetServerSideProps() {constrenderedComponent=renderToString(<MyComponent/>)return{props:{renderedComponent,},}}Potential ESLint errorsCertain methods accessible on therouterobject return a Promise. If you have the ESLint rule,no-floating-promisesenabled, consider disabling it either globally, or for the affected line.If your application needs this rule, you should eithervoidthe promise – or use anasyncfunction,awaitthe Promise, then void the function call.This is not applicable when the method is called from inside anonClickhandler.The affected methods are:router.pushrouter.replacerouter.prefetchPotential solutionsimport{ useEffect }from'react'import{ useRouter }from'next/router'// Here you would fetch and return the userconstuseUser=()=>({ user:null,loading:false})exportdefaultfunctionPage() {const{user,loading}=useUser()constrouter=useRouter()useEffect(()=>{// disable the linting on the next line - This is the cleanest solution// eslint-disable-next-line no-floating-promisesrouter.push('/login')// void the Promise returned by router.pushif(!(user||loading)) {voidrouter.push('/login')}// or use an async function, await the Promise, then void the function callasyncfunctionhandleRouteChange() {if(!(user||loading)) {awaitrouter.push('/login')}}voidhandleRouteChange()},[user,loading])return<p>Redirecting...</p>}withRouterIfuseRouteris not the best fit for you,withRoutercan also add the samerouterobjectto any component.Usageimport{ withRouter }from'next/router'functionPage({ router }) {return<p>{router.pathname}</p>}exportdefaultwithRouter(Page)TypeScriptTo use class components withwithRouter, the component needs to accept a router prop:importReactfrom'react'import{ withRouter,NextRouter }from'next/router'interfaceWithRouterProps{router:NextRouter}interfaceMyComponentPropsextendsWithRouterProps{}classMyComponentextendsReact.Component<MyComponentProps> {render() {return<p>{this.props.router.pathname}</p>}}exportdefaultwithRouter(MyComponent)PrevioususeReportWebVitalsNextuserAgentWas this helpful?supported.Send"
useragent,userAgent,"API ReferenceFunctionsuserAgentuserAgentTheuserAgenthelper extends theWeb Request APIwith additional properties and methods to interact with the user agent object from the request.middleware.tsTypeScriptJavaScriptTypeScriptimport{ NextRequest,NextResponse,userAgent }from'next/server'exportfunctionmiddleware(request:NextRequest) {consturl=request.nextUrlconst{device}=userAgent(request)constviewport=device.type==='mobile'?'mobile':'desktop'url.searchParams.set('viewport',viewport)returnNextResponse.rewrite(url)}isBotA boolean indicating whether the request comes from a known bot.browserAn object containing information about the browser used in the request.name: A string representing the browser's name, orundefinedif not identifiable.version: A string representing the browser's version, orundefined.deviceAn object containing information about the device used in the request.model: A string representing the model of the device, orundefined.type: A string representing the type of the device, such asconsole,mobile,tablet,smarttv,wearable,embedded, orundefined.vendor: A string representing the vendor of the device, orundefined.engineAn object containing information about the browser's engine.name: A string representing the engine's name. Possible values include:Amaya,Blink,EdgeHTML,Flow,Gecko,Goanna,iCab,KHTML,Links,Lynx,NetFront,NetSurf,Presto,Tasman,Trident,w3m,WebKitorundefined.version: A string representing the engine's version, orundefined.osAn object containing information about the operating system.name: A string representing the name of the OS, orundefined.version: A string representing the version of the OS, orundefined.cpuAn object containing information about the CPU architecture.architecture: A string representing the architecture of the CPU. Possible values include:68k,amd64,arm,arm64,armhf,avr,ia32,ia64,irix,irix64,mips,mips64,pa-risc,ppc,sparc,sparc64orundefinedPrevioususeRouterNextConfigurationWas this helpful?supported.Send"
configuration,Configuration,Pages RouterAPI ReferenceConfigurationConfigurationnext.config.js OptionsLearn about the options available in next.config.js for the Pages Router.TypeScriptNext.js provides a TypeScript-first development experience for building your React application.ESLintNext.js reports ESLint errors and warnings during builds by default. Learn how to opt-out of this behavior here.PrevioususerAgentNextnext.config.js OptionsWas this helpful?supported.Send
next.config.js options,next.config.js Options,"API ReferenceConfigurationnext.config.js Optionsnext.config.js OptionsNext.js can be configured through anext.config.jsfile in the root of your project directory (for example, bypackage.json) with a default export.next.config.js// @ts-check/**@type{import('next').NextConfig}*/constnextConfig={/* config options here */}module.exports=nextConfigECMAScript Modulesnext.config.jsis a regular Node.js module, not a JSON file. It gets used by the Next.js server and build phases, and it's not included in the browser build.If you needECMAScript modules, you can usenext.config.mjs:next.config.mjs// @ts-check/***@type{import('next').NextConfig}*/constnextConfig={/* config options here */}exportdefaultnextConfigGood to know:next.configwith the.cjs,.cts, or.mtsextensions are currentlynotsupported.Configuration as a FunctionYou can also use a function:next.config.mjs// @ts-checkexportdefault(phase,{ defaultConfig })=>{/***@type{import('next').NextConfig}*/constnextConfig={/* config options here */}returnnextConfig}Async ConfigurationSince Next.js 12.1.0, you can use an async function:next.config.js// @ts-checkmodule.exports=async(phase,{ defaultConfig })=>{/***@type{import('next').NextConfig}*/constnextConfig={/* config options here */}returnnextConfig}Phasephaseis the current context in which the configuration is loaded. You can see theavailable phases. Phases can be imported fromnext/constants:next.config.js// @ts-checkconst{PHASE_DEVELOPMENT_SERVER}=require('next/constants')module.exports=(phase,{ defaultConfig })=>{if(phase===PHASE_DEVELOPMENT_SERVER) {return{/* development only config options here */}}return{/* config options for all phases except development here */}}TypeScriptIf you are using TypeScript in your project, you can usenext.config.tsto use TypeScript in your configuration:next.config.tsimporttype{ NextConfig }from'next'constnextConfig:NextConfig={/* config options here */}exportdefaultnextConfigThe commented lines are the place where you can put the configs allowed bynext.config.js, which aredefined in this file.However, none of the configs are required, and it's not necessary to understand what each config does. Instead, search for the features you need to enable or modify in this section and they will show you what to do.Avoid using new JavaScript features not available in your target Node.js version.next.config.jswill not be parsed by Webpack or Babel.This page documents all the available configuration options:Unit Testing (experimental)Starting in Next.js 15.1, thenext/experimental/testing/serverpackage contains utilities to help unit testnext.config.jsfiles.Theunstable_getResponseFromNextConfigfunction runs theheaders,redirects, andrewritesfunctions fromnext.config.jswith the provided request information and returnsNextResponsewith the results of the routing.The response fromunstable_getResponseFromNextConfigonly considersnext.config.jsfields and does not consider middleware or filesystem routes, so the result in production may be different than the unit test.import{getRedirectUrl,unstable_getResponseFromNextConfig,}from'next/experimental/testing/server'constresponse=awaitunstable_getResponseFromNextConfig({url:'https://nextjs.org/test',nextConfig:{asyncredirects() {return[{ source:'/test',destination:'/test2',permanent:false}]},},})expect(response.status).toEqual(307)expect(getRedirectUrl(response)).toEqual('https://nextjs.org/test2')assetPrefixLearn how to use the assetPrefix config option to configure your CDN.basePathUse `basePath` to deploy a Next.js application under a sub-path of a domain.bundlePagesRouterDependenciesEnable automatic dependency bundling for Pages RoutercompressNext.js provides gzip compression to compress rendered content and static files, it only works with the server target. Learn more about it here.crossOriginUse the `crossOrigin` option to add a crossOrigin tag on the `script` tags generated by `next/script` and `next/head`.devIndicatorsOptimized pages include an indicator to let you know if it's being statically optimized. You can opt-out of it here.distDirSet a custom build directory to use instead of the default .next directory.envLearn to add and access environment variables in your Next.js application at build time.eslintNext.js reports ESLint errors and warnings during builds by default. Learn how to opt-out of this behavior here.exportPathMapCustomize the pages that will be exported as HTML files when using `next export`.generateBuildIdConfigure the build id, which is used to identify the current build in which your application is being served.generateEtagsNext.js will generate etags for every page by default. Learn more about how to disable etag generation here.headersAdd custom HTTP headers to your Next.js app.httpAgentOptionsNext.js will automatically use HTTP Keep-Alive by default. Learn more about how to disable HTTP Keep-Alive here.imagesCustom configuration for the next/image loaderonDemandEntriesConfigure how Next.js will dispose and keep in memory pages created in development.optimizePackageImportsAPI Reference for optimizePackageImports Next.js Config OptionoutputNext.js automatically traces which files are needed by each page to allow for easy deployment of your application. Learn how it works here.pageExtensionsExtend the default page extensions used by Next.js when resolving pages in the Pages Router.poweredByHeaderNext.js will add the `x-powered-by` header by default. Learn to opt-out of it here.productionBrowserSourceMapsEnables browser source map generation during the production build.reactStrictModeThe complete Next.js runtime is now Strict Mode-compliant, learn how to opt-inredirectsAdd redirects to your Next.js app.rewritesAdd rewrites to your Next.js app.Runtime ConfigAdd client and server runtime configuration to your Next.js app.serverExternalPackagesOpt-out specific dependencies from the dependency bundling enabled by `bundlePagesRouterDependencies`.trailingSlashConfigure Next.js pages to resolve with or without a trailing slash.transpilePackagesAutomatically transpile and bundle dependencies from local packages (like monorepos) or from external dependencies (`node_modules`).turboConfigure Next.js with Turbopack-specific optionstypescriptNext.js reports TypeScript errors by default. Learn to opt-out of this behavior here.urlImportsConfigure Next.js to allow importing modules from external URLs.useLightningcssEnable experimental support for Lightning CSS.webpackLearn how to customize the webpack config used by Next.jswebVitalsAttributionLearn how to use the webVitalsAttribution option to pinpoint the source of Web Vitals issues.PreviousConfigurationNextassetPrefixWas this helpful?supported.Send"
assetprefix,assetPrefix,"Configurationnext.config.js OptionsassetPrefixassetPrefixAttention:Deploying to Vercelautomatically configures a global CDN for your Next.js project.
You do not need to manually setup an Asset Prefix.Good to know: Next.js 9.5+ added support for a customizableBase Path, which is better
suited for hosting your application on a sub-path like/docs.
We do not suggest you use a custom Asset Prefix for this use case.Set up a CDNTo set up aCDN, you can set up an asset prefix and configure your CDN's origin to resolve to the domain that Next.js is hosted on.Opennext.config.mjsand add theassetPrefixconfig based on thephase:next.config.mjs// @ts-checkimport{ PHASE_DEVELOPMENT_SERVER }from'next/constants'exportdefault(phase)=>{constisDev=phase===PHASE_DEVELOPMENT_SERVER/***@type{import('next').NextConfig}*/constnextConfig={assetPrefix:isDev?undefined:'https://cdn.mydomain.com',}returnnextConfig}Next.js will automatically use your asset prefix for the JavaScript and CSS files it loads from the/_next/path (.next/static/folder). For example, with the above configuration, the following request for a JS chunk:/_next/static/chunks/4b9b41aaa062cbbfeff4add70f256968c51ece5d.4d708494b3aed70c04f0.jsWould instead become:https://cdn.mydomain.com/_next/static/chunks/4b9b41aaa062cbbfeff4add70f256968c51ece5d.4d708494b3aed70c04f0.jsThe exact configuration for uploading your files to a given CDN will depend on your CDN of choice. The only folder you need to host on your CDN is the contents of.next/static/, which should be uploaded as_next/static/as the above URL request indicates.Do not upload the rest of your.next/folder, as you should not expose your server code and other configuration to the public.WhileassetPrefixcovers requests to_next/static, it does not influence the following paths:Files in thepublicfolder; if you want to serve those assets over a CDN, you'll have to introduce the prefix yourself/_next/data/requests forgetServerSidePropspages. These requests will always be made against the main domain since they're not static./_next/data/requests forgetStaticPropspages. These requests will always be made against the main domain to supportIncremental Static Generation, even if you're not using it (for consistency).Previousnext.config.js OptionsNextbasePathWas this helpful?supported.Send"
basepath,basePath,"Configurationnext.config.js OptionsbasePathbasePathTo deploy a Next.js application under a sub-path of a domain you can use thebasePathconfig option.basePathallows you to set a path prefix for the application. For example, to use/docsinstead of''(an empty string, the default), opennext.config.jsand add thebasePathconfig:next.config.jsmodule.exports={basePath:'/docs',}Good to know: This value must be set at build time and cannot be changed without re-building as the value is inlined in the client-side bundles.LinksWhen linking to other pages usingnext/linkandnext/routerthebasePathwill be automatically applied.For example, using/aboutwill automatically become/docs/aboutwhenbasePathis set to/docs.exportdefaultfunctionHomePage() {return(<><Linkhref=""/about"">About Page</Link></>)}Output html:<ahref=""/docs/about"">About Page</a>This makes sure that you don't have to change all links in your application when changing thebasePathvalue.ImagesWhen using thenext/imagecomponent, you will need to add thebasePathin front ofsrc.For example, using/docs/me.pngwill properly serve your image whenbasePathis set to/docs.importImagefrom'next/image'functionHome() {return(<><h1>My Homepage</h1><Imagesrc=""/docs/me.png""alt=""Picture of the author""width={500}height={500}/><p>Welcome to my homepage!</p></>)}exportdefaultHomePreviousassetPrefixNextbundlePagesRouterDependenciesWas this helpful?supported.Send"
bundlepagesrouterdependencies,bundlePagesRouterDependencies,"Configurationnext.config.js OptionsbundlePagesRouterDependenciesbundlePagesRouterDependenciesEnable automatic server-side dependency bundling for Pages Router applications. Matches the automatic dependency bundling in App Router.next.config.js/**@type{import('next').NextConfig}*/constnextConfig={bundlePagesRouterDependencies:true,}module.exports=nextConfigExplicitly opt-out certain packages from being bundled using theserverExternalPackagesoption.Version HistoryVersionChangesv15.0.0Moved from experimental to stable. Renamed frombundlePagesExternalstobundlePagesRouterDependenciesPreviousbasePathNextcompressWas this helpful?supported.Send"
compress,compress,"Configurationnext.config.js OptionscompresscompressBy default, Next.js usesgzipto compress rendered content and static files when usingnext startor a custom server. This is an optimization for applications that do not have compression configured. If compression isalreadyconfigured in your application via a custom server, Next.js will not add compression.Good to know:When hosting your application onVercel, compression usesbrotlifirst, thengzip.You can check if compression is enabled and which algorithm is used by looking at theAccept-Encoding(browser accepted options) andContent-Encoding(currently used) headers in the response.Disabling compressionTo disablecompression, set thecompressconfig option tofalse:next.config.jsmodule.exports={compress:false,}We do not recommend disabling compression unless you have compression configured on your server, as compression reduces bandwidth usage and improves the performance of your application.Changing the compression algorithmTo change your compression algorithm, you will need to configure your custom server and set thecompressoption tofalsein yournext.config.jsfile.For example, you're usingnginxand want to switch tobrotli, set thecompressoption tofalseto allow nginx to handle compression.Good to know:For Next.js applications on Vercel, compression is handled by the Vercel's Edge Network and not Next.js. See theVercel documentationfor more information.PreviousbundlePagesRouterDependenciesNextcrossOriginWas this helpful?supported.Send"
crossorigin,crossOrigin,"Configurationnext.config.js OptionscrossOrigincrossOriginUse thecrossOriginoption to add acrossOriginattributein all<script>tags generated by thenext/scriptandnext/headcomponents, and define how cross-origin requests should be handled.next.config.jsmodule.exports={crossOrigin:'anonymous',}Options'anonymous': AddscrossOrigin=""anonymous""attribute.'use-credentials': AddscrossOrigin=""use-credentials"".PreviouscompressNextdevIndicatorsWas this helpful?supported.Send"
devindicators,devIndicators,"Configurationnext.config.js OptionsdevIndicatorsdevIndicatorsdevIndicatorsallows you to configure the on-screen indicator that gives context about the current route you're viewing during development.TypesdevIndicators:false|{position?:'bottom-right'|'bottom-left'|'top-right'|'top-left',// defaults to 'bottom-left',},SettingdevIndicatorstofalsewill hide the indicator, however Next.js will continue to surface any build or runtime errors that were encountered.TroubleshootingIndicator not marking a route as staticIf you expect a route to be static and the indicator has marked it as dynamic, it's likely the route has opted out of static rendering.You can confirm if a route isstaticordynamicby building your application usingnext build --debug, and checking the output in your terminal. Static (or prerendered) routes will display a○symbol, whereas dynamic routes will display aƒsymbol. For example:Build OutputRoute(app)                              Size     First Load JS┌○/_not-found0B0kB└ƒ/products/[id]0B0kB○(Static)   prerendered as static contentƒ(Dynamic)  server-rendered on demandWhen exportinggetServerSidePropsorgetInitialPropsfrom a page, it will be marked as dynamic.PreviouscrossOriginNextdistDirWas this helpful?supported.Send"
distdir,distDir,"Configurationnext.config.js OptionsdistDirdistDirYou can specify a name to use for a custom build directory to use instead of.next.Opennext.config.jsand add thedistDirconfig:next.config.jsmodule.exports={distDir:'build',}Now if you runnext buildNext.js will usebuildinstead of the default.nextfolder.distDirshould notleave your project directory. For example,../buildis aninvaliddirectory.PreviousdevIndicatorsNextenvWas this helpful?supported.Send"
env,env,"Configurationnext.config.js OptionsenvenvSince the release ofNext.js 9.4we now have a more intuitive and ergonomic experience foradding environment variables. Give it a try!Good to know: environment variables specified in this way willalwaysbe included in the JavaScript bundle, prefixing the environment variable name withNEXT_PUBLIC_only has an effect when specifying themthrough the environment or .env files.To add environment variables to the JavaScript bundle, opennext.config.jsand add theenvconfig:next.config.jsmodule.exports={env:{customKey:'my-value',},}Now you can accessprocess.env.customKeyin your code. For example:functionPage() {return<h1>The value of customKey is: {process.env.customKey}</h1>}exportdefaultPageNext.js will replaceprocess.env.customKeywith'my-value'at build time. Trying to destructureprocess.envvariables won't work due to the nature of webpackDefinePlugin.For example, the following line:return<h1>The value of customKey is: {process.env.customKey}</h1>Will end up being:return<h1>The value of customKey is: {'my-value'}</h1>PreviousdistDirNexteslintWas this helpful?supported.Send"
eslint,eslint,"Configurationnext.config.js OptionseslinteslintWhen ESLint is detected in your project, Next.js fails yourproduction build(next build) when errors are present.If you'd like Next.js to produce production code even when your application has ESLint errors, you can disable the built-in linting step completely. This is not recommended unless you already have ESLint configured to run in a separate part of your workflow (for example, in CI or a pre-commit hook).Opennext.config.jsand enable theignoreDuringBuildsoption in theeslintconfig:next.config.jsmodule.exports={eslint:{// Warning: This allows production builds to successfully complete even if// your project has ESLint errors.ignoreDuringBuilds:true,},}PreviousenvNextexportPathMapWas this helpful?supported.Send"
exportpathmap,exportPathMap,"Configurationnext.config.js OptionsexportPathMapexportPathMapThis feature is exclusive tonext exportand currentlydeprecatedin favor ofgetStaticPathswithpagesorgenerateStaticParamswithapp.exportPathMapallows you to specify a mapping of request paths to page destinations, to be used during export. Paths defined inexportPathMapwill also be available when usingnext dev.Let's start with an example, to create a customexportPathMapfor an app with the following pages:pages/index.jspages/about.jspages/post.jsOpennext.config.jsand add the followingexportPathMapconfig:next.config.jsmodule.exports={exportPathMap:asyncfunction(defaultPathMap,{ dev,dir,outDir,distDir,buildId }) {return{'/':{ page:'/'},'/about':{ page:'/about'},'/p/hello-nextjs':{ page:'/post',query:{ title:'hello-nextjs'} },'/p/learn-nextjs':{ page:'/post',query:{ title:'learn-nextjs'} },'/p/deploy-nextjs':{ page:'/post',query:{ title:'deploy-nextjs'} },}},}Good to know: thequeryfield inexportPathMapcannot be used withautomatically statically optimized pagesorgetStaticPropspagesas they are rendered to HTML files at build-time and additional query information cannot be provided duringnext export.The pages will then be exported as HTML files, for example,/aboutwill become/about.html.exportPathMapis anasyncfunction that receives 2 arguments: the first one isdefaultPathMap, which is the default map used by Next.js. The second argument is an object with:dev-truewhenexportPathMapis being called in development.falsewhen runningnext export. In developmentexportPathMapis used to define routes.dir- Absolute path to the project directoryoutDir- Absolute path to theout/directory (configurable with-o). Whendevistruethe value ofoutDirwill benull.distDir- Absolute path to the.next/directory (configurable with thedistDirconfig)buildId- The generated build idThe returned object is a map of pages where thekeyis thepathnameand thevalueis an object that accepts the following fields:page:String- the page inside thepagesdirectory to renderquery:Object- thequeryobject passed togetInitialPropswhen prerendering. Defaults to{}The exportedpathnamecan also be a filename (for example,/readme.md), but you may need to set theContent-Typeheader totext/htmlwhen serving its content if it is different than.html.Adding a trailing slashIt is possible to configure Next.js to export pages asindex.htmlfiles and require trailing slashes,/aboutbecomes/about/index.htmland is routable via/about/. This was the default behavior prior to Next.js 9.To switch back and add a trailing slash, opennext.config.jsand enable thetrailingSlashconfig:next.config.jsmodule.exports={trailingSlash:true,}Customizing the output directorynext exportwill useoutas the default output directory, you can customize this using the-oargument, like so:Terminalnextexport-ooutdirWarning: UsingexportPathMapis deprecated and is overridden bygetStaticPathsinsidepages. We don't recommend using them together.PreviouseslintNextgenerateBuildIdWas this helpful?supported.Send"
generatebuildid,generateBuildId,"Configurationnext.config.js OptionsgenerateBuildIdgenerateBuildIdNext.js generates an ID duringnext buildto identify which version of your application is being served. The same build should be used and boot up multiple containers.If you are rebuilding for each stage of your environment, you will need to generate a consistent build ID to use between containers. Use thegenerateBuildIdcommand innext.config.js:next.config.jsmodule.exports={generateBuildId:async()=>{// This could be anything, using the latest git hashreturnprocess.env.GIT_HASH},}PreviousexportPathMapNextgenerateEtagsWas this helpful?supported.Send"
generateetags,generateEtags,"Configurationnext.config.js OptionsgenerateEtagsgenerateEtagsNext.js will generateetagsfor every page by default. You may want to disable etag generation for HTML pages depending on your cache strategy.Opennext.config.jsand disable thegenerateEtagsoption:next.config.jsmodule.exports={generateEtags:false,}PreviousgenerateBuildIdNextheadersWas this helpful?supported.Send"
headers,headers,"Configurationnext.config.js OptionsheadersheadersHeaders allow you to set custom HTTP headers on the response to an incoming request on a given path.To set custom HTTP headers you can use theheaderskey innext.config.js:next.config.jsmodule.exports={asyncheaders() {return[{source:'/about',headers:[{key:'x-custom-header',value:'my custom header value',},{key:'x-another-custom-header',value:'my other custom header value',},],},]},}headersis an async function that expects an array to be returned holding objects withsourceandheadersproperties:sourceis the incoming request path pattern.headersis an array of response header objects, withkeyandvalueproperties.basePath:falseorundefined- if false the basePath won't be included when matching, can be used for external rewrites only.locale:falseorundefined- whether the locale should not be included when matching.hasis an array ofhas objectswith thetype,keyandvalueproperties.missingis an array ofmissing objectswith thetype,keyandvalueproperties.Headers are checked before the filesystem which includes pages and/publicfiles.Header Overriding BehaviorIf two headers match the same path and set the same header key, the last header key will override the first. Using the below headers, the path/hellowill result in the headerx-hellobeingworlddue to the last header value set beingworld.next.config.jsmodule.exports={asyncheaders() {return[{source:'/:path*',headers:[{key:'x-hello',value:'there',},],},{source:'/hello',headers:[{key:'x-hello',value:'world',},],},]},}Path MatchingPath matches are allowed, for example/blog/:slugwill match/blog/hello-world(no nested paths):next.config.jsmodule.exports={asyncheaders() {return[{source:'/blog/:slug',headers:[{key:'x-slug',value:':slug',// Matched parameters can be used in the value},{key:'x-slug-:slug',// Matched parameters can be used in the keyvalue:'my other custom header value',},],},]},}Wildcard Path MatchingTo match a wildcard path you can use*after a parameter, for example/blog/:slug*will match/blog/a/b/c/d/hello-world:next.config.jsmodule.exports={asyncheaders() {return[{source:'/blog/:slug*',headers:[{key:'x-slug',value:':slug*',// Matched parameters can be used in the value},{key:'x-slug-:slug*',// Matched parameters can be used in the keyvalue:'my other custom header value',},],},]},}Regex Path MatchingTo match a regex path you can wrap the regex in parenthesis after a parameter, for example/blog/:slug(\\d{1,})will match/blog/123but not/blog/abc:next.config.jsmodule.exports={asyncheaders() {return[{source:'/blog/:post(\\d{1,})',headers:[{key:'x-post',value:':post',},],},]},}The following characters(,),{,},:,*,+,?are used for regex path matching, so when used in thesourceas non-special values they must be escaped by adding\\before them:next.config.jsmodule.exports={asyncheaders() {return[{// this will match `/english(default)/something` being requestedsource:'/english\\(default\\)/:slug',headers:[{key:'x-header',value:'value',},],},]},}Header, Cookie, and Query MatchingTo only apply a header when header, cookie, or query values also match thehasfield or don't match themissingfield can be used. Both thesourceand allhasitems must match and allmissingitems must not match for the header to be applied.hasandmissingitems can have the following fields:type:String- must be eitherheader,cookie,host, orquery.key:String- the key from the selected type to match against.value:Stringorundefined- the value to check for, if undefined any value will match. A regex like string can be used to capture a specific part of the value, e.g. if the valuefirst-(?<paramName>.*)is used forfirst-secondthensecondwill be usable in the destination with:paramName.next.config.jsmodule.exports={asyncheaders() {return[// if the header `x-add-header` is present,// the `x-another-header` header will be applied{source:'/:path*',has:[{type:'header',key:'x-add-header',},],headers:[{key:'x-another-header',value:'hello',},],},// if the header `x-no-header` is not present,// the `x-another-header` header will be applied{source:'/:path*',missing:[{type:'header',key:'x-no-header',},],headers:[{key:'x-another-header',value:'hello',},],},// if the source, query, and cookie are matched,// the `x-authorized` header will be applied{source:'/specific/:path*',has:[{type:'query',key:'page',// the page value will not be available in the// header key/values since value is provided and// doesn't use a named capture group e.g. (?<page>home)value:'home',},{type:'cookie',key:'authorized',value:'true',},],headers:[{key:'x-authorized',value:':authorized',},],},// if the header `x-authorized` is present and// contains a matching value, the `x-another-header` will be applied{source:'/:path*',has:[{type:'header',key:'x-authorized',value:'(?<authorized>yes|true)',},],headers:[{key:'x-another-header',value:':authorized',},],},// if the host is `example.com`,// this header will be applied{source:'/:path*',has:[{type:'host',value:'example.com',},],headers:[{key:'x-another-header',value:':authorized',},],},]},}Headers with basePath supportWhen leveragingbasePathsupportwith headers eachsourceis automatically prefixed with thebasePathunless you addbasePath: falseto the header:next.config.jsmodule.exports={basePath:'/docs',asyncheaders() {return[{source:'/with-basePath',// becomes /docs/with-basePathheaders:[{key:'x-hello',value:'world',},],},{source:'/without-basePath',// is not modified since basePath: false is setheaders:[{key:'x-hello',value:'world',},],basePath:false,},]},}Headers with i18n supportWhen leveragingi18nsupportwith headers eachsourceis automatically prefixed to handle the configuredlocalesunless you addlocale: falseto the header. Iflocale: falseis used you must prefix thesourcewith a locale for it to be matched correctly.next.config.jsmodule.exports={i18n:{locales:['en','fr','de'],defaultLocale:'en',},asyncheaders() {return[{source:'/with-locale',// automatically handles all localesheaders:[{key:'x-hello',value:'world',},],},{// does not handle locales automatically since locale: false is setsource:'/nl/with-locale-manual',locale:false,headers:[{key:'x-hello',value:'world',},],},{// this matches '/' since `en` is the defaultLocalesource:'/en',locale:false,headers:[{key:'x-hello',value:'world',},],},{// this gets converted to /(en|fr|de)/(.*) so will not match the top-level// `/` or `/fr` routes like /:path* wouldsource:'/(.*)',headers:[{key:'x-hello',value:'world',},],},]},}Cache-ControlNext.js sets theCache-Controlheader ofpublic, max-age=31536000, immutablefor truly immutable assets. It cannot be overridden. These immutable files contain a SHA-hash in the file name, so they can be safely cached indefinitely. For example,Static Image Imports. You cannot setCache-Controlheaders innext.config.jsfor these assets.However, you can setCache-Controlheaders for other responses or data.If you need to revalidate the cache of a page that has beenstatically generated, you can do so by setting therevalidateprop in the page'sgetStaticPropsfunction.To cache the response from anAPI Route, you can useres.setHeader:pages/api/hello.tsTypeScriptJavaScriptTypeScriptimporttype{ NextApiRequest,NextApiResponse }from'next'typeResponseData={message:string}exportdefaultfunctionhandler(req:NextApiRequest,res:NextApiResponse<ResponseData>) {res.setHeader('Cache-Control','s-maxage=86400')res.status(200).json({ message:'Hello from Next.js!'})}You can also use caching headers (Cache-Control) insidegetServerSidePropsto cache dynamic responses. For example, usingstale-while-revalidate.pages/index.tsxTypeScriptJavaScriptTypeScriptimport{ GetStaticProps,GetStaticPaths,GetServerSideProps }from'next'// This value is considered fresh for ten seconds (s-maxage=10).// If a request is repeated within the next 10 seconds, the previously// cached value will still be fresh. If the request is repeated before 59 seconds,// the cached value will be stale but still render (stale-while-revalidate=59).//// In the background, a revalidation request will be made to populate the cache// with a fresh value. If you refresh the page, you will see the new value.exportconstgetServerSideProps=(async(context)=>{context.res.setHeader('Cache-Control','public, s-maxage=10, stale-while-revalidate=59')return{props:{},}})satisfiesGetServerSidePropsOptionsCORSCross-Origin Resource Sharing (CORS)is a security feature that allows you to control which sites can access your resources. You can set theAccess-Control-Allow-Originheader to allow a specific origin to access yourAPI Endpoints.asyncheaders() {return[{source:""/api/:path*"",headers:[{key:""Access-Control-Allow-Origin"",value:""*"",// Set your origin},{key:""Access-Control-Allow-Methods"",value:""GET, POST, PUT, DELETE, OPTIONS"",},{key:""Access-Control-Allow-Headers"",value:""Content-Type, Authorization"",},],},];},X-DNS-Prefetch-ControlThis headercontrols DNS prefetching, allowing browsers to proactively perform domain name resolution on external links, images, CSS, JavaScript, and more. This prefetching is performed in the background, so theDNSis more likely to be resolved by the time the referenced items are needed. This reduces latency when the user clicks a link.{key:'X-DNS-Prefetch-Control',value:'on'}Strict-Transport-SecurityThis headerinforms browsers it should only be accessed using HTTPS, instead of using HTTP. Using the configuration below, all present and future subdomains will use HTTPS for amax-ageof 2 years. This blocks access to pages or subdomains that can only be served over HTTP.If you're deploying toVercel, this header is not necessary as it's automatically added to all deployments unless you declareheadersin yournext.config.js.{key:'Strict-Transport-Security',value:'max-age=63072000; includeSubDomains; preload'}X-Frame-OptionsThis headerindicates whether the site should be allowed to be displayed within aniframe. This can prevent against clickjacking attacks.This header has been superseded by CSP'sframe-ancestorsoption, which has better support in modern browsers (seeContent Security Policyfor configuration details).{key:'X-Frame-Options',value:'SAMEORIGIN'}Permissions-PolicyThis headerallows you to control which features and APIs can be used in the browser. It was previously namedFeature-Policy.{key:'Permissions-Policy',value:'camera=(), microphone=(), geolocation=(), browsing-topics=()'}X-Content-Type-OptionsThis headerprevents the browser from attempting to guess the type of content if theContent-Typeheader is not explicitly set. This can prevent XSS exploits for websites that allow users to upload and share files.For example, a user trying to download an image, but having it treated as a differentContent-Typelike an executable, which could be malicious. This header also applies to downloading browser extensions. The only valid value for this header isnosniff.{key:'X-Content-Type-Options',value:'nosniff'}Referrer-PolicyThis headercontrols how much information the browser includes when navigating from the current website (origin) to another.{key:'Referrer-Policy',value:'origin-when-cross-origin'}Content-Security-PolicyLearn more about adding aContent Security Policyto your application.Version HistoryVersionChangesv13.3.0missingadded.v10.2.0hasadded.v9.5.0Headers added.PreviousgenerateEtagsNexthttpAgentOptionsWas this helpful?supported.Send"
httpagentoptions,httpAgentOptions,"Configurationnext.config.js OptionshttpAgentOptionshttpAgentOptionsIn Node.js versions prior to 18, Next.js automatically polyfillsfetch()withundiciand enablesHTTP Keep-Aliveby default.To disable HTTP Keep-Alive for allfetch()calls on the server-side, opennext.config.jsand add thehttpAgentOptionsconfig:next.config.jsmodule.exports={httpAgentOptions:{keepAlive:false,},}PreviousheadersNextimagesWas this helpful?supported.Send"
images,images,"Configurationnext.config.js OptionsimagesimagesIf you want to use a cloud provider to optimize images instead of using the Next.js built-in Image Optimization API, you can configurenext.config.jswith the following:next.config.jsmodule.exports={images:{loader:'custom',loaderFile:'./my/image/loader.js',},}ThisloaderFilemust point to a file relative to the root of your Next.js application. The file must export a default function that returns a string, for example:my/image/loader.jsexportdefaultfunctionmyImageLoader({ src,width,quality }) {return`https://example.com/${src}?w=${width}&q=${quality||75}`}Alternatively, you can use theloaderpropto pass the function to each instance ofnext/image.To learn more about configuring the behavior of the built-inImage Optimization APIand theImage Component, seeImage Configuration Optionsfor available options.Example Loader ConfigurationAkamaiAWS CloudFrontCloudinaryCloudflareContentfulFastlyGumletImageEngineImgixPixelBinSanitySirvSupabaseThumborImagekitNitrogen AIOAkamai// Docs: https://techdocs.akamai.com/ivm/reference/test-images-on-demandexportdefaultfunctionakamaiLoader({ src,width,quality }) {return`https://example.com/${src}?imwidth=${width}`}AWS CloudFront// Docs: https://aws.amazon.com/developer/application-security-performance/articles/image-optimizationexportdefaultfunctioncloudfrontLoader({ src,width,quality }) {consturl=newURL(`https://example.com${src}`)url.searchParams.set('format','auto')url.searchParams.set('width',width.toString())url.searchParams.set('quality',(quality||75).toString())returnurl.href}Cloudinary// Demo: https://res.cloudinary.com/demo/image/upload/w_300,c_limit,q_auto/turtles.jpgexportdefaultfunctioncloudinaryLoader({ src,width,quality }) {constparams=['f_auto','c_limit',`w_${width}`,`q_${quality||'auto'}`]return`https://example.com/${params.join(',')}${src}`}Cloudflare// Docs: https://developers.cloudflare.com/images/transform-imagesexportdefaultfunctioncloudflareLoader({ src,width,quality }) {constparams=[`width=${width}`,`quality=${quality||75}`,'format=auto']return`https://example.com/cdn-cgi/image/${params.join(',')}/${src}`}Contentful// Docs: https://www.contentful.com/developers/docs/references/images-api/exportdefaultfunctioncontentfulLoader({ src,width,quality }) {consturl=newURL(`https://example.com${src}`)url.searchParams.set('fm','webp')url.searchParams.set('w',width.toString())url.searchParams.set('q',(quality||75).toString())returnurl.href}Fastly// Docs: https://developer.fastly.com/reference/io/exportdefaultfunctionfastlyLoader({ src,width,quality }) {consturl=newURL(`https://example.com${src}`)url.searchParams.set('auto','webp')url.searchParams.set('width',width.toString())url.searchParams.set('quality',(quality||75).toString())returnurl.href}Gumlet// Docs: https://docs.gumlet.com/reference/image-transform-sizeexportdefaultfunctiongumletLoader({ src,width,quality }) {consturl=newURL(`https://example.com${src}`)url.searchParams.set('format','auto')url.searchParams.set('w',width.toString())url.searchParams.set('q',(quality||75).toString())returnurl.href}ImageEngine// Docs: https://support.imageengine.io/hc/en-us/articles/360058880672-DirectivesexportdefaultfunctionimageengineLoader({ src,width,quality }) {constcompression=100-(quality||50)constparams=[`w_${width}`,`cmpr_${compression}`)]return`https://example.com${src}?imgeng=/${params.join('/')`}Imgix// Demo: https://static.imgix.net/daisy.png?format=auto&fit=max&w=300exportdefaultfunctionimgixLoader({ src,width,quality }) {consturl=newURL(`https://example.com${src}`)constparams=url.searchParamsparams.set('auto',params.getAll('auto').join(',')||'format')params.set('fit',params.get('fit')||'max')params.set('w',params.get('w')||width.toString())params.set('q',(quality||50).toString())returnurl.href}PixelBin// Doc (Resize): https://www.pixelbin.io/docs/transformations/basic/resize/#width-w// Doc (Optimise): https://www.pixelbin.io/docs/optimizations/quality/#image-quality-when-delivering// Doc (Auto Format Delivery): https://www.pixelbin.io/docs/optimizations/format/#automatic-format-selection-with-f_auto-url-parameterexportdefaultfunctionpixelBinLoader({ src,width,quality }) {constname='<your-cloud-name>'constopt=`t.resize(w:${width})~t.compress(q:${quality||75})`return`https://cdn.pixelbin.io/v2/${name}/${opt}/${src}?f_auto=true`}Sanity// Docs: https://www.sanity.io/docs/image-urlsexportdefaultfunctionsanityLoader({ src,width,quality }) {constprj='zp7mbokg'constdataset='production'consturl=newURL(`https://cdn.sanity.io/images/${prj}/${dataset}${src}`)url.searchParams.set('auto','format')url.searchParams.set('fit','max')url.searchParams.set('w',width.toString())if(quality) {url.searchParams.set('q',quality.toString())}returnurl.href}Sirv// Docs: https://sirv.com/help/articles/dynamic-imaging/exportdefaultfunctionsirvLoader({ src,width,quality }) {consturl=newURL(`https://example.com${src}`)constparams=url.searchParamsparams.set('format',params.getAll('format').join(',')||'optimal')params.set('w',params.get('w')||width.toString())params.set('q',(quality||85).toString())returnurl.href}Supabase// Docs: https://supabase.com/docs/guides/storage/image-transformations#nextjs-loaderexportdefaultfunctionsupabaseLoader({ src,width,quality }) {consturl=newURL(`https://example.com${src}`)url.searchParams.set('width',width.toString())url.searchParams.set('quality',(quality||75).toString())returnurl.href}Thumbor// Docs: https://thumbor.readthedocs.io/en/latest/exportdefaultfunctionthumborLoader({ src,width,quality }) {constparams=[`${width}x0`,`filters:quality(${quality||75})`]return`https://example.com${params.join('/')}${src}`}ImageKit.io// Docs: https://imagekit.io/docs/image-transformationexportdefaultfunctionimageKitLoader({ src,width,quality }) {constparams=[`w-${width}`,`q-${quality||80}`]return`https://ik.imagekit.io/your_imagekit_id/${src}?tr=${params.join(',')}`}Nitrogen AIO// Docs: https://docs.n7.io/aio/intergrations/exportdefaultfunctionaioLoader({ src,width,quality }) {consturl=newURL(src,window.location.href)constparams=url.searchParamsconstaioParams=params.getAll('aio')aioParams.push(`w-${width}`)if(quality) {aioParams.push(`q-${quality.toString()}`)}params.set('aio',aioParams.join(';'))returnurl.href}PrevioushttpAgentOptionsNextonDemandEntriesWas this helpful?supported.Send"
ondemandentries,onDemandEntries,"Configurationnext.config.js OptionsonDemandEntriesonDemandEntriesNext.js exposes some options that give you some control over how the server will dispose or keep in memory built pages in development.To change the defaults, opennext.config.jsand add theonDemandEntriesconfig:next.config.jsmodule.exports={onDemandEntries:{// period (in ms) where the server will keep pages in the buffermaxInactiveAge:25*1000,// number of pages that should be kept simultaneously without being disposedpagesBufferLength:2,},}PreviousimagesNextoptimizePackageImportsWas this helpful?supported.Send"
optimizepackageimports,optimizePackageImports,"Configurationnext.config.js OptionsoptimizePackageImportsoptimizePackageImportsSome packages can export hundreds or thousands of modules, which can cause performance issues in development and production.Adding a package toexperimental.optimizePackageImportswill only load the modules you are actually using, while still giving you the convenience of writing import statements with many named exports.next.config.jsmodule.exports={experimental:{optimizePackageImports:['package-name'],},}The following libraries are optimized by default:lucide-reactdate-fnslodash-esramdaantdreact-bootstrapahooks@ant-design/icons@headlessui/react@headlessui-float/react@heroicons/react/20/solid@heroicons/react/24/solid@heroicons/react/24/outline@visx/visx@tremor/reactrxjs@mui/material@mui/icons-materialrechartsreact-use@material-ui/core@material-ui/icons@tabler/icons-reactmui-corereact-icons/*PreviousonDemandEntriesNextoutputWas this helpful?supported.Send"
output,output,"Configurationnext.config.js OptionsoutputoutputDuring a build, Next.js will automatically trace each page and its dependencies to determine all of the files that are needed for deploying a production version of your application.This feature helps reduce the size of deployments drastically. Previously, when deploying with Docker you would need to have all files from your package'sdependenciesinstalled to runnext start. Starting with Next.js 12, you can leverage Output File Tracing in the.next/directory to only include the necessary files.Furthermore, this removes the need for the deprecatedserverlesstarget which can cause various issues and also creates unnecessary duplication.How it WorksDuringnext build, Next.js will use@vercel/nftto statically analyzeimport,require, andfsusage to determine all files that a page might load.Next.js' production server is also traced for its needed files and output at.next/next-server.js.nft.jsonwhich can be leveraged in production.To leverage the.nft.jsonfiles emitted to the.nextoutput directory, you can read the list of files in each trace that are relative to the.nft.jsonfile and then copy them to your deployment location.Automatically Copying Traced FilesNext.js can automatically create astandalonefolder that copies only the necessary files for a production deployment including select files innode_modules.To leverage this automatic copying you can enable it in yournext.config.js:next.config.jsmodule.exports={output:'standalone',}This will create a folder at.next/standalonewhich can then be deployed on its own without installingnode_modules.Additionally, a minimalserver.jsfile is also output which can be used instead ofnext start. This minimal server does not copy thepublicor.next/staticfolders by default as these should ideally be handled by a CDN instead, although these folders can be copied to thestandalone/publicandstandalone/.next/staticfolders manually, after whichserver.jsfile will serve these automatically.To copy these manually, you can use thecpcommand-line tool after younext build:Terminalcp-rpublic.next/standalone/&&cp-r.next/static.next/standalone/.next/To start your minimalserver.jsfile locally, run the following command:Terminalnode.next/standalone/server.jsGood to know:next.config.jsis read duringnext buildand serialized into theserver.jsoutput file. If the legacyserverRuntimeConfigorpublicRuntimeConfigoptionsare being used, the values will be specific to values at build time.If your project needs to listen to a specific port or hostname, you can definePORTorHOSTNAMEenvironment variables before runningserver.js. For example, runPORT=8080 HOSTNAME=0.0.0.0 node server.jsto start the server onhttp://0.0.0.0:8080.CaveatsWhile tracing in monorepo setups, the project directory is used for tracing by default. Fornext build packages/web-app,packages/web-appwould be the tracing root and any files outside of that folder will not be included. To include files outside of this folder you can setoutputFileTracingRootin yournext.config.js.packages/web-app/next.config.jsmodule.exports={// this includes files from the monorepo base two directories upoutputFileTracingRoot:path.join(__dirname,'../../'),}There are some cases in which Next.js might fail to include required files, or might incorrectly include unused files. In those cases, you can leverageoutputFileTracingExcludesandoutputFileTracingIncludesrespectively innext.config.js. Each config accepts an object withminimatch globsfor the key to match specific pages and a value of an array with globs relative to the project's root to either include or exclude in the trace.next.config.jsmodule.exports={outputFileTracingExcludes:{'/api/hello':['./un-necessary-folder/**/*'],},outputFileTracingIncludes:{'/api/another':['./necessary-folder/**/*'],'/api/login/\\[\\[\\.\\.\\.slug\\]\\]':['./node_modules/aws-crt/dist/bin/**/*',],},}Note:The key ofoutputFileTracingIncludes/outputFileTracingExcludesis aglob, so special characters need to be escaped.Currently, Next.js does not do anything with the emitted.nft.jsonfiles. The files must be read by your deployment platform, for exampleVercel, to create a minimal deployment. In a future release, a new command is planned to utilize these.nft.jsonfiles.ExperimentalturbotraceTracing dependencies can be slow because it requires very complex computations and analysis. We createdturbotracein Rust as a faster and smarter alternative to the JavaScript implementation.To enable it, you can add the following configuration to yournext.config.js:next.config.jsmodule.exports={experimental:{turbotrace:{// control the log level of the turbotrace, default is `error`logLevel?:|'bug'|'fatal'|'error'|'warning'|'hint'|'note'|'suggestions'|'info',// control if the log of turbotrace should contain the details of the analysis, default is `false`logDetail?:boolean// show all log messages without limit// turbotrace only show 1 log message for each categories by defaultlogAll?:boolean// control the context directory of the turbotrace// files outside of the context directory will not be traced// set the `outputFileTracingRoot` has the same effect// if the `outputFileTracingRoot` and this option are both set, the `experimental.turbotrace.contextDirectory` will be usedcontextDirectory?:string// if there is `process.cwd()` expression in your code, you can set this option to tell `turbotrace` the value of `process.cwd()` while tracing.// for example the require(process.cwd() + '/package.json') will be traced as require('/path/to/cwd/package.json')processCwd?:string// control the maximum memory usage of the `turbotrace`, in `MB`, default is `6000`.memoryLimit?:number},},}PreviousoptimizePackageImportsNextpageExtensionsWas this helpful?supported.Send"
pageextensions,pageExtensions,"Configurationnext.config.js OptionspageExtensionspageExtensionsYou can extend the default Page extensions (.tsx,.ts,.jsx,.js) used by Next.js. Insidenext.config.js, add thepageExtensionsconfig:next.config.jsmodule.exports={pageExtensions:['mdx','md','jsx','js','tsx','ts'],}Changing these values affectsallNext.js pages, including the following:middleware.jsinstrumentation.jspages/_document.jspages/_app.jspages/api/For example, if you reconfigure.tspage extensions to.page.ts, you would need to rename pages likemiddleware.page.ts,instrumentation.page.ts,_app.page.ts.Including non-page files in thepagesdirectoryYou can colocate test files or other files used by components in thepagesdirectory. Insidenext.config.js, add thepageExtensionsconfig:next.config.jsmodule.exports={pageExtensions:['page.tsx','page.ts','page.jsx','page.js'],}Then, rename your pages to have a file extension that includes.page(e.g. renameMyPage.tsxtoMyPage.page.tsx). Ensure you renameallNext.js pages, including the files mentioned above.PreviousoutputNextpoweredByHeaderWas this helpful?supported.Send"
poweredbyheader,poweredByHeader,"Configurationnext.config.js OptionspoweredByHeaderpoweredByHeaderBy default Next.js will add thex-powered-byheader. To opt-out of it, opennext.config.jsand disable thepoweredByHeaderconfig:next.config.jsmodule.exports={poweredByHeader:false,}PreviouspageExtensionsNextproductionBrowserSourceMapsWas this helpful?supported.Send"
productionbrowsersourcemaps,productionBrowserSourceMaps,"Configurationnext.config.js OptionsproductionBrowserSourceMapsproductionBrowserSourceMapsSource Maps are enabled by default during development. During production builds, they are disabled to prevent you leaking your source on the client, unless you specifically opt-in with the configuration flag.Next.js provides a configuration flag you can use to enable browser source map generation during the production build:next.config.jsmodule.exports={productionBrowserSourceMaps:true,}When theproductionBrowserSourceMapsoption is enabled, the source maps will be output in the same directory as the JavaScript files. Next.js will automatically serve these files when requested.Adding source maps can increasenext buildtimeIncreases memory usage duringnext buildPreviouspoweredByHeaderNextreactStrictModeWas this helpful?supported.Send"
reactstrictmode,reactStrictMode,"Configurationnext.config.js OptionsreactStrictModereactStrictModeGood to know: Since Next.js 13.5.1, Strict Mode istrueby default withapprouter, so the above configuration is only necessary forpages. You can still disable Strict Mode by settingreactStrictMode: false.Suggested: We strongly suggest you enable Strict Mode in your Next.js application to better prepare your application for the future of React.React'sStrict Modeis a development mode only feature for highlighting potential problems in an application. It helps to identify unsafe lifecycles, legacy API usage, and a number of other features.The Next.js runtime is Strict Mode-compliant. To opt-in to Strict Mode, configure the following option in yournext.config.js:next.config.jsmodule.exports={reactStrictMode:true,}If you or your team are not ready to use Strict Mode in your entire application, that's OK! You can incrementally migrate on a page-by-page basis using<React.StrictMode>.PreviousproductionBrowserSourceMapsNextredirectsWas this helpful?supported.Send"
redirects,redirects,"Configurationnext.config.js OptionsredirectsredirectsRedirects allow you to redirect an incoming request path to a different destination path.To use redirects you can use theredirectskey innext.config.js:next.config.jsmodule.exports={asyncredirects() {return[{source:'/about',destination:'/',permanent:true,},]},}redirectsis an async function that expects an array to be returned holding objects withsource,destination, andpermanentproperties:sourceis the incoming request path pattern.destinationis the path you want to route to.permanenttrueorfalse- iftruewill use the 308 status code which instructs clients/search engines to cache the redirect forever, iffalsewill use the 307 status code which is temporary and is not cached.Why does Next.js use 307 and 308?Traditionally a 302 was used for a temporary redirect, and a 301 for a permanent redirect, but many browsers changed the request method of the redirect toGET, regardless of the original method. For example, if the browser made a request toPOST /v1/userswhich returned status code302with location/v2/users, the subsequent request might beGET /v2/usersinstead of the expectedPOST /v2/users. Next.js uses the 307 temporary redirect, and 308 permanent redirect status codes to explicitly preserve the request method used.basePath:falseorundefined- if false thebasePathwon't be included when matching, can be used for external redirects only.locale:falseorundefined- whether the locale should not be included when matching.hasis an array ofhas objectswith thetype,keyandvalueproperties.missingis an array ofmissing objectswith thetype,keyandvalueproperties.Redirects are checked before the filesystem which includes pages and/publicfiles.When using the Pages Router, redirects are not applied to client-side routing (Link,router.push) unlessMiddlewareis present and matches the path.When a redirect is applied, any query values provided in the request will be passed through to the redirect destination. For example, see the following redirect configuration:{source:'/old-blog/:path*',destination:'/blog/:path*',permanent:false}Good to know: Remember to include the forward slash/before the colon:in path parameters of thesourceanddestinationpaths, otherwise the path will be treated as a literal string and you run the risk of causing infinite redirects.When/old-blog/post-1?hello=worldis requested, the client will be redirected to/blog/post-1?hello=world.Path MatchingPath matches are allowed, for example/old-blog/:slugwill match/old-blog/hello-world(no nested paths):next.config.jsmodule.exports={asyncredirects() {return[{source:'/old-blog/:slug',destination:'/news/:slug',// Matched parameters can be used in the destinationpermanent:true,},]},}Wildcard Path MatchingTo match a wildcard path you can use*after a parameter, for example/blog/:slug*will match/blog/a/b/c/d/hello-world:next.config.jsmodule.exports={asyncredirects() {return[{source:'/blog/:slug*',destination:'/news/:slug*',// Matched parameters can be used in the destinationpermanent:true,},]},}Regex Path MatchingTo match a regex path you can wrap the regex in parentheses after a parameter, for example/post/:slug(\\d{1,})will match/post/123but not/post/abc:next.config.jsmodule.exports={asyncredirects() {return[{source:'/post/:slug(\\d{1,})',destination:'/news/:slug',// Matched parameters can be used in the destinationpermanent:false,},]},}The following characters(,),{,},:,*,+,?are used for regex path matching, so when used in thesourceas non-special values they must be escaped by adding\\before them:next.config.jsmodule.exports={asyncredirects() {return[{// this will match `/english(default)/something` being requestedsource:'/english\\(default\\)/:slug',destination:'/en-us/:slug',permanent:false,},]},}Header, Cookie, and Query MatchingTo only match a redirect when header, cookie, or query values also match thehasfield or don't match themissingfield can be used. Both thesourceand allhasitems must match and allmissingitems must not match for the redirect to be applied.hasandmissingitems can have the following fields:type:String- must be eitherheader,cookie,host, orquery.key:String- the key from the selected type to match against.value:Stringorundefined- the value to check for, if undefined any value will match. A regex like string can be used to capture a specific part of the value, e.g. if the valuefirst-(?<paramName>.*)is used forfirst-secondthensecondwill be usable in the destination with:paramName.next.config.jsmodule.exports={asyncredirects() {return[// if the header `x-redirect-me` is present,// this redirect will be applied{source:'/:path((?!another-page$).*)',has:[{type:'header',key:'x-redirect-me',},],permanent:false,destination:'/another-page',},// if the header `x-dont-redirect` is present,// this redirect will NOT be applied{source:'/:path((?!another-page$).*)',missing:[{type:'header',key:'x-do-not-redirect',},],permanent:false,destination:'/another-page',},// if the source, query, and cookie are matched,// this redirect will be applied{source:'/specific/:path*',has:[{type:'query',key:'page',// the page value will not be available in the// destination since value is provided and doesn't// use a named capture group e.g. (?<page>home)value:'home',},{type:'cookie',key:'authorized',value:'true',},],permanent:false,destination:'/another/:path*',},// if the header `x-authorized` is present and// contains a matching value, this redirect will be applied{source:'/',has:[{type:'header',key:'x-authorized',value:'(?<authorized>yes|true)',},],permanent:false,destination:'/home?authorized=:authorized',},// if the host is `example.com`,// this redirect will be applied{source:'/:path((?!another-page$).*)',has:[{type:'host',value:'example.com',},],permanent:false,destination:'/another-page',},]},}Redirects with basePath supportWhen leveragingbasePathsupportwith redirects eachsourceanddestinationis automatically prefixed with thebasePathunless you addbasePath: falseto the redirect:next.config.jsmodule.exports={basePath:'/docs',asyncredirects() {return[{source:'/with-basePath',// automatically becomes /docs/with-basePathdestination:'/another',// automatically becomes /docs/anotherpermanent:false,},{// does not add /docs since basePath: false is setsource:'/without-basePath',destination:'https://example.com',basePath:false,permanent:false,},]},}Redirects with i18n supportWhen leveragingi18nsupportwith redirects eachsourceanddestinationis automatically prefixed to handle the configuredlocalesunless you addlocale: falseto the redirect. Iflocale: falseis used you must prefix thesourceanddestinationwith a locale for it to be matched correctly.next.config.jsmodule.exports={i18n:{locales:['en','fr','de'],defaultLocale:'en',},asyncredirects() {return[{source:'/with-locale',// automatically handles all localesdestination:'/another',// automatically passes the locale onpermanent:false,},{// does not handle locales automatically since locale: false is setsource:'/nl/with-locale-manual',destination:'/nl/another',locale:false,permanent:false,},{// this matches '/' since `en` is the defaultLocalesource:'/en',destination:'/en/another',locale:false,permanent:false,},// it's possible to match all locales even when locale: false is set{source:'/:locale/page',destination:'/en/newpage',permanent:false,locale:false,},{// this gets converted to /(en|fr|de)/(.*) so will not match the top-level// `/` or `/fr` routes like /:path* wouldsource:'/(.*)',destination:'/another',permanent:false,},]},}In some rare cases, you might need to assign a custom status code for older HTTP Clients to properly redirect. In these cases, you can use thestatusCodeproperty instead of thepermanentproperty, but not both. To to ensure IE11 compatibility, aRefreshheader is automatically added for the 308 status code.Other RedirectsInsideAPI RoutesandRoute Handlers, you can redirect based on the incoming request.InsidegetStaticPropsandgetServerSideProps, you can redirect specific pages at request-time.Version HistoryVersionChangesv13.3.0missingadded.v10.2.0hasadded.v9.5.0redirectsadded.PreviousreactStrictModeNextrewritesWas this helpful?supported.Send"
rewrites,rewrites,"Configurationnext.config.js OptionsrewritesrewritesRewrites allow you to map an incoming request path to a different destination path.Rewrites act as a URL proxy and mask the destination path, making it appear the user hasn't changed their location on the site. In contrast,redirectswill reroute to a new page and show the URL changes.To use rewrites you can use therewriteskey innext.config.js:next.config.jsmodule.exports={asyncrewrites() {return[{source:'/about',destination:'/',},]},}Rewrites are applied to client-side routing, a<Link href=""/about"">will have the rewrite applied in the above example.rewritesis an async function that expects to return either an array or an object of arrays (see below) holding objects withsourceanddestinationproperties:source:String- is the incoming request path pattern.destination:Stringis the path you want to route to.basePath:falseorundefined- if false the basePath won't be included when matching, can be used for external rewrites only.locale:falseorundefined- whether the locale should not be included when matching.hasis an array ofhas objectswith thetype,keyandvalueproperties.missingis an array ofmissing objectswith thetype,keyandvalueproperties.When therewritesfunction returns an array, rewrites are applied after checking the filesystem (pages and/publicfiles) and before dynamic routes. When therewritesfunction returns an object of arrays with a specific shape, this behavior can be changed and more finely controlled, as ofv10.1of Next.js:next.config.jsmodule.exports={asyncrewrites() {return{beforeFiles:[// These rewrites are checked after headers/redirects// and before all files including _next/public files which// allows overriding page files{source:'/some-page',destination:'/somewhere-else',has:[{ type:'query',key:'overrideMe'}],},],afterFiles:[// These rewrites are checked after pages/public files// are checked but before dynamic routes{source:'/non-existent',destination:'/somewhere-else',},],fallback:[// These rewrites are checked after both pages/public files// and dynamic routes are checked{source:'/:path*',destination:`https://my-old-site.com/:path*`,},],}},}Good to know: rewrites inbeforeFilesdo not check the filesystem/dynamic routes immediately after matching a source, they continue until allbeforeFileshave been checked.The order Next.js routes are checked is:headersare checked/appliedredirectsare checked/appliedbeforeFilesrewrites are checked/appliedstatic files from thepublic directory,_next/staticfiles, and non-dynamic pages are checked/servedafterFilesrewrites are checked/applied, if one of these rewrites is matched we check dynamic routes/static files after each matchfallbackrewrites are checked/applied, these are applied before rendering the 404 page and after dynamic routes/all static assets have been checked. If you usefallback: true/'blocking'ingetStaticPaths, the fallbackrewritesdefined in yournext.config.jswillnotbe run.Rewrite parametersWhen using parameters in a rewrite the parameters will be passed in the query by default when none of the parameters are used in thedestination.next.config.jsmodule.exports={asyncrewrites() {return[{source:'/old-about/:path*',destination:'/about',// The :path parameter isn't used here so will be automatically passed in the query},]},}If a parameter is used in the destination none of the parameters will be automatically passed in the query.next.config.jsmodule.exports={asyncrewrites() {return[{source:'/docs/:path*',destination:'/:path*',// The :path parameter is used here so will not be automatically passed in the query},]},}You can still pass the parameters manually in the query if one is already used in the destination by specifying the query in thedestination.next.config.jsmodule.exports={asyncrewrites() {return[{source:'/:first/:second',destination:'/:first?second=:second',// Since the :first parameter is used in the destination the :second parameter// will not automatically be added in the query although we can manually add it// as shown above},]},}Good to know: Static pages fromAutomatic Static Optimizationorprerenderingparams from rewrites will be parsed on the client after hydration and provided in the query.Path MatchingPath matches are allowed, for example/blog/:slugwill match/blog/hello-world(no nested paths):next.config.jsmodule.exports={asyncrewrites() {return[{source:'/blog/:slug',destination:'/news/:slug',// Matched parameters can be used in the destination},]},}Wildcard Path MatchingTo match a wildcard path you can use*after a parameter, for example/blog/:slug*will match/blog/a/b/c/d/hello-world:next.config.jsmodule.exports={asyncrewrites() {return[{source:'/blog/:slug*',destination:'/news/:slug*',// Matched parameters can be used in the destination},]},}Regex Path MatchingTo match a regex path you can wrap the regex in parenthesis after a parameter, for example/blog/:slug(\\d{1,})will match/blog/123but not/blog/abc:next.config.jsmodule.exports={asyncrewrites() {return[{source:'/old-blog/:post(\\d{1,})',destination:'/blog/:post',// Matched parameters can be used in the destination},]},}The following characters(,),{,},[,],|,\,^,.,:,*,+,-,?,$are used for regex path matching, so when used in thesourceas non-special values they must be escaped by adding\\before them:next.config.jsmodule.exports={asyncrewrites() {return[{// this will match `/english(default)/something` being requestedsource:'/english\\(default\\)/:slug',destination:'/en-us/:slug',},]},}Header, Cookie, and Query MatchingTo only match a rewrite when header, cookie, or query values also match thehasfield or don't match themissingfield can be used. Both thesourceand allhasitems must match and allmissingitems must not match for the rewrite to be applied.hasandmissingitems can have the following fields:type:String- must be eitherheader,cookie,host, orquery.key:String- the key from the selected type to match against.value:Stringorundefined- the value to check for, if undefined any value will match. A regex like string can be used to capture a specific part of the value, e.g. if the valuefirst-(?<paramName>.*)is used forfirst-secondthensecondwill be usable in the destination with:paramName.next.config.jsmodule.exports={asyncrewrites() {return[// if the header `x-rewrite-me` is present,// this rewrite will be applied{source:'/:path*',has:[{type:'header',key:'x-rewrite-me',},],destination:'/another-page',},// if the header `x-rewrite-me` is not present,// this rewrite will be applied{source:'/:path*',missing:[{type:'header',key:'x-rewrite-me',},],destination:'/another-page',},// if the source, query, and cookie are matched,// this rewrite will be applied{source:'/specific/:path*',has:[{type:'query',key:'page',// the page value will not be available in the// destination since value is provided and doesn't// use a named capture group e.g. (?<page>home)value:'home',},{type:'cookie',key:'authorized',value:'true',},],destination:'/:path*/home',},// if the header `x-authorized` is present and// contains a matching value, this rewrite will be applied{source:'/:path*',has:[{type:'header',key:'x-authorized',value:'(?<authorized>yes|true)',},],destination:'/home?authorized=:authorized',},// if the host is `example.com`,// this rewrite will be applied{source:'/:path*',has:[{type:'host',value:'example.com',},],destination:'/another-page',},]},}Rewriting to an external URLExamplesIncremental adoption of Next.jsUsing Multiple ZonesRewrites allow you to rewrite to an external URL. This is especially useful for incrementally adopting Next.js. The following is an example rewrite for redirecting the/blogroute of your main app to an external site.next.config.jsmodule.exports={asyncrewrites() {return[{source:'/blog',destination:'https://example.com/blog',},{source:'/blog/:slug',destination:'https://example.com/blog/:slug',// Matched parameters can be used in the destination},]},}If you're usingtrailingSlash: true, you also need to insert a trailing slash in thesourceparameter. If the destination server is also expecting a trailing slash it should be included in thedestinationparameter as well.next.config.jsmodule.exports={trailingSlash:true,asyncrewrites() {return[{source:'/blog/',destination:'https://example.com/blog/',},{source:'/blog/:path*/',destination:'https://example.com/blog/:path*/',},]},}Incremental adoption of Next.jsYou can also have Next.js fall back to proxying to an existing website after checking all Next.js routes.This way you don't have to change the rewrites configuration when migrating more pages to Next.jsnext.config.jsmodule.exports={asyncrewrites() {return{fallback:[{source:'/:path*',destination:`https://custom-routes-proxying-endpoint.vercel.app/:path*`,},],}},}Rewrites with basePath supportWhen leveragingbasePathsupportwith rewrites eachsourceanddestinationis automatically prefixed with thebasePathunless you addbasePath: falseto the rewrite:next.config.jsmodule.exports={basePath:'/docs',asyncrewrites() {return[{source:'/with-basePath',// automatically becomes /docs/with-basePathdestination:'/another',// automatically becomes /docs/another},{// does not add /docs to /without-basePath since basePath: false is set// Note: this can not be used for internal rewrites e.g. `destination: '/another'`source:'/without-basePath',destination:'https://example.com',basePath:false,},]},}Rewrites with i18n supportWhen leveragingi18nsupportwith rewrites eachsourceanddestinationis automatically prefixed to handle the configuredlocalesunless you addlocale: falseto the rewrite. Iflocale: falseis used you must prefix thesourceanddestinationwith a locale for it to be matched correctly.next.config.jsmodule.exports={i18n:{locales:['en','fr','de'],defaultLocale:'en',},asyncrewrites() {return[{source:'/with-locale',// automatically handles all localesdestination:'/another',// automatically passes the locale on},{// does not handle locales automatically since locale: false is setsource:'/nl/with-locale-manual',destination:'/nl/another',locale:false,},{// this matches '/' since `en` is the defaultLocalesource:'/en',destination:'/en/another',locale:false,},{// it's possible to match all locales even when locale: false is setsource:'/:locale/api-alias/:path*',destination:'/api/:path*',locale:false,},{// this gets converted to /(en|fr|de)/(.*) so will not match the top-level// `/` or `/fr` routes like /:path* wouldsource:'/(.*)',destination:'/another',},]},}Version HistoryVersionChangesv13.3.0missingadded.v10.2.0hasadded.v9.5.0Headers added.PreviousredirectsNextRuntime ConfigWas this helpful?supported.Send"
runtime config,Runtime Config,"Configurationnext.config.js OptionsRuntime ConfigRuntime ConfigWarning:This feature is deprecated.We recommend usingenvironment variablesinstead, which also can support reading runtime values.You can run code on server startup using theregisterfunction.This feature does not work withAutomatic Static Optimization,Output File Tracing, orReact Server Components.To add runtime configuration to your app, opennext.config.jsand add thepublicRuntimeConfigandserverRuntimeConfigconfigs:next.config.jsmodule.exports={serverRuntimeConfig:{// Will only be available on the server sidemySecret:'secret',secondSecret:process.env.SECOND_SECRET,// Pass through env variables},publicRuntimeConfig:{// Will be available on both server and clientstaticFolder:'/static',},}Place any server-only runtime config underserverRuntimeConfig.Anything accessible to both client and server-side code should be underpublicRuntimeConfig.A page that relies onpublicRuntimeConfigmustusegetInitialPropsorgetServerSidePropsor your application must have aCustom AppwithgetInitialPropsto opt-out ofAutomatic Static Optimization. Runtime configuration won't be available to any page (or component in a page) without being server-side rendered.To get access to the runtime configs in your app usenext/config, like so:importgetConfigfrom'next/config'importImagefrom'next/image'// Only holds serverRuntimeConfig and publicRuntimeConfigconst{serverRuntimeConfig,publicRuntimeConfig}=getConfig()// Will only be available on the server-sideconsole.log(serverRuntimeConfig.mySecret)// Will be available on both server-side and client-sideconsole.log(publicRuntimeConfig.staticFolder)functionMyImage() {return(<div><Imagesrc={`${publicRuntimeConfig.staticFolder}/logo.png`}alt=""logo""layout=""fill""/></div>)}exportdefaultMyImagePreviousrewritesNextserverExternalPackagesWas this helpful?supported.Send"
serverexternalpackages,serverExternalPackages,"Configurationnext.config.js OptionsserverExternalPackagesserverExternalPackagesOpt-out specific dependencies from being included in the automatic bundling of thebundlePagesRouterDependenciesoption.These pages will then use native Node.jsrequireto resolve the dependency.next.config.js/**@type{import('next').NextConfig}*/constnextConfig={serverExternalPackages:['@acme/ui'],}module.exports=nextConfigNext.js includes ashort list of popular packagesthat currently are working on compatibility and automatically opt-ed out:@appsignal/nodejs@aws-sdk/client-s3@aws-sdk/s3-presigned-post@blockfrost/blockfrost-js@highlight-run/node@jpg-store/lucid-cardano@libsql/client@mikro-orm/core@mikro-orm/knex@node-rs/argon2@node-rs/bcrypt@prisma/client@react-pdf/renderer@sentry/profiling-node@sparticuz/chromium@swc/coreargon2autoprefixeraws-crtbcryptbetter-sqlite3canvascpu-featurescypressdd-traceeslintexpressfirebase-adminimport-in-the-middleisolated-vmjestjsdomkeyvlibsqlmdx-bundlermongodbmongoosenewrelicnext-mdx-remotenext-seonode-cronnode-ptynode-web-audio-apioslopgplaywrightplaywright-corepostcssprettierprismapuppeteer-corepuppeteerrequire-in-the-middlerimrafsharpshikisqlite3ts-nodets-morphtypescriptvscode-onigurumawebpackwebsocketzeromqPreviousRuntime ConfigNexttrailingSlashWas this helpful?supported.Send"
trailingslash,trailingSlash,"Configurationnext.config.js OptionstrailingSlashtrailingSlashBy default Next.js will redirect URLs with trailing slashes to their counterpart without a trailing slash. For example/about/will redirect to/about. You can configure this behavior to act the opposite way, where URLs without trailing slashes are redirected to their counterparts with trailing slashes.Opennext.config.jsand add thetrailingSlashconfig:next.config.jsmodule.exports={trailingSlash:true,}With this option set, URLs like/aboutwill redirect to/about/.When usingtrailingSlash: true, certain URLs are exceptions and will not have a trailing slash appended:Static file URLs, such as files with extensions.Any paths under.well-known/.For example, the following URLs will remain unchanged:/file.txt,images/photos/picture.png, and.well-known/subfolder/config.json.When used withoutput: ""export""configuration, the/aboutpage will output/about/index.html(instead of the default/about.html).Version HistoryVersionChangesv9.5.0trailingSlashadded.PreviousserverExternalPackagesNexttranspilePackagesWas this helpful?supported.Send"
transpilepackages,transpilePackages,"Configurationnext.config.js OptionstranspilePackagestranspilePackagesNext.js can automatically transpile and bundle dependencies from local packages (like monorepos) or from external dependencies (node_modules). This replaces thenext-transpile-modulespackage.next.config.js/**@type{import('next').NextConfig}*/constnextConfig={transpilePackages:['package-name'],}module.exports=nextConfigVersion HistoryVersionChangesv13.0.0transpilePackagesadded.PrevioustrailingSlashNextturboWas this helpful?supported.Send"
turbo,turbo,"Configurationnext.config.js OptionsturboturboThis feature is currently experimental and subject to change, it's not recommended for production. Try it out and share your feedback onGitHub.Theturbooption lets you customizeTurbopackto transform different files and change how modules are resolved.next.config.tsTypeScriptJavaScriptTypeScriptimporttype{ NextConfig }from'next'constnextConfig:NextConfig={experimental:{turbo:{// ...},},}exportdefaultnextConfigGood to know:Turbopack for Next.js does not require loaders nor loader configuration for built-in functionality. Turbopack has built-in support for CSS and compiling modern JavaScript, so there's no need forcss-loader,postcss-loader, orbabel-loaderif you're using@babel/preset-env.ReferenceOptionsThe following options are available for theturboconfiguration:OptionDescriptionrulesList of supported webpack loaders to apply when running with Turbopack.resolveAliasMap aliased imports to modules to load in their place.resolveExtensionsList of extensions to resolve when importing files.moduleIdStrategyAssign module IDstreeShakingEnable tree shaking for the turbopack dev server and build.memoryLimitA target memory limit for turbo, in bytes.Supported loadersThe following loaders have been tested to work with Turbopack's webpack loader implementation:babel-loader@svgr/webpacksvg-inline-loaderyaml-loaderstring-replace-loaderraw-loadersass-loaderExamplesConfiguring webpack loadersIf you need loader support beyond what's built in, many webpack loaders already work with Turbopack. There are currently some limitations:Only a core subset of the webpack loader API is implemented. Currently, there is enough coverage for some popular loaders, and we'll expand our API support in the future.Only loaders that return JavaScript code are supported. Loaders that transform files like stylesheets or images are not currently supported.Options passed to webpack loaders must be plain JavaScript primitives, objects, and arrays. For example, it's not possible to passrequire()plugin modules as option values.To configure loaders, add the names of the loaders you've installed and any options innext.config.js, mapping file extensions to a list of loaders:next.config.jsmodule.exports={experimental:{turbo:{rules:{'*.svg':{loaders:['@svgr/webpack'],as:'*.js',},},},},}Good to know: Prior to Next.js version 13.4.4,turbo.ruleswas namedturbo.loadersand only accepted file extensions like.mdxinstead of*.mdx.Resolving aliasesTurbopack can be configured to modify module resolution through aliases, similar to webpack'sresolve.aliasconfiguration.To configure resolve aliases, map imported patterns to their new destination innext.config.js:next.config.jsmodule.exports={experimental:{turbo:{resolveAlias:{underscore:'lodash',mocha:{ browser:'mocha/browser-entry.js'},},},},}This aliases imports of theunderscorepackage to thelodashpackage. In other words,import underscore from 'underscore'will load thelodashmodule instead ofunderscore.Turbopack also supports conditional aliasing through this field, similar to Node.js'conditional exports. At the moment only thebrowsercondition is supported. In the case above, imports of themochamodule will be aliased tomocha/browser-entry.jswhen Turbopack targets browser environments.Resolving custom extensionsTurbopack can be configured to resolve modules with custom extensions, similar to webpack'sresolve.extensionsconfiguration.To configure resolve extensions, use theresolveExtensionsfield innext.config.js:next.config.jsmodule.exports={experimental:{turbo:{resolveExtensions:['.mdx','.tsx','.ts','.jsx','.js','.mjs','.json',],},},}This overwrites the original resolve extensions with the provided list. Make sure to include the default extensions.For more information and guidance for how to migrate your app to Turbopack from webpack, seeTurbopack's documentation on webpack compatibility.Assigning module IDsTurbopack currently supports two strategies for assigning module IDs:'named'assigns readable module IDs based on the module's path and functionality.'deterministic'assigns small hashed numeric module IDs, which are mostly consistent between builds and therefore help with long-term caching.If not set, Turbopack will use'named'for development builds and'deterministic'for production builds.To configure the module IDs strategy, use themoduleIdStrategyfield innext.config.js:next.config.jsmodule.exports={experimental:{turbo:{moduleIdStrategy:'deterministic',},},}Version HistoryVersionChanges13.0.0experimental.turbointroduced.PrevioustranspilePackagesNexttypescriptWas this helpful?supported.Send"
typescript,typescript,"Configurationnext.config.js OptionstypescripttypescriptNext.js fails yourproduction build(next build) when TypeScript errors are present in your project.If you'd like Next.js to dangerously produce production code even when your application has errors, you can disable the built-in type checking step.If disabled, be sure you are running type checks as part of your build or deploy process, otherwise this can be very dangerous.Opennext.config.jsand enable theignoreBuildErrorsoption in thetypescriptconfig:next.config.jsmodule.exports={typescript:{// !! WARN !!// Dangerously allow production builds to successfully complete even if// your project has type errors.// !! WARN !!ignoreBuildErrors:true,},}PreviousturboNexturlImportsWas this helpful?supported.Send"
urlimports,urlImports,"Configurationnext.config.js OptionsurlImportsurlImportsThis feature is currently experimental and subject to change, it's not recommended for production. Try it out and share your feedback onGitHub.URL imports are an experimental feature that allows you to import modules directly from external servers (instead of from the local disk).Warning: Only use domains that you trust to download and execute on your machine. Please exercise discretion, and caution until the feature is flagged as stable.To opt-in, add the allowed URL prefixes insidenext.config.js:next.config.jsmodule.exports={experimental:{urlImports:['https://example.com/assets/','https://cdn.skypack.dev'],},}Then, you can import modules directly from URLs:import{ a,b,c }from'https://example.com/assets/some/module.js'URL Imports can be used everywhere normal package imports can be used.Security ModelThis feature is being designed withsecurity as the top priority. To start, we added an experimental flag forcing you to explicitly allow the domains you accept URL imports from. We're working to take this further by limiting URL imports to execute in the browser sandbox using theEdge Runtime.LockfileWhen using URL imports, Next.js will create anext.lockdirectory containing a lockfile and fetched assets.
This directorymust be committed to Git, not ignored by.gitignore.When runningnext dev, Next.js will download and add all newly discovered URL Imports to your lockfile.When runningnext build, Next.js will use only the lockfile to build the application for production.Typically, no network requests are needed and any outdated lockfile will cause the build to fail.
One exception is resources that respond withCache-Control: no-cache.
These resources will have ano-cacheentry in the lockfile and will always be fetched from the network on each build.ExamplesSkypackimportconfettifrom'https://cdn.skypack.dev/canvas-confetti'import{ useEffect }from'react'exportdefault()=>{useEffect(()=>{confetti()})return<p>Hello</p>}Static Image ImportsimportImagefrom'next/image'importlogofrom'https://example.com/assets/logo.png'exportdefault()=>(<div><Imagesrc={logo}placeholder=""blur""/></div>)URLs in CSS.className{background:url('https://example.com/assets/hero.jpg');}Asset Importsconstlogo=newURL('https://example.com/assets/file.txt',import.meta.url)console.log(logo.pathname)// prints ""/_next/static/media/file.a9727b5d.txt""PrevioustypescriptNextuseLightningcssWas this helpful?supported.Send"
uselightningcss,useLightningcss,"Configurationnext.config.js OptionsuseLightningcssuseLightningcssThis feature is currently experimental and subject to change, it's not recommended for production. Try it out and share your feedback onGitHub.Experimental support for usingLightning CSS, a fast CSS bundler and minifier, written in Rust.next.config.tsTypeScriptJavaScriptTypeScriptimporttype{ NextConfig }from'next'constnextConfig:NextConfig={experimental:{useLightningcss:true,},}exportdefaultnextConfigPreviousurlImportsNextwebpackWas this helpful?supported.Send"
webpack,webpack,"Configurationnext.config.js OptionswebpackCustom Webpack ConfigGood to know: changes to webpack config are not covered by semver so proceed at your own riskBefore continuing to add custom webpack configuration to your application make sure Next.js doesn't already support your use-case:CSS importsCSS modulesSass/SCSS importsSass/SCSS modulesCustomizing babel configurationSome commonly asked for features are available as plugins:@next/mdx@next/bundle-analyzerIn order to extend our usage ofwebpack, you can define a function that extends its config insidenext.config.js, like so:next.config.jsmodule.exports={webpack:(config,{ buildId,dev,isServer,defaultLoaders,nextRuntime,webpack })=>{// Important: return the modified configreturnconfig},}Thewebpackfunction is executed three times, twice for the server (nodejs / edge runtime) and once for the client. This allows you to distinguish between client and server configuration using theisServerproperty.The second argument to thewebpackfunction is an object with the following properties:buildId:String- The build id, used as a unique identifier between builds.dev:Boolean- Indicates if the compilation will be done in development.isServer:Boolean- It'struefor server-side compilation, andfalsefor client-side compilation.nextRuntime:String | undefined- The target runtime for server-side compilation; either""edge""or""nodejs"", it'sundefinedfor client-side compilation.defaultLoaders:Object- Default loaders used internally by Next.js:babel:Object- Defaultbabel-loaderconfiguration.Example usage ofdefaultLoaders.babel:// Example config for adding a loader that depends on babel-loader// This source was taken from the @next/mdx plugin source:// https://github.com/vercel/next.js/tree/canary/packages/next-mdxmodule.exports={webpack:(config,options)=>{config.module.rules.push({test:/\.mdx/,use:[options.defaultLoaders.babel,{loader:'@mdx-js/loader',options:pluginOptions.options,},],})returnconfig},}nextRuntimeNotice thatisServeristruewhennextRuntimeis""edge""or""nodejs"",nextRuntime""edge""is currently for middleware and Server Components in edge runtime only.PrevioususeLightningcssNextwebVitalsAttributionWas this helpful?supported.Send"
webvitalsattribution,webVitalsAttribution,"Configurationnext.config.js OptionswebVitalsAttributionwebVitalsAttributionWhen debugging issues related to Web Vitals, it is often helpful if we can pinpoint the source of the problem.
For example, in the case of Cumulative Layout Shift (CLS), we might want to know the first element that shifted when the single largest layout shift occurred.
Or, in the case of Largest Contentful Paint (LCP), we might want to identify the element corresponding to the LCP for the page.
If the LCP element is an image, knowing the URL of the image resource can help us locate the asset we need to optimize.Pinpointing the biggest contributor to the Web Vitals score, akaattribution,
allows us to obtain more in-depth information like entries forPerformanceEventTiming,PerformanceNavigationTimingandPerformanceResourceTiming.Attribution is disabled by default in Next.js but can be enabledper metricby specifying the following innext.config.js.next.config.jsmodule.exports={experimental:{webVitalsAttribution:['CLS','LCP'],},}Valid attribution values are allweb-vitalsmetrics specified in theNextWebVitalsMetrictype.PreviouswebpackNextTypeScriptWas this helpful?supported.Send"
typescript,TypeScript,"API ReferenceConfigurationTypeScriptTypeScriptNext.js comes with built-in TypeScript, automatically installing the necessary packages and configuring the proper settings when you create a new project withcreate-next-app.To add TypeScript to an existing project, rename a file to.ts/.tsx. Runnext devandnext buildto automatically install the necessary dependencies and add atsconfig.jsonfile with the recommended config options.Good to know: If you already have ajsconfig.jsonfile, copy thepathscompiler option from the oldjsconfig.jsoninto the newtsconfig.jsonfile, and delete the oldjsconfig.jsonfile.ExamplesType checkingnext.config.tsYou can use TypeScript and import types in your Next.js configuration by usingnext.config.ts.next.config.tsimporttype{ NextConfig }from'next'constnextConfig:NextConfig={/* config options here */}exportdefaultnextConfigGood to know: Module resolution innext.config.tsis currently limited toCommonJS. This may cause incompatibilities with ESM only packages being loaded innext.config.ts.When using thenext.config.jsfile, you can add some type checking in your IDE using JSDoc as below:next.config.js// @ts-check/**@type{import('next').NextConfig}*/constnextConfig={/* config options here */}module.exports=nextConfigStatic Generation and Server-side RenderingForgetStaticProps,getStaticPaths, andgetServerSideProps, you can use theGetStaticProps,GetStaticPaths, andGetServerSidePropstypes respectively:pages/blog/[slug].tsximporttype{ GetStaticProps,GetStaticPaths,GetServerSideProps }from'next'exportconstgetStaticProps=(async(context)=>{// ...})satisfiesGetStaticPropsexportconstgetStaticPaths=(async()=>{// ...})satisfiesGetStaticPathsexportconstgetServerSideProps=(async(context)=>{// ...})satisfiesGetServerSidePropsGood to know:satisfieswas added to TypeScript in4.9. We recommend upgrading to the latest version of TypeScript.With API RoutesThe following is an example of how to use the built-in types for API routes:pages/api/hello.tsimporttype{ NextApiRequest,NextApiResponse }from'next'exportdefaultfunctionhandler(req:NextApiRequest,res:NextApiResponse) {res.status(200).json({ name:'John Doe'})}You can also type the response data:pages/api/hello.tsimporttype{ NextApiRequest,NextApiResponse }from'next'typeData={name:string}exportdefaultfunctionhandler(req:NextApiRequest,res:NextApiResponse<Data>) {res.status(200).json({ name:'John Doe'})}With customAppIf you have acustomApp, you can use the built-in typeAppPropsand change file name to./pages/_app.tsxlike so:importtype{ AppProps }from'next/app'exportdefaultfunctionMyApp({ Component,pageProps }:AppProps) {return<Component{...pageProps} />}Incremental type checkingSincev10.2.1Next.js supportsincremental type checkingwhen enabled in yourtsconfig.json, this can help speed up type checking in larger applications.Disabling TypeScript errors in productionNext.js fails yourproduction build(next build) when TypeScript errors are present in your project.If you'd like Next.js to dangerously produce production code even when your application has errors, you can disable the built-in type checking step.If disabled, be sure you are running type checks as part of your build or deploy process, otherwise this can be very dangerous.Opennext.config.tsand enable theignoreBuildErrorsoption in thetypescriptconfig:next.config.tsimporttype{ NextConfig }from'next'constnextConfig:NextConfig={typescript:{// !! WARN !!// Dangerously allow production builds to successfully complete even if// your project has type errors.// !! WARN !!ignoreBuildErrors:true,},}exportdefaultnextConfigGood to know: You can runtsc --noEmitto check for TypeScript errors yourself before building. This is useful for CI/CD pipelines where you'd like to check for TypeScript errors before deploying.Custom type declarationsWhen you need to declare custom types, you might be tempted to modifynext-env.d.ts. However, this file is automatically generated, so any changes you make will be overwritten. Instead, you should create a new file, let's call itnew-types.d.ts, and reference it in yourtsconfig.json:tsconfig.json{""compilerOptions"":{""skipLibCheck"":true//...truncated...},""include"":[""new-types.d.ts"",""next-env.d.ts"","".next/types/**/*.ts"",""**/*.ts"",""**/*.tsx""],""exclude"":[""node_modules""]}Version ChangesVersionChangesv15.0.0next.config.tssupport added for TypeScript projects.v13.2.0Statically typed links are available in beta.v12.0.0SWCis now used by default to compile TypeScript and TSX for faster builds.v10.2.1Incremental type checkingsupport added when enabled in yourtsconfig.json.PreviouswebVitalsAttributionNextESLintWas this helpful?supported.Send"
eslint,ESLint,"API ReferenceConfigurationESLintESLintNext.js provides an ESLint plugin,eslint-plugin-next, already bundled within the base configuration that makes it possible to catch common issues and problems in a Next.js application.ReferenceRecommended rule-sets from the following ESLint plugins are all used withineslint-config-next:eslint-plugin-reacteslint-plugin-react-hookseslint-plugin-nextThis will take precedence over the configuration fromnext.config.js.RulesThe full set of rules is as follows:Enabled in recommended configRuleDescription@next/next/google-font-displayEnforce font-display behavior with Google Fonts.@next/next/google-font-preconnectEnsurepreconnectis used with Google Fonts.@next/next/inline-script-idEnforceidattribute onnext/scriptcomponents with inline content.@next/next/next-script-for-gaPrefernext/scriptcomponent when using the inline script for Google Analytics.@next/next/no-assign-module-variablePrevent assignment to themodulevariable.@next/next/no-async-client-componentPrevent client components from being async functions.@next/next/no-before-interactive-script-outside-documentPrevent usage ofnext/script'sbeforeInteractivestrategy outside ofpages/_document.js.@next/next/no-css-tagsPrevent manual stylesheet tags.@next/next/no-document-import-in-pagePrevent importingnext/documentoutside ofpages/_document.js.@next/next/no-duplicate-headPrevent duplicate usage of<Head>inpages/_document.js.@next/next/no-head-elementPrevent usage of<head>element.@next/next/no-head-import-in-documentPrevent usage ofnext/headinpages/_document.js.@next/next/no-html-link-for-pagesPrevent usage of<a>elements to navigate to internal Next.js pages.@next/next/no-img-elementPrevent usage of<img>element due to slower LCP and higher bandwidth.@next/next/no-page-custom-fontPrevent page-only custom fonts.@next/next/no-script-component-in-headPrevent usage ofnext/scriptinnext/headcomponent.@next/next/no-styled-jsx-in-documentPrevent usage ofstyled-jsxinpages/_document.js.@next/next/no-sync-scriptsPrevent synchronous scripts.@next/next/no-title-in-document-headPrevent usage of<title>withHeadcomponent fromnext/document.@next/next/no-typosPrevent common typos inNext.js's data fetching functions@next/next/no-unwanted-polyfillioPrevent duplicate polyfills from Polyfill.io.We recommend using an appropriateintegrationto view warnings and errors directly in your code editor during development.ExamplesLinting custom directories and filesBy default, Next.js will run ESLint for all files in thepages/,app/,components/,lib/, andsrc/directories. However, you can specify which directories using thedirsoption in theeslintconfig innext.config.jsfor production builds:next.config.jsmodule.exports={eslint:{dirs:['pages','utils'],// Only run ESLint on the 'pages' and 'utils' directories during production builds (next build)},}Similarly, the--dirand--fileflags can be used fornext lintto lint specific directories and files:Terminalnextlint--dirpages--dirutils--filebar.jsSpecifying a root directory within a monorepoIf you're usingeslint-plugin-nextin a project where Next.js isn't installed in your root directory (such as a monorepo), you can telleslint-plugin-nextwhere to find your Next.js application using thesettingsproperty in your.eslintrc:eslint.config.mjsimport { FlatCompat } from '@eslint/eslintrc'const compat = new FlatCompat({// import.meta.dirname is available after Node.js v20.11.0baseDirectory: import.meta.dirname,})const eslintConfig = [...compat.config({extends: ['next'],settings: {next: {rootDir: 'packages/my-app/',},},}),]export default eslintConfigrootDircan be a path (relative or absolute), a glob (i.e.""packages/*/""), or an array of paths and/or globs.Disabling the cacheTo improve performance, information of files processed by ESLint are cached by default. This is stored in.next/cacheor in your definedbuild directory. If you include any ESLint rules that depend on more than the contents of a single source file and need to disable the cache, use the--no-cacheflag withnext lint.Terminalnextlint--no-cacheDisabling rulesIf you would like to modify or disable any rules provided by the supported plugins (react,react-hooks,next), you can directly change them using therulesproperty in your.eslintrc:eslint.config.mjsimport { FlatCompat } from '@eslint/eslintrc'const compat = new FlatCompat({// import.meta.dirname is available after Node.js v20.11.0baseDirectory: import.meta.dirname,})const eslintConfig = [...compat.config({extends: ['next'],rules: {'react/no-unescaped-entities': 'off','@next/next/no-page-custom-font': 'off',},}),]export default eslintConfigWith Core Web VitalsThenext/core-web-vitalsrule set is enabled whennext lintis run for the first time and thestrictoption is selected.eslint.config.mjsimport { FlatCompat } from '@eslint/eslintrc'const compat = new FlatCompat({// import.meta.dirname is available after Node.js v20.11.0baseDirectory: import.meta.dirname,})const eslintConfig = [...compat.config({extends: ['next/core-web-vitals'],}),]export default eslintConfignext/core-web-vitalsupdateseslint-plugin-nextto error on a number of rules that are warnings by default if they affectCore Web Vitals.Thenext/core-web-vitalsentry point is automatically included for new applications built withCreate Next App.With TypeScriptIn addition to the Next.js ESLint rules,create-next-app --typescriptwill also add TypeScript-specific lint rules withnext/typescriptto your config:eslint.config.mjsimport { FlatCompat } from '@eslint/eslintrc'const compat = new FlatCompat({// import.meta.dirname is available after Node.js v20.11.0baseDirectory: import.meta.dirname,})const eslintConfig = [...compat.config({extends: ['next/core-web-vitals', 'next/typescript'],}),]export default eslintConfigThose rules are based onplugin:@typescript-eslint/recommended.
Seetypescript-eslint > Configsfor more details.With PrettierESLint also contains code formatting rules, which can conflict with your existingPrettiersetup. We recommend includingeslint-config-prettierin your ESLint config to make ESLint and Prettier work together.First, install the dependency:Terminalnpminstall--save-deveslint-config-prettieryarnadd--deveslint-config-prettierpnpmadd--save-deveslint-config-prettierbunadd--deveslint-config-prettierThen, addprettierto your existing ESLint config:eslint.config.mjsimport { FlatCompat } from '@eslint/eslintrc'const compat = new FlatCompat({// import.meta.dirname is available after Node.js v20.11.0baseDirectory: import.meta.dirname,})const eslintConfig = [...compat.config({extends: ['next', 'prettier'],}),]export default eslintConfigRunning lint on staged filesIf you would like to usenext lintwithlint-stagedto run the linter on staged git files, you'll have to add the following to the.lintstagedrc.jsfile in the root of your project in order to specify usage of the--fileflag..lintstagedrc.jsconstpath=require('path')constbuildEslintCommand=(filenames)=>`next lint --fix --file${filenames.map((f)=>path.relative(process.cwd(),f)).join(' --file ')}`module.exports={'*.{js,jsx,ts,tsx}':[buildEslintCommand],}Disabling linting during production buildsIf you do not want ESLint to run duringnext build, you can set theeslint.ignoreDuringBuildsoption innext.config.jstotrue:next.config.tsTypeScriptJavaScriptTypeScriptimporttype{ NextConfig }from'next'constnextConfig:NextConfig={eslint:{// Warning: This allows production builds to successfully complete even if// your project has ESLint errors.ignoreDuringBuilds:true,},}exportdefaultnextConfigMigrating existing configIf you already have ESLint configured in your application, we recommend extending from this plugin directly instead of includingeslint-config-nextunless a few conditions are met.Recommended plugin rulesetIf the following conditions are true:You have one or more of the following plugins already installed (either separately or through a different config such asairbnborreact-app):reactreact-hooksjsx-a11yimportYou've defined specificparserOptionsthat are different from how Babel is configured within Next.js (this is not recommended unless you havecustomized your Babel configuration)You haveeslint-plugin-importinstalled with Node.js and/or TypeScriptresolversdefined to handle importsThen we recommend either removing these settings if you prefer how these properties have been configured withineslint-config-nextor extending directly from the Next.js ESLint plugin instead:module.exports={extends:[//...'plugin:@next/next/recommended',],}The plugin can be installed normally in your project without needing to runnext lint:Terminalnpminstall--save-dev@next/eslint-plugin-nextyarnadd--dev@next/eslint-plugin-nextpnpmadd--save-dev@next/eslint-plugin-nextbunadd--dev@next/eslint-plugin-nextThis eliminates the risk of collisions or errors that can occur due to importing the same plugin or parser across multiple configurations.Additional configurationsIf you already use a separate ESLint configuration and want to includeeslint-config-next, ensure that it is extended last after other configurations. For example:eslint.config.mjsimport js from '@eslint/js'import { FlatCompat } from '@eslint/eslintrc'const compat = new FlatCompat({// import.meta.dirname is available after Node.js v20.11.0baseDirectory: import.meta.dirname,recommendedConfig: js.configs.recommended,})const eslintConfig = [...compat.config({extends: ['eslint:recommended', 'next'],}),]export default eslintConfigThenextconfiguration already handles setting default values for theparser,pluginsandsettingsproperties. There is no need to manually re-declare any of these properties unless you need a different configuration for your use case.If you include any other shareable configurations,you will need to make sure that these properties are not overwritten or modified. Otherwise, we recommend removing any configurations that share behavior with thenextconfiguration or extending directly from the Next.js ESLint plugin as mentioned above.PreviousTypeScriptNextCLIWas this helpful?supported.Send"
cli,CLI,"Pages RouterAPI ReferenceCLICLINext.js comes withtwoCommand Line Interface (CLI) tools:create-next-app: Quickly create a new Next.js application using the default template or anexamplefrom a public GitHub repository.next: Run the Next.js development server, build your application, and more.CLICreate Next.js apps using one command with the create-next-app CLI.next CLILearn how to run and build your application with the Next.js CLI.PreviousESLintNextCLIWas this helpful?supported.Send"
cli,CLI,"API ReferenceCLICLICLIThecreate-next-appCLI allow you to create a new Next.js application using the default template or anexamplefrom a public GitHub repository. It is the easiest way to get started with Next.js.Basic usage:Terminalnpxcreate-next-app@latest[project-name] [options]ReferenceThe following options are available:OptionsDescription-hor--helpShow all available options-vor--versionOutput the version number--no-*Negate default options. E.g.--no-eslint--tsor--typescriptInitialize as a TypeScript project (default)--jsor--javascriptInitialize as a JavaScript project--tailwindInitialize with Tailwind CSS config (default)--eslintInitialize with ESLint config--appInitialize as an App Router project--apiInitialize a project with only route handlers--src-dirInitialize inside asrc/directory--turbopackEnable Turbopack by default for development--import-alias <alias-to-configure>Specify import alias to use (default ""@/*"")--emptyInitialize an empty project--use-npmExplicitly tell the CLI to bootstrap the application using npm--use-pnpmExplicitly tell the CLI to bootstrap the application using pnpm--use-yarnExplicitly tell the CLI to bootstrap the application using Yarn--use-bunExplicitly tell the CLI to bootstrap the application using Bun-eor--example [name] [github-url]An example to bootstrap the app with--example-path <path-to-example>Specify the path to the example separately--reset-preferencesExplicitly tell the CLI to reset any stored preferences--skip-installExplicitly tell the CLI to skip installing packages--yesUse previous preferences or defaults for all optionsExamplesWith the default templateTo create a new app using the default template, run the following command in your terminal:Terminalnpxcreate-next-app@latestYou will then be asked the following prompts:TerminalWhat is your project named?  my-appWould you like to use TypeScript?  No / YesWould you like to use ESLint?  No / YesWould you like to use Tailwind CSS?  No / YesWould you like your code inside a `src/` directory?  No / YesWould you like to use App Router? (recommended)  No / YesWould you like to use Turbopack for `next dev`?  No / YesWould you like to customize the import alias (`@/*` by default)?  No / YesOnce you've answered the prompts, a new project will be created with your chosen configuration.With an official Next.js exampleTo create a new app using an official Next.js example, use the--exampleflag. For example:Terminalnpxcreate-next-app@latest--example[example-name] [your-project-name]You can view a list of all available examples along with setup instructions in theNext.js repository.With any public GitHub exampleTo create a new app using any public GitHub example, use the--exampleoption with the GitHub repo's URL. For example:Terminalnpxcreate-next-app@latest--example""https://github.com/.../""[your-project-name]PreviousCLINextnext CLIWas this helpful?supported.Send"
next cli,next CLI,"API ReferenceCLInext CLInext CLIThe Next.js CLI allows you to develop, build, start your application, and more.Basic usage:Terminalnpxnext[command] [options]ReferenceThe following options are available:OptionsDescription-hor--helpShows all available options-vor--versionOutputs the Next.js version numberCommandsThe following commands are available:CommandDescriptiondevStarts Next.js in development mode with Hot Module Reloading, error reporting, and more.buildCreates an optimized production build of your application. Displaying information about each route.startStarts Next.js in production mode. The application should be compiled withnext buildfirst.infoPrints relevant details about the current system which can be used to report Next.js bugs.lintRuns ESLint for all files in the/src,/app,/pages,/components, and/libdirectories. It also provides a guided setup to install any required dependencies if ESLint it is not already configured in your application.telemetryAllows you to enable or disable Next.js' completely anonymous telemetry collection.Good to know: Runningnextwithout a command is an alias fornext dev.next devoptionsnext devstarts the application in development mode with Hot Module Reloading (HMR), error reporting, and more. The following options are available when runningnext dev:OptionDescription-h, --helpShow all available options.[directory]A directory in which to build the application. If not provided, current directory is used.--turbopackStarts development mode usingTurbopack.-por--port <port>Specify a port number on which to start the application. Default: 3000, env: PORT-Hor--hostname <hostname>Specify a hostname on which to start the application. Useful for making the application available for other devices on the network. Default: 0.0.0.0--experimental-httpsStarts the server with HTTPS and generates a self-signed certificate.--experimental-https-key <path>Path to a HTTPS key file.--experimental-https-cert <path>Path to a HTTPS certificate file.--experimental-https-ca <path>Path to a HTTPS certificate authority file.--experimental-upload-trace <traceUrl>Reports a subset of the debugging trace to a remote HTTP URL.next buildoptionsnext buildcreates an optimized production build of your application. The output displays information about each route. For example:TerminalRoute(app)                              Size     First Load JS┌○/_not-found0B0kB└ƒ/products/[id]0B0kB○(Static)   prerendered as static contentƒ(Dynamic)  server-rendered on demandSize: The size of assets downloaded when navigating to the page client-side. The size for each route only includes its dependencies.First Load JS: The size of assets downloaded when visiting the page from the server. The amount of JS shared by all is shown as a separate metric.Both of these values arecompressed with gzip. The first load is indicated by green, yellow, or red. Aim for green for performant applications.The following options are available for thenext buildcommand:OptionDescription-h, --helpShow all available options.[directory]A directory on which to build the application. If not provided, the current directory will be used.-dor--debugEnables a more verbose build output. With this flag enabled additional build output like rewrites, redirects, and headers will be shown.--profileEnables productionprofiling for React.--no-lintDisables linting.--no-manglingDisablesmangling. This may affect performance and should only be used for debugging purposes.--experimental-app-onlyBuilds only App Router routes.--experimental-build-mode [mode]Uses an experimental build mode. (choices: ""compile"", ""generate"", default: ""default"")next startoptionsnext startstarts the application in production mode. The application should be compiled withnext buildfirst.The following options are available for thenext startcommand:OptionDescription-hor--helpShow all available options.[directory]A directory on which to start the application. If no directory is provided, the current directory will be used.-por--port <port>Specify a port number on which to start the application. (default: 3000, env: PORT)-Hor--hostname <hostname>Specify a hostname on which to start the application (default: 0.0.0.0).--keepAliveTimeout <keepAliveTimeout>Specify the maximum amount of milliseconds to wait before closing the inactive connections.next infooptionsnext infoprints relevant details about the current system which can be used to report Next.js bugs when opening aGitHub issue. This information includes Operating System platform/arch/version, Binaries (Node.js, npm, Yarn, pnpm), package versions (next,react,react-dom), and more.The output should look like this:TerminalOperatingSystem:Platform:darwinArch:arm64Version:DarwinKernelVersion23.6.0Availablememory(MB): 65536AvailableCPUcores:10Binaries:Node:20.12.0npm:10.5.0Yarn:1.22.19pnpm:9.6.0RelevantPackages:next:15.0.0-canary.115//Latestavailableversionisdetected(15.0.0-canary.115).eslint-config-next:14.2.5react:19.0.0-rcreact-dom:19.0.0typescript:5.5.4Next.jsConfig:output:N/AThe following options are available for thenext infocommand:OptionDescription-hor--helpShow all available options--verboseCollects additional information for debugging.next lintoptionsnext lintruns ESLint for all files in thepages/,app/,components/,lib/, andsrc/directories. It also provides a guided setup to install any required dependencies if ESLint is not already configured in your application.The following options are available for thenext lintcommand:OptionDescription[directory]A base directory on which to lint the application. If not provided, the current directory will be used.-d, --dir, <dirs...>Include directory, or directories, to run ESLint.--file, <files...>Include file, or files, to run ESLint.--ext, [exts...]Specify JavaScript file extensions. (default: ["".js"", "".mjs"", "".cjs"", "".jsx"", "".ts"", "".mts"", "".cts"", "".tsx""])-c, --config, <config>Uses this configuration file, overriding all other configuration options.--resolve-plugins-relative-to, <rprt>Specify a directory where plugins should be resolved from.--strictCreates a.eslintrc.jsonfile using the Next.js strict configuration.--rulesdir, <rulesdir...>Uses additional rules from this directory(s).--fixAutomatically fix linting issues.--fix-type <fixType>Specify the types of fixes to apply (e.g., problem, suggestion, layout).--ignore-path <path>Specify a file to ignore.--no-ignore <path>Disables the--ignore-pathoption.--quietReports errors only.--max-warnings [maxWarnings]Specify the number of warnings before triggering a non-zero exit code. (default: -1)-o, --output-file, <outputFile>Specify a file to write report to.-f, --format, <format>Uses a specific output format.--no-inline-configPrevents comments from changing config or rules.--report-unused-disable-directives-severity <level>Specify severity level for unused eslint-disable directives. (choices: ""error"", ""off"", ""warn"")--no-cacheDisables caching.--cache-location, <cacheLocation>Specify a location for cache.--cache-strategy, [cacheStrategy]Specify a strategy to use for detecting changed files in the cache. (default: ""metadata"")--error-on-unmatched-patternReports errors when any file patterns are unmatched.-h, --helpDisplays this message.next telemetryoptionsNext.js collectscompletely anonymoustelemetry data about general usage. Participation in this anonymous program is optional, and you can opt-out if you prefer not to share information.The following options are available for thenext telemetrycommand:OptionDescription-h, --helpShow all available options.--enableEnables Next.js' telemetry collection.--disableDisables Next.js' telemetry collection.Learn more aboutTelemetry.ExamplesChanging the default portBy default, Next.js useshttp://localhost:3000during development and withnext start. The default port can be changed with the-poption, like so:Terminalnextdev-p4000Or using thePORTenvironment variable:TerminalPORT=4000nextdevGood to know:PORTcannot be set in.envas booting up the HTTP server happens before any other code is initialized.Using HTTPS during developmentFor certain use cases like webhooks or authentication, you can useHTTPSto have a secure environment onlocalhost. Next.js can generate a self-signed certificate withnext devusing the--experimental-httpsflag:Terminalnextdev--experimental-httpsWith the generated certificate, the Next.js development server will exist athttps://localhost:3000. The default port3000is used unless a port is specified with-p,--port, orPORT.You can also provide a custom certificate and key with--experimental-https-keyand--experimental-https-cert. Optionally, you can provide a custom CA certificate with--experimental-https-caas well.Terminalnextdev--experimental-https--experimental-https-key./certificates/localhost-key.pem--experimental-https-cert./certificates/localhost.pemnext dev --experimental-httpsis only intended for development and creates a locally trusted certificate withmkcert. In production, use properly issued certificates from trusted authorities.Good to know: When deploying to Vercel, HTTPS isautomatically configuredfor your Next.js application.Configuring a timeout for downstream proxiesWhen deploying Next.js behind a downstream proxy (e.g. a load-balancer like AWS ELB/ALB), it's important to configure Next's underlying HTTP server withkeep-alive timeoutsthat arelargerthan the downstream proxy's timeouts. Otherwise, once a keep-alive timeout is reached for a given TCP connection, Node.js will immediately terminate that connection without notifying the downstream proxy. This results in a proxy error whenever it attempts to reuse a connection that Node.js has already terminated.To configure the timeout values for the production Next.js server, pass--keepAliveTimeout(in milliseconds) tonext start, like so:Terminalnextstart--keepAliveTimeout70000Passing Node.js argumentsYou can pass anynode argumentstonextcommands. For example:TerminalNODE_OPTIONS='--throw-deprecation'nextNODE_OPTIONS='-r esm'nextNODE_OPTIONS='--inspect'nextPreviousCLINextEdge RuntimeWas this helpful?supported.Send"
edge runtime,Edge Runtime,"Pages RouterAPI ReferenceEdge RuntimeEdge RuntimeThe Next.js Edge Runtime is used for Middleware and supports the following APIs:Network APIsAPIDescriptionBlobRepresents a blobfetchFetches a resourceFetchEventRepresents a fetch eventFileRepresents a fileFormDataRepresents form dataHeadersRepresents HTTP headersRequestRepresents an HTTP requestResponseRepresents an HTTP responseURLSearchParamsRepresents URL search parametersWebSocketRepresents a websocket connectionEncoding APIsAPIDescriptionatobDecodes a base-64 encoded stringbtoaEncodes a string in base-64TextDecoderDecodes a Uint8Array into a stringTextDecoderStreamChainable decoder for streamsTextEncoderEncodes a string into a Uint8ArrayTextEncoderStreamChainable encoder for streamsStream APIsAPIDescriptionReadableStreamRepresents a readable streamReadableStreamBYOBReaderRepresents a reader of a ReadableStreamReadableStreamDefaultReaderRepresents a reader of a ReadableStreamTransformStreamRepresents a transform streamWritableStreamRepresents a writable streamWritableStreamDefaultWriterRepresents a writer of a WritableStreamCrypto APIsAPIDescriptioncryptoProvides access to the cryptographic functionality of the platformCryptoKeyRepresents a cryptographic keySubtleCryptoProvides access to common cryptographic primitives, like hashing, signing, encryption or decryptionWeb Standard APIsAPIDescriptionAbortControllerAllows you to abort one or more DOM requests as and when desiredArrayRepresents an array of valuesArrayBufferRepresents a generic, fixed-length raw binary data bufferAtomicsProvides atomic operations as static methodsBigIntRepresents a whole number with arbitrary precisionBigInt64ArrayRepresents a typed array of 64-bit signed integersBigUint64ArrayRepresents a typed array of 64-bit unsigned integersBooleanRepresents a logical entity and can have two values:trueandfalseclearIntervalCancels a timed, repeating action which was previously established by a call tosetInterval()clearTimeoutCancels a timed, repeating action which was previously established by a call tosetTimeout()consoleProvides access to the browser's debugging consoleDataViewRepresents a generic view of anArrayBufferDateRepresents a single moment in time in a platform-independent formatdecodeURIDecodes a Uniform Resource Identifier (URI) previously created byencodeURIor by a similar routinedecodeURIComponentDecodes a Uniform Resource Identifier (URI) component previously created byencodeURIComponentor by a similar routineDOMExceptionRepresents an error that occurs in the DOMencodeURIEncodes a Uniform Resource Identifier (URI) by replacing each instance of certain characters by one, two, three, or four escape sequences representing the UTF-8 encoding of the characterencodeURIComponentEncodes a Uniform Resource Identifier (URI) component by replacing each instance of certain characters by one, two, three, or four escape sequences representing the UTF-8 encoding of the characterErrorRepresents an error when trying to execute a statement or accessing a propertyEvalErrorRepresents an error that occurs regarding the global functioneval()Float32ArrayRepresents a typed array of 32-bit floating point numbersFloat64ArrayRepresents a typed array of 64-bit floating point numbersFunctionRepresents a functionInfinityRepresents the mathematical Infinity valueInt8ArrayRepresents a typed array of 8-bit signed integersInt16ArrayRepresents a typed array of 16-bit signed integersInt32ArrayRepresents a typed array of 32-bit signed integersIntlProvides access to internationalization and localization functionalityisFiniteDetermines whether a value is a finite numberisNaNDetermines whether a value isNaNor notJSONProvides functionality to convert JavaScript values to and from the JSON formatMapRepresents a collection of values, where each value may occur only onceMathProvides access to mathematical functions and constantsNumberRepresents a numeric valueObjectRepresents the object that is the base of all JavaScript objectsparseFloatParses a string argument and returns a floating point numberparseIntParses a string argument and returns an integer of the specified radixPromiseRepresents the eventual completion (or failure) of an asynchronous operation, and its resulting valueProxyRepresents an object that is used to define custom behavior for fundamental operations (e.g. property lookup, assignment, enumeration, function invocation, etc)queueMicrotaskQueues a microtask to be executedRangeErrorRepresents an error when a value is not in the set or range of allowed valuesReferenceErrorRepresents an error when a non-existent variable is referencedReflectProvides methods for interceptable JavaScript operationsRegExpRepresents a regular expression, allowing you to match combinations of charactersSetRepresents a collection of values, where each value may occur only oncesetIntervalRepeatedly calls a function, with a fixed time delay between each callsetTimeoutCalls a function or evaluates an expression after a specified number of millisecondsSharedArrayBufferRepresents a generic, fixed-length raw binary data bufferStringRepresents a sequence of charactersstructuredCloneCreates a deep copy of a valueSymbolRepresents a unique and immutable data type that is used as the key of an object propertySyntaxErrorRepresents an error when trying to interpret syntactically invalid codeTypeErrorRepresents an error when a value is not of the expected typeUint8ArrayRepresents a typed array of 8-bit unsigned integersUint8ClampedArrayRepresents a typed array of 8-bit unsigned integers clamped to 0-255Uint32ArrayRepresents a typed array of 32-bit unsigned integersURIErrorRepresents an error when a global URI handling function was used in a wrong wayURLRepresents an object providing static methods used for creating object URLsURLPatternRepresents a URL patternURLSearchParamsRepresents a collection of key/value pairsWeakMapRepresents a collection of key/value pairs in which the keys are weakly referencedWeakSetRepresents a collection of objects in which each object may occur only onceWebAssemblyProvides access to WebAssemblyNext.js Specific PolyfillsAsyncLocalStorageEnvironment VariablesYou can useprocess.envto accessEnvironment Variablesfor bothnext devandnext build.Unsupported APIsThe Edge Runtime has some restrictions including:Native Node.js APIsare not supported. For example, you can't read or write to the filesystem.node_modulescanbe used, as long as they implement ES Modules and do not use native Node.js APIs.Callingrequiredirectly isnot allowed. Use ES Modules instead.The following JavaScript language features are disabled, andwill not work:APIDescriptionevalEvaluates JavaScript code represented as a stringnew Function(evalString)Creates a new function with the code provided as an argumentWebAssembly.compileCompiles a WebAssembly module from a buffer sourceWebAssembly.instantiateCompiles and instantiates a WebAssembly module from a buffer sourceIn rare cases, your code could contain (or import) some dynamic code evaluation statements whichcan not be reached at runtimeand which can not be removed by treeshaking.
You can relax the check to allow specific files with your Middleware configuration:middleware.tsexportconstconfig={unstable_allowDynamic:[// allows a single file'/lib/utilities.js',// use a glob to allow anything in the function-bind 3rd party module'**/node_modules/function-bind/**',],}unstable_allowDynamicis aglob, or an array of globs, ignoring dynamic code evaluation for specific files. The globs are relative to your application root folder.Be warned that if these statements are executed on the Edge,they will throw and cause a runtime error.Previousnext CLINextTurbopackWas this helpful?supported.Send"
turbopack,Turbopack,"Pages RouterAPI ReferenceTurbopackTurbopackTurbopackis an incremental bundler optimized for JavaScript and TypeScript, written in Rust, and built into Next.js. Turbopack can be used in Next.js in both thepagesandappdirectories for faster local development.To enable Turbopack, use the--turbopackflag when running the Next.js development server.package.json{""scripts"":{""dev"":""next dev --turbopack"",""build"":""next build"",""start"":""next start"",""lint"":""next lint""}}ReferenceSupported featuresTurbopack in Next.js requires zero-configuration for most users and can be extended for more advanced use cases. To learn more about the currently supported features for Turbopack, view theAPI Reference.Unsupported featuresTurbopack currently only supportsnext devand does not supportnext build. We are currently working on support for builds as we move closer towards stability.These features are currently not supported:Turbopack leveragesLightning CSSwhich doesn't support some low usage CSS Modules features:localand:globalas standalone pseudo classes. Only the function variant is supported, for example::global(a).The @value rule which has been superseded by CSS variables.:importand:exportICSS rules.Invalid CSS comment syntaxsuch as//CSS comments should be written as/* comment */per the specification.Preprocessors such as Sass do support this alternative syntax for comments.webpack()configuration innext.config.jsTurbopack replaces Webpack, this means that webpack configuration is not supported.To configure Turbopack,see the documentation.A subset ofWebpack loadersare supported in Turbopack.Babel (.babelrc)Turbopack leverages theSWCcompiler for all transpilation and optimizations. This means that Babel is not included by default.If you have a.babelrcfile, you might no longer need it because Next.js includes common Babel plugins as SWC transforms that can be enabled. You can read more about this in thecompiler documentation.If you still need to use Babel after verifying your particular use case is not covered, you can leverage Turbopack'ssupport for custom webpack loadersto includebabel-loader.Creating a root layout automatically in App Router.This behavior is currently not supported since it changes input files, instead, an error will be shown for you to manually add a root layout in the desired location.@next/font(legacy font support).@next/fontis deprecated in favor ofnext/font.next/fontis fully supported with Turbopack.Relay transformsWe are planning to implement this in the future.Blocking.cssimports inpages/_document.tsxCurrently with webpack Next.js blocks importing.cssfiles inpages/_document.tsxWe are planning to implement this warning in the future.experimental.typedRoutesWe are planning to implement this in the future.experimental.nextScriptWorkersWe are planning to implement this in the future.experimental.sri.algorithmWe are planning to implement this in the future.experimental.fallbackNodePolyfillsWe are planning to implement this in the future.experimental.esmExternalsWe are currently not planning to support the legacy esmExternals configuration in Next.js with Turbopack.AMP.We are currently not planning to support AMP in Next.js with Turbopack.Yarn PnPWe are currently not planning to support Yarn PnP in Next.js with Turbopack.experimental.urlImportsWe are currently not planning to supportexperimental.urlImportsin Next.js with Turbopack.:importand:exportICSS rulesWe are currently not planning to support:importand:exportICSS rules in Next.js with Turbopack asLightning CSSthe CSS parser Turbopack uses does not support these rules.unstable_allowDynamicconfiguration in edge runtimeExamplesGenerating Trace FilesTrace files allow the Next.js team to investigate and improve performance metrics and memory usage. To generate a trace file, appendNEXT_TURBOPACK_TRACING=1to thenext dev --turbopackcommand, this will generate a.next/trace-turbopackfile.When reporting issues related to Turbopack performance and memory usage, please include the trace file in yourGitHubissue.PreviousEdge RuntimeNextArchitectureWas this helpful?supported.Send"
architecture,Architecture,"IntroductionArchitectureArchitectureLearn about the Next.js architecture and how it works under the hood.AccessibilityThe built-in accessibility features of Next.js.Fast RefreshFast Refresh is a hot module reloading experience that gives you instantaneous feedback on edits made to your React components.Next.js CompilerNext.js Compiler, written in Rust, which transforms and minifies your Next.js application.Supported BrowsersBrowser support and which JavaScript features are supported by Next.js.PreviousTurbopackNextAccessibilityWas this helpful?supported.Send"
accessibility,Accessibility,"IntroductionArchitectureAccessibilityAccessibilityThe Next.js team is committed to making Next.js accessible to all developers (and their end-users). By adding accessibility features to Next.js by default, we aim to make the Web more inclusive for everyone.Route AnnouncementsWhen transitioning between pages rendered on the server (e.g. using the<a href>tag) screen readers and other assistive technology announce the page title when the page loads so that users understand that the page has changed.In addition to traditional page navigations, Next.js also supports client-side transitions for improved performance (usingnext/link). To ensure that client-side transitions are also announced to assistive technology, Next.js includes a route announcer by default.The Next.js route announcer looks for the page name to announce by first inspectingdocument.title, then the<h1>element, and finally the URL pathname. For the most accessible user experience, ensure that each page in your application has a unique and descriptive title.LintingNext.js provides anintegrated ESLint experienceout of the box, including custom rules for Next.js. By default, Next.js includeseslint-plugin-jsx-a11yto help catch accessibility issues early, including warning on:aria-propsaria-proptypesaria-unsupported-elementsrole-has-required-aria-propsrole-supports-aria-propsFor example, this plugin helps ensure you add alt text toimgtags, use correctaria-*attributes, use correctroleattributes, and more.Accessibility ResourcesWebAIM WCAG checklistWCAG 2.2 GuidelinesThe A11y ProjectCheckcolor contrast ratiosbetween foreground and background elementsUseprefers-reduced-motionwhen working with animationsPreviousArchitectureNextFast RefreshWas this helpful?supported.Send"
fast refresh,Fast Refresh,"IntroductionArchitectureFast RefreshFast RefreshFast refresh is a React feature integrated into Next.js that allows you live reload the browser page while maintaining temporary client-side state when you save changes to a file. It's enabled by default in all Next.js applications on9.4 or newer. With Fast Refresh enabled, most edits should be visible within a second.How It WorksIf you edit a file thatonly exports React component(s), Fast Refresh will
update the code only for that file, and re-render your component. You can edit
anything in that file, including styles, rendering logic, event handlers, or
effects.If you edit a file with exports thataren'tReact components, Fast Refresh
will re-run both that file, and the other files importing it. So if bothButton.jsandModal.jsimporttheme.js, editingtheme.jswill update
both components.Finally, if youedit a filethat'simported by files outside of the
React tree, Fast Refreshwill fall back to doing a full reload. You
might have a file which renders a React component but also exports a value
that is imported by anon-React component. For example, maybe your
component also exports a constant, and a non-React utility file imports it. In
that case, consider migrating the constant to a separate file and importing it
into both files. This will re-enable Fast Refresh to work. Other cases can
usually be solved in a similar way.Error ResilienceSyntax ErrorsIf you make a syntax error during development, you can fix it and save the file
again. The error will disappear automatically, so you won't need to reload the
app.You will not lose component state.Runtime ErrorsIf you make a mistake that leads to a runtime error inside your component,
you'll be greeted with a contextual overlay. Fixing the error will automatically
dismiss the overlay, without reloading the app.Component state will be retained if the error did not occur during rendering. If
the error did occur during rendering, React will remount your application using
the updated code.If you haveerror boundariesin your app (which is a good idea for graceful failures in production), they
will retry rendering on the next edit after a rendering error. This means having
an error boundary can prevent you from always getting reset to the root app
state. However, keep in mind that error boundaries shouldn't betoogranular.
They are used by React in production, and should always be designed
intentionally.LimitationsFast Refresh tries to preserve local React state in the component you're
editing, but only if it's safe to do so. Here's a few reasons why you might see
local state being reset on every edit to a file:Local state is not preserved for class components (only function components
and Hooks preserve state).The file you're editing might haveotherexports in addition to a React
component.Sometimes, a file would export the result of calling a higher-order component
likeHOC(WrappedComponent). If the returned component is a
class, its state will be reset.Anonymous arrow functions likeexport default () => <div />;cause Fast Refresh to not preserve local component state. For large codebases you can use ourname-default-componentcodemod.As more of your codebase moves to function components and Hooks, you can expect
state to be preserved in more cases.TipsFast Refresh preserves React local state in function components (and Hooks) by
default.Sometimes you might want toforcethe state to be reset, and a component to
be remounted. For example, this can be handy if you're tweaking an animation
that only happens on mount. To do this, you can add// @refresh resetanywhere in the file you're editing. This directive is local to the file, and
instructs Fast Refresh to remount components defined in that file on every
edit.You can putconsole.logordebugger;into the components you edit during
development.Remember that imports are case sensitive. Both fast and full refresh can fail,
when your import doesn't match the actual filename.
For example,'./header'vs'./Header'.Fast Refresh and HooksWhen possible, Fast Refresh attempts to preserve the state of your component
between edits. In particular,useStateanduseRefpreserve their previous
values as long as you don't change their arguments or the order of the Hook
calls.Hooks with dependencies—such asuseEffect,useMemo, anduseCallback—willalwaysupdate during Fast Refresh. Their list of dependencies will be ignored
while Fast Refresh is happening.For example, when you edituseMemo(() => x * 2, [x])touseMemo(() => x * 10, [x]), it will re-run even thoughx(the dependency)
has not changed. If React didn't do that, your edit wouldn't reflect on the
screen!Sometimes, this can lead to unexpected results. For example, even auseEffectwith an empty array of dependencies would still re-run once during Fast Refresh.However, writing code resilient to occasional re-running ofuseEffectis a good practice even
without Fast Refresh. It will make it easier for you to introduce new dependencies to it later on
and it's enforced byReact Strict Mode,
which we highly recommend enabling.PreviousAccessibilityNextNext.js CompilerWas this helpful?supported.Send"
next.js compiler,Next.js Compiler,"IntroductionArchitectureNext.js CompilerNext.js CompilerThe Next.js Compiler, written in Rust usingSWC, allows Next.js to transform and minify your JavaScript code for production. This replaces Babel for individual files and Terser for minifying output bundles.Compilation using the Next.js Compiler is 17x faster than Babel and enabled by default since Next.js version 12. If you have an existing Babel configuration or are usingunsupported features, your application will opt-out of the Next.js Compiler and continue using Babel.Why SWC?SWCis an extensible Rust-based platform for the next generation of fast developer tools.SWC can be used for compilation, minification, bundling, and more – and is designed to be extended. It's something you can call to perform code transformations (either built-in or custom). Running those transformations happens through higher-level tools like Next.js.We chose to build on SWC for a few reasons:Extensibility:SWC can be used as a Crate inside Next.js, without having to fork the library or workaround design constraints.Performance:We were able to achieve ~3x faster Fast Refresh and ~5x faster builds in Next.js by switching to SWC, with more room for optimization still in progress.WebAssembly:Rust's support for WASM is essential for supporting all possible platforms and taking Next.js development everywhere.Community:The Rust community and ecosystem are amazing and still growing.Supported FeaturesStyled ComponentsWe're working to portbabel-plugin-styled-componentsto the Next.js Compiler.First, update to the latest version of Next.js:npm install next@latest. Then, update yournext.config.jsfile:next.config.jsmodule.exports={compiler:{styledComponents:true,},}For advanced use cases, you can configure individual properties for styled-components compilation.Note:ssranddisplayNametransforms are the main requirement for usingstyled-componentsin Next.js.next.config.jsmodule.exports={compiler:{// see https://styled-components.com/docs/tooling#babel-plugin for more info on the options.styledComponents:{// Enabled by default in development, disabled in production to reduce file size,// setting this will override the default for all environments.displayName?:boolean,// Enabled by default.ssr?:boolean,// Enabled by default.fileName?:boolean,// Empty by default.topLevelImportPaths?:string[],// Defaults to [""index""].meaninglessFileNames?:string[],// Enabled by default.minify?:boolean,// Enabled by default.transpileTemplateLiterals?:boolean,// Empty by default.namespace?:string,// Disabled by default.pure?:boolean,// Enabled by default.cssProp?:boolean,},},}JestThe Next.js Compiler transpiles your tests and simplifies configuring Jest together with Next.js including:Auto mocking of.css,.module.css(and their.scssvariants), and image importsAutomatically sets uptransformusing SWCLoading.env(and all variants) intoprocess.envIgnoresnode_modulesfrom test resolving and transformsIgnoring.nextfrom test resolvingLoadsnext.config.jsfor flags that enable experimental SWC transformsFirst, update to the latest version of Next.js:npm install next@latest. Then, update yourjest.config.jsfile:jest.config.jsconstnextJest=require('next/jest')// Providing the path to your Next.js app which will enable loading next.config.js and .env filesconstcreateJestConfig=nextJest({ dir:'./'})// Any custom config you want to pass to JestconstcustomJestConfig={setupFilesAfterEnv:['<rootDir>/jest.setup.js'],}// createJestConfig is exported in this way to ensure that next/jest can load the Next.js configuration, which is asyncmodule.exports=createJestConfig(customJestConfig)RelayTo enableRelaysupport:next.config.jsmodule.exports={compiler:{relay:{// This should match relay.config.jssrc:'./',artifactDirectory:'./__generated__',language:'typescript',eagerEsModules:false,},},}Good to know: In Next.js, all JavaScript files inpagesdirectory are considered routes. So, forrelay-compileryou'll need to specifyartifactDirectoryconfiguration settings outside of thepages, otherwiserelay-compilerwill generate files next to the source file in the__generated__directory, and this file will be considered a route, which will break production builds.Remove React PropertiesAllows to remove JSX properties. This is often used for testing. Similar tobabel-plugin-react-remove-properties.To remove properties matching the default regex^data-test:next.config.jsmodule.exports={compiler:{reactRemoveProperties:true,},}To remove custom properties:next.config.jsmodule.exports={compiler:{// The regexes defined here are processed in Rust so the syntax is different from// JavaScript `RegExp`s. See https://docs.rs/regex.reactRemoveProperties:{ properties:['^data-custom$'] },},}Remove ConsoleThis transform allows for removing allconsole.*calls in application code (notnode_modules). Similar tobabel-plugin-transform-remove-console.Remove allconsole.*calls:next.config.jsmodule.exports={compiler:{removeConsole:true,},}Removeconsole.*output exceptconsole.error:next.config.jsmodule.exports={compiler:{removeConsole:{exclude:['error'],},},}Legacy DecoratorsNext.js will automatically detectexperimentalDecoratorsinjsconfig.jsonortsconfig.json. Legacy decorators are commonly used with older versions of libraries likemobx.This flag is only supported for compatibility with existing applications. We do not recommend using legacy decorators in new applications.First, update to the latest version of Next.js:npm install next@latest. Then, update yourjsconfig.jsonortsconfig.jsonfile:{""compilerOptions"": {""experimentalDecorators"":true}}importSourceNext.js will automatically detectjsxImportSourceinjsconfig.jsonortsconfig.jsonand apply that. This is commonly used with libraries likeTheme UI.First, update to the latest version of Next.js:npm install next@latest. Then, update yourjsconfig.jsonortsconfig.jsonfile:{""compilerOptions"": {""jsxImportSource"":""theme-ui""}}EmotionWe're working to port@emotion/babel-pluginto the Next.js Compiler.First, update to the latest version of Next.js:npm install next@latest. Then, update yournext.config.jsfile:next.config.jsmodule.exports={compiler:{emotion:boolean|{// default is true. It will be disabled when build type is production.sourceMap?:boolean,// default is 'dev-only'.autoLabel?:'never'|'dev-only'|'always',// default is '[local]'.// Allowed values: `[local]` `[filename]` and `[dirname]`// This option only works when autoLabel is set to 'dev-only' or 'always'.// It allows you to define the format of the resulting label.// The format is defined via string where variable parts are enclosed in square brackets [].// For example labelFormat: ""my-classname--[local]"", where [local] will be replaced with the name of the variable the result is assigned to.labelFormat?:string,// default is undefined.// This option allows you to tell the compiler what imports it should// look at to determine what it should transform so if you re-export// Emotion's exports, you can still use transforms.importMap?:{[packageName: string]:{[exportName: string]:{canonicalImport?:[string,string],styledBaseImport?:[string,string],}}},},},}MinificationNext.js' swc compiler is used for minification by default since v13. This is 7x faster than Terser.Good to know:Starting with v15, minification cannot be customized usingnext.config.js. Support for theswcMinifyflag has been removed.Module TranspilationNext.js can automatically transpile and bundle dependencies from local packages (like monorepos) or from external dependencies (node_modules). This replaces thenext-transpile-modulespackage.next.config.jsmodule.exports={transpilePackages:['@acme/ui','lodash-es'],}Modularize ImportsThis option has been superseded byoptimizePackageImportsin Next.js 13.5. We recommend upgrading to use the new option that does not require manual configuration of import paths.Define (Replacing variables during build)Thedefineoption allows you to statically replace variables in your code at build-time.
The option takes an object as key-value pairs, where the keys are the variables that should be replaced with the corresponding values.Use thecompiler.definefield innext.config.js:next.config.jsmodule.exports={compiler:{define:{MY_STRING_VARIABLE:JSON.stringify('my-string'),MY_NUMBER_VARIABLE:'42',},},}Experimental FeaturesSWC Trace profilingYou can generate SWC's internal transform traces as chromium'strace event format.next.config.jsmodule.exports={experimental:{swcTraceProfiling:true,},}Once enabled, swc will generate trace named asswc-trace-profile-${timestamp}.jsonunder.next/. Chromium's trace viewer (chrome://tracing/,https://ui.perfetto.dev/), or compatible flamegraph viewer (https://www.speedscope.app/) can load & visualize generated traces.SWC Plugins (experimental)You can configure swc's transform to use SWC's experimental plugin support written in wasm to customize transformation behavior.next.config.jsmodule.exports={experimental:{swcPlugins:[['plugin',{...pluginOptions,},],],},}swcPluginsaccepts an array of tuples for configuring plugins. A tuple for the plugin contains the path to the plugin and an object for plugin configuration. The path to the plugin can be an npm module package name or an absolute path to the.wasmbinary itself.Unsupported FeaturesWhen your application has a.babelrcfile, Next.js will automatically fall back to using Babel for transforming individual files. This ensures backwards compatibility with existing applications that leverage custom Babel plugins.If you're using a custom Babel setup,please share your configuration. We're working to port as many commonly used Babel transformations as possible, as well as supporting plugins in the future.Version HistoryVersionChangesv13.1.0Module TranspilationandModularize Importsstable.v13.0.0SWC Minifier enabled by default.v12.3.0SWC Minifierstable.v12.2.0SWC Pluginsexperimental support added.v12.1.0Added support for Styled Components, Jest, Relay, Remove React Properties, Legacy Decorators, Remove Console, and jsxImportSource.v12.0.0Next.js Compilerintroduced.PreviousFast RefreshNextSupported BrowsersWas this helpful?supported.Send"
supported browsers,Supported Browsers,"IntroductionArchitectureSupported BrowsersSupported BrowsersNext.js supportsmodern browserswith zero configuration.Chrome 64+Edge 79+Firefox 67+Opera 51+Safari 12+BrowserslistIf you would like to target specific browsers or features, Next.js supportsBrowserslistconfiguration in yourpackage.jsonfile. Next.js uses the following Browserslist configuration by default:package.json{""browserslist"":[""chrome 64"",""edge 79"",""firefox 67"",""opera 51"",""safari 12""]}PolyfillsWe injectwidely used polyfills, including:fetch()— Replacing:whatwg-fetchandunfetch.URL— Replacing: theurlpackage (Node.js API).Object.assign()— Replacing:object-assign,object.assign, andcore-js/object/assign.If any of your dependencies include these polyfills, they’ll be eliminated automatically from the production build to avoid duplication.In addition, to reduce bundle size, Next.js will only load these polyfills for browsers that require them. The majority of the web traffic globally will not download these polyfills.Custom PolyfillsIf your own code or any external npm dependencies require features not supported by your target browsers (such as IE 11), you need to add polyfills yourself.In this case, you should add a top-level import for thespecific polyfillyou need in yourCustom<App>or the individual component.JavaScript Language FeaturesNext.js allows you to use the latest JavaScript features out of the box. In addition toES6 features, Next.js also supports:Async/await(ES2017)Object Rest/Spread Properties(ES2018)Dynamicimport()(ES2020)Optional Chaining(ES2020)Nullish Coalescing(ES2020)Class FieldsandStatic Properties(ES2022)and more!TypeScript FeaturesNext.js has built-in TypeScript support.Learn more here.Customizing Babel Config (Advanced)You can customize babel configuration.Learn more here.PreviousNext.js CompilerNextCommunityWas this helpful?supported.Send"
community,Community,"IntroductionCommunityNext.js CommunityWith over 5 million weekly downloads, Next.js has a large and active community of developers across the world. Here's how you can get involved in our community:ContributingThere are a couple of ways you can contribute to the development of Next.js:Documentation: Suggest improvements or even write new sections to help our users understand how to use Next.js.Examples: Help developers integrate Next.js with other tools and services by creating a new example or improving an existing one.Codebase: Learn more about the underlying architecture, contribute to bug fixes, errors, and suggest new features.DiscussionsIf you have a question about Next.js, or want to help others, you're always welcome to join the conversation:GitHub DiscussionsDiscordRedditSocial MediaFollow Next.js onTwitterfor the latest updates, and subscribe to theVercel YouTube channelfor Next.js videos.Code of ConductWe believe in creating an inclusive, welcoming community. As such, we ask all members to adhere to ourCode of Conduct. This document outlines our expectations for participant behavior. We invite you to read it and help us maintain a safe and respectful environment.Contribution GuideLearn how to contribute to Next.js DocumentationPreviousSupported BrowsersNextContribution GuideWas this helpful?supported.Send"
contribution guide,Contribution Guide,"IntroductionCommunityContribution GuideDocs Contribution GuideWelcome to the Next.js Docs Contribution Guide! We're excited to have you here.This page provides instructions on how to edit the Next.js documentation. Our goal is to ensure that everyone in the community feels empowered to contribute and improve our docs.Why Contribute?Open-source work is never done, and neither is documentation. Contributing to docs is a good way for beginners to get involved in open-source and for experienced developers to clarify more complex topics while sharing their knowledge with the community.By contributing to the Next.js docs, you're helping us build a more robust learning resource for all developers. Whether you've found a typo, a confusing section, or you've realized that a particular topic is missing, your contributions are welcomed and appreciated.How to ContributeThe docs content can be found on theNext.js repo. To contribute, you can edit the files directly on GitHub or clone the repo and edit the files locally.GitHub WorkflowIf you're new to GitHub, we recommend reading theGitHub Open Source Guideto learn how to fork a repository, create a branch, and submit a pull request.Good to know: The underlying docs code lives in a private codebase that is synced to the Next.js public repo. This means that you can't preview the docs locally. However, you'll see your changes onnextjs.orgafter merging a pull request.Writing MDXThe docs are written inMDX, a markdown format that supports JSX syntax. This allows us to embed React components in the docs. See theGitHub Markdown Guidefor a quick overview of markdown syntax.VSCodePreviewing Changes LocallyVSCode has a built-in markdown previewer that you can use to see your edits locally. To enable the previewer for MDX files, you'll need to add a configuration option to your user settings.Open the command palette (⌘ + ⇧ + Pon Mac orCtrl + Shift + Pon Windows) and search fromPreferences: Open User Settings (JSON).Then, add the following line to yoursettings.jsonfile:settings.json{""files.associations"":{""*.mdx"":""markdown""}}Next, open the command palette again, and search forMarkdown: Preview FileorMarkdown: Open Preview to the Side. This will open a preview window where you can see your formatted changes.ExtensionsWe also recommend the following extensions for VSCode users:MDX: Intellisense and syntax highlighting for MDX.Prettier: Format MDX files on save.Review ProcessOnce you've submitted your contribution, the Next.js or Developer Experience teams will review your changes, provide feedback, and merge the pull request when it's ready.Please let us know if you have any questions or need further assistance in your PR's comments. Thank you for contributing to the Next.js docs and being a part of our community!Tip:Runpnpm prettier-fixto run Prettier before submitting your PR.File StructureThe docs usefile-system routing. Each folder and files inside/docsrepresent a route segment. These segments are used to generate the URL paths, navigation, and breadcrumbs.The file structure reflects the navigation that you see on the site, and by default, navigation items are sorted alphabetically. However, we can change the order of the items by prepending a two-digit number (00-) to the folder or file name.For example, in thefunctions API Reference, the pages are sorted alphabetically because it makes it easier for developers to find a specific function:04-functions├── after.mdx├── cacheLife.mdx├── cacheTag.mdx└── ...But, in therouting section, the files are prefixed with a two-digit number, sorted in the order developers should learn these concepts:01-routing├── 01-defining-routes.mdx├── 02-pages.mdx├── 03-layouts-and-templates.mdx└── ...To quickly find a page, you can use⌘ + P(Mac) orCtrl + P(Windows) to open the search bar on VSCode. Then, type the slug of the page you're looking for. E.g.defining-routesWhy not use a manifest?We considered using a manifest file (another popular way to generate the docs navigation), but we found that a manifest would quickly get out of sync with the files. File-system routing forces us to think about the structure of the docs and feels more native to Next.js.MetadataEach page has a metadata block at the top of the file separated by three dashes.Required FieldsThe following fields arerequired:FieldDescriptiontitleThe page's<h1>title, used for SEO and OG Images.descriptionThe page's description, used in the<meta name=""description"">tag for SEO.required-fields.mdx---title:Page Titledescription:Page Description---It's good practice to limit the page title to 2-3 words (e.g. Optimizing Images) and the description to 1-2 sentences (e.g. Learn how to optimize images in Next.js).Optional FieldsThe following fields areoptional:FieldDescriptionnav_titleOverrides the page's title in the navigation. This is useful when the page's title is too long to fit. If not provided, thetitlefield is used.sourcePulls content into a shared page. SeeShared Pages.relatedA list of related pages at the bottom of the document. These will automatically be turned into cards. SeeRelated Links.versionA stage of development. e.g.experimental,legacy,unstable,RCoptional-fields.mdx---nav_title:Nav Item Titlesource:app/building-your-application/optimizing/imagesrelated:description:See the image component API reference.links:-app/api-reference/components/imageversion:experimental---AppandPagesDocsSince most of the features in theApp RouterandPages Routerare completely different, their docs for each are kept in separate sections (02-appand03-pages). However, there are a few features that are shared between them.Shared PagesTo avoid content duplication and risk the content becoming out of sync, we use thesourcefield to pull content from one page into another. For example, the<Link>component behavesmostlythe same inAppandPages. Instead of duplicating the content, we can pull the content fromapp/.../link.mdxintopages/.../link.mdx:app/.../link.mdx---title:<Link>description:API reference for the <Link> component.---This API reference will help you understand how to use the propsand configuration options available for the Link Component.pages/.../link.mdx---title:<Link>description:API reference for the <Link> component.source:app/api-reference/components/link---{/* DO NOT EDIT THIS PAGE. */}{/* The content of this page is pulled from the source above. */}We can therefore edit the content in one place and have it reflected in both sections.Shared ContentIn shared pages, sometimes there might be content that isApp RouterorPages Routerspecific. For example, the<Link>component has ashallowprop that is only available inPagesbut not inApp.To make sure the content only shows in the correct router, we can wrap content blocks in an<AppOnly>or<PagesOnly>components:app/.../link.mdxThis content is shared between App and Pages.<PagesOnly>This content will only be shown on the Pages docs.</PagesOnly>This content is shared between App and Pages.You'll likely use these components for examples and code blocks.Code BlocksCode blocks should contain a minimum working example that can be copied and pasted. This means that the code should be able to run without any additional configuration.For example, if you're showing how to use the<Link>component, you should include theimportstatement and the<Link>component itself.app/page.tsximportLinkfrom'next/link'exportdefaultfunctionPage() {return<Linkhref=""/about"">About</Link>}Always run examples locally before committing them. This will ensure that the code is up-to-date and working.Language and FilenameCode blocks should have a header that includes the language and thefilename. Add afilenameprop to render a special Terminal icon that helps orientate users where to input the command. For example:code-example.mdx```bashfilename=""Terminal""npxcreate-next-app```Most examples in the docs are written intsxandjsx, and a few inbash. However, you can use any supported language, here's thefull list.When writing JavaScript code blocks, we use the following language and extension combinations.LanguageExtensionJavaScript files with JSX code```jsx.jsJavaScript files without JSX```js.jsTypeScript files with JSX```tsx.tsxTypeScript files without JSX```ts.tsGood to know:Make sure to usejsextension withJSXcode at JavaScript files.For example, ```jsx filename=""app/layout.js""TS and JS SwitcherAdd a language switcher to toggle between TypeScript and JavaScript. Code blocks should be TypeScript first with a JavaScript version to accommodate users.Currently, we write TS and JS examples one after the other, and link them withswitcherprop:code-example.mdx```tsxfilename=""app/page.tsx"" switcher``````jsxfilename=""app/page.js"" switcher```Good to know: We plan to automatically compile TypeScript snippets to JavaScript in the future. In the meantime, you can usetransform.tools.Line HighlightingCode lines can be highlighted. This is useful when you want to draw attention to a specific part of the code. You can highlight lines by passing a number to thehighlightprop.Single Line:highlight={1}app/page.tsximportLinkfrom'next/link'exportdefaultfunctionPage() {return<Linkhref=""/about"">About</Link>}Multiple Lines:highlight={1,3}app/page.tsximportLinkfrom'next/link'exportdefaultfunctionPage() {return<Linkhref=""/about"">About</Link>}Range of Lines:highlight={1-5}app/page.tsximportLinkfrom'next/link'exportdefaultfunctionPage() {return<Linkhref=""/about"">About</Link>}IconsThe following icons are available for use in the docs:mdx-icon.mdx<Checksize={18} /><Crosssize={18} />Output:We do not use emojis in the docs.NotesFor information that is important but not critical, use notes. Notes are a good way to add information without distracting the user from the main content.notes.mdx>**Good to know**: This is a single line note.>**Good to know**:>> - We also use this format for multi-line notes.> - There are sometimes multiple items worth knowing or keeping in mind.Output:Good to know: This is a single line note.Good to know:We also use this format for multi-line notes.There are sometimes multiple items worth knowing or keeping in mind.Related LinksRelated Links guide the user's learning journey by adding links to logical next steps.Links will be displayed in cards under the main content of the page.Links will be automatically generated for pages that have child pages. For example, theOptimizingsection has links to all of its child pages.Create related links using therelatedfield in the page's metadata.example.mdx---related:description:Learn how to quickly get started with your first application.links:-app/building-your-application/routing/defining-routes-app/building-your-application/data-fetching-app/api-reference/file-conventions/page---Nested FieldsFieldRequired?DescriptiontitleOptionalThe title of the card list. Defaults toNext Steps.descriptionOptionalThe description of the card list.linksRequiredA list of links to other doc pages. Each list item should be a relative URL path (without a leading slash) e.g.app/api-reference/file-conventions/pageDiagramsDiagrams are a great way to explain complex concepts. We useFigmato create diagrams, following Vercel's design guide.The diagrams currently live in the/publicfolder in our private Next.js site. If you'd like to update or add a diagram, please open aGitHub issuewith your ideas.Custom Components and HTMLThese are the React Components available for the docs:<Image />(next/image),<PagesOnly />,<AppOnly />,<Cross />, and<Check />. We do not allow raw HTML in the docs besides the<details>tag.If you have ideas for new components, please open aGitHub issue.Style GuideThis section contains guidelines for writing docs for those who are new to technical writing.Page TemplatesWhile we don't have a strict template for pages, there are page sections you'll see repeated across the docs:Overview:The first paragraph of a page should tell the user what the feature is and what it's used for. Followed by a minimum working example or its API reference.Convention:If the feature has a convention, it should be explained here.Examples: Show how the feature can be used with different use cases.API Tables: API Pages should have an overview table at the of the page with jump-to-section links (when possible).Next Steps (Related Links): Add links to related pages to guide the user's learning journey.Feel free to add these sections as needed.Page TypesDocs pages are also split into two categories: Conceptual and Reference.Conceptualpages are used to explain a concept or feature. They are usually longer and contain more information than reference pages. In the Next.js docs, conceptual pages are found in theBuilding Your Applicationsection.Referencepages are used to explain a specific API. They are usually shorter and more focused. In the Next.js docs, reference pages are found in theAPI Referencesection.Good to know: Depending on the page you're contributing to, you may need to follow a different voice and style. For example, conceptual pages are more instructional and use the wordyouto address the user. Reference pages are more technical, they use more imperative words like ""create, update, accept"" and tend to omit the wordyou.VoiceHere are some guidelines to maintain a consistent style and voice across the docs:Write clear, concise sentences. Avoid tangents.If you find yourself using a lot of commas, consider breaking the sentence into multiple sentences or use a list.Swap out complex words for simpler ones. For example,useinstead ofutilize.Be mindful with the wordthis. It can be ambiguous and confusing, don't be afraid to repeat the subject of the sentence if unclear.For example,Next.js uses Reactinstead ofNext.js uses this.Use an active voice instead of passive. An active sentence is easier to read.For example,Next.js uses Reactinstead ofReact is used by Next.js. If you find yourself using words likewasandbyyou may be using a passive voice.Avoid using words likeeasy,quick,simple,just, etc. This is subjective and can be discouraging to users.Avoid negative words likedon't,can't,won't, etc. This can be discouraging to readers.For example,""You can use theLinkcomponent to create links between pages""instead of""Don't use the<a>tag to create links between pages"".Write in second person (you/your). This is more personal and engaging.Use gender-neutral language. Usedevelopers,users, orreaders, when referring to the audience.If adding code examples, ensure they are properly formatted and working.While these guidelines are not exhaustive, they should help you get started. If you'd like to dive deeper into technical writing, check out theGoogle Technical Writing Course.Thank you for contributing to the docs and being part of the Next.js community!PreviousCommunityWas this helpful?supported.Send"
what is next.js?,What is Next.js?,Content not available.
main features,Main Features,Content not available.
how to use these docs,How to Use These Docs,Content not available.
app router vs pages router,App Router vs Pages Router,Content not available.
pre-requisite knowledge,Pre-Requisite Knowledge,Content not available.
accessibility,Accessibility,Content not available.
join our community,Join our Community,Content not available.
edit this page on github,Edit this page on GitHub,Content not available.
managed next.js (vercel),Managed Next.js (Vercel),"Cache, controlled.Define per-component response revalidation that persists across deploys with Vercel's Data Cache."
what is next.js?,What is Next.js?,Content not available.
main features,Main Features,Content not available.
routing,Routing,"App RouterBuilding Your ApplicationRoutingRouting FundamentalsLayouts and TemplatesCreate your first shared layout in Next.js.Linking and NavigatingLearn how navigation works in Next.js, and how to use the Link Component and `useRouter` hook.Error HandlingLearn how to display expected errors and handle uncaught exceptions.Loading UI and StreamingBuilt on top of Suspense, Loading UI allows you to create a fallback for specific route segments, and automatically stream content as it becomes ready.RedirectingLearn the different ways to handle redirects in Next.js.Route GroupsRoute Groups can be used to partition your Next.js application into different sections.Dynamic RoutesDynamic Routes can be used to programmatically generate route segments from dynamic data.Parallel RoutesSimultaneously render one or more pages in the same view that can be navigated independently. A pattern for highly dynamic applications.Intercepting RoutesUse intercepting routes to load a new route within the current layout while masking the browser URL, useful for advanced routing patterns such as modals.Route HandlersCreate custom request handlers for a given route using the Web's Request and Response APIs.MiddlewareLearn how to use Middleware to run code before a request is completed.InternationalizationAdd support for multiple languages with internationalized routing and localized content.PreviousBuilding Your ApplicationNextLayouts and TemplatesWas this helpful?supported.Send"
rendering,Rendering,"App RouterBuilding Your ApplicationRenderingRenderingRendering converts the code you write into user interfaces. React and Next.js allow you to create hybrid web applications where parts of your code can be rendered on the server or the client. This section will help you understand the differences between these rendering environments, strategies, and runtimes.FundamentalsTo start, it's helpful to be familiar with three foundational web concepts:TheEnvironmentsyour application code can be executed in: the server and the client.TheRequest-Response Lifecyclethat's initiated when a user visits or interacts with your application.TheNetwork Boundarythat separates server and client code.Rendering EnvironmentsThere are two environments where web applications can be rendered: the client and the server.Theclientrefers to the browser on a user's device that sends a request to a server for your application code. It then turns the response from the server into a user interface.Theserverrefers to the computer in a data center that stores your application code, receives requests from a client, and sends back an appropriate response.Historically, developers had to use different languages (e.g. JavaScript, PHP) and frameworks when writing code for the server and the client. With React, developers can use thesame language(JavaScript), and thesame framework(e.g. Next.js or your framework of choice). This flexibility allows you to seamlessly write code for both environments without context switching.However, each environment has its own set of capabilities and constraints. Therefore, the code you write for the server and the client is not always the same. There are certain operations (e.g. data fetching or managing user state) that are better suited for one environment over the other.Understanding these differences is key to effectively using React and Next.js. We'll cover the differences and use cases in more detail on theServerandClientComponents pages, for now, let's continue building on our foundation.Request-Response LifecycleBroadly speaking, all websites follow the sameRequest-Response Lifecycle:User Action:The user interacts with a web application. This could be clicking a link, submitting a form, or typing a URL directly into the browser's address bar.HTTP Request:The client sends anHTTPrequest to the server that contains necessary information about what resources are being requested, what method is being used (e.g.GET,POST), and additional data if necessary.Server:The server processes the request and responds with the appropriate resources. This process may take a couple of steps like routing, fetching data, etc.HTTP Response:After processing the request, the server sends an HTTP response back to the client. This response contains a status code (which tells the client whether the request was successful or not) and requested resources (e.g. HTML, CSS, JavaScript, static assets, etc).Client:The client parses the resources to render the user interface.User Action:Once the user interface is rendered, the user can interact with it, and the whole process starts again.A major part of building a hybrid web application is deciding how to split the work in the lifecycle, and where to place the Network Boundary.Network BoundaryIn web development, theNetwork Boundaryis a conceptual line that separates the different environments. For example, the client and the server, or the server and the data store.In React, you choose where to place the client-server network boundary wherever it makes the most sense.Behind the scenes, the work is split into two parts: theclient module graphand theserver module graph. The server module graph contains all the components that are rendered on the server, and the client module graph contains all components that are rendered on the client.It may be helpful to think about module graphs as a visual representation of how files in your application depend on each other.You can use the React""use client""convention to define the boundary. There's also a""use server""convention, which tells React to do some computational work on the server.Building Hybrid ApplicationsWhen working in these environments, it's helpful to think of the flow of the code in your application asunidirectional. In other words, during a response, your application code flows in one direction: from the server to the client.If you need to access the server from the client, you send anewrequest to the server rather than re-use the same request. This makes it easier to understand where to render your components and where to place the Network Boundary.In practice, this model encourages developers to think about what they want to execute on the server first, before sending the result to the client and making the application interactive.This concept will become clearer when we look at how you caninterleave client and server componentsin the same component tree.Server ComponentsLearn how you can use React Server Components to render parts of your application on the server.Client ComponentsLearn how to use Client Components to render parts of your application on the client.Composition PatternsRecommended patterns for using Server and Client Components.Partial PrerenderingLearn how to combine the benefits of static and dynamic rendering with Partial Prerendering.RuntimesLearn about the switchable runtimes (Edge and Node.js) in Next.js.PreviousIncremental Static Regeneration (ISR)NextServer ComponentsWas this helpful?supported.Send"
data fetching,Data Fetching,App RouterBuilding Your ApplicationData FetchingData FetchingData Fetching and CachingLearn best practices for fetching data on the server or client in Next.js.Server Actions and MutationsLearn how to handle form submissions and data mutations with Next.js.Incremental Static Regeneration (ISR)Learn how to create or update static pages at runtime with Incremental Static Regeneration.PreviousInternationalizationNextData Fetching and CachingWas this helpful?supported.Send
styling,Styling,"App RouterBuilding Your ApplicationStylingStylingNext.js supports different ways of styling your application, including:CSS Modules: Create locally scoped CSS classes to avoid naming conflicts and improve maintainability.Global CSS: Simple to use and familiar for those experienced with traditional CSS, but can lead to larger CSS bundles and difficulty managing styles as the application grows.Tailwind CSS: A utility-first CSS framework that allows for rapid custom designs by composing utility classes.Sass: A popular CSS preprocessor that extends CSS with features like variables, nested rules, and mixins.CSS-in-JS: Embed CSS directly in your JavaScript components, enabling dynamic and scoped styling.Learn more about each approach by exploring their respective documentation:CSSStyle your Next.js Application with CSS Modules, Global Styles, and external stylesheets.Tailwind CSSStyle your Next.js Application using Tailwind CSS.SassStyle your Next.js application using Sass.CSS-in-JSUse CSS-in-JS libraries with Next.jsPreviousCachingNextCSSWas this helpful?supported.Send"
optimizations,Optimizations,"App RouterBuilding Your ApplicationOptimizingOptimizationsNext.js comes with a variety of built-in optimizations designed to improve your application's speed andCore Web Vitals. This guide will cover the optimizations you can leverage to enhance your user experience.Built-in ComponentsBuilt-in components abstract away the complexity of implementing common UI optimizations. These components are:Images: Built on the native<img>element. The Image Component optimizes images for performance by lazy loading and automatically resizing images based on device size.Link: Built on the native<a>tags. The Link Component prefetches pages in the background, for faster and smoother page transitions.Scripts: Built on the native<script>tags. The Script Component gives you control over loading and execution of third-party scripts.MetadataMetadata helps search engines understand your content better (which can result in better SEO), and allows you to customize how your content is presented on social media, helping you create a more engaging and consistent user experience across various platforms.The Metadata API in Next.js allows you to modify the<head>element of a page. You can configure metadata in two ways:Config-based Metadata: Export astaticmetadataobjector a dynamicgenerateMetadatafunctionin alayout.jsorpage.jsfile.File-based Metadata: Add static or dynamically generated special files to route segments.Additionally, you can create dynamic Open Graph Images using JSX and CSS withimageResponseconstructor.Static AssetsNext.js/publicfolder can be used to serve static assets like images, fonts, and other files. Files inside/publiccan also be cached by CDN providers so that they are delivered efficiently.Analytics and MonitoringFor large applications, Next.js integrates with popular analytics and monitoring tools to help you understand how your application is performing. Learn more in theOpenTelemetryandInstrumentationguides.ImagesOptimize your images with the built-in `next/image` component.VideosRecommendations and best practices for optimizing videos in your Next.js application.FontsOptimize your application's web fonts with the built-in `next/font` loaders.MetadataUse the Metadata API to define metadata in any layout or page.ScriptsOptimize 3rd party scripts with the built-in Script component.Package BundlingLearn how to optimize your application's server and client bundles.Lazy LoadingLazy load imported libraries and React Components to improve your application's loading performance.AnalyticsMeasure and track page performance using Next.js Speed InsightsInstrumentationLearn how to use instrumentation to run code at server startup in your Next.js appOpenTelemetryLearn how to instrument your Next.js app with OpenTelemetry.Static AssetsNext.js allows you to serve static files, like images, in the public directory. You can learn how it works here.Third Party LibrariesOptimize the performance of third-party libraries in your application with the `@next/third-parties` package.Memory UsageOptimize memory used by your application in development and production.PreviousCSS-in-JSNextImagesWas this helpful?supported.Send"
typescript,TypeScript,"API ReferenceConfigurationTypeScriptTypeScriptNext.js comes with built-in TypeScript, automatically installing the necessary packages and configuring the proper settings when you create a new project withcreate-next-app.To add TypeScript to an existing project, rename a file to.ts/.tsx. Runnext devandnext buildto automatically install the necessary dependencies and add atsconfig.jsonfile with the recommended config options.Good to know: If you already have ajsconfig.jsonfile, copy thepathscompiler option from the oldjsconfig.jsoninto the newtsconfig.jsonfile, and delete the oldjsconfig.jsonfile.IDE PluginNext.js includes a custom TypeScript plugin and type checker, which VSCode and other code editors can use for advanced type-checking and auto-completion.You can enable the plugin in VS Code by:Opening the command palette (Ctrl/⌘+Shift+P)Searching for ""TypeScript: Select TypeScript Version""Selecting ""Use Workspace Version""Now, when editing files, the custom plugin will be enabled. When runningnext build, the custom type checker will be used.The TypeScript plugin can help with:Warning if the invalid values forsegment config optionsare passed.Showing available options and in-context documentation.Ensuring theuse clientdirective is used correctly.Ensuring client hooks (likeuseState) are only used in Client Components.🎥 Watch:Learn about the built-in TypeScript plugin →YouTube (3 minutes)End-to-End Type SafetyThe Next.js App Router hasenhanced type safety. This includes:No serialization of data between fetching function and page: You canfetchdirectly in components, layouts, and pages on the server. This datadoes notneed to be serialized (converted to a string) to be passed to the client side for consumption in React. Instead, sinceappuses Server Components by default, we can use values likeDate,Map,Set, and more without any extra steps. Previously, you needed to manually type the boundary between server and client with Next.js-specific types.Streamlined data flow between components: With the removal of_appin favor of root layouts, it is now easier to visualize the data flow between components and pages. Previously, data flowing between individualpagesand_appwere difficult to type and could introduce confusing bugs. Withcolocated data fetchingin the App Router, this is no longer an issue.Data Fetching in Next.jsnow provides as close to end-to-end type safety as possible without being prescriptive about your database or content provider selection.We're able to type the response data as you would expect with normal TypeScript. For example:app/page.tsxTypeScriptJavaScriptTypeScriptasyncfunctiongetData() {constres=awaitfetch('https://api.example.com/...')// The return value is *not* serialized// You can return Date, Map, Set, etc.returnres.json()}exportdefaultasyncfunctionPage() {constname=awaitgetData()return'...'}Forcompleteend-to-end type safety, this also requires your database or content provider to support TypeScript. This could be through using anORMor type-safe query builder.ExamplesType checkingnext.config.tsYou can use TypeScript and import types in your Next.js configuration by usingnext.config.ts.next.config.tsimporttype{ NextConfig }from'next'constnextConfig:NextConfig={/* config options here */}exportdefaultnextConfigGood to know: Module resolution innext.config.tsis currently limited toCommonJS. This may cause incompatibilities with ESM only packages being loaded innext.config.ts.When using thenext.config.jsfile, you can add some type checking in your IDE using JSDoc as below:next.config.js// @ts-check/**@type{import('next').NextConfig}*/constnextConfig={/* config options here */}module.exports=nextConfigStatically Typed LinksNext.js can statically type links to prevent typos and other errors when usingnext/link, improving type safety when navigating between pages.To opt-into this feature,experimental.typedRoutesneed to be enabled and the project needs to be using TypeScript.next.config.tsimporttype{ NextConfig }from'next'constnextConfig:NextConfig={experimental:{typedRoutes:true,},}exportdefaultnextConfigNext.js will generate a link definition in.next/typesthat contains information about all existing routes in your application, which TypeScript can then use to provide feedback in your editor about invalid links.Currently, experimental support includes any string literal, including dynamic segments. For non-literal strings, you currently need to manually cast thehrefwithas Route:importtype{ Route }from'next';importLinkfrom'next/link'// No TypeScript errors if href is a valid route<Linkhref=""/about""/><Linkhref=""/blog/nextjs""/><Linkhref={`/blog/${slug}`} /><Linkhref={('/blog'+slug)asRoute} />// TypeScript errors if href is not a valid route<Linkhref=""/aboot""/>To accepthrefin a custom component wrappingnext/link, use a generic:importtype{ Route }from'next'importLinkfrom'next/link'functionCard<Textendsstring>({ href }:{ href:Route<T>|URL}) {return(<Linkhref={href}><div>My Card</div></Link>)}How does it work?When runningnext devornext build, Next.js generates a hidden.d.tsfile inside.nextthat contains information about all existing routes in your application (all valid routes as thehreftype ofLink). This.d.tsfile is included intsconfig.jsonand the TypeScript compiler will check that.d.tsand provide feedback in your editor about invalid links.With Async Server ComponentsTo use anasyncServer Component with TypeScript, ensure you are using TypeScript5.1.3or higher and@types/react18.2.8or higher.If you are using an older version of TypeScript, you may see a'Promise<Element>' is not a valid JSX elementtype error. Updating to the latest version of TypeScript and@types/reactshould resolve this issue.Incremental type checkingSincev10.2.1Next.js supportsincremental type checkingwhen enabled in yourtsconfig.json, this can help speed up type checking in larger applications.Disabling TypeScript errors in productionNext.js fails yourproduction build(next build) when TypeScript errors are present in your project.If you'd like Next.js to dangerously produce production code even when your application has errors, you can disable the built-in type checking step.If disabled, be sure you are running type checks as part of your build or deploy process, otherwise this can be very dangerous.Opennext.config.tsand enable theignoreBuildErrorsoption in thetypescriptconfig:next.config.tsimporttype{ NextConfig }from'next'constnextConfig:NextConfig={typescript:{// !! WARN !!// Dangerously allow production builds to successfully complete even if// your project has type errors.// !! WARN !!ignoreBuildErrors:true,},}exportdefaultnextConfigGood to know: You can runtsc --noEmitto check for TypeScript errors yourself before building. This is useful for CI/CD pipelines where you'd like to check for TypeScript errors before deploying.Custom type declarationsWhen you need to declare custom types, you might be tempted to modifynext-env.d.ts. However, this file is automatically generated, so any changes you make will be overwritten. Instead, you should create a new file, let's call itnew-types.d.ts, and reference it in yourtsconfig.json:tsconfig.json{""compilerOptions"":{""skipLibCheck"":true//...truncated...},""include"":[""new-types.d.ts"",""next-env.d.ts"","".next/types/**/*.ts"",""**/*.ts"",""**/*.tsx""],""exclude"":[""node_modules""]}Version ChangesVersionChangesv15.0.0next.config.tssupport added for TypeScript projects.v13.2.0Statically typed links are available in beta.v12.0.0SWCis now used by default to compile TypeScript and TSX for faster builds.v10.2.1Incremental type checkingsupport added when enabled in yourtsconfig.json.PreviouswebVitalsAttributionNextESLintWas this helpful?supported.Send"
how to use these docs,How to Use These Docs,Content not available.
installation,Installation,"App RouterGetting StartedInstallationHow to set up a new Next.js projectSystem requirementsNode.js 18.18or later.macOS, Windows (including WSL), and Linux are supported.Automatic installationWe recommend starting a new Next.js app usingcreate-next-app, which sets up everything automatically for you. To create a project, run:Terminalnpxcreate-next-app@latestOn installation, you'll see the following prompts:TerminalWhat is your project named? my-appWould you like to use TypeScript? No / YesWould you like to use ESLint? No / YesWould you like to use Tailwind CSS? No / YesWould you like your code inside a `src/` directory? No / YesWould you like to use App Router? (recommended) No / YesWould you like to use Turbopack for `next dev`?  No / YesWould you like to customize the import alias (`@/*` by default)? No / YesWhat import alias would you like configured? @/*After the prompts,create-next-appwill create a folder with your project name and install the required dependencies.Manual installationTo manually create a new Next.js app, install the required packages:Terminalnpminstallnext@latestreact@latestreact-dom@latestOpen yourpackage.jsonfile and add the followingscripts:package.json{""scripts"":{""dev"":""next dev"",""build"":""next build"",""start"":""next start"",""lint"":""next lint""}}These scripts refer to the different stages of developing an application:dev: runsnext devto start Next.js in development mode.build: runsnext buildto build the application for production usage.start: runsnext startto start a Next.js production server.lint: runsnext lintto set up Next.js' built-in ESLint configuration.Create theappdirectoryNext.js uses file-system routing, which means the routes in your application are determined by how you structure your files.Create anappfolder, then add alayout.tsxandpage.tsxfile. These will be rendered when the user visits the root of your application (/).Create aroot layoutinsideapp/layout.tsxwith the required<html>and<body>tags:app/layout.tsxTypeScriptJavaScriptTypeScriptexportdefaultfunctionRootLayout({children,}:{children:React.ReactNode}) {return(<htmllang=""en""><body>{children}</body></html>)}Finally, create a home pageapp/page.tsxwith some initial content:app/page.tsxTypeScriptJavaScriptTypeScriptexportdefaultfunctionPage() {return<h1>Hello, Next.js!</h1>}Good to know:If you forget to createlayout.tsx, Next.js will automatically create this file when running the development server withnext dev.You can optionally use asrcdirectoryin the root of your project to separate your application's code from configuration files.Create thepublicfolder (optional)You can optionally create apublicfolderat the root of your project to store static assets such as images, fonts, etc. Files insidepubliccan then be referenced by your code starting from the base URL (/).Run the development serverRunnpm run devto start the development server.Visithttp://localhost:3000to view your application.Edit theapp/page.tsxfile and save it to see the updated result in your browser.Set up TypeScriptMinimum TypeScript version:v4.5.2Next.js comes with built-in TypeScript support. To add TypeScript to your project, rename a file to.ts/.tsx. Runnext dev, Next.js will automatically install the necessary dependencies and add atsconfig.jsonfile with the recommended config options.IDE PluginNext.js includes a custom TypeScript plugin and type checker, which VSCode and other code editors can use for advanced type-checking and auto-completion.You can enable the plugin in VS Code by:Opening the command palette (Ctrl/⌘+Shift+P)Searching for ""TypeScript: Select TypeScript Version""Selecting ""Use Workspace Version""Now, when editing files, the custom plugin will be enabled. When runningnext build, the custom type checker will be used.See theTypeScript configurationpage for more information on how to use TypeScript in your project.Set up ESLintNext.js comes with built-in ESLint, automatically installing the necessary packages and configuring the proper settings when you create a new project withcreate-next-app.To add ESLint to an existing project, addnext lintas a script topackage.json:package.json{""scripts"":{""lint"":""next lint""}}Then, runnpm run lintand you will be guided through the installation and configuration process.TerminalnpmrunlintYou'll see a prompt like this:? How would you like to configure ESLint?❯ Strict (recommended)BaseCancelStrict: Includes Next.js' base ESLint configuration along with a stricter Core Web Vitals rule-set. This is the recommended configuration for developers setting up ESLint for the first time.Base: Includes Next.js' base ESLint configuration.Cancel: Does not include any ESLint configuration. Only select this option if you plan on setting up your own custom ESLint configuration.If either of the two configuration options are selected, Next.js will automatically installeslintandeslint-config-nextas dependencies in your application and create an.eslintrc.jsonfile in the root of your project that includes your selected configuration.You can now runnext lintevery time you want to run ESLint to catch errors. Once ESLint has been set up, it will also automatically run during every build (next build). Errors will fail the build, while warnings will not.See theESLint Pluginpage for more information on how to configure ESLint in your project.Set up Absolute Imports and Module Path AliasesNext.js has in-built support for the""paths""and""baseUrl""options oftsconfig.jsonandjsconfig.jsonfiles. These options allow you to alias project directories to absolute paths, making it easier to import modules. For example:// Beforeimport{ Button }from'../../../components/button'// Afterimport{ Button }from'@/components/button'To configure absolute imports, add thebaseUrlconfiguration option to yourtsconfig.jsonorjsconfig.jsonfile. For example:tsconfig.json or jsconfig.json{""compilerOptions"":{""baseUrl"":""src/""}}In addition to configuring thebaseUrlpath, you can use the""paths""option to""alias""module paths.For example, the following configuration maps@/components/*tocomponents/*:tsconfig.json or jsconfig.json{""compilerOptions"":{""baseUrl"":""src/"",""paths"":{""@/styles/*"":[""styles/*""],""@/components/*"":[""components/*""]}}}Each of the""paths""are relative to thebaseUrllocation. For example:src/app/page.tsxTypeScriptJavaScriptTypeScriptimportButtonfrom'@/components/button'import'@/styles/styles.css'exportdefaultfunctionHomePage() {return(<div><h1>Hello World</h1><Button/></div>)}PreviousGetting StartedNextProject StructureWas this helpful?supported.Send"
app router vs pages router,App Router vs Pages Router,Content not available.
pre-requisite knowledge,Pre-Requisite Knowledge,Content not available.
react foundations course,React Foundations Course,"React FoundationsTo effectively learn Next.js, it helps to be familiar with JavaScript, React, and related web development concepts. But JavaScript and React are vast topics. How do you know when you're ready to start using Next.js?Welcome to the React Foundations course! This beginner-friendly, example-led course will guide you through the prerequisite knowledge for Next.js. You will build a simple project step-by-step; starting with a JavaScript application, then migrating it to React and Next.js.Each section builds on the previous one, so you can choose where to start depending on what you already know.Prerequisite knowledgeThis tutorial assumes knowledge of HTML, CSS, JavaScript, and no knowledge of React. If you're already familiar with React, you can skip to theFrom React to Next.jschapter or takeDashboard Appcourse.System requirementsBefore you start this course, make sure you have the following installed:Node.js 20.12.0 or later installed.Operating systems: macOS, Windows (including WSL), or Linux.VSCode or another text editor of your choice.Join the conversationIf you have questions about anything related to Next.js or this course, you're welcome to ask our community onDiscord.Ready to get started?Now that you've been introduced to the course, let's dive in.Next Up1: About React and Next.jsLearn what React and Next.js are, and how they can help you build modern web applications.Start Chapter 1Was this helpful?supported.Send"
building a dashboard application,building a dashboard application,"App RouterWelcome to the Next.js Foundations course! In this free interactive course, you'll learn the main features of Next.js by building a full-stack web application.What we'll be buildingFor this course, we'll build a financial dashboard that has:A public home page.A login page.Dashboard pages that are protected by authentication.The ability for users to add, edit, and delete invoices.The dashboard will also have an accompanying database, which you'll set up ina later chapter.By the end of the course, you'll have the essential skills needed to start building full-stack Next.js applications.OverviewHere's an overview of features you'll learn about in this course:Styling: The different ways to style your application in Next.js.Optimizations: How to optimize images, links, and fonts.Routing: How to create nested layouts and pages using file-system routing.Data Fetching: How to set up a Postgres database on Vercel, and best practices for fetching and streaming.Search and Pagination: How to implement search and pagination using URL search params.Mutating Data:How to mutate data using React Server Actions, and revalidate the Next.js cache.Error Handling:How to handle general and404not found errors.Form Validation and Accessibility:How to do server-side form validation and tips for improving accessibility.Authentication: How to add authentication to your application usingNextAuth.jsand Middleware.Metadata: How to add metadata and prepare your application for social sharing.Prerequisite knowledgeThis course assumes you have a basic understanding of React and JavaScript. If you're new to React, we recommend going through ourReact Foundationscourse first to learn the fundamentals of React, such as components, props, state, and hooks, and newer features like Server Components and Suspense.System requirementsBefore you start this course, make sure your system meets the following requirements:Node.js 18.18.0 or later installed.Download here.Operating systems: macOS, Windows (including WSL), or Linux.In addition, you'll also need aGitHub Accountand aVercel Account.Join the conversationIf you have questions about this course or would like to provide feedback, you can ask our community onRedditorGitHub.Ready to get started?Now that you've been introduced to the course, let's dive in.Next Up1: Getting StartedLearn how to create a Next.js application and run your local development server.Start Chapter 1Was this helpful?supported.Send"
accessibility,Accessibility,Content not available.
join our community,Join our Community,Content not available.
github discussions,GitHub Discussions,Content not available.
discord,Discord,Content not available.
x (twitter),X (Twitter),Could not fetch content.
reddit,Reddit,Nextjs vs. Nextjs + Expressjs?u/DaYroXy•Nextjs vs. Nextjs + Expressjs?QuestionHey guys! I have a unique project where it relay heavy on socket / shell commands and it uses real time communication that's why i need socket.in this situation what would fit best? Nextjs with singleton for RCON connection and custom server for socket or Nextjs + ExpressJS (used for socket/shell/rcon) or stick with vanilla react + express?i would love you recommendation and how you go about it cheers!
getting startedlearn how to create full-stack web applications with the next.js app router.,Getting StartedLearn how to create full-stack web applications with the Next.js App Router.,"IntroductionApp RouterGetting StartedGetting StartedInstallationCreate a new Next.js application with the `create-next-app` CLI, and set up TypeScript, ESLint, and Module Path Aliases.Project StructureAn overview of the folder and file conventions in Next.js, and how to organize your project.Layouts and PagesCreate your first pages and layouts, and link between them.Images and FontsLearn how to optimize images and fonts.CSSLearn about the different ways to add CSS to your application, including CSS Modules, Global CSS, Tailwind CSS, and more.Fetching DataStart fetching data and streaming content in your application.Updating DataLearn how to update data in your Next.js application.Error HandlingLearn how to display expected errors and handle uncaught exceptions.PreviousApp RouterNextInstallationWas this helpful?supported.Send"
exampleslearn how to implement common ui patterns and use cases  using next.js,ExamplesLearn how to implement common UI patterns and use cases  using Next.js,"IntroductionApp RouterExamplesExamplesData FetchingUsing thefetchAPIUsing an ORM or database clientReading search params on the serverReading search params on the clientRevalidating DataUsing ISR to revalidate data after a certain timeUsing ISR to revalidate data on-demandFormsShowing a pending state while submitting a formServer-side form validationHandling expected errorsHandling unexpected exceptionsShowing optimistic UI updatesProgrammatic form submissionServer ActionsPassing additional valuesRevalidating dataRedirectingSetting cookiesDeleting cookiesMetadataCreating an RSS feedCreating an Open Graph imageCreating a sitemapCreating a robots.txt fileCreating a custom 404 pageCreating a custom 500 pageAuthCreating a sign-up formStateless, cookie-based session managementStateful, database-backed session managementManaging authorizationTestingVitestJestPlaywrightCypressDeploymentCreating a DockerfileCreating a static export (SPA)Configuring caching when self-hostingConfiguring Image Optimization when self-hostingPreviousError HandlingNextBuilding Your ApplicationWas this helpful?supported.Send"
building your applicationlearn how to use next.js features to build your application.,Building Your ApplicationLearn how to use Next.js features to build your application.,"IntroductionApp RouterBuilding Your ApplicationBuilding Your ApplicationNext.js provides the building blocks to create flexible, full-stack web applications. The guides inBuilding Your Applicationexplain how to use these features and how to customize your application's behavior.The sections and pages are organized sequentially, from basic to advanced, so you can follow them step-by-step when building your Next.js application. However, you can read them in any order or skip to the pages that apply to your use case.If you're new to Next.js, we recommend starting with theRouting,Rendering,Data FetchingandStylingsections, as they introduce the fundamental Next.js and web concepts to help you get started. Then, you can dive deeper into the other sections such asOptimizingandConfiguring. Finally, once you're ready, checkout theDeployingandUpgradingsections.RoutingLearn the fundamentals of routing for front-end applications.Data FetchingLearn how to fetch, cache, revalidate, and mutate data with Next.js.RenderingLearn the differences between Next.js rendering environments, strategies, and runtimes.CachingAn overview of caching mechanisms in Next.js.StylingLearn the different ways you can style your Next.js application.OptimizingOptimize your Next.js application for best performance and user experience.ConfiguringLearn how to configure your Next.js application.TestingLearn how to set up Next.js with four commonly used testing tools — Cypress, Playwright, Vitest, and Jest.AuthenticationLearn how to implement authentication in your Next.js application.DeployingLearn how to deploy your Next.js app to production, either managed or self-hosted.UpgradingLearn how to upgrade to the latest versions of Next.js.PreviousExamplesNextRoutingWas this helpful?supported.Send"
api referencenext.js api reference for the app router.,API ReferenceNext.js API Reference for the App Router.,"IntroductionApp RouterAPI ReferenceAPI ReferenceThe Next.js API reference is divided into the following sections:DirectivesDirectives are used to modify the behavior of your Next.js application.ComponentsAPI Reference for Next.js built-in components.File ConventionsAPI Reference for Next.js File Conventions.FunctionsAPI Reference for Next.js Functions and Hooks.ConfigurationLearn how to configure Next.js applications.CLIAPI Reference for the Next.js Command Line Interface (CLI) tools.Edge RuntimeAPI Reference for the Edge Runtime.TurbopackTurbopack is an incremental bundler optimized for JavaScript and TypeScript, written in Rust, and built into Next.js.PreviousSingle-Page AppsNextDirectivesWas this helpful?supported.Send"
getting startedlearn how to create full-stack web applications with next.js with the pages router.,Getting StartedLearn how to create full-stack web applications with Next.js with the Pages Router.,"IntroductionPages RouterGetting StartedGetting Started - Pages RouterInstallationHow to create a new Next.js application with `create-next-app`. Set up TypeScript, ESLint,and configure your `next.config.js` file.Project StructureLearn about the folder and file conventions in a Next.js project, and how to organize your project.PreviousPages RouterNextInstallationWas this helpful?supported.Send"
building your applicationlearn how to use next.js features to build your application.,Building Your ApplicationLearn how to use Next.js features to build your application.,"IntroductionPages RouterBuilding Your ApplicationBuilding Your ApplicationNext.js provides the building blocks to create flexible, full-stack web applications. The guides inBuilding Your Applicationexplain how to use these features and how to customize your application's behavior.The sections and pages are organized sequentially, from basic to advanced, so you can follow them step-by-step when building your Next.js application. However, you can read them in any order or skip to the pages that apply to your use case.If you're new to Next.js, we recommend starting with theRouting,Rendering,Data FetchingandStylingsections, as they introduce the fundamental Next.js and web concepts to help you get started. Then, you can dive deeper into the other sections such asOptimizingandConfiguring. Finally, once you're ready, checkout theDeployingandUpgradingsections.RoutingLearn the fundamentals of routing for front-end applications with the Pages Router.RenderingLearn the fundamentals of rendering in React and Next.js.Data FetchingNext.js allows you to fetch data in multiple ways, with pre-rendering, server-side rendering or static-site generation, and incremental static regeneration. Learn how to manage your application data in Next.js.StylingLearn the different ways you can style your Next.js application.OptimizingOptimize your Next.js application for best performance and user experience.ConfiguringLearn how to configure your Next.js application.TestingLearn how to set up Next.js with three commonly used testing tools — Cypress, Playwright, Vitest, and Jest.AuthenticationLearn how to implement authentication in Next.js, covering best practices, securing routes, authorization techniques, and session management.DeployingLearn how to deploy your Next.js app to production, either managed or self-hosted.UpgradingLearn how to upgrade to the latest versions of Next.js.PreviousProject StructureNextRoutingWas this helpful?supported.Send"
api referencenext.js api reference for the pages router.,API ReferenceNext.js API Reference for the Pages Router.,"IntroductionPages RouterAPI ReferenceAPI ReferenceComponentsAPI Reference for Next.js built-in components in the Pages Router.FunctionsAPI Reference for Functions and Hooks in Pages Router.ConfigurationLearn how to configure your Next.js application.CLIAPI Reference for the Next.js Command Line Interface (CLI) tools.Edge RuntimeAPI Reference for the Edge Runtime.TurbopackTurbopack is an incremental bundler optimized for JavaScript and TypeScript, written in Rust, and built into Next.js.PreviousVersion 9NextComponentsWas this helpful?supported.Send"
architecturehow next.js works,ArchitectureHow Next.js Works,"IntroductionArchitectureArchitectureLearn about the Next.js architecture and how it works under the hood.AccessibilityThe built-in accessibility features of Next.js.Fast RefreshFast Refresh is a hot module reloading experience that gives you instantaneous feedback on edits made to your React components.Next.js CompilerNext.js Compiler, written in Rust, which transforms and minifies your Next.js application.Supported BrowsersBrowser support and which JavaScript features are supported by Next.js.PreviousTurbopackNextAccessibilityWas this helpful?supported.Send"
communityget involved in the next.js community.,CommunityGet involved in the Next.js community.,"IntroductionCommunityNext.js CommunityWith over 5 million weekly downloads, Next.js has a large and active community of developers across the world. Here's how you can get involved in our community:ContributingThere are a couple of ways you can contribute to the development of Next.js:Documentation: Suggest improvements or even write new sections to help our users understand how to use Next.js.Examples: Help developers integrate Next.js with other tools and services by creating a new example or improving an existing one.Codebase: Learn more about the underlying architecture, contribute to bug fixes, errors, and suggest new features.DiscussionsIf you have a question about Next.js, or want to help others, you're always welcome to join the conversation:GitHub DiscussionsDiscordRedditSocial MediaFollow Next.js onTwitterfor the latest updates, and subscribe to theVercel YouTube channelfor Next.js videos.Code of ConductWe believe in creating an inclusive, welcoming community. As such, we ask all members to adhere to ourCode of Conduct. This document outlines our expectations for participant behavior. We invite you to read it and help us maintain a safe and respectful environment.Contribution GuideLearn how to contribute to Next.js DocumentationPreviousSupported BrowsersNextContribution GuideWas this helpful?supported.Send"
previouscontribution guide,PreviousContribution Guide,"IntroductionCommunityContribution GuideYou are currently viewing documentation for version 14 of Next.js.Docs Contribution GuideWelcome to the Next.js Docs Contribution Guide! We're excited to have you here.This page provides instructions on how to edit the Next.js documentation. Our goal is to ensure that everyone in the community feels empowered to contribute and improve our docs.Why Contribute?Open-source work is never done, and neither is documentation. Contributing to docs is a good way for beginners to get involved in open-source and for experienced developers to clarify more complex topics while sharing their knowledge with the community.By contributing to the Next.js docs, you're helping us build a more robust learning resource for all developers. Whether you've found a typo, a confusing section, or you've realized that a particular topic is missing, your contributions are welcomed and appreciated.How to ContributeThe docs content can be found on theNext.js repo. To contribute, you can edit the files directly on GitHub or clone the repo and edit the files locally.GitHub WorkflowIf you're new to GitHub, we recommend reading theGitHub Open Source Guideto learn how to fork a repository, create a branch, and submit a pull request.Good to know: The underlying docs code lives in a private codebase that is synced to the Next.js public repo. This means that you can't preview the docs locally. However, you'll see your changes onnextjs.orgafter merging a pull request.Writing MDXThe docs are written inMDX, a markdown format that supports JSX syntax. This allows us to embed React components in the docs. See theGitHub Markdown Guidefor a quick overview of markdown syntax.VSCodePreviewing Changes LocallyVSCode has a built-in markdown previewer that you can use to see your edits locally. To enable the previewer for MDX files, you'll need to add a configuration option to your user settings.Open the command palette (⌘ + ⇧ + Pon Mac orCtrl + Shift + Pon Windows) and search fromPreferences: Open User Settings (JSON).Then, add the following line to yoursettings.jsonfile:settings.json{""files.associations"":{""*.mdx"":""markdown""}}Next, open the command palette again, and search forMarkdown: Preview FileorMarkdown: Open Preview to the Side. This will open a preview window where you can see your formatted changes.ExtensionsWe also recommend the following extensions for VSCode users:MDX: Intellisense and syntax highlighting for MDX.Grammarly: Grammar and spell checker.Prettier: Format MDX files on save.Review ProcessOnce you've submitted your contribution, the Next.js or Developer Experience teams will review your changes, provide feedback, and merge the pull request when it's ready.Please let us know if you have any questions or need further assistance in your PR's comments. Thank you for contributing to the Next.js docs and being a part of our community!Tip:Runpnpm prettier-fixto run Prettier before submitting your PR.File StructureThe docs usefile-system routing. Each folder and files inside/docsrepresent a route segment. These segments are used to generate the URL paths, navigation, and breadcrumbs.The file structure reflects the navigation that you see on the site, and by default, navigation items are sorted alphabetically. However, we can change the order of the items by prepending a two-digit number (00-) to the folder or file name.For example, in thefunctions API Reference, the pages are sorted alphabetically because it makes it easier for developers to find a specific function:03-functions├── cookies.mdx├── draft-mode.mdx├── fetch.mdx└── ...But, in therouting section, the files are prefixed with a two-digit number, sorted in the order developers should learn these concepts:02-routing├── 01-defining-routes.mdx├── 02-pages-and-layouts.mdx├── 03-linking-and-navigating.mdx└── ...To quickly find a page, you can use⌘ + P(Mac) orCtrl + P(Windows) to open the search bar on VSCode. Then, type the slug of the page you're looking for. E.g.defining-routesWhy not use a manifest?We considered using a manifest file (another popular way to generate the docs navigation), but we found that a manifest would quickly get out of sync with the files. File-system routing forces us to think about the structure of the docs and feels more native to Next.js.MetadataEach page has a metadata block at the top of the file separated by three dashes.Required FieldsThe following fields arerequired:FieldDescriptiontitleThe page's<h1>title, used for SEO and OG Images.descriptionThe page's description, used in the<meta name=""description"">tag for SEO.required-fields.mdx---title:Page Titledescription:Page Description---It's good practice to limit the page title to 2-3 words (e.g. Optimizing Images) and the description to 1-2 sentences (e.g. Learn how to optimize images in Next.js).Optional FieldsThe following fields areoptional:FieldDescriptionnav_titleOverrides the page's title in the navigation. This is useful when the page's title is too long to fit. If not provided, thetitlefield is used.sourcePulls content into a shared page. SeeShared Pages.relatedA list of related pages at the bottom of the document. These will automatically be turned into cards. SeeRelated Links.optional-fields.mdx---nav_title:Nav Item Titlesource:app/building-your-application/optimizing/imagesrelated:description:See the image component API reference.links:-app/api-reference/components/image---AppandPagesDocsSince most of the features in theApp RouterandPages Routerare completely different, their docs for each are kept in separate sections (02-appand03-pages). However, there are a few features that are shared between them.Shared PagesTo avoid content duplication and risk the content becoming out of sync, we use thesourcefield to pull content from one page into another. For example, the<Link>component behavesmostlythe same inAppandPages. Instead of duplicating the content, we can pull the content fromapp/.../link.mdxintopages/.../link.mdx:app/.../link.mdx---title:<Link>description:API reference for the <Link> component.---This API reference will help you understand how to use the propsand configuration options available for the Link Component.pages/.../link.mdx---title:<Link>description:API reference for the <Link> component.source:app/api-reference/components/link---{/* DO NOT EDIT THIS PAGE. */}{/* The content of this page is pulled from the source above. */}We can therefore edit the content in one place and have it reflected in both sections.Shared ContentIn shared pages, sometimes there might be content that isApp RouterorPages Routerspecific. For example, the<Link>component has ashallowprop that is only available inPagesbut not inApp.To make sure the content only shows in the correct router, we can wrap content blocks in an<AppOnly>or<PagesOnly>components:app/.../link.mdxThis content is shared between App and Pages.<PagesOnly>This content will only be shown on the Pages docs.</PagesOnly>This content is shared between App and Pages.You'll likely use these components for examples and code blocks.Code BlocksCode blocks should contain a minimum working example that can be copied and pasted. This means that the code should be able to run without any additional configuration.For example, if you're showing how to use the<Link>component, you should include theimportstatement and the<Link>component itself.app/page.tsximportLinkfrom'next/link'exportdefaultfunctionPage() {return<Linkhref=""/about"">About</Link>}Always run examples locally before committing them. This will ensure that the code is up-to-date and working.Language and FilenameCode blocks should have a header that includes the language and thefilename. Add afilenameprop to render a special Terminal icon that helps orientate users where to input the command. For example:code-example.mdx```bashfilename=""Terminal""npxcreate-next-app```Most examples in the docs are written intsxandjsx, and a few inbash. However, you can use any supported language, here's thefull list.When writing JavaScript code blocks, we use the following language and extension combinations.LanguageExtensionJavaScript files with JSX code```jsx.jsJavaScript files without JSX```js.jsTypeScript files with JSX```tsx.tsxTypeScript files without JSX```ts.tsTS and JS SwitcherAdd a language switcher to toggle between TypeScript and JavaScript. Code blocks should be TypeScript first with a JavaScript version to accommodate users.Currently, we write TS and JS examples one after the other, and link them withswitcherprop:code-example.mdx```tsxfilename=""app/page.tsx"" switcher``````jsxfilename=""app/page.js"" switcher```Good to know: We plan to automatically compile TypeScript snippets to JavaScript in the future. In the meantime, you can usetransform.tools.Line HighlightingCode lines can be highlighted. This is useful when you want to draw attention to a specific part of the code. You can highlight lines by passing a number to thehighlightprop.Single Line:highlight={1}app/page.tsximportLinkfrom'next/link'exportdefaultfunctionPage() {return<Linkhref=""/about"">About</Link>}Multiple Lines:highlight={1,3}app/page.tsximportLinkfrom'next/link'exportdefaultfunctionPage() {return<Linkhref=""/about"">About</Link>}Range of Lines:highlight={1-5}app/page.tsximportLinkfrom'next/link'exportdefaultfunctionPage() {return<Linkhref=""/about"">About</Link>}IconsThe following icons are available for use in the docs:mdx-icon.mdx<Checksize={18} /><Crosssize={18} />Output:We do not use emojis in the docs.NotesFor information that is important but not critical, use notes. Notes are a good way to add information without distracting the user from the main content.notes.mdx>**Good to know**: This is a single line note.>**Good to know**:>> - We also use this format for multi-line notes.> - There are sometimes multiple items worth knowing or keeping in mind.Output:Good to know: This is a single line note.Good to know:We also use this format for multi-line notes.There are sometimes multiple item worths knowing or keeping in mind.Related LinksRelated Links guide the user's learning journey by adding links to logical next steps.Links will be displayed in cards under the main content of the page.Links will be automatically generated for pages that have child pages. For example, theOptimizingsection has links to all of its child pages.Create related links using therelatedfield in the page's metadata.example.mdx---related:description:Learn how to quickly get started with your first application.links:-app/building-your-application/routing/defining-routes-app/building-your-application/data-fetching-app/api-reference/file-conventions/page---Nested FieldsFieldRequired?DescriptiontitleOptionalThe title of the card list. Defaults toNext Steps.descriptionOptionalThe description of the card list.linksRequiredA list of links to other doc pages. Each list item should be a relative URL path (without a leading slash) e.g.app/api-reference/file-conventions/pageDiagramsDiagrams are a great way to explain complex concepts. We useFigmato create diagrams, following Vercel's design guide.The diagrams currently live in the/publicfolder in our private Next.js site. If you'd like to update or add a diagram, please open aGitHub issuewith your ideas.Custom Components and HTMLThese are the React Components available for the docs:<Image />(next/image),<PagesOnly />,<AppOnly />,<Cross />, and<Check />. We do not allow raw HTML in the docs besides the<details>tag.If you have ideas for new components, please open aGitHub issue.Style GuideThis section contains guidelines for writing docs for those who are new to technical writing.Page TemplatesWhile we don't have a strict template for pages, there are page sections you'll see repeated across the docs:Overview:The first paragraph of a page should tell the user what the feature is and what it's used for. Followed by a minimum working example or its API reference.Convention:If the feature has a convention, it should be explained here.Examples: Show how the feature can be used with different use cases.API Tables: API Pages should have an overview table at the of the page with jump-to-section links (when possible).Next Steps (Related Links): Add links to related pages to guide the user's learning journey.Feel free to add these sections as needed.Page TypesDocs pages are also split into two categories: Conceptual and Reference.Conceptualpages are used to explain a concept or feature. They are usually longer and contain more information than reference pages. In the Next.js docs, conceptual pages are found in theBuilding Your Applicationsection.Referencepages are used to explain a specific API. They are usually shorter and more focused. In the Next.js docs, reference pages are found in theAPI Referencesection.Good to know: Depending on the page you're contributing to, you may need to follow a different voice and style. For example, conceptual pages are more instructional and use the wordyouto address the user. Reference pages are more technical, they use more imperative words like ""create, update, accept"" and tend to omit the wordyou.VoiceHere are some guidelines to maintain a consistent style and voice across the docs:Write clear, concise sentences. Avoid tangents.If you find yourself using a lot of commas, consider breaking the sentence into multiple sentences or use a list.Swap out complex words for simpler ones. For example,useinstead ofutilize.Be mindful with the wordthis. It can be ambiguous and confusing, don't be afraid to repeat the subject of the sentence if unclear.For example,Next.js uses Reactinstead ofNext.js uses this.Use an active voice instead of passive. An active sentence is easier to read.For example,Next.js uses Reactinstead ofReact is used by Next.js. If you find yourself using words likewasandbyyou may be using a passive voice.Avoid using words likeeasy,quick,simple,just, etc. This is subjective and can be discouraging to users.Avoid negative words likedon't,can't,won't, etc. This can be discouraging to readers.For example,""You can use theLinkcomponent to create links between pages""instead of""Don't use the<a>tag to create links between pages"".Write in second person (you/your). This is more personal and engaging.Use gender-neutral language. Usedevelopers,users, orreaders, when referring to the audience.If adding code examples, ensure they are properly formatted and working.While these guidelines are not exhaustive, they should help you get started. If you'd like to dive deeper into technical writing, check out theGoogle Technical Writing Course.Thank you for contributing to the docs and being part of the Next.js community!PreviousCommunityNextIntroductionWas this helpful?supported.Send"
nextapp router,NextApp Router,"IntroductionApp RouterApp RouterThe Next.js App Router introduces a new model for building applications using React's latest features such asServer Components,Streaming with Suspense, andServer Actions.Get started with the App Router bycreating your first page.Frequently Asked QuestionsHow can I access the request object in a layout?You intentionally cannot access the raw request object. However, you can accessheadersandcookiesthrough server-only functions. You can alsoset cookies.Layoutsdo not rerender. They can be cached and reused to avoid unnecessary computation when navigating between pages. By restricting layouts from accessing the raw request, Next.js can prevent the execution of potentially slow or expensive user code within the layout, which could negatively impact performance.This design also enforces consistent and predictable behavior for layouts across different pages, which simplifies development and debugging.Depending on the UI pattern you're building,Parallel Routesallow you to render multiple pages in the same layout, and pages have access to the route segments as well as the URL search params.How can I access the URL on a page?By default, pages are Server Components. You can access the route segments through theparamsprop and the URL search params through thesearchParamsprop for a given page.If you are using Client Components, you can useusePathname,useSelectedLayoutSegment, anduseSelectedLayoutSegmentsfor more complex routes.Further, depending on the UI pattern you're building,Parallel Routesallow you to render multiple pages in the same layout, and pages have access to the route segments as well as the URL search params.How can I redirect from a Server Component?You can useredirectto redirect from a page to a relative or absolute URL.redirectis a temporary (307) redirect, whilepermanentRedirectis a permanent (308) redirect. When these functions are used while streaming UI, they will insert a meta tag to emit the redirect on the client side.How can I handle authentication with the App Router?Here are some common authentication solutions that support the App Router:NextAuth.jsClerkStack AuthAuth0StytchKindeWorkOSOr manually handling sessions or JWTsHow can I set cookies?You can set cookies inServer ActionsorRoute Handlersusing thecookiesfunction.Since HTTP does not allow setting cookies after streaming starts, you cannot set cookies from a page or layout directly. You can also set cookies fromMiddleware.How can I build multi-tenant apps?If you are looking to build a single Next.js application that serves multiple tenants, we havebuilt an exampleshowing our recommended architecture.How can I invalidate the App Router cache?There are multiple layers of caching in Next.js, and thus, multiple ways to invalidate different parts of the cache.Learn more about caching.Are there any comprehensive, open-source applications built on the App Router?Yes. You can viewNext.js Commerceor thePlatforms Starter Kitfor two larger examples of using the App Router that are open-source.Learn MoreRouting FundamentalsData Fetching and CachingIncremental Static RegenerationForms and MutationsCachingRendering FundamentalsServer ComponentsClient ComponentsGetting StartedLearn how to create full-stack web applications with the Next.js App Router.ExamplesLearn how to implement common UI patterns and use cases  using Next.jsBuilding Your ApplicationLearn how to use Next.js features to build your application.API ReferenceNext.js API Reference for the App Router.PreviousIntroductionNextGetting StartedWas this helpful?supported.Send"
docs,Docs,"IntroductionWelcome to the Next.js documentation!What is Next.js?Next.js is a React framework for building full-stack web applications. You use React Components to build user interfaces, and Next.js for additional features and optimizations.Under the hood, Next.js also abstracts and automatically configures tooling needed for React, like bundling, compiling, and more. This allows you to focus on building your application instead of spending time with configuration.Whether you're an individual developer or part of a larger team, Next.js can help you build interactive, dynamic, and fast React applications.Main FeaturesSome of the main Next.js features include:FeatureDescriptionRoutingA file-system based router built on top of Server Components that supports layouts, nested routing, loading states, error handling, and more.RenderingClient-side and Server-side Rendering with Client and Server Components. Further optimized with Static and Dynamic Rendering on the server with Next.js. Streaming on Edge and Node.js runtimes.Data FetchingSimplified data fetching with async/await in Server Components, and an extendedfetchAPI for request memoization, data caching and revalidation.StylingSupport for your preferred styling methods, including CSS Modules, Tailwind CSS, and CSS-in-JSOptimizationsImage, Fonts, and Script Optimizations to improve your application's Core Web Vitals and User Experience.TypeScriptImproved support for TypeScript, with better type checking and more efficient compilation, as well as custom TypeScript Plugin and type checker.How to Use These DocsOn the left side of the screen, you'll find the docs navbar. The pages of the docs are organized sequentially, from basic to advanced, so you can follow them step-by-step when building your application. However, you can read them in any order or skip to the pages that apply to your use case.On the right side of the screen, you'll see a table of contents that makes it easier to navigate between sections of a page. If you need to quickly find a page, you can use the search bar at the top, or the search shortcut (Ctrl+KorCmd+K).To get started, check out theInstallationguide.App Router vs Pages RouterNext.js has two different routers: the App Router and the Pages Router. The App Router is a newer router that allows you to use React's latest features, such as Server Components and Streaming. The Pages Router is the original Next.js router, which allowed you to build server-rendered React applications and continues to be supported for older Next.js applications.At the top of the sidebar, you'll notice a dropdown menu that allows you to switch between theApp Routerand thePages Routerfeatures. Since there are features that are unique to each directory, it's important to keep track of which tab is selected.The breadcrumbs at the top of the page will also indicate whether you're viewing App Router docs or Pages Router docs.Pre-Requisite KnowledgeAlthough our docs are designed to be beginner-friendly, we need to establish a baseline so that the docs can stay focused on Next.js functionality. We'll make sure to provide links to relevant documentation whenever we introduce a new concept.To get the most out of our docs, it's recommended that you have a basic understanding of HTML, CSS, and React. If you need to brush up on your React skills, check out ourReact Foundations Course, which will introduce you to the fundamentals. Then, learn more about Next.js bybuilding a dashboard application.AccessibilityFor optimal accessibility when using a screen reader while reading the docs, we recommend using Firefox and NVDA, or Safari and VoiceOver.Join our CommunityIf you have questions about anything related to Next.js, you're always welcome to ask our community onGitHub Discussions,Discord,X (Twitter), andReddit.Getting StartedLearn how to create full-stack web applications with the Next.js App Router.ExamplesLearn how to implement common UI patterns and use cases  using Next.jsBuilding Your ApplicationLearn how to use Next.js features to build your application.API ReferenceNext.js API Reference for the App Router.Getting StartedLearn how to create full-stack web applications with Next.js with the Pages Router.Building Your ApplicationLearn how to use Next.js features to build your application.API ReferenceNext.js API Reference for the Pages Router.ArchitectureHow Next.js WorksCommunityGet involved in the Next.js community.PreviousContribution GuideNextApp RouterWas this helpful?supported.Send"
learn,Learn,Content not available.
showcase,Showcase,Content not available.
blog,Blog,"January 3rd, 2025Composable Caching with Next.jsWe’re working on a simple and powerful caching model for Next.js. In a previous post, we talked about our journey with caching and how we’ve arrived at the'use cache'directive.Read More"
team,Team,Content not available.
analytics,Analytics,Content not available.
next.js conf,Next.js Conf,Content not available.
previews,Previews,Content not available.
next.js commerce,Next.js Commerce,Content not available.
contact sales,Contact Sales,Content not available.
github,GitHub,"Next.jsGetting StartedUsed by some of the world's largest companies, Next.js enables you to create full-stack web applications by extending the latest React features, and integrating powerful Rust-based JavaScript tooling for the fastest builds.Visit ourLearn Next.jscourse to get started with Next.js.Visit theNext.js Showcaseto see more sites built with Next.js.DocumentationVisithttps://nextjs.org/docsto view the full documentation.CommunityThe Next.js community can be found onGitHub Discussionswhere you can ask questions, voice ideas, and share your projects with other people.To chat with other community members you can join the Next.jsDiscordserver.Do note that ourCode of Conductapplies to all Next.js community channels. Users arehighly encouragedto read and adhere to them to avoid repercussions.ContributingContributions to Next.js are welcome and highly appreciated. However, before you jump right into it, we would like you to review ourContribution Guidelinesto make sure you have a smooth experience contributing to Next.js.Good First Issues:We have a list ofgood first issuesthat contain bugs that have a relatively limited scope. This is a great place for newcomers and beginners alike to get started, gain experience, and get familiar with our contribution process.SecurityIf you believe you have found a security vulnerability in Next.js, we encourage you toresponsibly disclose this and NOT open a public issue. We will investigate all legitimate reports. Emailsecurity@vercel.comto disclose any security vulnerabilities. Alternatively, you can visit thislinkto know more about Vercel's security and report any security vulnerabilities."
releases,Releases,Content not available.
telemetry,Telemetry,"TelemetryNext.js collectscompletely anonymoustelemetry data about general usage.
Participation in this anonymous program is optional, and you may opt-out if you'd not like to share any information.Why is telemetry collected?Next.js has grown considerably since its release, becoming the de-facto React Framework for developers. Prior to telemetry collection, making decisions about how to improve Next.js was a very manual process.For example, Verceldogfoodsmany large React applications (including the Next.js website). Additionally, we actively engage with the community to gather feedback.However, this approach only allows us to collect feedback from a subset of users. This subset may have different needs and use cases than you. Telemetry allows us to accurately gauge Next.js feature usage, pain points, and customization.This data will let us better tailor Next.js to the masses, ensuring its continued growth, relevance, and best-in-class developer experience. Furthermore, this will allow us to verify if improvements made to the framework are improving the baseline of all applications.What is being collected?We track general usage information, such as Next.js plugins and build performance.
Specifically, we track the following anonymously:Command invoked (next build,next dev, ornext export)Version of Next.jsGeneral machine information (e.g. number of CPUs, macOS/Windows/Linux, whether or not the command was run within CI)What Next.js plugins are present in your projectDuration ofnext buildand size of application (total number of pages)During development, we ask for additional feedback on errors (seeError Feedback)Note: This list is regularly audited to ensure its accuracy.You can view exactly what is being collected by setting the following environment variable:NEXT_TELEMETRY_DEBUG=1.When this environment variable is set, data willnot be sent to us.
The data will only be printed out to thestderrstream, prefixed with[telemetry].An example telemetry event looks like this:{""eventName"":""NEXT_VERSION"",""payload"":{""version"":""9.0.5-canary.2"",""isDevelopment"":false}}What about sensitive data (e.g. secrets)?Wedo notcollect any metrics which may contain sensitive data.This includes, but is not limited to: environment variables, file paths, contents of files, logs, or serialized JavaScript errors.We take privacy and our security very seriously. Next.js telemetry falls under thesecurity disclosure policy.Will this data be shared?The data we collect is completely anonymous, not traceable to the source, and only meaningful in aggregate form.No data we collect is personally identifiable.Error FeedbackWhen an error is displayed during development, Next.js allows sending feedback whether the error was helpful or not.
This feedback is sent to Vercel and is used to improve the error messages in Next.js.
Next.js will not automatically collect this feedback.
Developers must click the thumbs up or down buttons to send the corresponding feedback.Next.js will only collect an error code and any other information it already automatically collects.
The error code is a unique identifier for a particular error.
The full error message cannot be reconstructed from this code since the error message may contain app-specific data like the page the error occured in.
A list of error codes and their corresponding messages is available atvercel/next.js/packages/next/errors.json.How do I opt-out?You may opt out-by runningnext telemetry disablein the root of your project directory:npxnexttelemetrydisableyarnnexttelemetrydisablepnpmexecnexttelemetrydisablebunnexttelemetrydisableYou may check the status of telemetry collection at any time by runningnext telemetry statusin the root of your project directory:npxnexttelemetrystatusyarnnexttelemetrystatuspnpmexecnexttelemetrystatusbunnexttelemetrystatusYou may re-enable telemetry if you'd like to re-join the program by running the following in the root of your project directory:npxnexttelemetryenableyarnnexttelemetryenablepnpmexecnexttelemetryenablebunnexttelemetryenableYou may also opt-out by setting an environment variable:NEXT_TELEMETRY_DISABLED=1."
governance,Governance,"GovernanceNext.js was created by the team atVercelin 2016.The research and development of Next.js is led by the core team working full-time at Vercel. With over 3,000 contributors from around the world, Next.js is a collaborative open-source effort to build tools for React and Web developers.TeamsCore Team:Next.js team atVercelmanages the direction of Next.js and leadership of the project, as well asSWC,Webpack, andTurbopackDocumentation:DevRel teams atVercelmanage documentation and learning platformsCollaborators:React team at Metaand theAurora team at GoogleRoadmap and RFC ProcessLarge architecture decisions and features start as aRequest for Comments (RFC)inside GitHub Discussions. The entire Next.js community is invited be to involved in the process and discuss the tradeoffs of proposed work.This process is essential to ensure features are built together with the community and our collaborators. More minor changes including bug fixes and documentation improvements are still implemented through GitHub pull requests. However, for larger initiatives, we believe it's essential to follow the RFC process.Stability and Release PhasesNext.js followsSemantic Versioningand releases new versions on a regular basis.Experimental:Experimental features lack essential capabilities required to be ready for stability. The feature is considered to be under active development and is being built to transition into Beta.Beta:Beta means the feature does not yet meet our quality standards for a stable release. There is also usually a need for more information or feedback from Next.js developers to validate this feature works as expected in a variety of environments.Stable:When the features reach stability, it is considered ready for use in production. APIs marked as stable will only change in a backward-compatible way unless there is amajor release.Deprecated:A feature is in the process of being removed. Deprecated features include documentation for existing users with the next steps and information on when to expect the feature to be removed.Next.js SupportFor individual developers looking for free support on their Next.js application, they can ask questions inGitHub Discussionsor in theNext.js Discord.For companies looking for paid support on their Next.js application, they cancontactthe Next.js team at Vercel for more information.Additional ResourcesLogo Policy and Brand GuidelinesReporting Security IssuesCode of ConductContributing Guidelines"
next.js + vercel,Next.js + Vercel,"Cache, controlled.Define per-component response revalidation that persists across deploys with Vercel's Data Cache."
open source software,Open Source Software,Content not available.
github,GitHub,Content not available.
bluesky,Bluesky,Content not available.
x,X,Could not fetch content.
privacy policy,Privacy Policy,Content not available.
